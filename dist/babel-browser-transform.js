!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.BabelTransform=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var isFunction = require("lodash/lang/isFunction");
var transform  = require("../transformation");
var util       = require("../util");
var fs         = require("fs");

exports.version = require("../../../package").version;

exports.buildExternalHelpers = require("../build-external-helpers");

exports.types = require("../types");

exports.register = function (opts) {
  var register = require("./register/node");
  if (opts != null) register(opts);
  return register;
};

exports.polyfill = function () {
  require("../polyfill");
};

exports.canCompile = util.canCompile;

// do not use this - this is for use by official maintained babel plugins
exports._util = util;

exports.transform = transform;

exports.transformFile = function (filename, opts, callback) {
  if (isFunction(opts)) {
    callback = opts;
    opts = {};
  }

  opts.filename = filename;

  fs.readFile(filename, function (err, code) {
    if (err) return callback(err);

    var result;

    try {
      result = transform(code, opts);
    } catch (err) {
      return callback(err);
    }

    callback(null, result);
  });
};

exports.transformFileSync = function (filename, opts) {
  opts = opts || {};
  opts.filename = filename;
  return transform(fs.readFileSync(filename), opts);
};

},{"../../../package":303,"../build-external-helpers":3,"../polyfill":32,"../transformation":45,"../types":122,"../util":124,"./register/node":2,"fs":305,"lodash/lang/isFunction":249}],2:[function(require,module,exports){
"use strict";

// required to safely use babel/register within a browserify codebase

module.exports = function () {};

require("../../polyfill");

},{"../../polyfill":32}],3:[function(require,module,exports){
"use strict";

var buildHelpers = require("./build-helpers");
var generator    = require("./generation");
var util         = require("./util");
var t            = require("./types");

module.exports = function () {
  var namespace = t.identifier("babelHelpers");

  var body      = [];
  var container = t.functionExpression(null, [t.identifier("global")], t.blockStatement(body));
  var tree      = t.program([t.expressionStatement(t.callExpression(container, [util.template("self-global")]))]);

  body.push(t.variableDeclaration("var", [
    t.variableDeclarator(
      namespace,
      t.assignmentExpression("=", t.memberExpression(t.identifier("global"), namespace), t.objectExpression([]))
    )
  ]));

  buildHelpers(body, namespace);

  return generator(tree).code;
};

},{"./build-helpers":4,"./generation":18,"./types":122,"./util":124}],4:[function(require,module,exports){
var File = require("./transformation/file");
var util = require("./util");
var each = require("lodash/collection/each");
var t    = require("./types");

module.exports = function (body, namespace) {
  each(File.helpers, function (name) {
    var key = t.identifier(t.toIdentifier(name));
    body.push(t.expressionStatement(
      t.assignmentExpression("=", t.memberExpression(namespace, key), util.template(name))
    ));
  });
};

},{"./transformation/file":33,"./types":122,"./util":124,"lodash/collection/each":172}],5:[function(require,module,exports){
"use strict";

module.exports = Buffer;

var repeating = require("repeating");
var trimRight = require("trim-right");
var isBoolean = require("lodash/lang/isBoolean");
var includes  = require("lodash/collection/includes");
var isNumber  = require("lodash/lang/isNumber");

function Buffer(position, format) {
  this.position = position;
  this._indent  = format.indent.base;
  this.format   = format;
  this.buf      = "";
}

Buffer.prototype.get = function () {
  return trimRight(this.buf);
};

Buffer.prototype.getIndent = function () {
  if (this.format.compact || this.format.concise) {
    return "";
  } else {
    return repeating(this.format.indent.style, this._indent);
  }
};

Buffer.prototype.indentSize = function () {
  return this.getIndent().length;
};

Buffer.prototype.indent = function () {
  this._indent++;
};

Buffer.prototype.dedent = function () {
  this._indent--;
};

Buffer.prototype.semicolon = function () {
  this.push(";");
};

Buffer.prototype.ensureSemicolon = function () {
  if (!this.isLast(";")) this.semicolon();
};

Buffer.prototype.rightBrace = function () {
  this.newline(true);
  this.push("}");
};

Buffer.prototype.keyword = function (name) {
  this.push(name);
  this.space();
};

Buffer.prototype.space = function () {
  if (this.format.compact) return;

  if (this.buf && !this.isLast([" ", "\n"])) {
    this.push(" ");
  }
};

Buffer.prototype.removeLast = function (cha) {
  if (!this.isLast(cha)) return;

  this.buf = this.buf.substr(0, this.buf.length - 1);
  this.position.unshift(cha);
};

Buffer.prototype.newline = function (i, removeLast) {
  if (this.format.compact || this.format.concise) {
    this.space();
    return;
  }

  removeLast = removeLast || false;

  if (isNumber(i)) {
    if (this.endsWith("{\n")) i--;
    if (this.endsWith(repeating("\n", i > 0 ? i : 0))) return;

    while (i--) {
      this._newline(removeLast);
    }
    return;
  }

  if (isBoolean(i)) {
    removeLast = i;
  }

  this._newline(removeLast);
};

Buffer.prototype._newline = function (removeLast) {
  if (removeLast && this.isLast("\n")) this.removeLast("\n");

  this.removeLast(" ");

  // remove whitespace if last character was a newline
  this._removeSpacesAfterLastNewline();
  this._push("\n");
};

/**
 * If buffer ends with a newline and some spaces after it, trim those spaces.
 */
Buffer.prototype._removeSpacesAfterLastNewline = function () {
  var lastNewlineIndex = this.buf.lastIndexOf("\n");
  if (lastNewlineIndex === -1)
    return;

  var index = this.buf.length - 1;
  while (index > lastNewlineIndex) {
    if (this.buf[index] !== " ") {
      break;
    }

    index--;
  }

  if (index === lastNewlineIndex) {
    this.buf = this.buf.substring(0, index + 1);
  }
};

Buffer.prototype.push = function (str, noIndent) {
  if (this._indent && !noIndent && str !== "\n") {
    // we have an indent level and we aren't pushing a newline
    var indent = this.getIndent();

    // replace all newlines with newlines with the indentation
    str = str.replace(/\n/g, "\n" + indent);

    // we've got a newline before us so prepend on the indentation
    if (this.isLast("\n")) str = indent + str;
  }

  this._push(str);
};

Buffer.prototype._push = function (str) {
  this.position.push(str);
  this.buf += str;
};

Buffer.prototype.endsWith = function (str) {
  var d = this.buf.length - str.length;
  return d >= 0 && this.buf.lastIndexOf(str) === d;
};

Buffer.prototype.isLast = function (cha, shouldTrimRight) {
  var buf = this.buf;
  if (shouldTrimRight) buf = trimRight(buf);
  var last = buf[buf.length - 1];

  if (Array.isArray(cha)) {
    return includes(cha, last);
  } else {
    return cha === last;
  }
};

},{"lodash/collection/includes":175,"lodash/lang/isBoolean":247,"lodash/lang/isNumber":251,"repeating":286,"trim-right":302}],6:[function(require,module,exports){
"use strict";

exports.File = function (node, print) {
  print(node.program);
};

exports.Program = function (node, print) {
  print.sequence(node.body);
};

exports.BlockStatement = function (node, print) {
  if (node.body.length === 0) {
    this.push("{}");
  } else {
    this.push("{");
    this.newline();
    print.sequence(node.body, { indent: true });
    this.removeLast("\n");
    this.rightBrace();
  }
};

},{}],7:[function(require,module,exports){
"use strict";

exports.ClassExpression =
exports.ClassDeclaration = function (node, print) {
  this.push("class");

  if (node.id) {
    this.space();
    print(node.id);
  }

  if (node.superClass) {
    this.push(" extends ");
    print(node.superClass);
  }

  this.space();
  print(node.body);
};

exports.ClassBody = function (node, print) {
  if (node.body.length === 0) {
    this.push("{}");
  } else {
    this.push("{");
    this.newline();

    this.indent();
    print.sequence(node.body);
    this.dedent();

    this.rightBrace();
  }
};

exports.MethodDefinition = function (node, print) {
  if (node.static) {
    this.push("static ");
  }

  this._method(node, print);
};

},{}],8:[function(require,module,exports){
"use strict";

exports.ComprehensionBlock = function (node, print) {
  this.keyword("for");
  this.push("(");
  print(node.left);
  this.push(" of ");
  print(node.right);
  this.push(")");
};

exports.ComprehensionExpression = function (node, print) {
  this.push(node.generator ? "(" : "[");

  print.join(node.blocks, { separator: " " });
  this.space();

  if (node.filter) {
    this.keyword("if");
    this.push("(");
    print(node.filter);
    this.push(")");
    this.space();
  }

  print(node.body);

  this.push(node.generator ? ")" : "]");
};

},{}],9:[function(require,module,exports){
"use strict";

var isInteger = require("is-integer");
var isNumber  = require("lodash/lang/isNumber");
var t         = require("../../types");

exports.UnaryExpression = function (node, print) {
  var hasSpace = /[a-z]$/.test(node.operator);
  var arg = node.argument;

  if (t.isUpdateExpression(arg) || t.isUnaryExpression(arg)) {
    hasSpace = true;
  }

  if (t.isUnaryExpression(arg) && arg.operator === "!") {
    hasSpace = false;
  }

  this.push(node.operator);
  if (hasSpace) this.push(" ");
  print(node.argument);
};

exports.UpdateExpression = function (node, print) {
  if (node.prefix) {
    this.push(node.operator);
    print(node.argument);
  } else {
    print(node.argument);
    this.push(node.operator);
  }
};

exports.ConditionalExpression = function (node, print) {
  print(node.test);
  this.space();
  this.push("?");
  this.space();
  print(node.consequent);
  this.space();
  this.push(":");
  this.space();
  print(node.alternate);
};

exports.NewExpression = function (node, print) {
  this.push("new ");
  print(node.callee);
  if (node.arguments.length || this.format.parentheses) {
    this.push("(");
    print.list(node.arguments);
    this.push(")");
  }
};

exports.SequenceExpression = function (node, print) {
  print.list(node.expressions);
};

exports.ThisExpression = function () {
  this.push("this");
};

exports.CallExpression = function (node, print) {
  print(node.callee);

  this.push("(");

  var separator = ",";

  if (node._prettyCall) {
    separator += "\n";
    this.newline();
    this.indent();
  } else {
    separator += " ";
  }

  print.list(node.arguments, { separator: separator });

  if (node._prettyCall) {
    this.newline();
    this.dedent();
  }

  this.push(")");
};

var buildYieldAwait = function (keyword) {
  return function (node, print) {
    this.push(keyword);

    if (node.delegate || node.all) {
      this.push("*");
    }

    if (node.argument) {
      this.space();
      print(node.argument);
    }
  };
};

exports.YieldExpression = buildYieldAwait("yield");
exports.AwaitExpression = buildYieldAwait("await");

exports.EmptyStatement = function () {
  this.semicolon();
};

exports.ExpressionStatement = function (node, print) {
  print(node.expression);
  this.semicolon();
};

exports.BinaryExpression =
exports.LogicalExpression =
exports.AssignmentPattern =
exports.AssignmentExpression = function (node, print) {
  // todo: add cases where the spaces can be dropped when in compact mode
  print(node.left);
  this.push(" ");
  this.push(node.operator);
  this.push(" ");
  print(node.right);
};

var SCIENTIFIC_NOTATION = /e/i;

exports.MemberExpression = function (node, print) {
  var obj = node.object;
  print(obj);

  if (!node.computed && t.isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  var computed = node.computed;
  if (t.isLiteral(node.property) && isNumber(node.property.value)) {
    computed = true;
  }

  if (computed) {
    this.push("[");
    print(node.property);
    this.push("]");
  } else {
    // 5..toFixed(2);
    if (t.isLiteral(obj) && isInteger(obj.value) && !SCIENTIFIC_NOTATION.test(obj.value.toString())) {
      this.push(".");
    }

    this.push(".");
    print(node.property);
  }
};

},{"../../types":122,"is-integer":161,"lodash/lang/isNumber":251}],10:[function(require,module,exports){
"use strict";

exports.AnyTypeAnnotation =
exports.ArrayTypeAnnotation =
exports.BooleanTypeAnnotation =
exports.ClassProperty =
exports.DeclareClass =
exports.DeclareFunction =
exports.DeclareModule =
exports.DeclareVariable =
exports.FunctionTypeAnnotation =
exports.FunctionTypeParam =
exports.GenericTypeAnnotation =
exports.InterfaceExtends =
exports.InterfaceDeclaration =
exports.IntersectionTypeAnnotation =
exports.NullableTypeAnnotation =
exports.NumberTypeAnnotation =
exports.StringLiteralTypeAnnotation =
exports.StringTypeAnnotation =
exports.TupleTypeAnnotation =
exports.TypeofTypeAnnotation =
exports.TypeAlias =
exports.TypeAnnotation =
exports.TypeParameterDeclaration =
exports.TypeParameterInstantiation =
exports.ObjectTypeAnnotation =
exports.ObjectTypeCallProperty =
exports.ObjectTypeIndexer =
exports.ObjectTypeProperty =
exports.QualifiedTypeIdentifier =
exports.UnionTypeAnnotation =
exports.TypeCastExpression =
exports.VoidTypeAnnotation = function () {
  // todo: implement these once we have a `--keep-types` option
};

},{}],11:[function(require,module,exports){
"use strict";

var t    = require("../../types");
var each = require("lodash/collection/each");

exports.JSXAttribute = function (node, print) {
  print(node.name);
  if (node.value) {
    this.push("=");
    print(node.value);
  }
};

exports.JSXIdentifier = function (node) {
  this.push(node.name);
};

exports.JSXNamespacedName = function (node, print) {
  print(node.namespace);
  this.push(":");
  print(node.name);
};

exports.JSXMemberExpression = function (node, print) {
  print(node.object);
  this.push(".");
  print(node.property);
};

exports.JSXSpreadAttribute = function (node, print) {
  this.push("{...");
  print(node.argument);
  this.push("}");
};

exports.JSXExpressionContainer = function (node, print) {
  this.push("{");
  print(node.expression);
  this.push("}");
};

exports.JSXElement = function (node, print) {
  var self = this;

  var open = node.openingElement;
  print(open);
  if (open.selfClosing) return;

  this.indent();
  each(node.children, function (child) {
    if (t.isLiteral(child)) {
      self.push(child.value);
    } else {
      print(child);
    }
  });
  this.dedent();

  print(node.closingElement);
};

exports.JSXOpeningElement = function (node, print) {
  this.push("<");
  print(node.name);
  if (node.attributes.length > 0) {
    this.push(" ");
    print.join(node.attributes, { separator: " " });
  }
  this.push(node.selfClosing ? " />" : ">");
};

exports.JSXClosingElement = function (node, print) {
  this.push("</");
  print(node.name);
  this.push(">");
};

exports.JSXEmptyExpression = function () {};

},{"../../types":122,"lodash/collection/each":172}],12:[function(require,module,exports){
"use strict";

var t = require("../../types");

exports._params = function (node, print) {
  this.push("(");
  print.list(node.params);
  this.push(")");
};

exports._method = function (node, print) {
  var value = node.value;
  var kind  = node.kind;
  var key   = node.key;

  if (!kind || kind === "init") {
    if (value.generator) {
      this.push("*");
    }
  } else {
    this.push(kind + " ");
  }

  if (value.async) this.push("async ");

  if (node.computed) {
    this.push("[");
    print(key);
    this.push("]");
  } else {
    print(key);
  }

  this._params(value, print);
  this.push(" ");
  print(value.body);
};

exports.FunctionDeclaration =
exports.FunctionExpression = function (node, print) {
  if (node.async) this.push("async ");
  this.push("function");
  if (node.generator) this.push("*");

  if (node.id) {
    this.push(" ");
    print(node.id);
  } else {
    this.space();
  }

  this._params(node, print);
  this.space();
  print(node.body);
};

exports.ArrowFunctionExpression = function (node, print) {
  if (node.async) this.push("async ");

  if (node.params.length === 1 && t.isIdentifier(node.params[0])) {
    print(node.params[0]);
  } else {
    this._params(node, print);
  }

  this.push(" => ");
  print(node.body);
};

},{"../../types":122}],13:[function(require,module,exports){
"use strict";

var t    = require("../../types");
var each = require("lodash/collection/each");

exports.ImportSpecifier = function (node, print) {
  if (t.isSpecifierDefault(node)) {
    print(t.getSpecifierName(node));
  } else {
    return exports.ExportSpecifier.apply(this, arguments);
  }
};

exports.ExportSpecifier = function (node, print) {
  print(node.id);
  if (node.name) {
    this.push(" as ");
    print(node.name);
  }
};

exports.ExportBatchSpecifier = function () {
  this.push("*");
};

exports.ExportDeclaration = function (node, print) {
  this.push("export ");

  var specifiers = node.specifiers;

  if (node.default) {
    this.push("default ");
  }

  if (node.declaration) {
    print(node.declaration);
    if (t.isStatement(node.declaration)) return;
  } else {
    if (specifiers.length === 1 && t.isExportBatchSpecifier(specifiers[0])) {
      print(specifiers[0]);
    } else {
      this.push("{");
      if (specifiers.length) {
        this.space();
        print.join(specifiers, { separator: ", " });
        this.space();
      }
      this.push("}");
    }

    if (node.source) {
      this.push(" from ");
      print(node.source);
    }
  }

  this.ensureSemicolon();
};

exports.ImportDeclaration = function (node, print) {
  var self = this;

  this.push("import ");

  var specfiers = node.specifiers;
  if (specfiers && specfiers.length) {
    var foundImportSpecifier = false;

    each(node.specifiers, function (spec, i) {
      if (+i > 0) {
        self.push(", ");
      }

      var isDefault = t.isSpecifierDefault(spec);

      if (!isDefault && spec.type !== "ImportBatchSpecifier" && !foundImportSpecifier) {
        foundImportSpecifier = true;
        self.push("{ ");
      }

      print(spec);
    });

    if (foundImportSpecifier) {
      this.push(" }");
    }

    this.push(" from ");
  }

  print(node.source);
  this.semicolon();
};

exports.ImportBatchSpecifier = function (node, print) {
  this.push("* as ");
  print(node.name);
};

},{"../../types":122,"lodash/collection/each":172}],14:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

each(["BindMemberExpression", "BindFunctionExpression"], function (type) {
  exports[type] = function () {
    throw new ReferenceError("Trying to render non-standard playground node " + JSON.stringify(type));
  };
});

},{"lodash/collection/each":172}],15:[function(require,module,exports){
"use strict";

var repeating = require("repeating");
var t         = require("../../types");

exports.WithStatement = function (node, print) {
  this.keyword("with");
  this.push("(");
  print(node.object);
  this.push(")");
  print.block(node.body);
};

exports.IfStatement = function (node, print) {
  this.keyword("if");
  this.push("(");
  print(node.test);
  this.push(")");
  this.space();

  print.indentOnComments(node.consequent);

  if (node.alternate) {
    if (this.isLast("}")) this.space();
    this.keyword("else");

    if (this.format.format && !t.isBlockStatement(node.alternate)) {
      this.push(" ");
    }

    print.indentOnComments(node.alternate);
  }
};

exports.ForStatement = function (node, print) {
  this.keyword("for");
  this.push("(");

  print(node.init);
  this.push(";");

  if (node.test) {
    this.push(" ");
    print(node.test);
  }
  this.push(";");

  if (node.update) {
    this.push(" ");
    print(node.update);
  }

  this.push(")");
  print.block(node.body);
};

exports.WhileStatement = function (node, print) {
  this.keyword("while");
  this.push("(");
  print(node.test);
  this.push(")");
  print.block(node.body);
};

var buildForXStatement = function (op) {
  return function (node, print) {
    this.keyword("for");
    this.push("(");
    print(node.left);
    this.push(" " + op + " ");
    print(node.right);
    this.push(")");
    print.block(node.body);
  };
};

exports.ForInStatement = buildForXStatement("in");
exports.ForOfStatement = buildForXStatement("of");

exports.DoWhileStatement = function (node, print) {
  this.keyword("do");
  print(node.body);
  this.space();
  this.keyword("while");
  this.push("(");
  print(node.test);
  this.push(");");
};

var buildLabelStatement = function (prefix, key) {
  return function (node, print) {
    this.push(prefix);

    var label = node[key || "label"];
    if (label) {
      this.push(" ");
      print(label);
    }

    this.semicolon();
  };
};

exports.ContinueStatement = buildLabelStatement("continue");
exports.ReturnStatement   = buildLabelStatement("return", "argument");
exports.BreakStatement    = buildLabelStatement("break");

exports.LabeledStatement = function (node, print) {
  print(node.label);
  this.push(": ");
  print(node.body);
};

exports.TryStatement = function (node, print) {
  this.keyword("try");
  print(node.block);
  this.space();

  // Esprima bug puts the catch clause in a `handlers` array.
  // see https://code.google.com/p/esprima/issues/detail?id=433
  // We run into this from regenerator generated ast.
  if (node.handlers) {
    print(node.handlers[0]);
  } else {
    print(node.handler);
  }

  if (node.finalizer) {
    this.space();
    this.push("finally ");
    print(node.finalizer);
  }
};

exports.CatchClause = function (node, print) {
  this.keyword("catch");
  this.push("(");
  print(node.param);
  this.push(") ");
  print(node.body);
};

exports.ThrowStatement = function (node, print) {
  this.push("throw ");
  print(node.argument);
  this.semicolon();
};

exports.SwitchStatement = function (node, print) {
  this.keyword("switch");
  this.push("(");
  print(node.discriminant);
  this.push(")");
  this.space();
  this.push("{");
  print.sequence(node.cases, { indent: true });
  this.push("}");
};

exports.SwitchCase = function (node, print) {
  if (node.test) {
    this.push("case ");
    print(node.test);
    this.push(":");
  } else {
    this.push("default:");
  }

  this.newline();
  print.sequence(node.consequent, { indent: true });
};

exports.DebuggerStatement = function () {
  this.push("debugger;");
};

exports.VariableDeclaration = function (node, print, parent) {
  this.push(node.kind + " ");

  var hasInits = false;
  // don't add whitespace to loop heads
  if (!t.isFor(parent)) {
    for (var i = 0; i < node.declarations.length; i++) {
      if (node.declarations[i].init) {
        // has an init so let's split it up over multiple lines
        hasInits = true;
      }
    }
  }

  var sep = ",";
  if (hasInits) {
    sep += "\n" + repeating(" ", node.kind.length + 1);
  } else {
    sep += " ";
  }

  print.list(node.declarations, { separator: sep });

  if (!t.isFor(parent)) {
    this.semicolon();
  }
};

exports.PrivateDeclaration = function (node, print) {
  this.push("private ");
  print.join(node.declarations, { separator: ", " });
  this.semicolon();
};

exports.VariableDeclarator = function (node, print) {
  if (node.init) {
    print(node.id);
    this.space();
    this.push("=");
    this.space();
    print(node.init);
  } else {
    print(node.id);
  }
};

},{"../../types":122,"repeating":286}],16:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

exports.TaggedTemplateExpression = function (node, print) {
  print(node.tag);
  print(node.quasi);
};

exports.TemplateElement = function (node) {
  this._push(node.value.raw);
};

exports.TemplateLiteral = function (node, print) {
  this.push("`");

  var quasis = node.quasis;
  var self   = this;
  var len    = quasis.length;

  each(quasis, function (quasi, i) {
    print(quasi);

    if (i + 1 < len) {
      self.push("${ ");
      print(node.expressions[i]);
      self.push(" }");
    }
  });

  this._push("`");
};

},{"lodash/collection/each":172}],17:[function(require,module,exports){
"use strict";

var each = require("lodash/collection/each");

exports.Identifier = function (node) {
  this.push(node.name);
};

exports.RestElement =
exports.SpreadElement =
exports.SpreadProperty = function (node, print) {
  this.push("...");
  print(node.argument);
};

exports.VirtualPropertyExpression = function (node, print) {
  print(node.object);
  this.push("::");
  print(node.property);
};

exports.ObjectExpression =
exports.ObjectPattern = function (node, print) {
  var props = node.properties;

  if (props.length) {
    this.push("{");
    this.space();

    print.list(props, { indent: true });

    this.space();
    this.push("}");
  } else {
    this.push("{}");
  }
};

exports.Property = function (node, print) {
  if (node.method || node.kind === "get" || node.kind === "set") {
    this._method(node, print);
  } else {
    if (node.computed) {
      this.push("[");
      print(node.key);
      this.push("]");
    } else {
      print(node.key);
      if (node.shorthand) return;
    }

    this.push(":");
    this.space();
    print(node.value);
  }
};

exports.ArrayExpression =
exports.ArrayPattern = function (node, print) {
  var elems = node.elements;
  var self  = this;
  var len   = elems.length;

  this.push("[");

  each(elems, function (elem, i) {
    if (!elem) {
      // If the array expression ends with a hole, that hole
      // will be ignored by the interpreter, but if it ends with
      // two (or more) holes, we need to write out two (or more)
      // commas so that the resulting code is interpreted with
      // both (all) of the holes.
      self.push(",");
    } else {
      if (i > 0 && !self.format.compact) self.push(" ");
      print(elem);
      if (i < len - 1) self.push(",");
    }
  });

  this.push("]");
};

exports.Literal = function (node) {
  var val  = node.value;
  var type = typeof val;

  if (type === "string") {
    val = JSON.stringify(val);

    // escape illegal js but valid json unicode characters
    val = val.replace(/[\u000A\u000D\u2028\u2029]/g, function (c) {
      return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
    });

    this.push(val);
  } else if (type === "number") {
    this.push(val + "");
  } else if (type === "boolean") {
    this.push(val ? "true" : "false");
  } else if (node.regex) {
    this.push("/" + node.regex.pattern + "/" + node.regex.flags);
  } else if (val === null) {
    this.push("null");
  }
};

},{"lodash/collection/each":172}],18:[function(require,module,exports){
"use strict";

module.exports = function (ast, opts, code) {
  var gen = new CodeGenerator(ast, opts, code);
  return gen.generate();
};

module.exports.CodeGenerator = CodeGenerator;

var detectIndent = require("detect-indent");
var Whitespace   = require("./whitespace");
var repeating    = require("repeating");
var SourceMap    = require("./source-map");
var Position     = require("./position");
var Buffer       = require("./buffer");
var extend       = require("lodash/object/extend");
var merge        = require("lodash/object/merge");
var each         = require("lodash/collection/each");
var n            = require("./node");
var t            = require("../types");

function CodeGenerator(ast, opts, code) {
  opts = opts || {};

  this.comments = ast.comments || [];
  this.tokens   = ast.tokens || [];
  this.format   = CodeGenerator.normalizeOptions(code, opts);
  this.opts     = opts;
  this.ast      = ast;

  this.whitespace = new Whitespace(this.tokens, this.comments);
  this.position   = new Position;
  this.map        = new SourceMap(this.position, opts, code);
  this.buffer     = new Buffer(this.position, this.format);
}

each(Buffer.prototype, function (fn, key) {
  CodeGenerator.prototype[key] = function () {
    return fn.apply(this.buffer, arguments);
  };
});

CodeGenerator.normalizeOptions = function (code, opts) {
  var style = "  ";
  if (code) {
    var indent = detectIndent(code).indent;
    if (indent && indent !== " ") style = indent;
  }

  return merge({
    parentheses: true,
    comments: opts.comments == null || opts.comments,
    compact: false,
    concise: false,
    indent: {
      adjustMultilineComment: true,
      style: style,
      base: 0
    }
  }, opts.format || {});
};

CodeGenerator.generators = {
  templateLiterals: require("./generators/template-literals"),
  comprehensions:   require("./generators/comprehensions"),
  expressions:      require("./generators/expressions"),
  statements:       require("./generators/statements"),
  playground:       require("./generators/playground"),
  classes:          require("./generators/classes"),
  methods:          require("./generators/methods"),
  modules:          require("./generators/modules"),
  types:            require("./generators/types"),
  flow:             require("./generators/flow"),
  base:             require("./generators/base"),
  jsx:              require("./generators/jsx")
};

each(CodeGenerator.generators, function (generator) {
  extend(CodeGenerator.prototype, generator);
});

CodeGenerator.prototype.generate = function () {
  var ast = this.ast;

  this.print(ast);

  var comments = [];
  each(ast.comments, function (comment) {
    if (!comment._displayed) comments.push(comment);
  });
  this._printComments(comments);

  return {
    map:  this.map.get(),
    code: this.buffer.get()
  };
};

CodeGenerator.prototype.buildPrint = function (parent) {
  var self = this;

  var print = function (node, opts) {
    return self.print(node, parent, opts);
  };

  print.sequence = function (nodes, opts) {
    opts = opts || {};
    opts.statement = true;
    return self.printJoin(print, nodes, opts);
  };

  print.join = function (nodes, opts) {
    return self.printJoin(print, nodes, opts);
  };

  print.list = function (items, opts) {
    opts = opts || {};

    var sep = opts.separator || ", ";
    if (self.format.compact) sep = ",";
    opts.separator = sep;

    print.join(items, opts);
  };

  print.block = function (node) {
    return self.printBlock(print, node);
  };

  print.indentOnComments = function (node) {
    return self.printAndIndentOnComments(print, node);
  };

  return print;
};

CodeGenerator.prototype.print = function (node, parent, opts) {
  if (!node) return "";

  if (parent && parent._compact) {
    node._compact = true;
  }

  var oldConcise = this.format.concise;
  if (node._compact) {
    this.format.concise = true;
  }

  var self = this;

  opts = opts || {};

  var newline = function (leading) {
    if (!opts.statement && !n.isUserWhitespacable(node, parent)) {
      return;
    }

    var lines = 0;

    if (node.start != null && !node._ignoreUserWhitespace) {
      // user node
      if (leading) {
        lines = self.whitespace.getNewlinesBefore(node);
      } else {
        lines = self.whitespace.getNewlinesAfter(node);
      }
    } else {
      // generated node
      if (!leading) lines++; // always include at least a single line after

      var needs = n.needsWhitespaceAfter;
      if (leading) needs = n.needsWhitespaceBefore;
      lines += needs(node, parent);

      // generated nodes can't add starting file whitespace
      if (!self.buffer.get()) lines = 0;
    }

    self.newline(lines);
  };

  if (this[node.type]) {
    var needsNoLineTermParens = n.needsParensNoLineTerminator(node, parent);
    var needsParens           = needsNoLineTermParens || n.needsParens(node, parent);

    if (needsParens) this.push("(");
    if (needsNoLineTermParens) this.indent();

    this.printLeadingComments(node, parent);

    newline(true);

    if (opts.before) opts.before();
    this.map.mark(node, "start");

    this[node.type](node, this.buildPrint(node), parent);

    if (needsNoLineTermParens) {
      this.newline();
      this.dedent();
    }
    if (needsParens) this.push(")");

    this.map.mark(node, "end");
    if (opts.after) opts.after();

    newline(false);

    this.printTrailingComments(node, parent);
  } else {
    throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
  }

  this.format.concise = oldConcise;
};

CodeGenerator.prototype.printJoin = function (print, nodes, opts) {
  if (!nodes || !nodes.length) return;

  opts = opts || {};

  var self = this;
  var len  = nodes.length;

  if (opts.indent) self.indent();

  each(nodes, function (node, i) {
    print(node, {
      statement: opts.statement,
      after: function () {
        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < len - 1) {
          self.push(opts.separator);
        }
      }
    });
  });

  if (opts.indent) self.dedent();
};

CodeGenerator.prototype.printAndIndentOnComments = function (print, node) {
  var indent = !!node.leadingComments;
  if (indent) this.indent();
  print(node);
  if (indent) this.dedent();
};

CodeGenerator.prototype.printBlock = function (print, node) {
  if (t.isEmptyStatement(node)) {
    this.semicolon();
  } else {
    this.push(" ");
    print(node);
  }
};

CodeGenerator.prototype.generateComment = function (comment) {
  var val = comment.value;
  if (comment.type === "Line") {
    val = "//" + val;
  } else {
    val = "/*" + val + "*/";
  }
  return val;
};

CodeGenerator.prototype.printTrailingComments = function (node, parent) {
  this._printComments(this.getComments("trailingComments", node, parent));
};

CodeGenerator.prototype.printLeadingComments = function (node, parent) {
  this._printComments(this.getComments("leadingComments", node, parent));
};

CodeGenerator.prototype.getComments = function (key, node, parent) {
  if (t.isExpressionStatement(parent)) {
    return [];
  }

  var comments = [];
  var nodes    = [node];
  var self     = this;

  if (t.isExpressionStatement(node)) {
    nodes.push(node.argument);
  }

  each(nodes, function (node) {
    comments = comments.concat(self._getComments(key, node));
  });

  return comments;
};

CodeGenerator.prototype._getComments = function (key, node) {
  return (node && node[key]) || [];
};

CodeGenerator.prototype._printComments = function (comments) {
  if (this.format.compact) return;
  if (!this.format.comments) return;
  if (!comments || !comments.length) return;

  var self = this;

  each(comments, function (comment) {
    var skip = false;

    // find the original comment in the ast and set it as displayed
    each(self.ast.comments, function (origComment) {
      if (origComment.start === comment.start) {
        // comment has already been output
        if (origComment._displayed) skip = true;

        origComment._displayed = true;
        return false;
      }
    });

    if (skip) return;

    // whitespace before
    self.newline(self.whitespace.getNewlinesBefore(comment));

    var column = self.position.column;
    var val    = self.generateComment(comment);

    if (column && !self.isLast(["\n", " ", "[", "{"])) {
      self._push(" ");
      column++;
    }

    //

    if (comment.type === "Block" && self.format.indent.adjustMultilineComment) {
      var offset = comment.loc.start.column;
      if (offset) {
        var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }

      var indent = Math.max(self.indentSize(), column);
      val = val.replace(/\n/g, "\n" + repeating(" ", indent));
    }

    if (column === 0) {
      val = self.getIndent() + val;
    }

    //

    self._push(val);

    // whitespace after
    self.newline(self.whitespace.getNewlinesAfter(comment));
  });
};

},{"../types":122,"./buffer":5,"./generators/base":6,"./generators/classes":7,"./generators/comprehensions":8,"./generators/expressions":9,"./generators/flow":10,"./generators/jsx":11,"./generators/methods":12,"./generators/modules":13,"./generators/playground":14,"./generators/statements":15,"./generators/template-literals":16,"./generators/types":17,"./node":19,"./position":22,"./source-map":23,"./whitespace":24,"detect-indent":153,"lodash/collection/each":172,"lodash/object/extend":260,"lodash/object/merge":264,"repeating":286}],19:[function(require,module,exports){
"use strict";

module.exports = Node;

var whitespace = require("./whitespace");
var parens     = require("./parentheses");
var t          = require("../../types");
var each       = require("lodash/collection/each");
var some       = require("lodash/collection/some");

var find = function (obj, node, parent) {
  if (!obj) return;
  var result;

  var types = Object.keys(obj);
  for (var i = 0; i < types.length; i++) {
    var type = types[i];

    if (t.is(type, node)) {
      var fn = obj[type];
      result = fn(node, parent);
      if (result != null) break;
    }
  }

  return result;
};

function Node(node, parent) {
  this.parent = parent;
  this.node   = node;
}

Node.isUserWhitespacable = function (node) {
  return t.isUserWhitespacable(node);
};

Node.needsWhitespace = function (node, parent, type) {
  if (!node) return 0;

  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  var lines = find(whitespace[type].nodes, node, parent);
  if (lines) return lines;

  each(find(whitespace[type].list, node, parent), function (expr) {
    lines = Node.needsWhitespace(expr, node, type);
    if (lines) return false;
  });
  return lines || 0;
};

Node.needsWhitespaceBefore = function (node, parent) {
  return Node.needsWhitespace(node, parent, "before");
};

Node.needsWhitespaceAfter = function (node, parent) {
  return Node.needsWhitespace(node, parent, "after");
};

Node.needsParens = function (node, parent) {
  if (!parent) return false;

  if (t.isNewExpression(parent) && parent.callee === node) {
    if (t.isCallExpression(node)) return true;

    var hasCall = some(node, function (val) {
      return t.isCallExpression(val);
    });
    if (hasCall) return true;
  }

  return find(parens, node, parent);
};

Node.needsParensNoLineTerminator = function (node, parent) {
  if (!parent) return false;

  // no comments
  if (!node.leadingComments || !node.leadingComments.length) {
    return false;
  }

  if (t.isYieldExpression(parent) || t.isAwaitExpression(parent)) {
    return true;
  }

  if (t.isContinueStatement(parent) || t.isBreakStatement(parent) ||
      t.isReturnStatement(parent) || t.isThrowStatement(parent)) {
    return true;
  }

  return false;
};

each(Node, function (fn, key) {
  Node.prototype[key] = function () {
    // Avoid leaking arguments to prevent deoptimization
    var args = new Array(arguments.length + 2);

    args[0] = this.node;
    args[1] = this.parent;

    for (var i = 0; i < args.length; i++) {
      args[i + 2] = arguments[i];
    }

    return Node[key].apply(null, args);
  };
});

},{"../../types":122,"./parentheses":20,"./whitespace":21,"lodash/collection/each":172,"lodash/collection/some":178}],20:[function(require,module,exports){
"use strict";

var t    = require("../../types");
var each = require("lodash/collection/each");

var PRECEDENCE = {};

each([
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%"],
  ["**"]
], function (tier, i) {
  each(tier, function (op) {
    PRECEDENCE[op] = i;
  });
});

exports.UpdateExpression = function (node, parent) {
  if (t.isMemberExpression(parent) && parent.object === node) {
    // (foo++).test()
    return true;
  }
};

exports.ObjectExpression = function (node, parent) {
  if (t.isExpressionStatement(parent)) {
    // ({ foo: "bar" });
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    // ({ foo: "bar" }).foo
    return true;
  }

  return false;
};

exports.Binary = function (node, parent) {
  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {
    return true;
  }

  if (t.isUnaryLike(parent)) {
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  if (t.isBinary(parent)) {
    var parentOp  = parent.operator;
    var parentPos = PRECEDENCE[parentOp];

    var nodeOp = node.operator;
    var nodePos = PRECEDENCE[nodeOp];

    if (parentPos > nodePos) {
      return true;
    }

    if (parentPos === nodePos && parent.right === node) {
      return true;
    }
  }
};

exports.BinaryExpression = function (node, parent) {
  if (node.operator === "in") {
    // var i = (1 in []);
    if (t.isVariableDeclarator(parent)) {
      return true;
    }

    // for ((1 in []);;);
    if (t.isFor(parent)) {
      return true;
    }
  }
};

exports.SequenceExpression = function (node, parent) {
  if (t.isForStatement(parent)) {
    // Although parentheses wouldn't hurt around sequence
    // expressions in the head of for loops, traditional style
    // dictates that e.g. i++, j++ should not be wrapped with
    // parentheses.
    return false;
  }

  if (t.isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  // Otherwise err on the side of overparenthesization, adding
  // explicit exceptions above if this proves overzealous.
  return true;
};

exports.YieldExpression = function (node, parent) {
  return t.isBinary(parent) ||
         t.isUnaryLike(parent) ||
         t.isCallExpression(parent) ||
         t.isMemberExpression(parent) ||
         t.isNewExpression(parent) ||
         t.isConditionalExpression(parent) ||
         t.isYieldExpression(parent);
};

exports.ClassExpression = function (node, parent) {
  return t.isExpressionStatement(parent);
};

exports.UnaryLike = function (node, parent) {
  return t.isMemberExpression(parent) && parent.object === node;
};

exports.FunctionExpression = function (node, parent) {
  // function () {};
  if (t.isExpressionStatement(parent)) {
    return true;
  }

  // (function test() {}).name;
  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  // (function () {})();
  if (t.isCallExpression(parent) && parent.callee === node) {
    return true;
  }
};

exports.AssignmentExpression =
exports.ConditionalExpression = function (node, parent) {
  if (t.isUnaryLike(parent)) {
    return true;
  }

  if (t.isBinary(parent)) {
    return true;
  }

  if (t.isCallExpression(parent) || t.isNewExpression(parent)) {
    if (parent.callee === node) {
      return true;
    }
  }

  if (t.isConditionalExpression(parent) && parent.test === node) {
    return true;
  }

  if (t.isMemberExpression(parent) && parent.object === node) {
    return true;
  }

  return false;
};

},{"../../types":122,"lodash/collection/each":172}],21:[function(require,module,exports){
"use strict";

var t        = require("../../types");
var each     = require("lodash/collection/each");
var map      = require("lodash/collection/map");
var isNumber = require("lodash/lang/isNumber");

exports.before = {
  nodes: {
    Property: function (node, parent) {
      if (parent.properties[0] === node) {
        return 1;
      }
    },

    SpreadProperty: function (node, parent) {
      return exports.before.nodes.Property(node, parent);
    },

    SwitchCase: function (node, parent) {
      if (parent.cases[0] === node) {
        return 1;
      }
    },

    CallExpression: function (node) {
      if (t.isFunction(node.callee)) {
        return 1;
      }
    }
  }
};

exports.after = {
  nodes: {
    LogicalExpression: function (node) {
      return t.isFunction(node.left) || t.isFunction(node.right);
    },

    AssignmentExpression: function (node) {
      if (t.isFunction(node.right)) {
        return 1;
      }
    }
  },

  list: {
    VariableDeclaration: function (node) {
      return map(node.declarations, "init");
    },

    ArrayExpression: function (node) {
      return node.elements;
    },

    ObjectExpression: function (node) {
      return node.properties;
    }
  }
};

each({
  Function: 1,
  Class: 1,
  For: 1,
  ArrayExpression: { after: 1 },
  ObjectExpression: { after: 1 },
  SwitchStatement: 1,
  IfStatement: { before: 1 },
  CallExpression: { after: 1 },
  Literal: { after: 1 }
}, function (amounts, type) {
  if (isNumber(amounts)) {
    amounts = { after: amounts, before: amounts };
  }

  each([type].concat(t.FLIPPED_ALIAS_KEYS[type] || []), function (type) {
    each(amounts, function (amount, key) {
      exports[key].nodes[type] = function () {
        return amount;
      };
    });
  });
});

},{"../../types":122,"lodash/collection/each":172,"lodash/collection/map":176,"lodash/lang/isNumber":251}],22:[function(require,module,exports){
"use strict";

module.exports = Position;

function Position() {
  this.line = 1;
  this.column = 0;
}

Position.prototype.push = function (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\n") {
      this.line++;
      this.column = 0;
    } else {
      this.column++;
    }
  }
};

Position.prototype.unshift = function (str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\n") {
      this.line--;
    } else {
      this.column--;
    }
  }
};

},{}],23:[function(require,module,exports){
"use strict";

module.exports = SourceMap;

var sourceMap = require("source-map");
var t         = require("../types");

function SourceMap(position, opts, code) {
  this.position = position;
  this.opts     = opts;

  if (opts.sourceMap) {
    this.map = new sourceMap.SourceMapGenerator({
      file: opts.sourceMapName,
      sourceRoot: opts.sourceRoot
    });

    this.map.setSourceContent(opts.sourceFileName, code);
  } else {
    this.map = null;
  }
}

SourceMap.prototype.get = function () {
  var map = this.map;
  if (map) {
    return map.toJSON();
  } else {
    return map;
  }
};

SourceMap.prototype.mark = function (node, type) {
  var loc = node.loc;
  if (!loc) return; // no location info

  var map = this.map;
  if (!map) return; // no source map

  if (t.isProgram(node) || t.isFile(node)) return; // illegal mapping nodes

  var position = this.position;

  var generated = {
    line: position.line,
    column: position.column
  };

  var original = loc[type];

  map.addMapping({
    source: this.opts.sourceFileName,
    generated: generated,
    original: original
  });
};

},{"../types":122,"source-map":291}],24:[function(require,module,exports){
"use strict";

module.exports = Whitespace;

var sortBy = require("lodash/collection/sortBy");

/**
 * Returns `i`th number from `base`, continuing from 0 when `max` is reached.
 * Useful for shifting `for` loop by a fixed number but going over all items.
 *
 * @param {Number} i Current index in the loop
 * @param {Number} base Start index for which to return 0
 * @param {Number} max Array length
 * @returns {Number} shiftedIndex
 */
function getLookupIndex(i, base, max) {
  i += base;

  if (i >= max)
    i -= max;

  return i;
}

function Whitespace(tokens, comments) {
  this.tokens = sortBy(tokens.concat(comments), "start");
  this.used   = {};

  // Profiling this code shows that while generator passes over it, indexes
  // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.

  // We use this implementation detail for an optimization: instead of always
  // starting to look from `this.tokens[0]`, we will start `for` loops from the
  // previous successful match. We will enumerate all tokens—but the common
  // case will be much faster.

  this._lastFoundIndex = 0;
}

Whitespace.prototype.getNewlinesBefore = function (node) {
  var startToken;
  var endToken;
  var tokens = this.tokens;
  var token;

  for (var j = 0; j < tokens.length; j++) {
    // optimize for forward traversal by shifting for loop index
    var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
    token = tokens[i];

    // this is the token this node starts with
    if (node.start === token.start) {
      startToken = tokens[i - 1];
      endToken = token;

      this._lastFoundIndex = i;
      break;
    }
  }

  return this.getNewlinesBetween(startToken, endToken);
};

Whitespace.prototype.getNewlinesAfter = function (node) {
  var startToken;
  var endToken;
  var tokens = this.tokens;
  var token;

  for (var j = 0; j < tokens.length; j++) {
    // optimize for forward traversal by shifting for loop index
    var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);
    token = tokens[i];

    // this is the token this node ends with
    if (node.end === token.end) {
      startToken = token;
      endToken = tokens[i + 1];

      this._lastFoundIndex = i;
      break;
    }
  }

  if (endToken && endToken.type.type === "eof") {
    return 1;
  } else {
    var lines = this.getNewlinesBetween(startToken, endToken);
    if (node.type === "Line" && !lines) {
      // line comment
      return 1;
    } else {
      return lines;
    }
  }
};

Whitespace.prototype.getNewlinesBetween = function (startToken, endToken) {
  if (!endToken || !endToken.loc) return 0;

  var start = startToken ? startToken.loc.end.line : 1;
  var end   = endToken.loc.start.line;
  var lines = 0;

  for (var line = start; line < end; line++) {
    if (typeof this.used[line] === "undefined") {
      this.used[line] = true;
      lines++;
    }
  }

  return lines;
};

},{"lodash/collection/sortBy":179}],25:[function(require,module,exports){
// syntax highlighting based on https://github.com/dominictarr/ansi-highlight by the fantastic Dominic Tarr

var repeating = require("repeating");
var tokenize  = require("js-tokenizer");
var chalk     = require("chalk");

var defs = {
  string1:  "red",
  string2:  "red",
  punct:    ["white", "bold"],
  curly:    "green",
  parens:   ["blue", "bold"],
  square:   ["yellow"],
  name:     "white",
  keyword:  ["cyan"],
  number:   "magenta",
  regexp:   "magenta",
  comment1: "grey",
  comment2: "grey"
};

var highlight = function (text) {
  var colorize = function (str, col) {
    if (!col) return str;

    if (Array.isArray(col)) {
      col.forEach(function (col) {
        str = chalk[col](str);
      });
    } else {
      str = chalk[col](str);
    }
    return str;
  };

  return tokenize(text, true).map(function (str) {
    var type = tokenize.type(str);
    return colorize(str, defs[type]);
  }).join("");
};

module.exports = function (lines, lineNumber, colNumber) {
  colNumber = Math.max(colNumber, 0);

  if (chalk.supportsColor) {
    lines = highlight(lines);
  }

  lines = lines.split(/\r\n|[\n\r\u2028\u2029]/);

  var start = Math.max(lineNumber - 3, 0);
  var end   = Math.min(lines.length, lineNumber + 3);
  var width = (end + "").length;

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  return "\n" + lines.slice(start, end).map(function (line, i) {
    var curr = i + start + 1;

    var gutter = curr === lineNumber ? "> " : "  ";

    var sep = curr + repeating(" ", width + 1);
    gutter += sep + "| ";

    var str = gutter + line;

    if (colNumber && curr === lineNumber) {
      str += "\n";
      str += repeating(" ", gutter.length - 2);
      str += "|" + repeating(" ", colNumber) + "^";
    }

    return str;
  }).join("\n");
};

},{"chalk":140,"js-tokenizer":164,"repeating":286}],26:[function(require,module,exports){
var t = require("../types");

module.exports = function (ast, comments, tokens) {
  if (ast && ast.type === "Program") {
    return t.file(ast, comments || [], tokens || []);
  } else {
    throw new Error("Not a valid ast?");
  }
};

},{"../types":122}],27:[function(require,module,exports){
"use strict";

module.exports = function () {
  return Object.create(null);
};

},{}],28:[function(require,module,exports){
var normalizeAst = require("./normalize-ast");
var estraverse   = require("estraverse");
var codeFrame    = require("./code-frame");
var acorn        = require("acorn-babel");

module.exports = function (opts, code, callback) {
  try {
    var comments = [];
    var tokens   = [];

    var ast = acorn.parse(code, {
      allowImportExportEverywhere: opts.allowImportExportEverywhere,
      allowReturnOutsideFunction:  !opts._anal,
      ecmaVersion:                 opts.experimental ? 7 : 6,
      playground:                  opts.playground,
      strictMode:                  opts.strictMode,
      onComment:                   comments,
      locations:                   true,
      onToken:                     tokens,
      ranges:                      true
    });

    estraverse.attachComments(ast, comments, tokens);

    ast = normalizeAst(ast, comments, tokens);

    if (callback) {
      return callback(ast);
    } else {
      return ast;
    }
  } catch (err) {
    if (!err._babel) {
      err._babel = true;
      var message = opts.filename + ": " + err.message;

      var loc = err.loc;
      if (loc) {
        var frame = codeFrame(code, loc.line, loc.column + 1);
        message += frame;
      }

      if (err.stack) err.stack = err.stack.replace(err.message, message);
      err.message = message;
    }

    throw err;
  }
};

},{"./code-frame":25,"./normalize-ast":26,"acorn-babel":125,"estraverse":154}],29:[function(require,module,exports){
"use strict";

/**
 * A trick from Bluebird to force V8 to use fast properties for an object.
 * Read more: http://stackoverflow.com/questions/24987896/
 *
 * Use %HasFastProperties(obj) and --allow-natives-syntax to check whether
 * a particular object already has fast properties.
 */

module.exports = function toFastProperties(obj) {
  /*jshint -W027*/
  function f() {}
  f.prototype = obj;
  return f;
  eval(obj);
};

},{}],30:[function(require,module,exports){
var util = require("util");

exports.messages = {
  tailCallReassignmentDeopt: "Function reference has been reassigned so it's probably be dereferenced so we can't optimise this with confidence",
  JSXNamespacedTags: "Namespace tags are not supported. ReactJSX is not XML.",
  classesIllegalBareSuper: "Illegal use of bare super",
  classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
  classesIllegalConstructorKind: "Illegal kind for constructor method",
  scopeDuplicateDeclaration: "Duplicate declaration $1",
  undeclaredVariable: "Reference to undeclared variable $1",
  undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
  settersInvalidParamLength: "Setters must have exactly one parameter",
  noAssignmentsInForHead: "No assignments allowed in for-in/of head",
  expectedMemberExpressionOrIdentifier: "Expected type MemeberExpression or Identifier",
  invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
  readOnly: "$1 is read-only",
  modulesIllegalExportName: "Illegal export $1",
  unknownForHead: "Unknown node type $1 in ForStatement",
  didYouMean: "Did you mean $1?",
  evalInStrictMode: "eval is not allowed in strict mode"
};

exports.get = function (key) {
  var msg = exports.messages[key];
  if (!msg) throw new ReferenceError("Unknown message `" + key + "`");

  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }
  args = exports.parseArgs(args);

  return msg.replace(/\$(\d+)/g, function (str, i) {
    return args[--i];
  });
};

exports.parseArgs = function (args) {
  return args.map(function (val) {
    if (val != null && val.inspect) {
      return val.inspect();
    } else {
      try {
        return JSON.stringify(val) || val + "";
      } catch (e) {
        return util.inspect(val);
      }
    }
  });
};

},{"util":331}],31:[function(require,module,exports){
"use strict";

var extend = require("lodash/object/extend");
var t      = require("./types");

// estraverse

var estraverse = require("estraverse");
extend(estraverse.VisitorKeys, t.VISITOR_KEYS);

// regenerator-babel/ast-types

var types = require("ast-types");
var def   = types.Type.def;
var or    = types.Type.or;

def("File")
  .bases("Node")
  .build("program")
  .field("program", def("Program"));

def("AssignmentPattern")
  .bases("Pattern")
  .build("left", "right")
  .field("left", def("Pattern"))
  .field("right", def("Expression"));

// Acorn - Same as ImportNamespaceSpecifier but `id` is `name`
def("ImportBatchSpecifier")
  .bases("Specifier")
  .build("name")
  .field("name", def("Identifier"));

def("RestElement")
  .bases("Pattern")
  .build("argument")
  .field("argument", def("expression"));

// Abstract references
def("VirtualPropertyExpression")
  .bases("Expression")
  .build("object", "property")
  .field("object", def("Expression"))
  .field("property", or(def("Identifier"), def("Expression")));

def("PrivateDeclaration")
  .bases("Declaration")
  .build("declarations")
  .field("declarations", [def("Identifier")]);

// Playground
def("BindMemberExpression")
  .bases("Expression")
  .build("object", "property", "arguments")
  .field("object", def("Expression"))
  .field("property", or(def("Identifier"), def("Expression")))
  .field("arguments", [def("Expression")]);

def("BindFunctionExpression")
  .bases("Expression")
  .build("callee", "arguments")
  .field("callee", def("Expression"))
  .field("arguments", [def("Expression")]);

types.finalize();

},{"./types":122,"ast-types":139,"estraverse":154,"lodash/object/extend":260}],32:[function(require,module,exports){
(function (global){
"use strict";

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;

require("core-js/shim");
require("regenerator-babel/runtime");

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/shim":149,"regenerator-babel/runtime":279}],33:[function(require,module,exports){
"use strict";

module.exports = File;

var sourceMapToComment = require("source-map-to-comment");
var shebangRegex       = require("shebang-regex");
var isFunction         = require("lodash/lang/isFunction");
var transform          = require("./index");
var generate           = require("../generation");
var defaults           = require("lodash/object/defaults");
var includes           = require("lodash/collection/includes");
var assign             = require("lodash/object/assign");
var parse              = require("../helpers/parse");
var Scope              = require("../traversal/scope");
var slash              = require("slash");
var util               = require("../util");
var path               = require("path");
var each               = require("lodash/collection/each");
var t                  = require("../types");

function File(opts) {
  this.dynamicImportedNoDefault = [];
  this.dynamicImportIds         = {};
  this.dynamicImported          = [];
  this.dynamicImports           = [];

  this.dynamicData      = {};
  this.data             = {};

  this.lastStatements   = [];
  this.opts             = this.normalizeOptions(opts);
  this.ast              = {};

  this.buildTransformers();
}

File.helpers = [
  "inherits",
  "defaults",
  "prototype-properties",
  "apply-constructor",
  "tagged-template-literal",
  "tagged-template-literal-loose",
  "interop-require",
  "to-array",
  "to-consumable-array",
  "sliced-to-array",
  "object-without-properties",
  "has-own",
  "slice",
  "bind",
  "define-property",
  "async-to-generator",
  "interop-require-wildcard",
  "typeof",
  "extends",
  "get",
  "set",
  "class-call-check",
  "object-destructuring-empty",
  "temporal-undefined",
  "temporal-assert-defined",
  "tail-call",
  "self-global"
];

File.validOptions = [
  "filename",
  "filenameRelative",
  "blacklist",
  "whitelist",
  "loose",
  "optional",
  "modules",
  "sourceMap",
  "sourceMapName",
  "sourceFileName",
  "sourceRoot",
  "moduleRoot",
  "moduleIds",
  "comments",
  "reactCompat",
  "keepModuleIdExtensions",
  "code",
  "ast",
  "format",
  "playground",
  "experimental",
  "resolveModuleSource",
  "externalHelpers",
  "auxiliaryComment",

  // these are used by plugins
  "ignore",
  "only",
  "extensions",
  "accept"
];

File.prototype.normalizeOptions = function (opts) {
  opts = assign({}, opts);

  for (var key in opts) {
    if (key[0] !== "_" && File.validOptions.indexOf(key) < 0) {
      throw new ReferenceError("Unknown option: " + key);
    }
  }

  defaults(opts, {
    keepModuleIdExtensions: false,
    resolveModuleSource:    null,
    externalHelpers:        false,
    auxilaryComment:        "",
    experimental:           false,
    reactCompat:            false,
    playground:             false,
    whitespace:             true,
    moduleIds:              false,
    blacklist:              [],
    whitelist:              [],
    sourceMap:              false,
    optional:               [],
    comments:               true,
    filename:               "unknown",
    modules:                "common",
    loose:                  [],
    code:                   true,
    ast:                    true
  });

  // normalize windows path separators to unix
  opts.filename = slash(opts.filename);
  if (opts.sourceRoot) {
    opts.sourceRoot = slash(opts.sourceRoot);
  }

  opts.basename = path.basename(opts.filename, path.extname(opts.filename));

  opts.blacklist = util.arrayify(opts.blacklist);
  opts.whitelist = util.arrayify(opts.whitelist);
  opts.optional  = util.arrayify(opts.optional);
  opts.loose     = util.arrayify(opts.loose);

  if (includes(opts.loose, "all") || includes(opts.loose, true)) {
    opts.loose = Object.keys(transform.transformers);
  }

  defaults(opts, {
    moduleRoot: opts.sourceRoot
  });

  defaults(opts, {
    sourceRoot: opts.moduleRoot
  });

  defaults(opts, {
    filenameRelative: opts.filename
  });

  defaults(opts, {
    sourceFileName: opts.filenameRelative,
    sourceMapName:  opts.filenameRelative
  });

  if (opts.playground) {
    opts.experimental = true;
  }

  if (opts.externalHelpers) {
    this.set("runtimeIdentifier", t.identifier("babelHelpers"));
  }

  opts.blacklist = transform._ensureTransformerNames("blacklist", opts.blacklist);
  opts.whitelist = transform._ensureTransformerNames("whitelist", opts.whitelist);
  opts.optional  = transform._ensureTransformerNames("optional", opts.optional);
  opts.loose     = transform._ensureTransformerNames("loose", opts.loose);

  if (opts.reactCompat) {
    opts.optional.push("reactCompat");
    console.error("The reactCompat option has been moved into the optional transformer " +
                  "`reactCompat` - backwards compatibility will be removed in v4.0.0");
  }

  var ensureEnabled = function (key) {
    var namespace = transform.transformerNamespaces[key];
    if (namespace === "es7") opts.experimental = true;
    if (namespace === "playground") opts.playground = true;
  };

  each(opts.whitelist, ensureEnabled);
  each(opts.optional, ensureEnabled);

  return opts;
};

File.prototype.isLoose = function (key) {
  return includes(this.opts.loose, key);
};

File.prototype.buildTransformers = function () {
  var file = this;

  var transformers = {};

  var secondaryStack = [];
  var stack = [];

  each(transform.transformers, function (transformer, key) {
    var pass = transformers[key] = transformer.buildPass(file);

    if (pass.canRun(file)) {
      stack.push(pass);

      if (transformer.secondPass) {
        secondaryStack.push(pass);
      }

      if (transformer.manipulateOptions) {
        transformer.manipulateOptions(file.opts, file);
      }
    }
  });

  this.transformerStack = stack.concat(secondaryStack);
  this.transformers = transformers;
};

File.prototype.debug = function (msg) {
  var parts = this.opts.filename;
  if (msg) parts += ": " + msg;
  util.debug(parts);
};

File.prototype.getModuleFormatter = function (type) {
  var ModuleFormatter = isFunction(type) ? type : transform.moduleFormatters[type];

  if (!ModuleFormatter) {
    var loc = util.resolve(type);
    if (loc) ModuleFormatter = require(loc);
  }

  if (!ModuleFormatter) {
    throw new ReferenceError("Unknown module formatter type " + JSON.stringify(type));
  }

  return new ModuleFormatter(this);
};

File.prototype.parseShebang = function (code) {
  var shebangMatch = shebangRegex.exec(code);

  if (shebangMatch) {
    this.shebang = shebangMatch[0];

    // remove shebang
    code = code.replace(shebangRegex, "");
  }

  return code;
};

File.prototype.set = function (key, val) {
  return this.data[key] = val;
};

File.prototype.setDynamic = function (key, fn) {
  this.dynamicData[key] = fn;
};

File.prototype.get = function (key) {
  var data = this.data[key];
  if (data) {
    return data;
  } else {
    var dynamic = this.dynamicData[key];
    if (dynamic) {
      return this.set(key, dynamic());
    }
  }
};

File.prototype.addImport = function (source, name, noDefault) {
  name = name || source;
  var id = this.dynamicImportIds[name];

  if (!id) {
    id = this.dynamicImportIds[name] = this.scope.generateUidIdentifier(name);

    var specifiers = [t.importSpecifier(t.identifier("default"), id)];
    var declar = t.importDeclaration(specifiers, t.literal(source));
    declar._blockHoist = 3;

    this.dynamicImported.push(declar);
    if (noDefault) this.dynamicImportedNoDefault.push(declar);

    this.moduleFormatter.importSpecifier(specifiers[0], declar, this.dynamicImports);
  }

  return id;
};

File.prototype.isConsequenceExpressionStatement = function (node) {
  return t.isExpressionStatement(node) && this.lastStatements.indexOf(node) >= 0;
};

File.prototype.attachAuxiliaryComment = function (node) {
  var comment = this.opts.auxiliaryComment;
  if (comment) {
    node.leadingComments = node.leadingComments || [];
    node.leadingComments.push({
      type: "Line",
      value: " " + comment
    });
  }
  return node;
};

File.prototype.addHelper = function (name) {
  if (!includes(File.helpers, name)) {
    throw new ReferenceError("Unknown helper " + name);
  }

  var program = this.ast.program;

  var declar = program._declarations && program._declarations[name];
  if (declar) return declar.id;

  var runtime = this.get("runtimeIdentifier");
  if (runtime) {
    name = t.identifier(t.toIdentifier(name));
    return t.memberExpression(runtime, name);
  } else {
    var ref = util.template(name);
    ref._compact = true;
    var uid = this.scope.generateUidIdentifier(name);
    this.scope.push({
      key: name,
      id: uid,
      init: ref
    });
    return uid;
  }
};

File.prototype.logDeopt = function () {
  // todo, (node, msg)
};

File.prototype.errorWithNode = function (node, msg, Error) {
  Error = Error || SyntaxError;

  var loc = node.loc.start;
  var err = new Error("Line " + loc.line + ": " + msg);
  err.loc = loc;
  return err;
};

File.prototype.addCode = function (code) {
  code = (code || "") + "";
  this.code = code;
  return this.parseShebang(code);
};

File.prototype.parse = function (code) {
  var self = this;

  code = this.addCode(code);

  var opts = this.opts;

  opts.allowImportExportEverywhere = this.isLoose("es6.modules");
  opts.strictMode = this.transformers.useStrict.canRun();

  return parse(opts, code, function (tree) {
    self.transform(tree);
    return self.generate();
  });
};

File.prototype.transform = function (ast) {
  this.debug();

  this.ast = ast;
  this.lastStatements = t.getLastStatements(ast.program);
  this.scope = new Scope(ast.program, ast, null, this);

  var modFormatter = this.moduleFormatter = this.getModuleFormatter(this.opts.modules);
  if (modFormatter.init && this.transformers["es6.modules"].canRun()) {
    modFormatter.init();
  }

  this.checkNode(ast);

  this.call("pre");

  each(this.transformerStack, function (pass) {
    pass.transform();
  });

  this.call("post");
};

File.prototype.call = function (key) {
  var stack = this.transformerStack;
  for (var i = 0; i < stack.length; i++) {
    var transformer = stack[i].transformer;
    if (transformer[key]) {
      transformer[key](this);
    }
  }
};

var checkTransformerVisitor = {
  enter: function (node, parent, scope, state) {
    checkNode(state.stack, node, scope);
  }
};

var checkNode = function (stack, node, scope) {
  each(stack, function (pass) {
    if (pass.shouldRun) return;
    pass.checkNode(node, scope);
  });
};

File.prototype.checkNode = function (node, scope) {
  var stack = this.transformerStack;
  scope = scope || this.scope;

  checkNode(stack, node, scope);

  scope.traverse(node, checkTransformerVisitor, {
    stack: stack
  });
};

File.prototype.generate = function () {
  var opts = this.opts;
  var ast  = this.ast;

  var result = {
    code: "",
    map: null,
    ast: null
  };

  if (opts.ast) result.ast = ast;
  if (!opts.code) return result;

  var _result = generate(ast, opts, this.code);
  result.code = _result.code;
  result.map  = _result.map;

  if (this.shebang) {
    // add back shebang
    result.code = this.shebang + "\n" + result.code;
  }

  if (opts.sourceMap === "inline") {
    result.code += "\n" + sourceMapToComment(result.map);
    result.map = null;
  }

  return result;
};

},{"../generation":18,"../helpers/parse":28,"../traversal/scope":119,"../types":122,"../util":124,"./index":45,"lodash/collection/each":172,"lodash/collection/includes":175,"lodash/lang/isFunction":249,"lodash/object/assign":258,"lodash/object/defaults":259,"path":314,"shebang-regex":288,"slash":289,"source-map-to-comment":290}],34:[function(require,module,exports){
"use strict";

var explode = require("./explode-assignable-expression");
var t       = require("../../types");

module.exports = function (exports, opts) {
  var isAssignment = function (node) {
    return node.operator === opts.operator + "=";
  };

  var buildAssignment = function (left, right) {
    return t.assignmentExpression("=", left, right);
  };

  exports.ExpressionStatement = function (node, parent, scope, file) {
    // hit the `AssignmentExpression` one below
    if (file.isConsequenceExpressionStatement(node)) return;

    var expr = node.expression;
    if (!isAssignment(expr)) return;

    var nodes    = [];
    var exploded = explode(expr.left, nodes, file, scope, true);

    nodes.push(t.expressionStatement(
      buildAssignment(exploded.ref, opts.build(exploded.uid, expr.right))
    ));

    return nodes;
  };

  exports.AssignmentExpression = function (node, parent, scope, file) {
    if (!isAssignment(node)) return;

    var nodes    = [];
    var exploded = explode(node.left, nodes, file, scope);
    nodes.push(buildAssignment(exploded.ref, opts.build(exploded.uid, node.right)));

    return t.toSequenceExpression(nodes, scope);
  };

  exports.BinaryExpression = function (node) {
    if (node.operator !== opts.operator) return;
    return opts.build(node.left, node.right);
  };
};

},{"../../types":122,"./explode-assignable-expression":39}],35:[function(require,module,exports){
"use strict";

var t = require("../../types");

module.exports = function build(node, buildBody) {
  var self = node.blocks.shift();
  if (!self) return;

  var child = build(node, buildBody);
  if (!child) {
    // last item
    child = buildBody();

    // add a filter as this is our final stop
    if (node.filter) {
      child = t.ifStatement(node.filter, t.blockStatement([child]));
    }
  }

  return t.forOfStatement(
    t.variableDeclaration("let", [t.variableDeclarator(self.left)]),
    self.right,
    t.blockStatement([child])
  );
};

},{"../../types":122}],36:[function(require,module,exports){
"use strict";

var explode = require("./explode-assignable-expression");
var t       = require("../../types");

module.exports = function (exports, opts) {
  var buildAssignment = function (left, right) {
    return t.assignmentExpression("=", left, right);
  };

  exports.ExpressionStatement = function (node, parent, scope, file) {
    // hit the `AssignmentExpression` one below
    if (file.isConsequenceExpressionStatement(node)) return;

    var expr = node.expression;
    if (!opts.is(expr, file)) return;

    var nodes = [];

    var exploded = explode(expr.left, nodes, file, scope);

    nodes.push(t.ifStatement(
      opts.build(exploded.uid, file),
      t.expressionStatement(buildAssignment(exploded.ref, expr.right))
    ));

    return nodes;
  };

  exports.AssignmentExpression = function (node, parent, scope, file) {
    if (!opts.is(node, file)) return;

    var nodes    = [];
    var exploded = explode(node.left, nodes, file, scope);

    nodes.push(t.logicalExpression(
      "&&",
      opts.build(exploded.uid, file),
      buildAssignment(exploded.ref, node.right)
    ));

    // todo: duplicate expression node
    nodes.push(exploded.ref);

    return t.toSequenceExpression(nodes, scope);
  };
};

},{"../../types":122,"./explode-assignable-expression":39}],37:[function(require,module,exports){
"use strict";

// Based upon the excellent jsx-transpiler by Ingvar Stepanyan (RReverser)
// https://github.com/RReverser/jsx-transpiler

// jsx

var isString = require("lodash/lang/isString");
var messages = require("../../messages");
var esutils  = require("esutils");
var react    = require("./react");
var t        = require("../../types");

module.exports = function (exports, opts) {
  exports.check = function (node) {
    if (t.isJSX(node)) return true;
    if (react.isCreateClass(node)) return true;
    return false;
  };

  exports.JSXIdentifier = function (node, parent) {
    if (node.name === "this" && t.isReferenced(node, parent)) {
      return t.thisExpression();
    } else if (esutils.keyword.isIdentifierName(node.name)) {
      node.type = "Identifier";
    } else {
      return t.literal(node.name);
    }
  };

  exports.JSXNamespacedName = function (node, parent, scope, file) {
    throw file.errorWithNode(node, messages.get("JSXNamespacedTags"));
  };

  exports.JSXMemberExpression = {
    exit: function (node) {
      node.computed = t.isLiteral(node.property);
      node.type = "MemberExpression";
    }
  };

  exports.JSXExpressionContainer = function (node) {
    return node.expression;
  };

  exports.JSXAttribute = {
    exit: function (node) {
      var value = node.value || t.literal(true);

      if (t.isLiteral(value) && isString(value.value)) {
        value.value = value.value.replace(/\n\s+/g, " ");
      }

      return t.inherits(t.property("init", node.name, value), node);
    }
  };
  exports.JSXOpeningElement = {
    exit: function (node, parent, scope, file) {
      var tagExpr = node.name;
      var args = [];

      var tagName;
      if (t.isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (t.isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args:    args
      };

      if (opts.pre) {
        opts.pre(state);
      }

      var attribs = node.attributes;
      if (attribs.length) {
        attribs = buildJSXOpeningElementAttributes(attribs, file);
      } else {
        attribs = t.literal(null);
      }

      args.push(attribs);

      if (opts.post) {
        opts.post(state);
      }

      return state.call || t.callExpression(state.callee, args);
    }
  };

  /**
   * The logic for this is quite terse. It's because we need to
   * support spread elements. We loop over all attributes,
   * breaking on spreads, we then push a new object containg
   * all prior attributes to an array for later processing.
   */

  var buildJSXOpeningElementAttributes = function (attribs, file) {
    var _props = [];
    var objs = [];

    var pushProps = function () {
      if (!_props.length) return;

      objs.push(t.objectExpression(_props));
      _props = [];
    };

    while (attribs.length) {
      var prop = attribs.shift();
      if (t.isJSXSpreadAttribute(prop)) {
        pushProps();
        objs.push(prop.argument);
      } else {
        _props.push(prop);
      }
    }

    pushProps();

    if (objs.length === 1) {
      // only one object
      attribs = objs[0];
    } else {
      // looks like we have multiple objects
      if (!t.isObjectExpression(objs[0])) {
        objs.unshift(t.objectExpression([]));
      }

      // spread it
      attribs = t.callExpression(
        file.addHelper("extends"),
        objs
      );
    }

    return attribs;
  };

  exports.JSXElement = {
    exit: function (node) {
      var callExpr = node.openingElement;

      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];

        if (t.isLiteral(child) && typeof child.value === "string") {
          cleanJSXElementLiteralChild(child, callExpr.arguments);
          continue;
        } else if (t.isJSXEmptyExpression(child)) {
          continue;
        }

        callExpr.arguments.push(child);
      }

      callExpr.arguments = flatten(callExpr.arguments);

      if (callExpr.arguments.length >= 3) {
        callExpr._prettyCall = true;
      }

      return t.inherits(callExpr, node);
    }
  };

  var isStringLiteral = function (node) {
    return t.isLiteral(node) && isString(node.value);
  };

  var flatten = function (args) {
    var flattened = [];
    var last;

    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (isStringLiteral(arg) && isStringLiteral(last)) {
        last.value += arg.value;
      } else {
        last = arg;
        flattened.push(arg);
      }
    }

    return flattened;
  };

  var cleanJSXElementLiteralChild = function (child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);

    var lastNonEmptyLine = 0;
    var i;

    for (i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    for (i = 0; i < lines.length; i++) {
      var line = lines[i];

      var isFirstLine = i === 0;
      var isLastLine = i === lines.length - 1;
      var isLastNonEmptyLine = i === lastNonEmptyLine;

      // replace rendered whitespace tabs with spaces
      var trimmedLine = line.replace(/\t/g, " ");

      // trim whitespace touching a newline
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      // trim whitespace touching an endline
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        args.push(t.literal(trimmedLine));
      }
    }
  };

  // display names

  var addDisplayName = function (id, call) {
    var props = call.arguments[0].properties;
    var safe = true;

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (t.isIdentifier(prop.key, { name: "displayName" })) {
        safe = false;
        break;
      }
    }

    if (safe) {
      props.unshift(t.property("init", t.identifier("displayName"), t.literal(id)));
    }
  };

  exports.ExportDeclaration = function (node, parent, scope, file) {
    if (node.default && react.isCreateClass(node.declaration)) {
      addDisplayName(file.opts.basename, node.declaration);
    }
  };

  exports.AssignmentExpression =
  exports.Property =
  exports.VariableDeclarator = function (node) {
    var left, right;

    if (t.isAssignmentExpression(node)) {
      left = node.left;
      right = node.right;
    } else if (t.isProperty(node)) {
      left = node.key;
      right = node.value;
    } else if (t.isVariableDeclarator(node)) {
      left = node.id;
      right = node.init;
    }

    if (t.isMemberExpression(left)) {
      left = left.property;
    }

    if (t.isIdentifier(left) && react.isCreateClass(right)) {
      addDisplayName(left.name, right);
    }
  };
};

},{"../../messages":30,"../../types":122,"./react":41,"esutils":158,"lodash/lang/isString":255}],38:[function(require,module,exports){
var cloneDeep = require("lodash/lang/cloneDeep");
var traverse  = require("../../traversal");
var clone     = require("lodash/lang/clone");
var each      = require("lodash/collection/each");
var has       = require("lodash/object/has");
var t         = require("../../types");

exports.push = function (mutatorMap, key, kind, computed, value) {
  var alias;

  if (t.isIdentifier(key)) {
    alias = key.name;
    if (computed) alias = "computed:" + alias;
  } else if (t.isLiteral(key)) {
    alias = String(key.value);
  } else {
    alias = JSON.stringify(traverse.removeProperties(cloneDeep(key)));
  }

  var map;
  if (has(mutatorMap, alias)) {
    map = mutatorMap[alias];
  } else {
    map = {};
  }
  mutatorMap[alias] = map;

  map._key = key;
  if (computed) {
    map._computed = true;
  }

  map[kind] = value;
};

exports.build = function (mutatorMap) {
  var objExpr = t.objectExpression([]);

  each(mutatorMap, function (map) {
    var mapNode = t.objectExpression([]);

    var propNode = t.property("init", map._key, mapNode, map._computed);

    if (!map.get && !map.set) {
      map.writable = t.literal(true);
    }

    if (map.enumerable === false) {
      delete map.enumerable;
    } else {
      map.enumerable = t.literal(true);
    }

    map.configurable = t.literal(true);

    each(map, function (node, key) {
      if (key[0] === "_") return;

      node = clone(node);
      var inheritNode = node;
      if (t.isMethodDefinition(node)) node = node.value;

      var prop = t.property("init", t.identifier(key), node);
      t.inheritsComments(prop, inheritNode);
      t.removeComments(inheritNode);
      mapNode.properties.push(prop);
    });

    objExpr.properties.push(propNode);
  });

  return objExpr;
};

},{"../../traversal":117,"../../types":122,"lodash/collection/each":172,"lodash/lang/clone":243,"lodash/lang/cloneDeep":244,"lodash/object/has":261}],39:[function(require,module,exports){
"use strict";

var t = require("../../types");

var getObjRef = function (node, nodes, file, scope) {
  var ref;
  if (t.isIdentifier(node)) {
    if (scope.hasBinding(node.name)) {
      // this variable is declared in scope so we can be 100% sure
      // that evaluating it multiple times wont trigger a getter
      // or something else
      return node;
    } else {
      // could possibly trigger a getter so we need to only evaluate
      // it once
      ref = node;
    }
  } else if (t.isMemberExpression(node)) {
    ref = node.object;

    if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {
      // the object reference that we need to save is locally declared
      // so as per the previous comment we can be 100% sure evaluating
      // it multiple times will be safe
      return ref;
    }
  } else {
    throw new Error("We can't explode this node type " + node.type);
  }

  var temp = scope.generateUidBasedOnNode(ref);
  nodes.push(t.variableDeclaration("var", [
    t.variableDeclarator(temp, ref)
  ]));
  return temp;
};

var getPropRef = function (node, nodes, file, scope) {
  var prop = node.property;
  var key = t.toComputedKey(node, prop);
  if (t.isLiteral(key)) return key;

  var temp = scope.generateUidBasedOnNode(prop);
  nodes.push(t.variableDeclaration("var", [
    t.variableDeclarator(temp, prop)
  ]));
  return temp;
};

module.exports = function (node, nodes, file, scope, allowedSingleIdent) {
  var obj;
  if (t.isIdentifier(node) && allowedSingleIdent) {
    obj = node;
  } else {
    obj = getObjRef(node, nodes, file, scope);
  }

  var ref, uid;

  if (t.isIdentifier(node)) {
    ref = node;
    uid = obj;
  } else {
    var prop = getPropRef(node, nodes, file, scope);
    var computed = node.computed || t.isLiteral(prop);
    uid = ref = t.memberExpression(obj, prop, computed);
  }

  return {
    uid: uid,
    ref: ref
  };
};

},{"../../types":122}],40:[function(require,module,exports){
"use strict";

var util = require("../../util");
var t    = require("../../types");

var visitor = {
  enter: function (node, parent, scope, state) {
    // check if this node is an identifier that matches the same as our function id
    if (!t.isIdentifier(node, { name: state.id })) return;

    // check if this node is the one referenced
    if (!t.isReferenced(node, parent)) return;

    // check that we don't have a local variable declared as that removes the need
    // for the wrapper
    var localDeclar = scope.getBindingIdentifier(state.id);
    if (localDeclar !== state.outerDeclar) return;

    state.selfReference = true;
    this.stop();
  }
};

exports.property = function (node, file, scope) {
  var key = t.toComputedKey(node, node.key);
  if (!t.isLiteral(key)) return node; // we can't set a function id with this

  var id = t.toIdentifier(key.value);
  key = t.identifier(id);

  var state = {
    id: id,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(id),
  };

  scope.traverse(node, visitor, state);

  var method = node.value;

  if (state.selfReference) {
    var templateName = "property-method-assignment-wrapper";
    if (method.generator) templateName += "-generator";
    node.value = util.template(templateName, {
      FUNCTION: method,
      FUNCTION_ID: key,
      FUNCTION_KEY: scope.generateUidIdentifier(id),
      WRAPPER_KEY: scope.generateUidIdentifier(id + "Wrapper")
    });
  } else {
    method.id = key;
  }
};

},{"../../types":122,"../../util":124}],41:[function(require,module,exports){
var t = require("../../types");

var isCreateClassCallExpression = t.buildMatchMemberExpression("React.createClass");

exports.isCreateClass = function (node) {
  if (!node || !t.isCallExpression(node)) return false;

  // not React.createClass call member object
  if (!isCreateClassCallExpression(node.callee)) return false;

  // no call arguments
  var args = node.arguments;
  if (args.length !== 1) return false;

  // first node arg is not an object
  var first = args[0];
  if (!t.isObjectExpression(first)) return false;

  return true;
};

exports.isReactComponent = t.buildMatchMemberExpression("React.Component");

exports.isCompatTag = function (tagName) {
  return tagName && /^[a-z]|\-/.test(tagName);
};

},{"../../types":122}],42:[function(require,module,exports){
"use strict";

var t = require("../../types");

var visitor = {
  enter: function (node) {
    if (t.isFunction(node)) this.skip();

    if (t.isAwaitExpression(node)) {
      node.type = "YieldExpression";

      if (node.all) {
        // await* foo; -> yield Promise.all(foo);
        node.all = false;
        node.argument = t.callExpression(t.memberExpression(t.identifier("Promise"), t.identifier("all")), [node.argument]);
      }
    }
  }
};

module.exports = function (node, callId, scope) {
  node.async = false;
  node.generator = true;

  scope.traverse(node, visitor);

  var call = t.callExpression(callId, [node]);
  var id = node.id;
  delete node.id;

  if (t.isFunctionDeclaration(node)) {
    var declar = t.variableDeclaration("let", [
      t.variableDeclarator(id, call)
    ]);
    declar._blockHoist = true;
    return declar;
  } else {
    return call;
  }
};

},{"../../types":122}],43:[function(require,module,exports){
"use strict";

module.exports = ReplaceSupers;

var messages = require("../../messages");
var t        = require("../../types");

/**
 * Description
 *
 * @param {Object} opts
 * @param {Boolean} [inClass]
 */

function ReplaceSupers(opts, inClass) {
  this.topLevelThisReference = opts.topLevelThisReference;
  this.methodNode            = opts.methodNode;
  this.className             = opts.className;
  this.superName             = opts.superName;
  this.isStatic              = opts.isStatic;
  this.hasSuper              = false;
  this.inClass               = inClass;
  this.isLoose               = opts.isLoose;
  this.scope                 = opts.scope;
  this.file                  = opts.file;
}

/**
 * Sets a super class value of the named property.
 *
 * @example
 *
 *   _set(Object.getPrototypeOf(CLASS.prototype), "METHOD", "VALUE", this)
 *
 * @param {Node} property
 * @param {Node} value
 * @param {Boolean} isComputed
 * @param {Node} thisExpression
 *
 * @returns {Node}
 */

ReplaceSupers.prototype.setSuperProperty = function (property, value, isComputed, thisExpression) {
  return t.callExpression(
    this.file.addHelper("set"),
    [
      t.callExpression(
        t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")),
        [
          this.isStatic ? this.className : t.memberExpression(this.className, t.identifier("prototype"))
        ]
      ),
      isComputed ? property : t.literal(property.name),
      value,
      thisExpression
    ]
  );
};

/**
 * Gets a node representing the super class value of the named property.
 *
 * @example
 *
 *   _get(Object.getPrototypeOf(CLASS.prototype), "METHOD", this)
 *
 * @param {Node} property
 * @param {Boolean} isComputed
 * @param {Node} thisExpression
 *
 * @returns {Node}
 */

ReplaceSupers.prototype.getSuperProperty = function (property, isComputed, thisExpression) {
  return t.callExpression(
    this.file.addHelper("get"),
    [
      t.callExpression(
        t.memberExpression(t.identifier("Object"), t.identifier("getPrototypeOf")),
        [
          this.isStatic ? this.className : t.memberExpression(this.className, t.identifier("prototype"))
        ]
      ),
      isComputed ? property : t.literal(property.name),
      thisExpression
    ]
  );
};

/**
 * Description
 */

ReplaceSupers.prototype.replace = function () {
  this.traverseLevel(this.methodNode.value, true);
};

var visitor = {
  enter: function (node, parent, scope, state) {
    var topLevel = state.topLevel;
    var self = state.self;

    if (t.isFunction(node) && !t.isArrowFunctionExpression(node)) {
      // we need to call traverseLevel again so we're context aware
      self.traverseLevel(node, false);
      return this.skip();
    }

    if (t.isProperty(node, { method: true }) || t.isMethodDefinition(node)) {
      // break on object methods
      return this.skip();
    }

    var getThisReference = topLevel ?
      // top level so `this` is the instance
      t.thisExpression :
      // not in the top level so we need to create a reference
      self.getThisReference.bind(self);

    var callback = self.specHandle;
    if (self.isLoose) callback = self.looseHandle;
    return callback.call(self, getThisReference, node, parent);
  }
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Boolean} topLevel
 */

ReplaceSupers.prototype.traverseLevel = function (node, topLevel) {
  var state = { self: this, topLevel: topLevel };
  this.scope.traverse(node, visitor, state);
};

/**
 * Description
 */

ReplaceSupers.prototype.getThisReference = function () {
  if (this.topLevelThisReference) {
    return this.topLevelThisReference;
  } else {
    var ref = this.topLevelThisReference = this.scope.generateUidIdentifier("this");
    this.methodNode.value.body.body.unshift(t.variableDeclaration("var", [
      t.variableDeclarator(this.topLevelThisReference, t.thisExpression())
    ]));
    return ref;
  }
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Object} id
 * @param {Object} parent
 * @returns {Object}
 */

ReplaceSupers.prototype.getLooseSuperProperty = function (id, parent) {
  var methodNode = this.methodNode;
  var methodName = methodNode.key;
  var superName  = this.superName || t.identifier("Function");

  if (parent.property === id) {
    return;
  } else if (t.isCallExpression(parent, { callee: id })) {
    // super(); -> ClassName.prototype.MethodName.call(this);
    parent.arguments.unshift(t.thisExpression());

    if (methodName.name === "constructor") {
      // constructor() { super(); }
      return t.memberExpression(superName, t.identifier("call"));
    } else {
      id = superName;

      // foo() { super(); }
      if (!methodNode.static) {
        id = t.memberExpression(id, t.identifier("prototype"));
      }

      id = t.memberExpression(id, methodName, methodNode.computed);
      return t.memberExpression(id, t.identifier("call"));
    }
  } else if (t.isMemberExpression(parent) && !methodNode.static) {
    // super.test -> ClassName.prototype.test
    return t.memberExpression(superName, t.identifier("prototype"));
  } else {
    return superName;
  }
};

/**
 * Description
 *
 * @param {Function} getThisReference
 * @param {Object} node
 * @param {Object} parent
 */

ReplaceSupers.prototype.looseHandle = function (getThisReference, node, parent) {
  if (t.isIdentifier(node, { name: "super" })) {
    this.hasSuper = true;
    return this.getLooseSuperProperty(node, parent);
  } else if (t.isCallExpression(node)) {
    var callee = node.callee;
    if (!t.isMemberExpression(callee)) return;
    if (callee.object.name !== "super") return;

    // super.test(); -> ClassName.prototype.MethodName.call(this);
    this.hasSuper = true;
    t.appendToMemberExpression(callee, t.identifier("call"));
    node.arguments.unshift(getThisReference());
  }
};

/**
 * Description
 *
 * @param {Function} getThisReference
 * @param {Object} node
 * @param {Object} parent
 */

ReplaceSupers.prototype.specHandle = function (getThisReference, node, parent) {
  var methodNode = this.methodNode;
  var property;
  var computed;
  var args;
  var thisReference;

  if (isIllegalBareSuper(node, parent)) {
    throw this.file.errorWithNode(node, messages.get("classesIllegalBareSuper"));
  }

  if (t.isCallExpression(node)) {
    var callee = node.callee;
    if (isSuper(callee, node)) {
      // super(); -> _get(Object.getPrototypeOf(ClassName), "MethodName", this).call(this);
      property = methodNode.key;
      computed = methodNode.computed;
      args = node.arguments;

      // bare `super` call is illegal inside non-constructors
      //  - https://esdiscuss.org/topic/super-call-in-methods
      //  - https://twitter.com/wycats/status/544553184396836864
      if (methodNode.key.name !== "constructor" || !this.inClass) {
        var methodName = methodNode.key.name || "METHOD_NAME";
        throw this.file.errorWithNode(node, messages.get("classesIllegalSuperCall", methodName));
      }
    } else if (t.isMemberExpression(callee) && isSuper(callee.object, callee)) {
      // super.test(); -> _get(Object.getPrototypeOf(ClassName.prototype), "test", this).call(this);
      property = callee.property;
      computed = callee.computed;
      args = node.arguments;
    }
  } else if (t.isMemberExpression(node) && isSuper(node.object, node)) {
    // super.name; -> _get(Object.getPrototypeOf(ClassName.prototype), "name", this);
    property = node.property;
    computed = node.computed;
  } else if (t.isAssignmentExpression(node) && isSuper(node.left.object, node.left) && methodNode.kind === "set") {
    // super.name = "val"; -> _set(Object.getPrototypeOf(ClassName.prototype), "name", this);
    this.hasSuper = true;
    return this.setSuperProperty(node.left.property, node.right, node.left.computed, getThisReference());
  }

  if (!property) return;

  this.hasSuper = true;

  thisReference = getThisReference();
  var superProperty = this.getSuperProperty(property, computed, thisReference);
  if (args) {
    if (args.length === 1 && t.isSpreadElement(args[0])) {
      // super(...arguments);
      return t.callExpression(
        t.memberExpression(superProperty, t.identifier("apply")),
        [thisReference, args[0].argument]
      );
    } else {
      return t.callExpression(
        t.memberExpression(superProperty, t.identifier("call")),
        [thisReference].concat(args)
      );
    }
  } else {
    return superProperty;
  }
};

var isIllegalBareSuper = function (node, parent) {
  if (!isSuper(node, parent)) return false;
  if (t.isMemberExpression(parent, { computed: false })) return false;
  if (t.isCallExpression(parent, { callee: node })) return false;
  return true;
};

var isSuper = function (node, parent) {
  return t.isIdentifier(node, { name: "super" }) && t.isReferenced(node, parent);
};

},{"../../messages":30,"../../types":122}],44:[function(require,module,exports){
"use strict";

var t = require("../../types");

exports.has = function (node) {
  var first = node.body[0];
  return t.isExpressionStatement(first) && t.isLiteral(first.expression, { value: "use strict" });
};

exports.wrap = function (node, callback) {
  var useStrictNode;
  if (exports.has(node)) {
    useStrictNode = node.body.shift();
  }

  callback();

  if (useStrictNode) {
    node.body.unshift(useStrictNode);
  }
};

},{"../../types":122}],45:[function(require,module,exports){
"use strict";

module.exports = transform;

var normalizeAst = require("../helpers/normalize-ast");
var Transformer  = require("./transformer");
var object       = require("../helpers/object");
var File         = require("./file");
var each         = require("lodash/collection/each");

function transform(code, opts) {
  var file = new File(opts);
  return file.parse(code);
}

transform.fromAst = function (ast, code, opts) {
  ast = normalizeAst(ast);

  var file = new File(opts);
  file.addCode(code);
  file.transform(ast);
  return file.generate();
};

transform._ensureTransformerNames = function (type, rawKeys) {
  var keys = [];

  for (var i = 0; i < rawKeys.length; i++) {
    var key = rawKeys[i];

    var deprecatedKey = transform.deprecatedTransformerMap[key];
    if (deprecatedKey) {
      // deprecated key, remap it to the new one
      console.error("The transformer " + key + " has been renamed to " + deprecatedKey);
      rawKeys.push(deprecatedKey);
    } else if (transform.transformers[key]) {
      // valid key
      keys.push(key);
    } else if (transform.namespaces[key]) {
      // namespace, append all transformers within this namespace
      keys = keys.concat(transform.namespaces[key]);
    } else {
      // invalid key
      throw new ReferenceError("Unknown transformer " + key + " specified in " + type);
    }
  }

  return keys;
};

transform.transformerNamespaces = object();
transform.transformers          = object();
transform.namespaces            = object();

transform.deprecatedTransformerMap = require("./transformers/deprecated");
transform.moduleFormatters = require("./modules");

var rawTransformers = require("./transformers");

each(rawTransformers, function (transformer, key) {
  var namespace = key.split(".")[0];

  transform.namespaces[namespace] = transform.namespaces[namespace] || [];
  transform.namespaces[namespace].push(key);
  transform.transformerNamespaces[key] = namespace;

  transform.transformers[key] = new Transformer(key, transformer);
});

},{"../helpers/normalize-ast":26,"../helpers/object":27,"./file":33,"./modules":53,"./transformer":58,"./transformers":84,"./transformers/deprecated":59,"lodash/collection/each":172}],46:[function(require,module,exports){
"use strict";

module.exports = DefaultFormatter;

var messages = require("../../messages");
var extend   = require("lodash/object/extend");
var object   = require("../../helpers/object");
var util     = require("../../util");
var t        = require("../../types");

function DefaultFormatter(file) {
  this.scope = file.scope;
  this.file  = file;
  this.ids   = object();

  this.hasNonDefaultExports = false;

  this.hasLocalExports = false;
  this.hasLocalImports = false;

  this.localImportOccurences = object();
  this.localExports = object();
  this.localImports = object();

  this.getLocalExports();
  this.getLocalImports();

  this.remapAssignments();
}

DefaultFormatter.prototype.doDefaultExportInterop = function (node) {
  return node.default && !this.noInteropRequireExport && !this.hasNonDefaultExports;
};

DefaultFormatter.prototype.bumpImportOccurences = function (node) {
  var source = node.source.value;
  var occurs = this.localImportOccurences;
  occurs[source] = occurs[source] || 0;
  occurs[source] += node.specifiers.length;
};

var exportsVisitor = {
  enter: function (node, parent, scope, formatter) {
    var declar = node && node.declaration;
    if (t.isExportDeclaration(node)) {
      formatter.hasLocalImports = true;

      if (declar && t.isStatement(declar)) {
        extend(formatter.localExports, t.getBindingIdentifiers(declar));
      }

      if (!node.default) {
        formatter.hasNonDefaultExports = true;
      }

      if (node.source) {
        formatter.bumpImportOccurences(node);
      }
    }
  }
};

DefaultFormatter.prototype.getLocalExports = function () {
  this.file.scope.traverse(this.file.ast, exportsVisitor, this);
};

var importsVisitor = {
  enter: function (node, parent, scope, formatter) {
    if (t.isImportDeclaration(node)) {
      formatter.hasLocalImports = true;
      extend(formatter.localImports, t.getBindingIdentifiers(node));
      formatter.bumpImportOccurences(node);
    }
  }
};

DefaultFormatter.prototype.getLocalImports = function () {
  this.file.scope.traverse(this.file.ast, importsVisitor, this);
};

var remapVisitor = {
  enter: function (node, parent, scope, formatter) {
    if (t.isUpdateExpression(node) && formatter.isLocalReference(node.argument, scope)) {
      this.skip();

      // expand to long file assignment expression
      var assign = t.assignmentExpression(node.operator[0] + "=", node.argument, t.literal(1));

      // remap this assignment expression
      var remapped = formatter.remapExportAssignment(assign);

      // we don't need to change the result
      if (t.isExpressionStatement(parent) || node.prefix) {
        return remapped;
      }

      var nodes = [];
      nodes.push(remapped);

      var operator;
      if (node.operator === "--") {
        operator = "+";
      } else { // "++"
        operator = "-";
      }
      nodes.push(t.binaryExpression(operator, node.argument, t.literal(1)));

      return t.sequenceExpression(nodes);
    }

    if (t.isAssignmentExpression(node) && formatter.isLocalReference(node.left, scope)) {
      this.skip();
      return formatter.remapExportAssignment(node);
    }
  }
};

DefaultFormatter.prototype.remapAssignments = function () {
  if (this.hasLocalImports) {
    this.file.scope.traverse(this.file.ast, remapVisitor, this);
  }
};

DefaultFormatter.prototype.isLocalReference = function (node) {
  var localImports = this.localImports;
  return t.isIdentifier(node) && localImports[node.name] && localImports[node.name] !== node;
};

DefaultFormatter.prototype.remapExportAssignment = function (node) {
  return t.assignmentExpression(
    "=",
    node.left,
    t.assignmentExpression(
      node.operator,
      t.memberExpression(t.identifier("exports"), node.left),
      node.right
    )
  );
};

DefaultFormatter.prototype.isLocalReference = function (node, scope) {
  var localExports = this.localExports;
  var name = node.name;
  return t.isIdentifier(node) && localExports[name] && localExports[name] === scope.getBindingIdentifier(name);
};

DefaultFormatter.prototype.getModuleName = function () {
  var opts = this.file.opts;
  var filenameRelative = opts.filenameRelative;
  var moduleName = "";

  if (opts.moduleRoot) {
    moduleName = opts.moduleRoot + "/";
  }

  if (!opts.filenameRelative) {
    return moduleName + opts.filename.replace(/^\//, "");
  }

  if (opts.sourceRoot) {
    // remove sourceRoot from filename
    var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "\/?");
    filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
  }

  if (!opts.keepModuleIdExtensions) {
    // remove extension
    filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");
  }

  moduleName += filenameRelative;

  // normalize path separators
  moduleName = moduleName.replace(/\\/g, "/");

  return moduleName;
};

DefaultFormatter.prototype._pushStatement = function (ref, nodes) {
  if (t.isClass(ref) || t.isFunction(ref)) {
    if (ref.id) {
      nodes.push(t.toStatement(ref));
      ref = ref.id;
    }
  }

  return ref;
};

DefaultFormatter.prototype._hoistExport = function (declar, assign, priority) {
  if (t.isFunctionDeclaration(declar)) {
    assign._blockHoist = priority || 2;
  }

  return assign;
};

DefaultFormatter.prototype.getExternalReference = function (node, nodes) {
  var ids = this.ids;
  var id = node.source.value;

  if (ids[id]) {
    return ids[id];
  } else {
    return this.ids[id] = this._getExternalReference(node, nodes);
  }
};

DefaultFormatter.prototype.checkExportIdentifier = function (node) {
  if (t.isIdentifier(node, { name: "__esModule" })) {
    throw this.file.errorWithNode(node, messages.get("modulesIllegalExportName", node.name));
  }
};

DefaultFormatter.prototype.exportSpecifier = function (specifier, node, nodes) {
  if (node.source) {
    var ref = this.getExternalReference(node, nodes);

    if (t.isExportBatchSpecifier(specifier)) {
      // export * from "foo";
      nodes.push(this.buildExportsWildcard(ref, node));
    } else {
      if (t.isSpecifierDefault(specifier) && !this.noInteropRequireExport) {
        // importing a default so we need to normalize it
        ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
      } else {
        ref = t.memberExpression(ref, t.getSpecifierId(specifier));
      }

      // export { foo } from "test";
      nodes.push(this.buildExportsAssignment(
        t.getSpecifierName(specifier),
        ref,
        node
      ));
    }
  } else {
    // export { foo };
    nodes.push(this.buildExportsAssignment(t.getSpecifierName(specifier), specifier.id, node));
  }
};

DefaultFormatter.prototype.buildExportsWildcard = function (objectIdentifier) {
  return t.expressionStatement(t.callExpression(this.file.addHelper("defaults"), [
    t.identifier("exports"),
    t.callExpression(this.file.addHelper("interop-require-wildcard"), [objectIdentifier])
  ]));
};

DefaultFormatter.prototype.buildExportsAssignment = function (id, init) {
  this.checkExportIdentifier(id);
  return util.template("exports-assign", {
    VALUE: init,
    KEY:   id
  }, true);
};

DefaultFormatter.prototype.exportDeclaration = function (node, nodes) {
  var declar = node.declaration;

  var id = declar.id;

  if (node.default) {
    id = t.identifier("default");
  }

  var assign;

  if (t.isVariableDeclaration(declar)) {
    for (var i = 0; i < declar.declarations.length; i++) {
      var decl = declar.declarations[i];

      decl.init = this.buildExportsAssignment(decl.id, decl.init, node).expression;

      var newDeclar = t.variableDeclaration(declar.kind, [decl]);
      if (i === 0) t.inherits(newDeclar, declar);
      nodes.push(newDeclar);
    }
  } else {
    var ref = declar;

    if (t.isFunctionDeclaration(declar) || t.isClassDeclaration(declar)) {
      ref = declar.id;
      nodes.push(declar);
    }

    assign = this.buildExportsAssignment(id, ref, node);

    nodes.push(assign);

    this._hoistExport(declar, assign);
  }
};

},{"../../helpers/object":27,"../../messages":30,"../../types":122,"../../util":124,"lodash/object/extend":260}],47:[function(require,module,exports){
"use strict";

var util = require("../../util");

module.exports = function (Parent) {
  var Constructor = function () {
    this.noInteropRequireImport = true;
    this.noInteropRequireExport = true;
    Parent.apply(this, arguments);
  };

  util.inherits(Constructor, Parent);

  return Constructor;
};

},{"../../util":124}],48:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./amd"));

},{"./_strict":47,"./amd":49}],49:[function(require,module,exports){
"use strict";

module.exports = AMDFormatter;

var DefaultFormatter = require("./_default");
var CommonFormatter  = require("./common");
var includes         = require("lodash/collection/includes");
var values           = require("lodash/object/values");
var util             = require("../../util");
var t                = require("../../types");

function AMDFormatter() {
  CommonFormatter.apply(this, arguments);
}

util.inherits(AMDFormatter, DefaultFormatter);

AMDFormatter.prototype.init = CommonFormatter.prototype.init;

AMDFormatter.prototype.buildDependencyLiterals = function () {
  var names = [];
  for (var name in this.ids) {
    names.push(t.literal(name));
  }
  return names;
};

/**
 * Wrap the entire body in a `define` wrapper.
 */

AMDFormatter.prototype.transform = function (program) {
  var body = program.body;

  // build an array of module names

  var names = [t.literal("exports")];
  if (this.passModuleArg) names.push(t.literal("module"));
  names = names.concat(this.buildDependencyLiterals());
  names = t.arrayExpression(names);

  // build up define container

  var params = values(this.ids);
  if (this.passModuleArg) params.unshift(t.identifier("module"));
  params.unshift(t.identifier("exports"));

  var container = t.functionExpression(null, params, t.blockStatement(body));

  var defineArgs = [names, container];
  var moduleName = this.getModuleName();
  if (moduleName) defineArgs.unshift(t.literal(moduleName));

  var call = t.callExpression(t.identifier("define"), defineArgs);

  program.body = [t.expressionStatement(call)];
};

/**
 * Get the AMD module name that we'll prepend to the wrapper
 * to define this module
 */

AMDFormatter.prototype.getModuleName = function () {
  if (this.file.opts.moduleIds) {
    return DefaultFormatter.prototype.getModuleName.apply(this, arguments);
  } else {
    return null;
  }
};

AMDFormatter.prototype._getExternalReference = function (node) {
  return this.scope.generateUidIdentifier(node.source.value);
};

AMDFormatter.prototype.importDeclaration = function (node) {
  this.getExternalReference(node);
};

AMDFormatter.prototype.importSpecifier = function (specifier, node, nodes) {
  var key = t.getSpecifierName(specifier);
  var ref = this.getExternalReference(node);

  if (includes(this.file.dynamicImportedNoDefault, node)) {
    // Prevent unnecessary renaming of dynamic imports.
    this.ids[node.source.value] = ref;
  } else if (t.isImportBatchSpecifier(specifier)) {
    // import * as bar from "foo";
  } else if (!includes(this.file.dynamicImported, node) && t.isSpecifierDefault(specifier) && !this.noInteropRequireImport) {
    // import foo from "foo";
    ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
  } else {
    // import {foo} from "foo";
    ref = t.memberExpression(ref, t.getSpecifierId(specifier), false);
  }

  nodes.push(t.variableDeclaration("var", [
    t.variableDeclarator(key, ref)
  ]));
};

AMDFormatter.prototype.exportDeclaration = function (node) {
  if (this.doDefaultExportInterop(node)) {
    this.passModuleArg = true;
  }

  CommonFormatter.prototype.exportDeclaration.apply(this, arguments);
};

},{"../../types":122,"../../util":124,"./_default":46,"./common":51,"lodash/collection/includes":175,"lodash/object/values":265}],50:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./common"));

},{"./_strict":47,"./common":51}],51:[function(require,module,exports){
"use strict";

module.exports = CommonJSFormatter;

var DefaultFormatter = require("./_default");
var includes         = require("lodash/collection/includes");
var util             = require("../../util");
var t                = require("../../types");

function CommonJSFormatter() {
  DefaultFormatter.apply(this, arguments);
}

util.inherits(CommonJSFormatter, DefaultFormatter);

CommonJSFormatter.prototype.init = function () {
  var file  = this.file;
  var scope = file.scope;

  scope.rename("module");

  if (!this.noInteropRequireImport && this.hasNonDefaultExports) {
    var templateName = "exports-module-declaration";
    if (this.file.isLoose("es6.modules")) templateName += "-loose";
    file.ast.program.body.push(util.template(templateName, true));
  }
};

CommonJSFormatter.prototype.importSpecifier = function (specifier, node, nodes) {
  var variableName = t.getSpecifierName(specifier);

  var ref = this.getExternalReference(node, nodes);

  // import foo from "foo";
  if (t.isSpecifierDefault(specifier)) {
    if (!includes(this.file.dynamicImportedNoDefault, node)) {
      if (this.noInteropRequireImport || includes(this.file.dynamicImported, node)) {
        ref = t.memberExpression(ref, t.identifier("default"));
      } else {
        ref = t.callExpression(this.file.addHelper("interop-require"), [ref]);
      }
    }
    nodes.push(t.variableDeclaration("var", [t.variableDeclarator(variableName, ref)]));
  } else {
    if (specifier.type === "ImportBatchSpecifier") {

      if (!this.noInteropRequireImport) {
        ref = t.callExpression(this.file.addHelper("interop-require-wildcard"), [ref]);
      }

      // import * as bar from "foo";
      nodes.push(t.variableDeclaration("var", [
        t.variableDeclarator(variableName, ref)
      ]));
    } else {
      // import { foo } from "foo";
      nodes.push(t.variableDeclaration("var", [
        t.variableDeclarator(
          variableName,
          t.memberExpression(ref, t.getSpecifierId(specifier))
        )
      ]));
    }
  }
};

CommonJSFormatter.prototype.importDeclaration = function (node, nodes) {
  // import "foo";
  nodes.push(util.template("require", {
    MODULE_NAME: node.source
  }, true));
};

CommonJSFormatter.prototype.exportDeclaration = function (node, nodes) {
  if (this.doDefaultExportInterop(node)) {
    var declar = node.declaration;
    var assign = util.template("exports-default-assign", {
      VALUE: this._pushStatement(declar, nodes)
    }, true);

    if (t.isFunctionDeclaration(declar)) {
      // we can hoist this assignment to the top of the file
      assign._blockHoist = 3;
    }

    nodes.push(assign);
    return;
  }

  DefaultFormatter.prototype.exportDeclaration.apply(this, arguments);
};

CommonJSFormatter.prototype._getExternalReference = function (node, nodes) {
  var source = node.source.value;
  var call = t.callExpression(t.identifier("require"), [node.source]);

  if (this.localImportOccurences[source] > 1) {
    var uid = this.scope.generateUidIdentifier(source);
    nodes.push(t.variableDeclaration("var", [
      t.variableDeclarator(uid, call)
    ]));
    return uid;
  } else {
    return call;
  }
};

},{"../../types":122,"../../util":124,"./_default":46,"lodash/collection/includes":175}],52:[function(require,module,exports){
"use strict";

module.exports = IgnoreFormatter;

var t = require("../../types");

function IgnoreFormatter() {

}

IgnoreFormatter.prototype.exportDeclaration = function (node, nodes) {
  var declar = t.toStatement(node.declaration, true);
  if (declar) nodes.push(t.inherits(declar, node));
};

IgnoreFormatter.prototype.importDeclaration =
IgnoreFormatter.prototype.importSpecifier =
IgnoreFormatter.prototype.exportSpecifier = function () {

};

},{"../../types":122}],53:[function(require,module,exports){
module.exports = {
  commonStrict: require("./common-strict"),
  amdStrict:    require("./amd-strict"),
  umdStrict:    require("./umd-strict"),
  common:       require("./common"),
  system:       require("./system"),
  ignore:       require("./ignore"),
  amd:          require("./amd"),
  umd:          require("./umd")
};

},{"./amd":49,"./amd-strict":48,"./common":51,"./common-strict":50,"./ignore":52,"./system":54,"./umd":56,"./umd-strict":55}],54:[function(require,module,exports){
"use strict";

module.exports = SystemFormatter;

var DefaultFormatter = require("./_default");
var AMDFormatter     = require("./amd");
var useStrict        = require("../helpers/use-strict");
var util             = require("../../util");
var t                = require("../../types");
var last             = require("lodash/array/last");
var each             = require("lodash/collection/each");
var map              = require("lodash/collection/map");

function SystemFormatter(file) {
  this.exportIdentifier = file.scope.generateUidIdentifier("export");
  this.noInteropRequireExport = true;
  this.noInteropRequireImport = true;

  DefaultFormatter.apply(this, arguments);
}

util.inherits(SystemFormatter, AMDFormatter);

SystemFormatter.prototype.init = function () {};

SystemFormatter.prototype._addImportSource = function (node, exportNode) {
  node._importSource = exportNode.source && exportNode.source.value;
  return node;
};

SystemFormatter.prototype.buildExportsWildcard = function (objectIdentifier, node) {
  var leftIdentifier = this.scope.generateUidIdentifier("key");
  var valIdentifier  = t.memberExpression(objectIdentifier, leftIdentifier, true);

  var left = t.variableDeclaration("var", [
    t.variableDeclarator(leftIdentifier)
  ]);

  var right = objectIdentifier;

  var block = t.blockStatement([
    t.expressionStatement(this.buildExportCall(leftIdentifier, valIdentifier))
  ]);

  return this._addImportSource(t.forInStatement(left, right, block), node);
};

SystemFormatter.prototype.buildExportsAssignment = function (id, init, node) {
  var call = this.buildExportCall(t.literal(id.name), init, true);
  return this._addImportSource(call, node);
};

SystemFormatter.prototype.remapExportAssignment = function (node) {
  return this.buildExportCall(t.literal(node.left.name), node);
};

SystemFormatter.prototype.buildExportCall = function (id, init, isStatement) {
  var call = t.callExpression(this.exportIdentifier, [id, init]);
  if (isStatement) {
    return t.expressionStatement(call);
  } else {
    return call;
  }
};

SystemFormatter.prototype.importSpecifier = function (specifier, node, nodes) {
  AMDFormatter.prototype.importSpecifier.apply(this, arguments);
  this._addImportSource(last(nodes), node);
};

var runnerSettersVisitor = {
  enter: function (node, parent, scope, state) {
    if (node._importSource === state.source) {
      if (t.isVariableDeclaration(node)) {
        each(node.declarations, function (declar) {
          state.hoistDeclarators.push(t.variableDeclarator(declar.id));
          state.nodes.push(t.expressionStatement(
            t.assignmentExpression("=", declar.id, declar.init)
          ));
        });
      } else {
        state.nodes.push(node);
      }

      this.remove();
    }
  }
};

SystemFormatter.prototype.buildRunnerSetters = function (block, hoistDeclarators) {
  var scope = this.file.scope;

  return t.arrayExpression(map(this.ids, function (uid, source) {
    var state = {
      source:           source,
      nodes:            [],
      hoistDeclarators: hoistDeclarators
    };

    scope.traverse(block, runnerSettersVisitor, state);

    return t.functionExpression(null, [uid], t.blockStatement(state.nodes));
  }));
};

var hoistVariablesVisitor = {
  enter: function (node, parent, scope, hoistDeclarators) {
    if (t.isFunction(node)) {
      // nothing inside is accessible
      return this.skip();
    }

    if (t.isVariableDeclaration(node)) {
      if (node.kind !== "var" && !t.isProgram(parent)) { // let, const
        // can't be accessed
        return;
      }

      // ignore block hoisted nodes as these can be left in
      if (node._blockHoist) return;

      var nodes = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        hoistDeclarators.push(t.variableDeclarator(declar.id));
        if (declar.init) {
          // no initializer so we can just hoist it as-is
          var assign = t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init));
          nodes.push(assign);
        }
      }

      // for (var i in test)
      // for (var i = 0;;)
      if (t.isFor(parent)) {
        if (parent.left === node) {
          return node.declarations[0].id;
        }

        if (parent.init === node) {
          return t.toSequenceExpression(nodes, scope);
        }
      }

      return nodes;
    }
  }
};

var hoistFunctionsVisitor = {
  enter: function (node, parent, scope, handlerBody) {
    if (t.isFunction(node)) this.skip();

    if (t.isFunctionDeclaration(node) || node._blockHoist) {
      handlerBody.push(node);
      this.remove();
    }
  }
};

SystemFormatter.prototype.transform = function (program) {
  var hoistDeclarators = [];
  var moduleName = this.getModuleName();
  var moduleNameLiteral = t.literal(moduleName);

  var block = t.blockStatement(program.body);

  var runner = util.template("system", {
    MODULE_NAME: moduleNameLiteral,
    MODULE_DEPENDENCIES: t.arrayExpression(this.buildDependencyLiterals()),
    EXPORT_IDENTIFIER: this.exportIdentifier,
    SETTERS: this.buildRunnerSetters(block, hoistDeclarators),
    EXECUTE: t.functionExpression(null, [], block)
  }, true);

  var handlerBody = runner.expression.arguments[2].body.body;
  if (!moduleName) runner.expression.arguments.shift();

  var returnStatement = handlerBody.pop();

  // hoist up all variable declarations
  this.file.scope.traverse(block, hoistVariablesVisitor, hoistDeclarators);

  if (hoistDeclarators.length) {
    var hoistDeclar = t.variableDeclaration("var", hoistDeclarators);
    hoistDeclar._blockHoist = true;
    handlerBody.unshift(hoistDeclar);
  }

  // hoist up function declarations for circular references
  this.file.scope.traverse(block, hoistFunctionsVisitor, handlerBody);

  handlerBody.push(returnStatement);

  if (useStrict.has(block)) {
    handlerBody.unshift(block.body.shift());
  }

  program.body = [runner];
};

},{"../../types":122,"../../util":124,"../helpers/use-strict":44,"./_default":46,"./amd":49,"lodash/array/last":168,"lodash/collection/each":172,"lodash/collection/map":176}],55:[function(require,module,exports){
"use strict";

module.exports = require("./_strict")(require("./umd"));

},{"./_strict":47,"./umd":56}],56:[function(require,module,exports){
"use strict";

module.exports = UMDFormatter;

var AMDFormatter = require("./amd");
var util         = require("../../util");
var t            = require("../../types");
var values       = require("lodash/object/values");

function UMDFormatter() {
  AMDFormatter.apply(this, arguments);
}

util.inherits(UMDFormatter, AMDFormatter);

UMDFormatter.prototype.transform = function (program) {
  var body = program.body;

  // build an array of module names

  var names = [];
  for (var name in this.ids) {
    names.push(t.literal(name));
  }

  // factory

  var ids  = values(this.ids);
  var args = [t.identifier("exports")];
  if (this.passModuleArg) args.push(t.identifier("module"));
  args = args.concat(ids);

  var factory = t.functionExpression(null, args, t.blockStatement(body));

  // amd

  var defineArgs = [t.literal("exports")];
  if (this.passModuleArg) defineArgs.push(t.literal("module"));
  defineArgs = defineArgs.concat(names);
  defineArgs = [t.arrayExpression(defineArgs)];

  // common

  var testExports = util.template("test-exports");
  var testModule  = util.template("test-module");
  var commonTests = this.passModuleArg ? t.logicalExpression("&&", testExports, testModule) : testExports;

  var commonArgs = [t.identifier("exports")];
  if (this.passModuleArg) commonArgs.push(t.identifier("module"));
  commonArgs = commonArgs.concat(names.map(function (name) {
    return t.callExpression(t.identifier("require"), [name]);
  }));

  // globals

  //var umdArgs = [];

  //

  var moduleName = this.getModuleName();
  if (moduleName) defineArgs.unshift(t.literal(moduleName));

  var runner = util.template("umd-runner-body", {
    AMD_ARGUMENTS: defineArgs,
    COMMON_TEST: commonTests,
    COMMON_ARGUMENTS: commonArgs
  });

  //

  var call = t.callExpression(runner, [factory]);
  program.body = [t.expressionStatement(call)];
};

},{"../../types":122,"../../util":124,"./amd":49,"lodash/object/values":265}],57:[function(require,module,exports){
module.exports = TransformerPass;

var includes = require("lodash/collection/includes");

/**
 * This class is responsible for traversing over the provided `File`s
 * AST and running it's parent transformers handlers over it.
 */

function TransformerPass(file, transformer) {
  this.transformer = transformer;
  this.shouldRun   = !transformer.check;
  this.handlers    = transformer.handlers;
  this.file        = file;
}

TransformerPass.prototype.canRun = function () {
  var transformer = this.transformer;

  var opts = this.file.opts;
  var key  = transformer.key;

  // internal
  if (key[0] === "_") return true;

  // blacklist
  var blacklist = opts.blacklist;
  if (blacklist.length && includes(blacklist, key)) return false;

  // whitelist
  var whitelist = opts.whitelist;
  if (whitelist.length) return includes(whitelist, key);

  // optional
  if (transformer.optional && !includes(opts.optional, key)) return false;

  // experimental
  if (transformer.experimental && !opts.experimental) return false;

  // playground
  if (transformer.playground && !opts.playground) return false;

  return true;
};

TransformerPass.prototype.checkNode = function (node) {
  var check = this.transformer.check;
  if (check) {
    return this.shouldRun = check(node);
  } else {
    return true;
  }
};

TransformerPass.prototype.transform = function () {
  if (!this.shouldRun) return;

  var file = this.file;

  file.debug("Running transformer " + this.transformer.key);

  file.scope.traverse(file.ast, this.handlers, file);
};

},{"lodash/collection/includes":175}],58:[function(require,module,exports){
"use strict";

module.exports = Transformer;

var TransformerPass = require("./transformer-pass");
var isFunction      = require("lodash/lang/isFunction");
var traverse        = require("../traversal");
var isObject        = require("lodash/lang/isObject");
var assign          = require("lodash/object/assign");
var each            = require("lodash/collection/each");

/**
 * This is the class responsible for normalising a transformers handlers
 * as well as constructing a `TransformerPass` that is repsonsible for
 * actually running the transformer over the provided `File`.
 */

function Transformer(key, transformer, opts) {
  transformer = assign({}, transformer);

  var take = function (key) {
    var val = transformer[key];
    delete transformer[key];
    return val;
  };

  this.manipulateOptions = take("manipulateOptions");
  this.check             = take("check");
  this.post              = take("post");
  this.pre               = take("pre");

  this.experimental = !!take("experimental");
  this.playground   = !!take("playground");
  this.secondPass   = !!take("secondPass");
  this.optional     = !!take("optional");

  this.handlers = this.normalize(transformer);
  this.opts     = opts || {};
  this.key      = key;
}

Transformer.prototype.normalize = function (transformer) {
  var self = this;

  if (isFunction(transformer)) {
    transformer = { ast: transformer };
  }

  traverse.explode(transformer);

  each(transformer, function (fns, type) {
    // hidden property
    if (type[0] === "_") {
      self[type] = fns;
      return;
    }

    if (type === "enter" || type === "exit") return;

    if (isFunction(fns)) fns = { enter: fns };

    if (!isObject(fns)) return;

    if (!fns.enter) fns.enter = function () { };
    if (!fns.exit) fns.exit = function () { };

    transformer[type] = fns;
  });

  return transformer;
};

Transformer.prototype.buildPass = function (file) {
  return new TransformerPass(file, this);
};

},{"../traversal":117,"./transformer-pass":57,"lodash/collection/each":172,"lodash/lang/isFunction":249,"lodash/lang/isObject":252,"lodash/object/assign":258}],59:[function(require,module,exports){
module.exports={}

},{}],60:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.MemberExpression = function (node) {
  var prop = node.property;
  if (node.computed && t.isLiteral(prop) && t.isValidIdentifier(prop.value)) {
    // foo["bar"] => foo.bar
    node.property = t.identifier(prop.value);
    node.computed = false;
  } else if (!node.computed && t.isIdentifier(prop) && !t.isValidIdentifier(prop.name)) {
    // foo.default -> foo["default"]
    node.property = t.literal(prop.name);
    node.computed = true;
  }
};

},{"../../../types":122}],61:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.Property = function (node) {
  var key = node.key;
  if (t.isLiteral(key) && t.isValidIdentifier(key.value)) {
    // "foo": "bar" -> foo: "bar"
    node.key = t.identifier(key.value);
    node.computed = false;
  } else if (!node.computed && t.isIdentifier(key) && !t.isValidIdentifier(key.name)) {
    // default: "bar" -> "default": "bar"
    node.key = t.literal(key.name);
  }
};

},{"../../../types":122}],62:[function(require,module,exports){
"use strict";

var defineMap = require("../../helpers/define-map");
var t         = require("../../../types");

exports.check = function (node) {
  return t.isProperty(node) && (node.kind === "get" || node.kind === "set");
};

exports.ObjectExpression = function (node) {
  var mutatorMap = {};
  var hasAny = false;

  node.properties = node.properties.filter(function (prop) {
    if (prop.kind === "get" || prop.kind === "set") {
      hasAny = true;
      defineMap.push(mutatorMap, prop.key, prop.kind, prop.computed, prop.value);
      return false;
    } else {
      return true;
    }
  });

  if (!hasAny) return;

  return t.callExpression(
    t.memberExpression(t.identifier("Object"), t.identifier("defineProperties")),
    [node, defineMap.build(mutatorMap)]
  );
};

},{"../../../types":122,"../../helpers/define-map":38}],63:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = t.isArrowFunctionExpression;

exports.ArrowFunctionExpression = function (node) {
  t.ensureBlock(node);

  node._aliasFunction = "arrow";
  node.expression = false;
  node.type = "FunctionExpression";

  return node;
};

},{"../../../types":122}],64:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var visitor = {
  enter: function (node, parent, scope, state) {
    if (!t.isReferencedIdentifier(node, parent)) return;

    var declared = state.letRefs[node.name];
    if (!declared) return;

    // declared node is different in this scope
    if (scope.getBindingIdentifier(node.name) !== declared) return;

    var assert = t.callExpression(
      state.file.addHelper("temporal-assert-defined"),
      [node, t.literal(node.name), state.file.addHelper("temporal-undefined")]
    );

    this.skip();

    if (t.isAssignmentExpression(parent) || t.isUpdateExpression(parent)) {
      if (parent._ignoreBlockScopingTDZ) return;
      this.parentPath.replaceNode(t.sequenceExpression([assert, parent]));
    } else {
      return t.logicalExpression("&&", assert, node);
    }
  }
};

exports.optional = true;

exports.Loop =
exports.Program =
exports.BlockStatement = function (node, parent, scope, file) {
  var letRefs = node._letReferences;
  if (!letRefs) return;

  var state = {
    letRefs: letRefs,
    file:    file
  };

  scope.traverse(node, visitor, state);
};

},{"../../../types":122}],65:[function(require,module,exports){
"use strict";

var traverse = require("../../../traversal");
var object   = require("../../../helpers/object");
var util     = require("../../../util");
var t        = require("../../../types");
var values   = require("lodash/object/values");
var extend   = require("lodash/object/extend");

exports.check = function (node) {
  return t.isVariableDeclaration(node) && (node.kind === "let" || node.kind === "const");
};

var isLet = function (node, parent) {
  if (!t.isVariableDeclaration(node)) return false;
  if (node._let) return true;
  if (node.kind !== "let") return false;

  // https://github.com/babel/babel/issues/255
  if (isLetInitable(node, parent)) {
    for (var i = 0; i < node.declarations.length; i++) {
      var declar = node.declarations[i];
      declar.init = declar.init || t.identifier("undefined");
    }
  }

  node._let = true;
  node.kind = "var";
  return true;
};

var isLetInitable = function (node, parent) {
  return !t.isFor(parent) || t.isFor(parent) && parent.left !== node;
};

var isVar = function (node, parent) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !isLet(node, parent);
};

var standardizeLets = function (declars) {
  for (var i = 0; i < declars.length; i++) {
    delete declars[i]._let;
  }
};

exports.VariableDeclaration = function (node, parent, scope, file) {
  if (!isLet(node, parent)) return;

  if (isLetInitable(node) && file.transformers["es6.blockScopingTDZ"].canRun()) {
    var nodes = [node];

    for (var i = 0; i < node.declarations.length; i++) {
      var decl = node.declarations[i];
      if (decl.init) {
        var assign = t.assignmentExpression("=", decl.id, decl.init);
        assign._ignoreBlockScopingTDZ = true;
        nodes.push(t.expressionStatement(assign));
      }
      decl.init = file.addHelper("temporal-undefined");
    }

    node._blockHoist = 2;

    return nodes;
  }
};

exports.Loop = function (node, parent, scope, file) {
  var init = node.left || node.init;
  if (isLet(init, node)) {
    t.ensureBlock(node);
    node.body._letDeclarators = [init];
  }
  var blockScoping = new BlockScoping(node, node.body, parent, scope, file);
  blockScoping.run();
};

exports.Program =
exports.BlockStatement = function (block, parent, scope, file) {
  if (!t.isLoop(parent)) {
    var blockScoping = new BlockScoping(false, block, parent, scope, file);
    blockScoping.run();
  }
};

/**
 * Description
 *
 * @param {Boolean|Node} loopParent
 * @param {Node} block
 * @param {Node} parent
 * @param {Scope} scope
 * @param {File} file
 */

function BlockScoping(loopParent, block, parent, scope, file) {
  this.loopParent = loopParent;
  this.parent     = parent;
  this.scope      = scope;
  this.block      = block;
  this.file       = file;

  this.outsideLetReferences = object();
  this.hasLetReferences     = false;
  this.letReferences        = block._letReferences = object();
  this.body                 = [];
}

/**
 * Start the ball rolling.
 */

BlockScoping.prototype.run = function () {
  var block = this.block;
  if (block._letDone) return;
  block._letDone = true;

  var needsClosure = this.getLetReferences();

  // this is a block within a `Function/Program` so we can safely leave it be
  if (t.isFunction(this.parent) || t.isProgram(this.block)) return;

  // we can skip everything
  if (!this.hasLetReferences) return;

  if (needsClosure) {
    this.wrapClosure();
  } else {
    this.remap();
  }
};

function replace(node, parent, scope, remaps) {
  if (!t.isReferencedIdentifier(node, parent)) return;

  var remap = remaps[node.name];
  if (!remap) return;

  var ownBinding = scope.getBindingIdentifier(node.name);
  if (ownBinding === remap.binding) {
    node.name = remap.uid;
  } else {
    // scope already has it's own binding that doesn't
    // match the one we have a stored replacement for
    if (this) this.skip();
  }
}

var replaceVisitor = {
  enter: replace
};

function traverseReplace(node, parent, scope, remaps) {
  replace(node, parent, scope, remaps);
  scope.traverse(node, replaceVisitor, remaps);
}

/**
 * Description
 */

BlockScoping.prototype.remap = function () {
  var hasRemaps = false;
  var letRefs   = this.letReferences;
  var scope     = this.scope;

  // alright, so since we aren't wrapping this block in a closure
  // we have to check if any of our let variables collide with
  // those in upper scopes and then if they do, generate a uid
  // for them and replace all references with it
  var remaps = object();

  for (var key in letRefs) {
    // just an Identifier node we collected in `getLetReferences`
    // this is the defining identifier of a declaration
    var ref = letRefs[key];

    if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
      var uid = scope.generateUidIdentifier(ref.name).name;
      ref.name = uid;

      hasRemaps = true;
      remaps[key] = remaps[uid] = {
        binding: ref,
        uid: uid
      };
    }
  }

  if (!hasRemaps) return;

  //

  var loopParent = this.loopParent;
  if (loopParent) {
    traverseReplace(loopParent.right, loopParent, scope, remaps);
    traverseReplace(loopParent.test, loopParent, scope, remaps);
    traverseReplace(loopParent.update, loopParent, scope, remaps);
  }

  scope.traverse(this.block, replaceVisitor, remaps);
};

/**
 * Description
 */

BlockScoping.prototype.wrapClosure = function () {
  var block = this.block;

  var outsideRefs = this.outsideLetReferences;

  // remap loop heads with colliding variables
  if (this.loopParent) {
    for (var name in outsideRefs) {
      var id = outsideRefs[name];

      if (this.scope.hasGlobal(id.name)) {
        delete outsideRefs[id.name];
        delete this.letReferences[id.name];

        this.scope.rename(id.name);

        this.letReferences[id.name] = id;
        outsideRefs[id.name] = id;
      }
    }
  }

  // if we're inside of a for loop then we search to see if there are any
  // `break`s, `continue`s, `return`s etc
  this.has = this.checkLoop();

  // hoist var references to retain scope
  this.hoistVarDeclarations();

  // turn outsideLetReferences into an array
  var params = values(outsideRefs);

  // build the closure that we're going to wrap the block with
  var fn = t.functionExpression(null, params, t.blockStatement(block.body));
  fn._aliasFunction = true;

  // replace the current block body with the one we're going to build
  block.body = this.body;

  // build a call and a unique id that we can assign the return value to
  var call = t.callExpression(fn, params);
  var ret  = this.scope.generateUidIdentifier("ret");

  // handle generators
  var hasYield = traverse.hasType(fn.body, this.scope, "YieldExpression", t.FUNCTION_TYPES);
  if (hasYield) {
    fn.generator = true;
    call = t.yieldExpression(call, true);
  }

  // handlers async functions
  var hasAsync = traverse.hasType(fn.body, this.scope, "AwaitExpression", t.FUNCTION_TYPES);
  if (hasAsync) {
    fn.async = true;
    call = t.awaitExpression(call, true);
  }

  this.build(ret, call);
};

var letReferenceFunctionVisitor = {
  enter: function (node, parent, scope, state) {
    // not a direct reference
    if (!t.isReferencedIdentifier(node, parent)) return;

    // this scope has a variable with the same name so it couldn't belong
    // to our let scope
    if (scope.hasOwnBinding(node.name)) return;

    // not a part of our scope
    if (!state.letReferences[node.name]) return;

    state.closurify = true;
  }
};

var letReferenceBlockVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isFunction(node)) {
      scope.traverse(node, letReferenceFunctionVisitor, state);
      return this.skip();
    }
  }
};

/**
 * Description
 */

BlockScoping.prototype.getLetReferences = function () {
  var block = this.block;

  var declarators = block._letDeclarators || [];
  var declar;

  //
  for (var i = 0; i < declarators.length; i++) {
    declar = declarators[i];
    extend(this.outsideLetReferences, t.getBindingIdentifiers(declar));
  }

  //
  if (block.body) {
    for (i = 0; i < block.body.length; i++) {
      declar = block.body[i];
      if (isLet(declar, block)) {
        declarators = declarators.concat(declar.declarations);
      }
    }
  }

  //
  for (i = 0; i < declarators.length; i++) {
    declar = declarators[i];
    var keys = t.getBindingIdentifiers(declar);
    extend(this.letReferences, keys);
    this.hasLetReferences = true;
  }

  // no let references so we can just quit
  if (!this.hasLetReferences) return;

  // set let references to plain var references
  standardizeLets(declarators);

  var state = {
    letReferences: this.letReferences,
    closurify:     false
  };

  // traverse through this block, stopping on functions and checking if they
  // contain any local let references
  this.scope.traverse(this.block, letReferenceBlockVisitor, state);

  return state.closurify;
};

var loopNodeTo = function (node) {
  if (t.isBreakStatement(node)) {
    return "break";
  } else if (t.isContinueStatement(node)) {
    return "continue";
  }
};

var loopVisitor = {
  enter: function (node, parent, scope, state) {
    var replace;

    if (t.isLoop(node)) {
      state.ignoreLabeless = true;
      scope.traverse(node, loopVisitor, state);
      state.ignoreLabeless = false;
    }

    if (t.isFunction(node) || t.isLoop(node)) {
      return this.skip();
    }

    var loopText = loopNodeTo(node);

    if (loopText) {
      if (node.label) {
        // we shouldn't be transforming this because it exists somewhere inside
        if (state.innerLabels.indexOf(node.label.name) >= 0) {
          return;
        }

        loopText = loopText + "|" + node.label.name;
      } else {
        // we shouldn't be transforming these statements because
        // they don't refer to the actual loop we're scopifying
        if (state.ignoreLabeless) return;

        // break statements mean something different in this context
        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;
      }

      state.hasBreakContinue = true;
      state.map[loopText] = node;
      replace = t.literal(loopText);
    }

    if (t.isReturnStatement(node)) {
      state.hasReturn = true;
      replace = t.objectExpression([
        t.property("init", t.identifier("v"), node.argument || t.identifier("undefined"))
      ]);
    }

    if (replace) {
      replace = t.returnStatement(replace);
      return t.inherits(replace, node);
    }
  }
};

var loopLabelVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isLabeledStatement(node)) {
      state.innerLabels.push(node.label.name);
    }
  }
};

/**
 * If we're inside of a loop then traverse it and check if it has one of
 * the following node types `ReturnStatement`, `BreakStatement`,
 * `ContinueStatement` and replace it with a return value that we can track
 * later on.
 *
 * @returns {Object}
 */

BlockScoping.prototype.checkLoop = function () {
  var state = {
    hasBreakContinue: false,
    ignoreLabeless:   false,
    innerLabels:      [],
    hasReturn:        false,
    isLoop:           !!this.loopParent,
    map:              {}
  };

  this.scope.traverse(this.block, loopLabelVisitor, state);
  this.scope.traverse(this.block, loopVisitor, state);

  return state;
};

var hoistVarDeclarationsVisitor = {
  enter: function (node, parent, scope, self) {
    if (t.isForStatement(node)) {
      if (isVar(node.init, node)) {
        node.init = t.sequenceExpression(self.pushDeclar(node.init));
      }
    } else if (t.isFor(node)) {
      if (isVar(node.left, node)) {
        node.left = node.left.declarations[0].id;
      }
    } else if (isVar(node, parent)) {
      return self.pushDeclar(node).map(t.expressionStatement);
    } else if (t.isFunction(node)) {
      return this.skip();
    }
  }
};

/**
 * Hoist all var declarations in this block to before it so they retain scope
 * once we wrap everything in a closure.
 */

BlockScoping.prototype.hoistVarDeclarations = function () {
  traverse(this.block, hoistVarDeclarationsVisitor, this.scope, this);
};

/**
 * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with
 * their declarations hoisted to before the closure wrapper.
 *
 * @param {Node} node VariableDeclaration
 * @returns {Array}
 */

BlockScoping.prototype.pushDeclar = function (node) {
  this.body.push(t.variableDeclaration(node.kind, node.declarations.map(function (declar) {
    return t.variableDeclarator(declar.id);
  })));

  var replace = [];

  for (var i = 0; i < node.declarations.length; i++) {
    var declar = node.declarations[i];
    if (!declar.init) continue;

    var expr = t.assignmentExpression("=", declar.id, declar.init);
    replace.push(t.inherits(expr, declar));
  }

  return replace;
};

/**
 * Push the closure to the body.
 *
 * @param {Node} ret Identifier
 * @param {Node} call CallExpression
 */

BlockScoping.prototype.build = function (ret, call) {
  var has = this.has;
  if (has.hasReturn || has.hasBreakContinue) {
    this.buildHas(ret, call);
  } else {
    this.body.push(t.expressionStatement(call));
  }
};

/**
 * Description
 *
 * @param {Node} ret Identifier
 * @param {Node} call CallExpression
 */

BlockScoping.prototype.buildHas = function (ret, call) {
  var body = this.body;

  body.push(t.variableDeclaration("var", [
    t.variableDeclarator(ret, call)
  ]));

  var loopParent = this.loopParent;
  var retCheck;
  var has = this.has;
  var cases = [];

  if (has.hasReturn) {
    // typeof ret === "object"
    retCheck = util.template("let-scoping-return", {
      RETURN: ret
    });
  }

  if (has.hasBreakContinue) {
    if (!loopParent) {
      throw new Error("Has no loop parent but we're trying to reassign breaks " +
                      "and continues, something is going wrong here.");
    }

    for (var key in has.map) {
      cases.push(t.switchCase(t.literal(key), [has.map[key]]));
    }

    if (has.hasReturn) {
      cases.push(t.switchCase(null, [retCheck]));
    }

    if (cases.length === 1) {
      var single = cases[0];
      body.push(this.file.attachAuxiliaryComment(t.ifStatement(
        t.binaryExpression("===", ret, single.test),
        single.consequent[0]
      )));
    } else {
      body.push(this.file.attachAuxiliaryComment(t.switchStatement(ret, cases)));
    }
  } else {
    if (has.hasReturn) {
      body.push(this.file.attachAuxiliaryComment(retCheck));
    }
  }
};

},{"../../../helpers/object":27,"../../../traversal":117,"../../../types":122,"../../../util":124,"lodash/object/extend":260,"lodash/object/values":265}],66:[function(require,module,exports){
"use strict";

var ReplaceSupers = require("../../helpers/replace-supers");
var nameMethod    = require("../../helpers/name-method");
var defineMap     = require("../../helpers/define-map");
var messages      = require("../../../messages");
var util          = require("../../../util");
var t             = require("../../../types");

exports.check = t.isClass;

exports.ClassDeclaration = function (node, parent, scope, file) {
  return new ClassTransformer(node, file, scope, true).run();
};

exports.ClassExpression = function (node, parent, scope, file) {
  if (!node.id) {
    if (t.isProperty(parent) && parent.value === node && !parent.computed && t.isIdentifier(parent.key)) {
      // var o = { foo: class {} };
      node.id = parent.key;
    }

    if (t.isVariableDeclarator(parent) && t.isIdentifier(parent.id)) {
      // var foo = class {};
      node.id = parent.id;
    }
  }

  return new ClassTransformer(node, file, scope, false).run();
};

/**
 * Description
 *
 * @param {Node} node
 * @param {File} file
 * @param {Scope} scope
 * @param {Boolean} isStatement
 */

function ClassTransformer(node, file, scope, isStatement) {
  this.isStatement = isStatement;
  this.scope       = scope;
  this.node        = node;
  this.file        = file;

  this.hasInstanceMutators = false;
  this.hasStaticMutators   = false;

  this.instanceMutatorMap = {};
  this.staticMutatorMap   = {};
  this.hasConstructor     = false;
  this.className          = node.id || scope.generateUidIdentifier("class");
  this.superName          = node.superClass || t.identifier("Function");
  this.hasSuper           = !!node.superClass;
  this.isLoose            = file.isLoose("es6.classes");
}

/**
 * Description
 *
 * @returns {Array}
 */

ClassTransformer.prototype.run = function () {
  var superName = this.superName;
  var className = this.className;
  var file      = this.file;

  //

  var body = this.body = [];

  var constructorBody = t.blockStatement([
    t.expressionStatement(t.callExpression(file.addHelper("class-call-check"), [
      t.thisExpression(),
      className
    ]))
  ]);
  var constructor;

  if (this.node.id) {
    constructor = t.functionDeclaration(className, [], constructorBody);
    body.push(constructor);
  } else {
    constructor = t.functionExpression(null, [], constructorBody);
    body.push(t.variableDeclaration("var", [
      t.variableDeclarator(className, constructor)
    ]));
  }
  this.constructor = constructor;

  var closureParams = [];
  var closureArgs = [];

  //

  if (this.hasSuper) {
    closureArgs.push(superName);

    if (!t.isIdentifier(superName)) {
      superName = this.scope.generateUidBasedOnNode(superName, this.file);
    }

    closureParams.push(superName);

    this.superName = superName;
    body.push(t.expressionStatement(t.callExpression(file.addHelper("inherits"), [className, superName])));
  }

  this.buildBody();

  t.inheritsComments(body[0], this.node);

  var init;

  if (body.length === 1) {
    // only a constructor so no need for a closure container
    init = t.toExpression(constructor);
  } else {
    body.push(t.returnStatement(className));
    init = t.callExpression(
      t.functionExpression(null, closureParams, t.blockStatement(body)),
      closureArgs
    );
  }

  if (this.isStatement) {
    return t.variableDeclaration("let", [
      t.variableDeclarator(className, init)
    ]);
  } else {
    return init;
  }
};

/**
 * Description
 */

ClassTransformer.prototype.buildBody = function () {
  var constructor = this.constructor;
  var className   = this.className;
  var superName   = this.superName;
  var classBody   = this.node.body.body;
  var body        = this.body;

  for (var i = 0; i < classBody.length; i++) {
    var node = classBody[i];
    if (t.isMethodDefinition(node)) {
      var replaceSupers = new ReplaceSupers({
        methodNode: node,
        className:  this.className,
        superName:  this.superName,
        isStatic:   node.static,
        isLoose:    this.isLoose,
        scope:      this.scope,
        file:       this.file
      }, true);
      replaceSupers.replace();

      if (node.key.name === "constructor") {
        this.pushConstructor(node);
      } else {
        this.pushMethod(node);
      }
    } else if (t.isPrivateDeclaration(node)) {
      this.closure = true;
      body.unshift(node);
    } else if (t.isClassProperty(node)) {
      this.pushProperty(node);
    }
  }

  // we have no constructor, we have a super, and the super doesn't appear to be falsy
  if (!this.hasConstructor && this.hasSuper && !t.isFalsyExpression(superName)) {
    var helperName = "class-super-constructor-call";
    if (this.isLoose) helperName += "-loose";
    constructor.body.body.push(util.template(helperName, {
      CLASS_NAME: className,
      SUPER_NAME: this.superName
    }, true));
  }

  var instanceProps;
  var staticProps;

  if (this.hasInstanceMutators) {
    instanceProps = defineMap.build(this.instanceMutatorMap);
  }

  if (this.hasStaticMutators) {
    staticProps = defineMap.build(this.staticMutatorMap);
  }

  if (instanceProps || staticProps) {
    staticProps = staticProps || t.literal(null);

    var args = [className, staticProps];
    if (instanceProps) args.push(instanceProps);

    body.push(t.expressionStatement(
      t.callExpression(this.file.addHelper("prototype-properties"), args)
    ));
  }
};

/**
 * Push a method to its respective mutatorMap.
 *
 * @param {Node} node MethodDefinition
 */

ClassTransformer.prototype.pushMethod = function (node) {
  var methodName = node.key;

  var kind = node.kind;

  if (kind === "") {
    nameMethod.property(node, this.file, this.scope);

    if (this.isLoose) {
      // use assignments instead of define properties for loose classes

      var className = this.className;
      if (!node.static) className = t.memberExpression(className, t.identifier("prototype"));
      methodName = t.memberExpression(className, methodName, node.computed);

      var expr = t.expressionStatement(t.assignmentExpression("=", methodName, node.value));
      t.inheritsComments(expr, node);
      this.body.push(expr);
      return;
    }

    kind = "value";
  }

  var mutatorMap = this.instanceMutatorMap;
  if (node.static) {
    this.hasStaticMutators = true;
    mutatorMap = this.staticMutatorMap;
  } else {
    this.hasInstanceMutators = true;
  }

  defineMap.push(mutatorMap, methodName, kind, node.computed, node);
  defineMap.push(mutatorMap, methodName, "enumerable", node.computed, false);
};

/**
 * Description
 *
 * @param {Node} node
 */

ClassTransformer.prototype.pushProperty = function (node) {
  if (!node.value) return;

  var key;

  if (node.static) {
    key = t.memberExpression(this.className, node.key);
    this.body.push(
      t.expressionStatement(t.assignmentExpression("=", key, node.value))
    );
  } else {
    key = t.memberExpression(t.thisExpression(), node.key);
    this.constructor.body.body.unshift(
      t.expressionStatement(t.assignmentExpression("=", key, node.value))
    );
  }
};

/**
 * Replace the constructor body of our class.
 *
 * @param {Node} method MethodDefinition
 */

ClassTransformer.prototype.pushConstructor = function (method) {
  if (method.kind) {
    throw this.file.errorWithNode(method, messages.get("classesIllegalConstructorKind"));
  }

  var construct = this.constructor;
  var fn        = method.value;

  this.hasConstructor = true;

  t.inherits(construct, fn);
  t.inheritsComments(construct, method);

  construct._ignoreUserWhitespace = true;
  construct.params                = fn.params;
  construct.body.body             = construct.body.body.concat(fn.body.body);
};

},{"../../../messages":30,"../../../types":122,"../../../util":124,"../../helpers/define-map":38,"../../helpers/name-method":40,"../../helpers/replace-supers":43}],67:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t        = require("../../../types");

exports.check = function (node) {
  return t.isVariableDeclaration(node, { kind: "const" });
};

var visitor = {
  enter: function (node, parent, scope, state) {
    if (t.isAssignmentExpression(node) || t.isUpdateExpression(node)) {
      var ids = t.getBindingIdentifiers(node);

      for (var name in ids) {
        var id = ids[name];

        var constant = state.constants[name];

        // no constant exists
        if (!constant) continue;

        var constantIdentifier = constant.identifier;

        // check if the assignment id matches the constant declaration id
        // if it does then it was the id used to initially declare the
        // constant so we can just ignore it
        if (id === constantIdentifier) continue;

        // check if there's been a local binding that shadows this constant
        if (!scope.bindingIdentifierEquals(name, constantIdentifier)) continue;

        throw state.file.errorWithNode(id, messages.get("readOnly", name));
      }
    } else if (t.isScope(node, parent)) {
      this.skip();
    }
  }
};

exports.Scopable = function (node, parent, scope, file) {
  scope.traverse(node, visitor, {
    constants: scope.getAllBindingsOfKind("const"),
    file:      file
  });
};

exports.VariableDeclaration = function (node) {
  if (node.kind === "const") node.kind = "let";
};

},{"../../../messages":30,"../../../types":122}],68:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t        = require("../../../types");

exports.check = t.isPattern;

function DestructuringTransformer(opts) {
  this.blockHoist = opts.blockHoist;
  this.operator   = opts.operator;
  this.nodes      = opts.nodes;
  this.scope      = opts.scope;
  this.file       = opts.file;
  this.kind       = opts.kind;
}

DestructuringTransformer.prototype.buildVariableAssignment = function (id, init) {
  var op = this.operator;
  if (t.isMemberExpression(id)) op = "=";

  var node;

  if (op) {
    node = t.expressionStatement(t.assignmentExpression(op, id, init));
  } else {
    node = t.variableDeclaration(this.kind, [
      t.variableDeclarator(id, init)
    ]);
  }

  node._blockHoist = this.blockHoist;

  return node;
};

DestructuringTransformer.prototype.buildVariableDeclaration = function (id, init) {
  var declar = t.variableDeclaration("var", [
    t.variableDeclarator(id, init)
  ]);
  declar._blockHoist = this.blockHoist;
  return declar;
};

DestructuringTransformer.prototype.push = function (elem, parentId) {
  if (t.isObjectPattern(elem)) {
    this.pushObjectPattern(elem, parentId);
  } else if (t.isArrayPattern(elem)) {
    this.pushArrayPattern(elem, parentId);
  } else if (t.isAssignmentPattern(elem)) {
    this.pushAssignmentPattern(elem, parentId);
  } else {
    this.nodes.push(this.buildVariableAssignment(elem, parentId));
  }
};

DestructuringTransformer.prototype.pushAssignmentPattern = function (pattern, parentId) {
  var tempParentId = this.scope.generateUidBasedOnNode(parentId);

  var declar = t.variableDeclaration("var", [
    t.variableDeclarator(tempParentId, parentId)
  ]);
  declar._blockHoist = this.blockHoist;
  this.nodes.push(declar);

  this.nodes.push(this.buildVariableAssignment(
    pattern.left,
    t.conditionalExpression(
      t.binaryExpression("===", tempParentId, t.identifier("undefined")),
      pattern.right,
      tempParentId
    )
  ));
};

DestructuringTransformer.prototype.pushObjectSpread = function (pattern, parentId, prop, i) {
  // get all the keys that appear in this object before the current spread
  var keys = [];
  for (var i2 = 0; i2 < pattern.properties.length; i2++) {
    var prop2 = pattern.properties[i2];

    if (i2 >= i) break;
    if (t.isSpreadProperty(prop2)) continue;

    var key = prop2.key;
    if (t.isIdentifier(key)) {
      key = t.literal(prop2.key.name);
    }
    keys.push(key);
  }
  keys = t.arrayExpression(keys);

  var value = t.callExpression(this.file.addHelper("object-without-properties"), [parentId, keys]);
  this.nodes.push(this.buildVariableAssignment(prop.argument, value));
};

DestructuringTransformer.prototype.pushObjectProperty = function (prop, parentId) {
  if (t.isLiteral(prop.key)) prop.computed = true;

  var pattern2   = prop.value;
  var patternId2 = t.memberExpression(parentId, prop.key, prop.computed);

  if (t.isPattern(pattern2)) {
    this.push(pattern2, patternId2);
  } else {
    this.nodes.push(this.buildVariableAssignment(pattern2, patternId2));
  }
};

DestructuringTransformer.prototype.pushObjectPattern = function (pattern, parentId) {
  if (!pattern.properties.length) {
    this.nodes.push(t.expressionStatement(
      t.callExpression(this.file.addHelper("object-destructuring-empty"), [parentId])
    ));
  }

  if (pattern.properties.length > 1 && t.isMemberExpression(parentId)) {
    var temp = this.scope.generateUidBasedOnNode(parentId, this.file);
    this.nodes.push(this.buildVariableDeclaration(temp, parentId));
    parentId = temp;
  }

  for (var i = 0; i < pattern.properties.length; i++) {
    var prop = pattern.properties[i];
    if (t.isSpreadProperty(prop)) {
      this.pushObjectSpread(pattern, parentId, prop, i);
    } else {
      this.pushObjectProperty(prop, parentId);
    }
  }
};

var hasRest = function (pattern) {
  for (var i = 0; i < pattern.elements.length; i++) {
    if (t.isRestElement(pattern.elements[i])) {
      return true;
    }
  }
  return false;
};

DestructuringTransformer.prototype.pushArrayPattern = function (pattern, parentId) {
  if (!pattern.elements) return;

  // if we have a rest then we need all the elements
  var count = !hasRest(pattern) && pattern.elements.length;

  var toArray = this.scope.toArray(parentId, count);

  var _parentId = this.scope.generateUidBasedOnNode(parentId);
  this.nodes.push(this.buildVariableDeclaration(_parentId, toArray));
  parentId = _parentId;

  this.scope.assignTypeGeneric(parentId.name, "Array");

  for (var i = 0; i < pattern.elements.length; i++) {
    var elem = pattern.elements[i];

    // hole
    if (!elem) continue;

    var newPatternId;

    if (t.isRestElement(elem)) {
      newPatternId = this.scope.toArray(parentId);

      if (i > 0) {
        newPatternId = t.callExpression(t.memberExpression(newPatternId, t.identifier("slice")), [t.literal(i)]);
      }

      elem = elem.argument;
    } else {
      newPatternId = t.memberExpression(parentId, t.literal(i), true);
    }

    this.push(elem, newPatternId);
  }
};

DestructuringTransformer.prototype.init = function (pattern, parentId) {
  if (!t.isArrayExpression(parentId) && !t.isMemberExpression(parentId) && !t.isIdentifier(parentId)) {
    var key = this.scope.generateUidBasedOnNode(parentId);
    this.nodes.push(this.buildVariableDeclaration(key, parentId));
    parentId = key;
  }

  this.push(pattern, parentId);
};

exports.ForInStatement =
exports.ForOfStatement = function (node, parent, scope, file) {
  var left = node.left;

  if (t.isPattern(left)) {
    // for ({ length: k } in { abc: 3 });

    var temp = scope.generateUidIdentifier("ref");

    node.left = t.variableDeclaration("var", [
      t.variableDeclarator(temp)
    ]);

    t.ensureBlock(node);

    node.body.body.unshift(t.variableDeclaration("var", [
      t.variableDeclarator(left, temp)
    ]));

    return;
  }

  if (!t.isVariableDeclaration(left)) return;

  var pattern = left.declarations[0].id;
  if (!t.isPattern(pattern)) return;

  var key = scope.generateUidIdentifier("ref");
  node.left = t.variableDeclaration(left.kind, [
    t.variableDeclarator(key, null)
  ]);

  var nodes = [];

  var destructuring = new DestructuringTransformer({
    kind: left.kind,
    file: file,
    scope: scope,
    nodes: nodes
  });

  destructuring.init(pattern, key);

  t.ensureBlock(node);

  var block = node.body;
  block.body = nodes.concat(block.body);
};

exports.Function = function (node, parent, scope, file) {
  var nodes = [];

  var hasDestructuringTransformer = false;

  node.params = node.params.map(function (pattern, i) {
    if (!t.isPattern(pattern)) return pattern;

    hasDestructuringTransformer = true;
    var parentId = scope.generateUidIdentifier("ref");

    var destructuring = new DestructuringTransformer({
      blockHoist: node.params.length - i,
      nodes:      nodes,
      scope:      scope,
      file:       file,
      kind:       "var",
    });
    destructuring.init(pattern, parentId);

    return parentId;
  });

  if (!hasDestructuringTransformer) return;

  t.ensureBlock(node);

  var block = node.body;
  block.body = nodes.concat(block.body);
};

exports.CatchClause = function (node, parent, scope, file) {
  var pattern = node.param;
  if (!t.isPattern(pattern)) return;

  var ref = scope.generateUidIdentifier("ref");
  node.param = ref;

  var nodes = [];

  var destructuring = new DestructuringTransformer({
    kind: "let",
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(pattern, ref);

  node.body.body = nodes.concat(node.body.body);

  return node;
};

exports.ExpressionStatement = function (node, parent, scope, file) {
  var expr = node.expression;
  if (expr.type !== "AssignmentExpression") return;
  if (!t.isPattern(expr.left)) return;
  if (file.isConsequenceExpressionStatement(node)) return;

  var nodes = [];

  var ref = scope.generateUidIdentifier("ref");
  nodes.push(t.variableDeclaration("var", [
    t.variableDeclarator(ref, expr.right)
  ]));

  var destructuring = new DestructuringTransformer({
    operator: expr.operator,
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(expr.left, ref);

  return nodes;
};

exports.AssignmentExpression = function (node, parent, scope, file) {
  if (!t.isPattern(node.left)) return;

  var ref = scope.generateUidIdentifier("temp");
  scope.push({
    key: ref.name,
    id: ref
  });

  var nodes = [];
  nodes.push(t.assignmentExpression("=", ref, node.right));

  var destructuring = new DestructuringTransformer({
    operator: node.operator,
    file: file,
    scope: scope,
    nodes: nodes
  });
  destructuring.init(node.left, ref);

  nodes.push(ref);

  return t.toSequenceExpression(nodes, scope);
};

var variableDeclarationhasPattern = function (node) {
  for (var i = 0; i < node.declarations.length; i++) {
    if (t.isPattern(node.declarations[i].id)) {
      return true;
    }
  }
  return false;
};

exports.VariableDeclaration = function (node, parent, scope, file) {
  if (t.isForInStatement(parent) || t.isForOfStatement(parent)) return;
  if (!variableDeclarationhasPattern(node)) return;

  var nodes = [];
  var declar;

  for (var i = 0; i < node.declarations.length; i++) {
    declar = node.declarations[i];

    var patternId = declar.init;
    var pattern   = declar.id;

    var destructuring = new DestructuringTransformer({
      nodes: nodes,
      scope: scope,
      kind:  node.kind,
      file:  file
    });

    if (t.isPattern(pattern) && patternId) {
      destructuring.init(pattern, patternId);

      if (+i !== node.declarations.length - 1) {
        // we aren't the last declarator so let's just make the
        // last transformed node inherit from us
        t.inherits(nodes[nodes.length - 1], declar);
      }
    } else {
      nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));
    }
  }

  if (!t.isProgram(parent) && !t.isBlockStatement(parent)) {
    // https://github.com/babel/babel/issues/113
    // for (let [x] = [0]; false;) {}

    declar = null;

    for (i = 0; i < nodes.length; i++) {
      node = nodes[i];
      declar = declar || t.variableDeclaration(node.kind, []);

      if (!t.isVariableDeclaration(node) && declar.kind !== node.kind) {
        throw file.errorWithNode(node, messages.get("invalidParentForThisNode"));
      }

      declar.declarations = declar.declarations.concat(node.declarations);
    }

    return declar;
  }

  return nodes;
};

},{"../../../messages":30,"../../../types":122}],69:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var util     = require("../../../util");
var t        = require("../../../types");

exports.check = t.isForOfStatement;

exports.ForOfStatement = function (node, parent, scope, file) {
  var callback = spec;
  if (file.isLoose("es6.forOf")) callback = loose;

  var build  = callback(node, parent, scope, file);
  var declar = build.declar;
  var loop   = build.loop;
  var block  = loop.body;

  // inherit comments from the original loop
  t.inheritsComments(loop, node);

  // ensure that it's a block so we can take all its statements
  t.ensureBlock(node);

  // add the value declaration to the new loop body
  if (declar) {
    block.body.push(declar);
  }

  // push the rest of the original loop body onto our new body
  block.body = block.body.concat(node.body.body);

  t.inherits(loop, node);

  // todo: find out why this is necessary? #538
  loop._scopeInfo = node._scopeInfo;

  return loop;
};

var loose = function (node, parent, scope, file) {
  var left = node.left;
  var declar, id;

  if (t.isIdentifier(left) || t.isPattern(left)) {
    // for (i of test), for ({ i } of test)
    id = left;
  } else if (t.isVariableDeclaration(left)) {
    // for (var i of test)
    id = scope.generateUidIdentifier("ref");
    declar = t.variableDeclaration(left.kind, [
      t.variableDeclarator(left.declarations[0].id, id)
    ]);
  } else {
    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
  }

  var loop = util.template("for-of-loose", {
    LOOP_OBJECT:  scope.generateUidIdentifier("iterator"),
    IS_ARRAY:     scope.generateUidIdentifier("isArray"),
    OBJECT:       node.right,
    INDEX:        scope.generateUidIdentifier("i"),
    ID:           id
  });

  if (!declar) {
    // no declaration so we need to remove the variable declaration at the top of
    // the for-of-loose template
    loop.body.body.shift();
  }

  return {
    declar: declar,
    loop:   loop
  };
};

var spec = function (node, parent, scope, file) {
  var left = node.left;
  var declar;

  var stepKey   = scope.generateUidIdentifier("step");
  var stepValue = t.memberExpression(stepKey, t.identifier("value"));

  if (t.isIdentifier(left) || t.isPattern(left)) {
    // for (i of test), for ({ i } of test)
    declar = t.expressionStatement(t.assignmentExpression("=", left, stepValue));
  } else if (t.isVariableDeclaration(left)) {
    // for (var i of test)
    declar = t.variableDeclaration(left.kind, [
      t.variableDeclarator(left.declarations[0].id, stepValue)
    ]);
  } else {
    throw file.errorWithNode(left, messages.get("unknownForHead", left.type));
  }

  var loop = util.template("for-of", {
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    STEP_KEY:     stepKey,
    OBJECT:       node.right
  });

  return {
    declar: declar,
    loop:   loop
  };
};

},{"../../../messages":30,"../../../types":122,"../../../util":124}],70:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = require("../internal/modules").check;

exports.ImportDeclaration = function (node, parent, scope, file) {
  var nodes = [];

  if (node.specifiers.length) {
    for (var i = 0; i < node.specifiers.length; i++) {
      file.moduleFormatter.importSpecifier(node.specifiers[i], node, nodes, parent);
    }
  } else {
    file.moduleFormatter.importDeclaration(node, nodes, parent);
  }

  if (nodes.length === 1) {
    // inherit `_blockHoist` - this is for `_blockHoist` in File.prototype.addImport
    nodes[0]._blockHoist = node._blockHoist;
  }

  return nodes;
};

exports.ExportDeclaration = function (node, parent, scope, file) {
  var nodes = [];
  var i;

  if (node.declaration) {
    // make sure variable exports have an initializer
    // this is done here to avoid duplicating it in the module formatters
    if (t.isVariableDeclaration(node.declaration)) {
      var declar = node.declaration.declarations[0];
      declar.init = declar.init || t.identifier("undefined");
    }

    file.moduleFormatter.exportDeclaration(node, nodes, parent);
  } else if (node.specifiers) {
    for (i = 0; i < node.specifiers.length; i++) {
      file.moduleFormatter.exportSpecifier(node.specifiers[i], node, nodes, parent);
    }
  }

  if (node._blockHoist) {
    for (i = 0; i < nodes.length; i++) {
      nodes[i]._blockHoist = node._blockHoist;
    }
  }

  return nodes;
};

},{"../../../types":122,"../internal/modules":90}],71:[function(require,module,exports){
"use strict";

var ReplaceSupers = require("../../helpers/replace-supers");
var t             = require("../../../types");

exports.check = function (node) {
  return t.isIdentifier(node, { name: "super" });
};

exports.Property = function (node, parent, scope, file) {
  if (!node.method) return;

  var value = node.value;
  var thisExpr = scope.generateUidIdentifier("this");

  var replaceSupers = new ReplaceSupers({
    topLevelThisReference: thisExpr,
    methodNode:            node,
    className:             thisExpr,
    isStatic:              true,
    scope:                 scope,
    file:                  file
  });

  replaceSupers.replace();

  if (replaceSupers.hasSuper) {
    value.body.body.unshift(
      t.variableDeclaration("var", [
        t.variableDeclarator(thisExpr, t.thisExpression())
      ])
    );
  }
};

},{"../../../types":122,"../../helpers/replace-supers":43}],72:[function(require,module,exports){
"use strict";

var util = require("../../../util");
var t    = require("../../../types");

exports.check = function (node) {
  return t.isFunction(node) && hasDefaults(node);
};

var hasDefaults = function (node) {
  for (var i = 0; i < node.params.length; i++) {
    if (!t.isIdentifier(node.params[i])) return true;
  }
  return false;
};

var iifeVisitor = {
  enter: function (node, parent, scope, state) {
    if (!t.isReferencedIdentifier(node, parent)) return;
    if (!state.scope.hasOwnBinding(node.name)) return;
    if (state.scope.bindingIdentifierEquals(node.name, node)) return;

    state.iife = true;
    this.stop();
  }
};

exports.Function = function (node, parent, scope, file) {
  if (!hasDefaults(node)) return;

  t.ensureBlock(node);

  var body = [];

  var argsIdentifier = t.identifier("arguments");
  argsIdentifier._ignoreAliasFunctions = true;

  var lastNonDefaultParam = 0;

  var state = { iife: false, scope: scope };

  var pushDefNode = function (left, right, i) {
    var defNode = util.template("default-parameter", {
      VARIABLE_NAME: left,
      DEFAULT_VALUE: right,
      ARGUMENT_KEY:  t.literal(i),
      ARGUMENTS:     argsIdentifier
    }, true);
    file.checkNode(defNode);
    defNode._blockHoist = node.params.length - i;
    body.push(defNode);
  };

  for (var i = 0; i < node.params.length; i++) {
    var param = node.params[i];

    if (!t.isAssignmentPattern(param)) {
      if (!t.isRestElement(param)) {
        lastNonDefaultParam = i + 1;
      }

      if (!t.isIdentifier(param)) {
        scope.traverse(param, iifeVisitor, state);
      }

      if (file.transformers["es6.blockScopingTDZ"].canRun()) {
        pushDefNode(param, t.identifier("undefined"), i);
      }

      continue;
    }

    var left  = param.left;
    var right = param.right;

    var placeholder = scope.generateUidIdentifier("x");
    placeholder._isDefaultPlaceholder = true;
    node.params[i] = placeholder;

    if (!state.iife) {
      if (t.isIdentifier(right) && scope.hasOwnBinding(right.name)) {
        state.iife = true;
      } else {
        scope.traverse(right, iifeVisitor, state);
      }
    }

    pushDefNode(left, right, i);
  }

  // we need to cut off all trailing default parameters
  node.params = node.params.slice(0, lastNonDefaultParam);

  if (state.iife) {
    var container = t.functionExpression(null, [], node.body, node.generator);
    container._aliasFunction = true;

    body.push(t.returnStatement(t.callExpression(container, [])));

    node.body = t.blockStatement(body);
  } else {
    node.body.body = body.concat(node.body.body);
  }
};

},{"../../../types":122,"../../../util":124}],73:[function(require,module,exports){
"use strict";

var util = require("../../../util");
var t    = require("../../../types");

exports.check = t.isRestElement;

var hasRest = function (node) {
  return t.isRestElement(node.params[node.params.length - 1]);
};

exports.Function = function (node, parent, scope) {
  if (!hasRest(node)) return;

  var rest = node.params.pop().argument;

  var argsId = t.identifier("arguments");

  // otherwise `arguments` will be remapped in arrow functions
  argsId._ignoreAliasFunctions = true;

  var start = t.literal(node.params.length);
  var key = scope.generateUidIdentifier("key");
  var len = scope.generateUidIdentifier("len");

  var arrKey = key;
  var arrLen = len;
  if (node.params.length) {
    // this method has additional params, so we need to subtract
    // the index of the current argument position from the
    // position in the array that we want to populate
    arrKey = t.binaryExpression("-", key, start);

    // we need to work out the size of the array that we're
    // going to store all the rest parameters
    //
    // we need to add a check to avoid constructing the array
    // with <0 if there are less arguments than params as it'll
    // cause an error
    arrLen = t.conditionalExpression(
      t.binaryExpression(">", len, start),
      t.binaryExpression("-", len, start),
      t.literal(0)
    );
  }

  // support patterns
  if (t.isPattern(rest)) {
    var pattern = rest;
    rest = scope.generateUidIdentifier("ref");

    // let the destructuring transformer handle this
    var restDeclar = t.variableDeclaration("var", [
      t.variableDeclarator(pattern, rest)
    ]);

    // retain evaluation position
    restDeclar._blockHoist = node.params.length + 1;

    node.body.body.unshift(restDeclar);
  }

  scope.assignTypeGeneric(rest.name, "Array");

  var loop = util.template("rest", {
    ARGUMENTS: argsId,
    ARRAY_KEY: arrKey,
    ARRAY_LEN: arrLen,
    START: start,
    ARRAY: rest,
    KEY: key,
    LEN: len,
  });
  loop._blockHoist = node.params.length + 1;
  node.body.body.unshift(loop);
};

},{"../../../types":122,"../../../util":124}],74:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.check = function (node) {
  return t.isProperty(node) && node.computed;
};

exports.ObjectExpression = function (node, parent, scope, file) {
  var hasComputed = false;

  for (var i = 0; i < node.properties.length; i++) {
    hasComputed = t.isProperty(node.properties[i], { computed: true, kind: "init" });
    if (hasComputed) break;
  }

  if (!hasComputed) return;

  var initProps = [];
  var objId = scope.generateUidBasedOnNode(parent);

  //

  var body = [];
  var container = t.functionExpression(null, [], t.blockStatement(body));
  container._aliasFunction = true;

  //

  var callback = spec;
  if (file.isLoose("es6.properties.computed")) callback = loose;

  var result = callback(node, body, objId, initProps, file);
  if (result) return result;

  //

  body.unshift(t.variableDeclaration("var", [
    t.variableDeclarator(objId, t.objectExpression(initProps))
  ]));

  body.push(t.returnStatement(objId));

  return t.callExpression(container, []);
};

var loose = function (node, body, objId) {
  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];

    body.push(t.expressionStatement(
      t.assignmentExpression(
        "=",
        t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)),
        prop.value
      )
    ));
  }
};

var spec = function (node, body, objId, initProps, file) {
  var props = node.properties;
  var prop, key;

  // normalize key

  for (var i = 0; i < props.length; i++) {
    prop = props[i];
    if (prop.kind !== "init") continue;

    key = prop.key;

    if (!prop.computed && t.isIdentifier(key)) {
      prop.key = t.literal(key.name);
    }
  }

  // add all non-computed properties and `__proto__` properties to the initializer

  var broken = false;

  for (i = 0; i < props.length; i++) {
    prop = props[i];

    if (prop.computed) {
      broken = true;
    }

    if (prop.kind !== "init" || !broken || t.isLiteral(t.toComputedKey(prop, prop.key), { value: "__proto__" })) {
      initProps.push(prop);
      props[i] = null;
    }
  }

  // add a simple assignment for all Symbol member expressions due to symbol polyfill limitations
  // otherwise use Object.defineProperty

  for (i = 0; i < props.length; i++) {
    prop = props[i];
    if (!prop) continue;

    key = prop.key;
    var bodyNode;

    if (prop.computed && t.isMemberExpression(key) && t.isIdentifier(key.object, { name: "Symbol" })) {
      // { [Symbol.iterator]: "foo" }
      bodyNode = t.assignmentExpression(
        "=",
        t.memberExpression(objId, key, true),
        prop.value
      );
    } else {
      bodyNode = t.callExpression(file.addHelper("define-property"), [objId, key, prop.value]);
    }

    body.push(t.expressionStatement(bodyNode));
  }

  // only one node and it's a Object.defineProperty that returns the object

  if (body.length === 1) {
    var first = body[0].expression;

    if (t.isCallExpression(first)) {
      first.arguments[0] = t.objectExpression(initProps);
      return first;
    }
  }
};

},{"../../../types":122}],75:[function(require,module,exports){
"use strict";

var nameMethod = require("../../helpers/name-method");
var t          = require("../../../types");
var clone      = require("lodash/lang/clone");

exports.check = function (node) {
  return t.isProperty(node) && (node.method || node.shorthand);
};

exports.Property = function (node, parent, scope, file) {
  if (node.method) {
    node.method = false;
    nameMethod.property(node, file, scope);
  }

  if (node.shorthand) {
    node.shorthand = false;
    node.key = t.removeComments(clone(node.key));
  }
};

},{"../../../types":122,"../../helpers/name-method":40,"lodash/lang/clone":243}],76:[function(require,module,exports){
"use strict";

var includes = require("lodash/collection/includes");
var t        = require("../../../types");

exports.check = t.isSpreadElement;

var getSpreadLiteral = function (spread, scope) {
  return scope.toArray(spread.argument, true);
};

var hasSpread = function (nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (t.isSpreadElement(nodes[i])) {
      return true;
    }
  }
  return false;
};

var build = function (props, scope) {
  var nodes = [];

  var _props = [];

  var push = function () {
    if (!_props.length) return;
    nodes.push(t.arrayExpression(_props));
    _props = [];
  };

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    if (t.isSpreadElement(prop)) {
      push();
      nodes.push(getSpreadLiteral(prop, scope));
    } else {
      _props.push(prop);
    }
  }

  push();

  return nodes;
};

exports.ArrayExpression = function (node, parent, scope) {
  var elements = node.elements;
  if (!hasSpread(elements)) return;

  var nodes = build(elements, scope);
  var first = nodes.shift();

  if (!t.isArrayExpression(first)) {
    nodes.unshift(first);
    first = t.arrayExpression([]);
  }

  return t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
};

exports.CallExpression = function (node, parent, scope) {
  var args = node.arguments;
  if (!hasSpread(args)) return;

  var contextLiteral = t.identifier("undefined");

  node.arguments = [];

  var nodes;
  if (args.length === 1 && args[0].argument.name === "arguments") {
    nodes = [args[0].argument];
  } else {
    nodes = build(args, scope);
  }

  var first = nodes.shift();
  if (nodes.length) {
    node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes));
  } else {
    node.arguments.push(first);
  }

  var callee = node.callee;

  if (t.isMemberExpression(callee)) {
    var temp = scope.generateTempBasedOnNode(callee.object);
    if (temp) {
      callee.object = t.assignmentExpression("=", temp, callee.object);
      contextLiteral = temp;
    } else {
      contextLiteral = callee.object;
    }
    t.appendToMemberExpression(callee, t.identifier("apply"));
  } else {
    node.callee = t.memberExpression(node.callee, t.identifier("apply"));
  }

  node.arguments.unshift(contextLiteral);
};

exports.NewExpression = function (node, parent, scope, file) {
  var args = node.arguments;
  if (!hasSpread(args)) return;

  var nativeType = t.isIdentifier(node.callee) && includes(t.NATIVE_TYPE_NAMES, node.callee.name);

  var nodes = build(args, scope);

  if (nativeType) {
    nodes.unshift(t.arrayExpression([t.literal(null)]));
  }

  var first = nodes.shift();

  if (nodes.length) {
    args = t.callExpression(t.memberExpression(first, t.identifier("concat")), nodes);
  } else {
    args = first;
  }

  if (nativeType) {
    return t.newExpression(
      t.callExpression(
        t.memberExpression(file.addHelper("bind"), t.identifier("apply")),
        [node.callee, args]
      ),
      []
    );
  } else {
    return t.callExpression(file.addHelper("apply-constructor"), [node.callee, args]);
  }
};

},{"../../../types":122,"lodash/collection/includes":175}],77:[function(require,module,exports){
"use strict";

var reduceRight = require("lodash/collection/reduceRight");
var messages    = require("../../../messages");
var flatten     = require("lodash/array/flatten");
var util        = require("../../../util");
var map         = require("lodash/collection/map");
var t           = require("../../../types");

function returnBlock(expr) {
  return t.blockStatement([t.returnStatement(expr)]);
}

function TailCallTransformer(node, scope, file) {
  this.hasTailRecursion = false;
  this.needsArguments   = false;
  this.setsArguments    = false;
  this.needsThis        = false;
  this.ownerId          = node.id;
  this.vars             = [];

  this.scope = scope;
  this.file  = file;
  this.node  = node;
}

TailCallTransformer.prototype.getArgumentsId = function () {
  return this.argumentsId = this.argumentsId || this.scope.generateUidIdentifier("arguments");
};

TailCallTransformer.prototype.getThisId = function () {
  return this.thisId = this.thisId || this.scope.generateUidIdentifier("this");
};

TailCallTransformer.prototype.getLeftId = function () {
  return this.leftId = this.leftId || this.scope.generateUidIdentifier("left");
};

TailCallTransformer.prototype.getFunctionId = function () {
  return this.functionId = this.functionId || this.scope.generateUidIdentifier("function");
};

TailCallTransformer.prototype.getParams = function () {
  var params = this.params;

  if (!params) {
    params = this.node.params;
    this.paramDecls = [];

    for (var i = 0; i < params.length; i++) {
      var param = params[i];
      if (!param._isDefaultPlaceholder) {
        this.paramDecls.push(t.variableDeclarator(
          param,
          params[i] = this.scope.generateUidIdentifier("x")
        ));
      }
    }
  }

  return this.params = params;
};

TailCallTransformer.prototype.hasDeopt = function () {
  // check if the ownerId has been reassigned, if it has then it's not safe to
  // perform optimisations
  var ownerIdInfo = this.scope.getBindingInfo(this.ownerId.name);
  return ownerIdInfo && ownerIdInfo.reassigned;
};

TailCallTransformer.prototype.run = function () {
  var scope = this.scope;
  var node  = this.node;

  // only tail recursion can be optimized as for now, so we can skip anonymous
  // functions entirely
  var ownerId = this.ownerId;
  if (!ownerId) return;

  // traverse the function and look for tail recursion
  scope.traverse(node, firstPass, this);

  if (!this.hasTailRecursion) return;

  if (this.hasDeopt()) {
    this.file.logDeopt(node, messages.get("tailCallReassignmentDeopt"));
    return;
  }

  //

  scope.traverse(node, secondPass, this);

  if (!this.needsThis || !this.needsArguments) {
    scope.traverse(node, thirdPass, this);
  }

  var body = t.ensureBlock(node).body;

  if (this.vars.length > 0) {
    var declarations = flatten(map(this.vars, function (decl) {
      return decl.declarations;
    }, this));
    var statement = reduceRight(declarations, function (expr, decl) {
      return t.assignmentExpression("=", decl.id, expr);
    }, t.identifier("undefined"));
    body.unshift(t.expressionStatement(statement));
  }

  var paramDecls = this.paramDecls;
  if (paramDecls.length > 0) {
    body.unshift(t.variableDeclaration("var", paramDecls));
  }

  node.body = util.template("tail-call-body", {
    THIS_ID:       this.thisId,
    ARGUMENTS_ID:  this.argumentsId,
    FUNCTION_ID:   this.getFunctionId(),
    BLOCK:         node.body
  });

  var topVars = [];

  if (this.needsThis) {
    topVars.push(t.variableDeclarator(this.getThisId(), t.thisExpression()));
  }

  if (this.needsArguments || this.setsArguments) {
    var decl = t.variableDeclarator(this.getArgumentsId());
    if (this.needsArguments) {
      decl.init = t.identifier("arguments");
    }
    topVars.push(decl);
  }

  var leftId = this.leftId;
  if (leftId) {
    topVars.push(t.variableDeclarator(leftId));
  }

  if (topVars.length > 0) {
    node.body.body.unshift(t.variableDeclaration("var", topVars));
  }
};

TailCallTransformer.prototype.subTransform = function (node) {
  if (!node) return;

  var handler = this["subTransform" + node.type];
  if (handler) return handler.call(this, node);
};

TailCallTransformer.prototype.subTransformConditionalExpression = function (node) {
  var callConsequent = this.subTransform(node.consequent);
  var callAlternate = this.subTransform(node.alternate);
  if (!callConsequent && !callAlternate) {
    return;
  }

  // if ternary operator had tail recursion in value, convert to optimized if-statement
  node.type = "IfStatement";
  node.consequent = callConsequent ? t.toBlock(callConsequent) : returnBlock(node.consequent);

  if (callAlternate) {
    node.alternate = t.isIfStatement(callAlternate) ? callAlternate : t.toBlock(callAlternate);
  } else {
    node.alternate = returnBlock(node.alternate);
  }

  return [node];
};

TailCallTransformer.prototype.subTransformLogicalExpression = function (node) {
  // only call in right-value of can be optimized
  var callRight = this.subTransform(node.right);
  if (!callRight) return;

  // cache left value as it might have side-effects
  var leftId = this.getLeftId();
  var testExpr = t.assignmentExpression(
    "=",
    leftId,
    node.left
  );

  if (node.operator === "&&") {
    testExpr = t.unaryExpression("!", testExpr);
  }

  return [t.ifStatement(testExpr, returnBlock(leftId))].concat(callRight);
};

TailCallTransformer.prototype.subTransformSequenceExpression = function (node) {
  var seq = node.expressions;

  // only last element can be optimized
  var lastCall = this.subTransform(seq[seq.length - 1]);
  if (!lastCall) {
    return;
  }

  // remove converted expression from sequence
  // and convert to regular expression if needed
  if (--seq.length === 1) {
    node = seq[0];
  }

  return [t.expressionStatement(node)].concat(lastCall);
};

TailCallTransformer.prototype.subTransformCallExpression = function (node) {
  var callee = node.callee, thisBinding, args;

  if (t.isMemberExpression(callee, { computed: false }) && t.isIdentifier(callee.property)) {
    switch (callee.property.name) {
      case "call":
        args = t.arrayExpression(node.arguments.slice(1));
        break;

      case "apply":
        args = node.arguments[1] || t.identifier("undefined");
        break;

      default:
        return;
    }

    thisBinding = node.arguments[0];
    callee = callee.object;
  }

  // only tail recursion can be optimized as for now
  if (!t.isIdentifier(callee) || !this.scope.bindingIdentifierEquals(callee.name, this.ownerId)) {
    return;
  }

  this.hasTailRecursion = true;

  if (this.hasDeopt()) return;

  var body = [];

  if (!t.isThisExpression(thisBinding)) {
    body.push(t.expressionStatement(t.assignmentExpression(
      "=",
      this.getThisId(),
      thisBinding || t.identifier("undefined")
    )));
  }

  if (!args) {
    args = t.arrayExpression(node.arguments);
  }

  var argumentsId = this.getArgumentsId();
  var params = this.getParams();

  body.push(t.expressionStatement(t.assignmentExpression(
    "=",
    argumentsId,
    args
  )));

  var i, param;

  if (t.isArrayExpression(args)) {
    var elems = args.elements;
    for (i = 0; i < elems.length && i < params.length; i++) {
      param = params[i];
      var elem = elems[i] || (elems[i] = t.identifier("undefined"));
      if (!param._isDefaultPlaceholder) {
        elems[i] = t.assignmentExpression("=", param, elem);
      }
    }
  } else {
    this.setsArguments = true;
    for (i = 0; i < params.length; i++) {
      param = params[i];
      if (!param._isDefaultPlaceholder) {
        body.push(t.expressionStatement(t.assignmentExpression(
          "=",
          param,
          t.memberExpression(argumentsId, t.literal(i), true)
        )));
      }
    }
  }

  body.push(t.continueStatement(this.getFunctionId()));

  return body;
};

// looks for and replaces tail recursion calls
var firstPass = {
  enter: function (node, parent, scope, state) {
    if (t.isIfStatement(node)) {
      if (t.isReturnStatement(node.alternate)) {
        t.ensureBlock(node, "alternate");
      }

      if (t.isReturnStatement(node.consequent)) {
        t.ensureBlock(node, "consequent");
      }
    } else if (t.isReturnStatement(node)) {
      this.skip();
      return state.subTransform(node.argument);
    } else if (t.isTryStatement(parent)) {
      if (node === parent.block) {
        this.skip();
      } else if (parent.finalizer && node !== parent.finalizer) {
        this.skip();
      }
    } else if (t.isFunction(node)) {
      this.skip();
    } else if (t.isVariableDeclaration(node)) {
      this.skip();
      state.vars.push(node);
    }
  }
};

// hoists up function declarations, replaces `this` and `arguments` and marks
// them as needed
var secondPass = {
  enter: function (node, parent, scope, state) {
    if (t.isThisExpression(node)) {
      state.needsThis = true;
      return state.getThisId();
    } else if (t.isReferencedIdentifier(node, parent, { name: "arguments" })) {
      state.needsArguments = true;
      return state.getArgumentsId();
    } else if (t.isFunction(node)) {
      this.skip();
      if (t.isFunctionDeclaration(node)) {
        node = t.variableDeclaration("var", [
          t.variableDeclarator(node.id, t.toExpression(node))
        ]);
        node._blockHoist = 2;
        return node;
      }
    }
  }
};

// optimizes recursion by removing `this` and `arguments` if they aren't used
var thirdPass = {
  enter: function (node, parent, scope, state) {
    if (!t.isExpressionStatement(node)) return;

    var expr = node.expression;
    if (!t.isAssignmentExpression(expr)) return;

    if (!state.needsThis && expr.left === state.getThisId()) {
      this.remove();
    } else if (!state.needsArguments && expr.left === state.getArgumentsId() && t.isArrayExpression(expr.right)) {
      return map(expr.right.elements, function (elem) {
        return t.expressionStatement(elem);
      });
    }
  }
};

exports.Function = function (node, parent, scope, file) {
  var tailCall = new TailCallTransformer(node, scope, file);
  tailCall.run();
};

},{"../../../messages":30,"../../../types":122,"../../../util":124,"lodash/array/flatten":167,"lodash/collection/map":176,"lodash/collection/reduceRight":177}],78:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var buildBinaryExpression = function (left, right) {
  return t.binaryExpression("+", left, right);
};

exports.check = function (node) {
  return t.isTemplateLiteral(node) || t.isTaggedTemplateExpression(node);
};

exports.TaggedTemplateExpression = function (node, parent, scope, file) {
  var args = [];
  var quasi = node.quasi;

  var strings = [];
  var raw = [];

  for (var i = 0; i < quasi.quasis.length; i++) {
    var elem = quasi.quasis[i];
    strings.push(t.literal(elem.value.cooked));
    raw.push(t.literal(elem.value.raw));
  }

  strings = t.arrayExpression(strings);
  raw = t.arrayExpression(raw);

  var templateName = "tagged-template-literal";
  if (file.isLoose("es6.templateLiterals")) templateName += "-loose";
  args.push(t.callExpression(file.addHelper(templateName), [strings, raw]));

  args = args.concat(quasi.expressions);

  return t.callExpression(node.tag, args);
};

exports.TemplateLiteral = function (node) {
  var nodes = [];
  var i;

  for (i = 0; i < node.quasis.length; i++) {
    var elem = node.quasis[i];

    nodes.push(t.literal(elem.value.cooked));

    var expr = node.expressions.shift();
    if (expr) nodes.push(expr);
  }

  if (nodes.length > 1) {
    // remove redundant '' at the end of the expression
    var last = nodes[nodes.length - 1];
    if (t.isLiteral(last, { value: "" })) nodes.pop();

    var root = buildBinaryExpression(nodes.shift(), nodes.shift());

    for (i = 0; i < nodes.length; i++) {
      root = buildBinaryExpression(root, nodes[i]);
    }

    return root;
  } else {
    return nodes[0];
  }
};

},{"../../../types":122}],79:[function(require,module,exports){
"use strict";

var rewritePattern = require("regexpu/rewrite-pattern");
var pull           = require("lodash/array/pull");
var t              = require("../../../types");

exports.check = function (node) {
  return t.isLiteral(node) && node.regex && node.regex.flags.indexOf("u") >= 0;
};

exports.Literal = function (node) {
  var regex = node.regex;
  if (!regex) return;

  var flags = regex.flags.split("");
  if (regex.flags.indexOf("u") < 0) return;
  pull(flags, "u");

  regex.pattern = rewritePattern(regex.pattern, regex.flags);
  regex.flags   = flags.join("");
};

},{"../../../types":122,"lodash/array/pull":169,"regexpu/rewrite-pattern":285}],80:[function(require,module,exports){
"use strict";

// https://github.com/zenparsing/es-abstract-refs

var util = require("../../../util");
var t    = require("../../../types");

exports.experimental = true;

var container = function (parent, call, ret, file) {
  if (t.isExpressionStatement(parent) && !file.isConsequenceExpressionStatement(parent)) {
    // we don't need to worry about return values
    return call;
  } else {
    var exprs = [];
    if (t.isSequenceExpression(call)) {
      exprs = call.expressions;
    } else {
      exprs.push(call);
    }
    exprs.push(ret);
    return t.sequenceExpression(exprs);
  }
};

exports.AssignmentExpression = function (node, parent, scope, file) {
  var left = node.left;
  if (!t.isVirtualPropertyExpression(left)) return;

  var value = node.right;
  var temp;

  // we need to return `node.right`
  if (!t.isExpressionStatement(parent)) {
    temp = scope.generateTempBasedOnNode(node.right);
    if (temp) value = temp;
  }

  if (node.operator !== "=") {
    value = t.binaryExpression(
      node.operator[0],
      util.template("abstract-expression-get", {
        PROPERTY: node.property,
        OBJECT:   node.object
      }),
      value
    );
  }

  var call = util.template("abstract-expression-set", {
    PROPERTY: left.property,
    OBJECT:   left.object,
    VALUE:    value
  });

  if (temp) {
    call = t.sequenceExpression([
      t.assignmentExpression("=", temp, node.right),
      call
    ]);
  }

  return container(parent, call, value, file);
};

exports.UnaryExpression = function (node, parent, scope, file) {
  var arg = node.argument;
  if (!t.isVirtualPropertyExpression(arg)) return;
  if (node.operator !== "delete") return;

  var call = util.template("abstract-expression-delete", {
    PROPERTY: arg.property,
    OBJECT:   arg.object
  });

  return container(parent, call, t.literal(true), file);
};

exports.CallExpression = function (node, parent, scope) {
  var callee = node.callee;
  if (!t.isVirtualPropertyExpression(callee)) return;

  var temp = scope.generateTempBasedOnNode(callee.object);

  var call = util.template("abstract-expression-call", {
    PROPERTY: callee.property,
    OBJECT:   temp || callee.object
  });

  call.arguments = call.arguments.concat(node.arguments);

  if (temp) {
    return t.sequenceExpression([
      t.assignmentExpression("=", temp, callee.object),
      call
    ]);
  } else {
    return call;
  }
};

exports.VirtualPropertyExpression = function (node) {
  return util.template("abstract-expression-get", {
    PROPERTY: node.property,
    OBJECT:   node.object
  });
};

exports.PrivateDeclaration = function (node) {
  return t.variableDeclaration("const", node.declarations.map(function (id) {
    return t.variableDeclarator(id, t.newExpression(t.identifier("WeakMap"), []));
  }));
};

},{"../../../types":122,"../../../util":124}],81:[function(require,module,exports){
"use strict";

var buildComprehension = require("../../helpers/build-comprehension");
var traverse           = require("../../../traversal");
var util               = require("../../../util");
var t                  = require("../../../types");

exports.experimental = true;

exports.ComprehensionExpression = function (node, parent, scope, file) {
  var callback = array;
  if (node.generator) callback = generator;
  return callback(node, parent, scope, file);
};

var generator = function (node) {
  var body = [];
  var container = t.functionExpression(null, [], t.blockStatement(body), true);
  container._aliasFunction = true;

  body.push(buildComprehension(node, function () {
    return t.expressionStatement(t.yieldExpression(node.body));
  }));

  return t.callExpression(container, []);
};

var array = function (node, parent, scope, file) {
  var uid = scope.generateUidBasedOnNode(parent, file);

  var container = util.template("array-comprehension-container", {
    KEY: uid
  });
  container.callee._aliasFunction = true;

  var block = container.callee.body;
  var body  = block.body;

  if (traverse.hasType(node, scope, "YieldExpression", t.FUNCTION_TYPES)) {
    container.callee.generator = true;
    container = t.yieldExpression(container, true);
  }

  var returnStatement = body.pop();

  body.push(buildComprehension(node, function () {
    return util.template("array-push", {
      STATEMENT: node.body,
      KEY:       uid
    }, true);
  }));
  body.push(returnStatement);

  return container;
};

},{"../../../traversal":117,"../../../types":122,"../../../util":124,"../../helpers/build-comprehension":35}],82:[function(require,module,exports){
"use strict";

// https://github.com/rwaldron/exponentiation-operator

exports.experimental = true;

var build = require("../../helpers/build-binary-assignment-operator-transformer");
var t     = require("../../../types");

var MATH_POW = t.memberExpression(t.identifier("Math"), t.identifier("pow"));

build(exports, {
  operator: "**",

  build: function (left, right) {
    return t.callExpression(MATH_POW, [left, right]);
  }
});

},{"../../../types":122,"../../helpers/build-binary-assignment-operator-transformer":34}],83:[function(require,module,exports){
"use strict";

// https://github.com/sebmarkbage/ecmascript-rest-spread

var t = require("../../../types");

exports.experimental = true;

exports.manipulateOptions = function (opts) {
  if (opts.whitelist.length) opts.whitelist.push("es6.destructuring");
};

var hasSpread = function (node) {
  for (var i = 0; i < node.properties.length; i++) {
    if (t.isSpreadProperty(node.properties[i])) {
      return true;
    }
  }
  return false;
};

exports.ObjectExpression = function (node, parent, scope, file) {
  if (!hasSpread(node)) return;

  var args = [];
  var props = [];

  var push = function () {
    if (!props.length) return;
    args.push(t.objectExpression(props));
    props = [];
  };

  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];
    if (t.isSpreadProperty(prop)) {
      push();
      args.push(prop.argument);
    } else {
      props.push(prop);
    }
  }

  push();

  if (!t.isObjectExpression(args[0])) {
    args.unshift(t.objectExpression([]));
  }

  return t.callExpression(file.addHelper("extends"), args);
};

},{"../../../types":122}],84:[function(require,module,exports){
module.exports = {
  useStrict:                               require("./other/use-strict"),

  "validation.undeclaredVariableCheck":    require("./validation/undeclared-variable-check"),
  "validation.noForInOfAssignment":        require("./validation/no-for-in-of-assignment"),
  "validation.setters":                    require("./validation/setters"),
  "validation.react":                      require("./validation/react"),
  "spec.blockScopedFunctions":             require("./spec/block-scoped-functions"),

  "playground.malletOperator":             require("./playground/mallet-operator"),
  "playground.methodBinding":              require("./playground/method-binding"),
  "playground.memoizationOperator":        require("./playground/memoization-operator"),
  "playground.objectGetterMemoization":    require("./playground/object-getter-memoization"),

  reactCompat:                             require("./other/react-compat"),
  flow:                                    require("./other/flow"),
  react:                                   require("./other/react"),

  _modules:                                require("./internal/modules"),

  // needs to be before `regenerator` due to generator comprehensions
  // needs to be before `_aliasFunction`
  "es7.comprehensions":                    require("./es7/comprehensions"),

  // needs to be before `_aliasFunction`
  "es6.arrowFunctions":                    require("./es6/arrow-functions"),

  "es6.classes":                           require("./es6/classes"),

  asyncToGenerator:                        require("./other/async-to-generator"),
  bluebirdCoroutines:                      require("./other/bluebird-coroutines"),

  "es6.objectSuper":                       require("./es6/object-super"),
  "es7.objectRestSpread":                  require("./es7/object-rest-spread"),
  "es7.exponentiationOperator":            require("./es7/exponentiation-operator"),
  "es6.templateLiterals":                  require("./es6/template-literals"),

  "es5.properties.mutators":               require("./es5/properties.mutators"),
  "es6.properties.shorthand":              require("./es6/properties.shorthand"),

  // needs to be before `_aliasFunction` due to define property closure
  "es6.properties.computed":               require("./es6/properties.computed"),

  "es6.forOf":                             require("./es6/for-of"),

  "es6.unicodeRegex":                      require("./es6/unicode-regex"),
  "es7.abstractReferences":                require("./es7/abstract-references"),

  "es6.constants":                         require("./es6/constants"),

  // needs to be before `es6.parameters.default` as default parameters will destroy the rest param
  "es6.parameters.rest":                   require("./es6/parameters.rest"),

  // needs to be after `es6.parameters.rest` as we use `toArray` and avoid turning an already known array into one
  "es6.spread":                            require("./es6/spread"),

  // needs to be before `es6.blockScoping` as default parameters have a TDZ
  "es6.parameters.default":                require("./es6/parameters.default"),

  // needs to be before `es6.blockScoping` as let variables may be produced
  "es6.destructuring":                     require("./es6/destructuring"),

  // needs to be before `_aliasFunction` due to block scopes sometimes being wrapped in a
  // closure
  "es6.blockScoping":                      require("./es6/block-scoping"),

  // needs to be after `es6.blockScoping` due to needing `letReferences` set on blocks
  "es6.blockScopingTDZ":                   require("./es6/block-scoping-tdz"),

  // needs to be after `es6.parameters.*` and `es6.blockScoping` due to needing pure
  // identifiers in parameters and variable declarators
  "es6.tailCall":                          require("./es6/tail-call"),

  regenerator:                             require("./other/regenerator"),

  // needs to be after `regenerator` due to needing `regeneratorRuntime` references
  // needs to be after `es6.forOf` due to needing `Symbol.iterator` references
  // needs to be before `es6.modules` due to dynamic imports
  selfContained:                           require("./other/self-contained"),

  // needs to be before `_blockHoist` due to function hoisting etc
  "es6.modules":                           require("./es6/modules"),

  _blockHoist:                             require("./internal/block-hoist"),

  "spec.protoToAssign":                    require("./spec/proto-to-assign"),

  _declarations:                           require("./internal/declarations"),

  _aliasFunctions:                         require("./internal/alias-functions"),

  "spec.typeofSymbol":                     require("./spec/typeof-symbol"),
  "spec.undefinedToVoid":                  require("./spec/undefined-to-void"),
  "spec.functionName":                     require("./spec/function-name"),

  _moduleFormatter:                        require("./internal/module-formatter"),

  "es3.propertyLiterals":                  require("./es3/property-literals"),
  "es3.memberExpressionLiterals":          require("./es3/member-expression-literals"),

  "minification.removeDebugger":           require("./minification/remove-debugger"),
  "minification.removeConsoleCalls":       require("./minification/remove-console-calls"),
  "minification.deadCodeElimination":      require("./minification/dead-code-elimination"),
  "minification.renameLocalVariables":     require("./minification/rename-local-variables"),

  _cleanUp:                                require("./internal/cleanup")
};

},{"./es3/member-expression-literals":60,"./es3/property-literals":61,"./es5/properties.mutators":62,"./es6/arrow-functions":63,"./es6/block-scoping":65,"./es6/block-scoping-tdz":64,"./es6/classes":66,"./es6/constants":67,"./es6/destructuring":68,"./es6/for-of":69,"./es6/modules":70,"./es6/object-super":71,"./es6/parameters.default":72,"./es6/parameters.rest":73,"./es6/properties.computed":74,"./es6/properties.shorthand":75,"./es6/spread":76,"./es6/tail-call":77,"./es6/template-literals":78,"./es6/unicode-regex":79,"./es7/abstract-references":80,"./es7/comprehensions":81,"./es7/exponentiation-operator":82,"./es7/object-rest-spread":83,"./internal/alias-functions":85,"./internal/block-hoist":86,"./internal/cleanup":87,"./internal/declarations":88,"./internal/module-formatter":89,"./internal/modules":90,"./minification/dead-code-elimination":91,"./minification/remove-console-calls":92,"./minification/remove-debugger":93,"./minification/rename-local-variables":94,"./other/async-to-generator":95,"./other/bluebird-coroutines":96,"./other/flow":97,"./other/react":99,"./other/react-compat":98,"./other/regenerator":100,"./other/self-contained":101,"./other/use-strict":102,"./playground/mallet-operator":103,"./playground/memoization-operator":104,"./playground/method-binding":105,"./playground/object-getter-memoization":106,"./spec/block-scoped-functions":107,"./spec/function-name":108,"./spec/proto-to-assign":109,"./spec/typeof-symbol":110,"./spec/undefined-to-void":111,"./validation/no-for-in-of-assignment":112,"./validation/react":113,"./validation/setters":114,"./validation/undeclared-variable-check":115}],85:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var functionChildrenVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isFunction(node) && !node._aliasFunction) {
      return this.skip();
    }

    if (node._ignoreAliasFunctions) return this.skip();

    var getId;

    if (t.isIdentifier(node) && node.name === "arguments") {
      getId = state.getArgumentsId;
    } else if (t.isThisExpression(node)) {
      getId = state.getThisId;
    } else {
      return;
    }

    if (t.isReferenced(node, parent)) return getId();
  }
};

var functionVisitor = {
  enter: function (node, parent, scope, state) {
    if (!node._aliasFunction) {
      if (t.isFunction(node)) {
        // stop traversal of this node as it'll be hit again by this transformer
        return this.skip();
      } else {
        return;
      }
    }

    // traverse all child nodes of this function and find `arguments` and `this`
    scope.traverse(node, functionChildrenVisitor, state);

    return this.skip();
  }
};

var go = function (getBody, node, scope) {
  var argumentsId;
  var thisId;

  var state = {
    getArgumentsId: function () {
      return argumentsId = argumentsId || scope.generateUidIdentifier("arguments");
    },
    getThisId: function () {
      return thisId = thisId || scope.generateUidIdentifier("this");
    }
  };

  // traverse the function and find all alias functions so we can alias
  // `arguments` and `this` if necessary
  scope.traverse(node, functionVisitor, state);

  var body;

  var pushDeclaration = function (id, init) {
    body = body || getBody();
    body.unshift(t.variableDeclaration("var", [
      t.variableDeclarator(id, init)
    ]));
  };

  if (argumentsId) {
    pushDeclaration(argumentsId, t.identifier("arguments"));
  }

  if (thisId) {
    pushDeclaration(thisId, t.thisExpression());
  }
};

exports.Program = function (node, parent, scope) {
  go(function () {
    return node.body;
  }, node, scope);
};

exports.FunctionDeclaration =
exports.FunctionExpression = function (node, parent, scope) {
  go(function () {
    t.ensureBlock(node);
    return node.body.body;
  }, node, scope);
};

},{"../../../types":122}],86:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");
var groupBy   = require("lodash/collection/groupBy");
var flatten   = require("lodash/array/flatten");
var values    = require("lodash/object/values");

// Priority:
//
//  - 0 We want this to be at the **very** bottom
//  - 1 Default node position
//  - 2 Priority over normal nodes
//  - 3 We want this to be at the **very** top

exports.BlockStatement =
exports.Program = {
  exit: function (node) {
    var hasChange = false;
    for (var i = 0; i < node.body.length; i++) {
      var bodyNode = node.body[i];
      if (bodyNode && bodyNode._blockHoist != null) hasChange = true;
    }
    if (!hasChange) return;

    useStrict.wrap(node, function () {
      var nodePriorities = groupBy(node.body, function (bodyNode) {
        var priority = bodyNode._blockHoist;
        if (priority == null) priority = 1;
        if (priority === true) priority = 2;
        return priority;
      });

      node.body = flatten(values(nodePriorities).reverse());
    });
  }
};

},{"../../helpers/use-strict":44,"lodash/array/flatten":167,"lodash/collection/groupBy":174,"lodash/object/values":265}],87:[function(require,module,exports){
exports.SequenceExpression = function (node) {
  if (node.expressions.length === 1) {
    return node.expressions[0];
  }
};

},{}],88:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");
var t         = require("../../../types");

exports.secondPass = true;

exports.BlockStatement =
exports.Program = function (node, parent, scope, file) {
  if (!node._declarations) return;

  var kinds = {};
  var kind;

  useStrict.wrap(node, function () {
    for (var i in node._declarations) {
      var declar = node._declarations[i];

      kind = declar.kind || "var";
      var declarNode = t.variableDeclarator(declar.id, declar.init);

      if (declar.init) {
        node.body.unshift(file.attachAuxiliaryComment(t.variableDeclaration(kind, [declarNode])));
      } else {
        kinds[kind] = kinds[kind] || [];
        kinds[kind].push(declarNode);
      }
    }

    for (kind in kinds) {
      node.body.unshift(file.attachAuxiliaryComment(t.variableDeclaration(kind, kinds[kind])));
    }
  });

  node._declarations = null;
};

},{"../../../types":122,"../../helpers/use-strict":44}],89:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");

exports.Program = function (program, parent, scope, file) {
  if (!file.transformers["es6.modules"].canRun()) return;

  useStrict.wrap(program, function () {
    program.body = file.dynamicImports.concat(program.body);
  });

  if (file.moduleFormatter.transform) {
    file.moduleFormatter.transform(program);
  }
};

},{"../../helpers/use-strict":44}],90:[function(require,module,exports){
"use strict";

// in this transformer we have to split up classes and function declarations
// from their exports. why? because sometimes we need to replace classes with
// nodes that aren't allowed in the same contexts. also, if you're exporting
// a generator function as a default then regenerator will destroy the export
// declaration and leave a variable declaration in it's place... yeah, handy.

var t = require("../../../types");

var resolveModuleSource = function (node, parent, scope, file) {
  var resolveModuleSource = file.opts.resolveModuleSource;
  if (node.source && resolveModuleSource) {
    node.source.value = resolveModuleSource(node.source.value);
  }
};

exports.check = function (node) {
  return t.isImportDeclaration(node) || t.isExportDeclaration(node);
};

exports.ImportDeclaration = resolveModuleSource;

exports.ExportDeclaration = function (node, parent, scope) {
  resolveModuleSource.apply(null, arguments);

  var declar = node.declaration;

  if (node.default) {
    if (t.isClassDeclaration(declar)) {
      node.declaration = declar.id;
      return [declar, node];
    } else if (t.isClassExpression(declar)) {
      var temp = scope.generateUidIdentifier("default");
      declar = t.variableDeclaration("var", [
        t.variableDeclarator(temp, declar)
      ]);
      node.declaration = temp;
      return [declar, node];
    } else if (t.isFunctionDeclaration(declar)) {
      node._blockHoist = 2;
      node.declaration = declar.id;
      return [declar, node];
    }
  } else {
    if (t.isFunctionDeclaration(declar)) {
      node.specifiers  = [t.importSpecifier(declar.id, declar.id)];
      node.declaration = null;
      node._blockHoist = 2;
      return [declar, node];
    }
  }
};

},{"../../../types":122}],91:[function(require,module,exports){
var t = require("../../../types");

exports.optional = true;

exports.ExpressionStatement = function (node) {
  // remove consequence-less expressions such as local variables and literals
  // note: will remove directives
  //
  //   var foo = true; foo; -> var foo = true;
  //   "foo"; ->
  //

  var expr = node.expression;
  if (t.isLiteral(expr) || (t.isIdentifier(node) && t.hasBinding(node.name))) {
    this.remove();
  }
};

exports.IfStatement = {
  exit: function (node) {
    // todo: in scenarios where we can just return the consequent or
    // alternate we should drop the block statement if it contains no
    // block scoped variables

    var consequent = node.consequent;
    var alternate  = node.alternate;
    var test       = node.test;

    // we can check if a test will be truthy 100% and if so then we can inline
    // the consequent and completely ignore the alternate
    //
    //   if (true) { foo; } -> { foo; }
    //   if ("foo") { foo; } -> { foo; }
    //

    if (t.isLiteral(test) && test.value) {
      return consequent;
    }

    // we can check if a test will be falsy 100% and if so we can inline the
    // alternate if there is one and completely remove the consequent
    //
    //   if ("") { bar; } else { foo; } -> { foo; }
    //   if ("") { bar; } ->
    //

    if (t.isFalsyExpression(test)) {
      if (alternate) {
        return alternate;
      } else {
        return this.remove();
      }
    }

    // remove alternate blocks that are empty
    //
    //   if (foo) { foo; } else {} -> if (foo) { foo; }
    //

    if (t.isBlockStatement(alternate) && !alternate.body.length) {
      alternate = node.alternate = null;
    }

    // if the consequent block is empty turn alternate blocks into a consequent
    // and flip the test
    //
    //   if (foo) {} else { bar; } -> if (!foo) { bar; }
    //

    if (t.blockStatement(consequent) && !consequent.body.length && t.isBlockStatement(alternate) && alternate.body.length) {
      node.consequent = node.alternate;
      node.alternate  = null;
      node.test       = t.unaryExpression("!", test, true);
    }
  }
};

},{"../../../types":122}],92:[function(require,module,exports){
"use strict";

var t = require("../../../types");

var isConsole = t.buildMatchMemberExpression("console", true);

exports.optional = true;

exports.CallExpression = function (node, parent) {
  if (isConsole(node.callee)) {
    if (t.isExpressionStatement(parent)) {
      this.parentPath.remove();
    } else {
      this.remove();
    }
  }
};

},{"../../../types":122}],93:[function(require,module,exports){
var t = require("../../../types");

exports.optional = true;

exports.ExpressionStatement = function (node) {
  if (t.isIdentifier(node.expression, { name: "debugger" })) {
    this.remove();
  }
};

},{"../../../types":122}],94:[function(require,module,exports){
//var t = require("../../../types");

exports.optional = true;

exports.Scopable = function () {
  //for (var name in scope.bindings) {
  //  scope.rename(name, scope.generateUidIdentifier("a").name);
  //}
};

},{}],95:[function(require,module,exports){
"use strict";

var remapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
var bluebirdCoroutines    = require("./bluebird-coroutines");

exports.optional = true;

exports.manipulateOptions = bluebirdCoroutines.manipulateOptions;

exports.Function = function (node, parent, scope, file) {
  if (!node.async || node.generator) return;

  return remapAsyncToGenerator(node, file.addHelper("async-to-generator"), scope);
};

},{"../../helpers/remap-async-to-generator":42,"./bluebird-coroutines":96}],96:[function(require,module,exports){
"use strict";

var remapAsyncToGenerator = require("../../helpers/remap-async-to-generator");
var t                     = require("../../../types");

exports.manipulateOptions = function (opts) {
  opts.experimental = true;
  opts.blacklist.push("regenerator");
};

exports.optional = true;

exports.Function = function (node, parent, scope, file) {
  if (!node.async || node.generator) return;

  return remapAsyncToGenerator(
    node,
    t.memberExpression(file.addImport("bluebird", null, true), t.identifier("coroutine")),
    scope
  );
};

},{"../../../types":122,"../../helpers/remap-async-to-generator":42}],97:[function(require,module,exports){
var t = require("../../../types");

exports.TypeCastExpression = function (node) {
  return node.expression;
};

exports.ImportDeclaration = function (node) {
  if (node.isType) this.remove();
};

exports.ExportDeclaration = function (node) {
  if (t.isTypeAlias(node.declaration)) this.remove();
};

},{"../../../types":122}],98:[function(require,module,exports){
"use strict";

var react = require("../../helpers/react");
var t     = require("../../../types");

exports.manipulateOptions = function (opts) {
  opts.blacklist.push("react");
};

exports.optional = true;

require("../../helpers/build-react-transformer")(exports, {
  pre: function (state) {
    state.callee = state.tagExpr;
  },

  post: function (state) {
    if (react.isCompatTag(state.tagName)) {
      state.call = t.callExpression(
        t.memberExpression(
          t.memberExpression(t.identifier("React"), t.identifier("DOM")),
          state.tagExpr,
          t.isLiteral(state.tagExpr)
        ),
        state.args
      );
    }
  }
});

},{"../../../types":122,"../../helpers/build-react-transformer":37,"../../helpers/react":41}],99:[function(require,module,exports){
"use strict";

var react = require("../../helpers/react");
var t     = require("../../../types");

require("../../helpers/build-react-transformer")(exports, {
  pre: function (state) {
    var tagName = state.tagName;
    var args    = state.args;
    if (react.isCompatTag(tagName)) {
      args.push(t.literal(tagName));
    } else {
      args.push(state.tagExpr);
    }
  },

  post: function (state) {
    state.callee = t.memberExpression(t.identifier("React"), t.identifier("createElement"));
  }
});

},{"../../../types":122,"../../helpers/build-react-transformer":37,"../../helpers/react":41}],100:[function(require,module,exports){
"use strict";

var regenerator = require("regenerator-babel");
var t           = require("../../../types");

exports.check = function (node) {
  return t.isFunction(node) && (node.async || node.generator);
};

exports.Program = {
  enter: function (ast) {
    regenerator.transform(ast);
    this.stop();
  }
};

},{"../../../types":122,"regenerator-babel":277}],101:[function(require,module,exports){
"use strict";

var includes = require("lodash/collection/includes");
var util     = require("../../../util");
var core     = require("core-js/library");
var has      = require("lodash/object/has");
var t        = require("../../../types");

var isSymboliterator = t.buildMatchMemberExpression("Symbol.iterator");

var coreHas = function (node) {
  return node.name !== "_" && has(core, node.name);
};

var ALIASABLE_CONSTRUCTORS = [
  "Symbol",
  "Promise",
  "Map",
  "WeakMap",
  "Set",
  "WeakSet"
];

var astVisitor = {
  enter: function (node, parent, scope, file) {
    var prop;

    if (t.isMemberExpression(node) && t.isReferenced(node, parent)) {
      // Array.from -> _core.Array.from
      var obj = node.object;
      prop = node.property;

      if (!t.isReferenced(obj, node)) return;

      if (!node.computed && coreHas(obj) && has(core[obj.name], prop.name) && !scope.getBindingIdentifier(obj.name)) {
        this.skip();
        return t.prependToMemberExpression(node, file.get("coreIdentifier"));
      }
    } else if (t.isReferencedIdentifier(node, parent) && !t.isMemberExpression(parent) && includes(ALIASABLE_CONSTRUCTORS, node.name) && !scope.getBindingIdentifier(node.name)) {
      // Symbol() -> _core.Symbol(); new Promise -> new _core.Promise
      return t.memberExpression(file.get("coreIdentifier"), node);
    } else if (t.isCallExpression(node)) {
      // arr[Symbol.iterator]() -> _core.$for.getIterator(arr)

      var callee = node.callee;
      if (node.arguments.length) return false;

      if (!t.isMemberExpression(callee)) return false;
      if (!callee.computed) return false;

      prop = callee.property;
      if (!isSymboliterator(prop)) return false;

      return util.template("corejs-iterator", {
        CORE_ID: file.get("coreIdentifier"),
        VALUE:   callee.object
      });
    } else if (t.isBinaryExpression(node)) {
      // Symbol.iterator in arr -> core.$for.isIterable(arr)

      if (node.operator !== "in") return;

      var left = node.left;
      if (!isSymboliterator(left)) return;

      return util.template("corejs-is-iterator", {
        CORE_ID: file.get("coreIdentifier"),
        VALUE:   node.right
      });
    }
  }
};

exports.optional = true;

exports.manipulateOptions = function (opts) {
  if (opts.whitelist.length) opts.whitelist.push("es6.modules");
};

exports.Program = function (node, parent, scope, file) {
  scope.traverse(node, astVisitor, file);
};

exports.pre = function (file) {
  file.setDynamic("runtimeIdentifier", function () {
    return file.addImport("babel-runtime/helpers", "babelHelpers");
  });

  file.setDynamic("coreIdentifier", function () {
    return file.addImport("babel-runtime/core-js", "core");
  });

  file.setDynamic("regeneratorIdentifier", function () {
    return file.addImport("babel-runtime/regenerator", "regeneratorRuntime");
  });
};

exports.Identifier = function (node, parent, scope, file) {
  if (t.isReferencedIdentifier(node, parent, { name: "regeneratorRuntime" })) {
    return file.get("regeneratorIdentifier");
  }
};

},{"../../../types":122,"../../../util":124,"core-js/library":148,"lodash/collection/includes":175,"lodash/object/has":261}],102:[function(require,module,exports){
"use strict";

var useStrict = require("../../helpers/use-strict");
var messages  = require("../../../messages");
var t         = require("../../../types");

exports.Program = function (program) {
  if (!useStrict.has(program)) {
    program.body.unshift(t.expressionStatement(t.literal("use strict")));
  }
};

exports.FunctionDeclaration =
exports.FunctionExpression = function () {
  this.skip();
};

exports.ThisExpression = function () {
  return t.identifier("undefined");
};

exports.CallExpression = function (node, parent, scope, file) {
  if (t.isIdentifier(node.callee, { name: "eval" })) {
    throw file.errorWithNode(node, messages.get("evalInStrictMode"));
  }
};

},{"../../../messages":30,"../../../types":122,"../../helpers/use-strict":44}],103:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var build    = require("../../helpers/build-conditional-assignment-operator-transformer");
var t        = require("../../../types");

exports.playground = true;

build(exports, {
  is: function (node, file) {
    var is = t.isAssignmentExpression(node) && node.operator === "||=";
    if (is) {
      var left = node.left;
      if (!t.isMemberExpression(left) && !t.isIdentifier(left)) {
        throw file.errorWithNode(left, messages.get("expectedMemberExpressionOrIdentifier"));
      }
      return true;
    }
  },

  build: function (node) {
    return t.unaryExpression("!", node, true);
  }
});

},{"../../../messages":30,"../../../types":122,"../../helpers/build-conditional-assignment-operator-transformer":36}],104:[function(require,module,exports){
"use strict";

var build = require("../../helpers/build-conditional-assignment-operator-transformer");
var t     = require("../../../types");

exports.playground = true;

build(exports, {
  is: function (node) {
    var is = t.isAssignmentExpression(node) && node.operator === "?=";
    if (is) t.assertMemberExpression(node.left);
    return is;
  },

  build: function (node, file) {
    return t.unaryExpression(
      "!",
      t.callExpression(
        t.memberExpression(file.addHelper("has-own"), t.identifier("call")),
        [node.object, node.property]
      ),
      true
    );
  }
});

},{"../../../types":122,"../../helpers/build-conditional-assignment-operator-transformer":36}],105:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.playground = true;

exports.BindMemberExpression = function (node, parent, scope) {
  var object = node.object;
  var prop   = node.property;

  var temp = scope.generateTempBasedOnNode(node.object);
  if (temp) object = temp;

  var call = t.callExpression(
    t.memberExpression(t.memberExpression(object, prop), t.identifier("bind")),
    [object].concat(node.arguments)
  );

  if (temp) {
    return t.sequenceExpression([
      t.assignmentExpression("=", temp, node.object),
      call
    ]);
  } else {
    return call;
  }
};

exports.BindFunctionExpression = function (node, parent, scope) {
  var buildCall = function (args) {
    var param = scope.generateUidIdentifier("val");
    return t.functionExpression(null, [param], t.blockStatement([
      t.returnStatement(t.callExpression(t.memberExpression(param, node.callee), args))
    ]));
  };

  var temp = scope.generateTemp("args");

  return t.sequenceExpression([
    t.assignmentExpression("=", temp, t.arrayExpression(node.arguments)),
    buildCall(node.arguments.map(function (node, i) {
      return t.memberExpression(temp, t.literal(i), true);
    }))
  ]);
};

},{"../../../types":122}],106:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.playground = true;

var visitor = {
  enter: function (node, parent, scope, state) {
    if (t.isFunction(node)) return this.skip();

    if (t.isReturnStatement(node) && node.argument) {
      node.argument = t.memberExpression(t.callExpression(state.file.addHelper("define-property"), [
        t.thisExpression(),
        state.key,
        node.argument
      ]), state.key, true);
    }
  }
};

exports.Property =
exports.MethodDefinition = function (node, parent, scope, file) {
  if (node.kind !== "memo") return;
  node.kind = "get";

  var value = node.value;
  t.ensureBlock(value);

  var key = node.key;

  if (t.isIdentifier(key) && !node.computed) {
    key = t.literal(key.name);
  }

  var state = {
    key:  key,
    file: file
  };

  scope.traverse(value, visitor, state);

  return node;
};

},{"../../../types":122}],107:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.BlockStatement = function (node, parent, scope, file) {
  if ((t.isFunction(parent) && parent.body === node) || t.isExportDeclaration(parent)) {
    return;
  }

  for (var i = 0; i < node.body.length; i++) {
    var func = node.body[i];
    if (!t.isFunctionDeclaration(func)) continue;

    var declar = t.variableDeclaration("let", [
      t.variableDeclarator(func.id, t.toExpression(func))
    ]);

    // hoist it up above everything else
    declar._blockHoist = 2;

    // todo: name this
    func.id = null;

    node.body[i] = declar;

    file.checkNode(declar);
  }
};

},{"../../../types":122}],108:[function(require,module,exports){
"use strict";

var util = require("../../../util");
var t    = require("../../../types");

var propertyFunctionVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isReferencedIdentifier(node, parent, { name: state.name }) && scope.getBindingIdentifier(node.name) === state.binding) {
      return state.getOuter();
    }
  }
};

exports.FunctionExpression = function (node, parent, scope, file) {
  if (node.id) return;
  var id;
  if (t.isProperty(parent)) {
    id = parent.key;
  } else if (t.isVariableDeclarator(parent)) {
    id = parent.id;
  } else {
    return;
  }
  var binding = scope.getBindingIdentifier(id.name);
  var outerId, selfGlobalId;
  scope.traverse(node, propertyFunctionVisitor, {
    name: id.name,
    binding: binding,

    getOuter: function () {
      if (!binding) {
        return t.memberExpression(
          selfGlobalId || (selfGlobalId = file.addHelper("self-global")),
          id
        );
      }
      return t.callExpression(
        outerId || (outerId = scope.generateUidIdentifier("getOuter")),
        []
      );
    }
  });
  node.id = id;
  if (outerId) {
    return util.template("named-func", {
      GET_OUTER_ID: outerId,
      ID:           id,
      FUNCTION:     node
    });
  }
};

exports.optional = true;

},{"../../../types":122,"../../../util":124}],109:[function(require,module,exports){
"use strict";

var t    = require("../../../types");
var pull = require("lodash/array/pull");

var isProtoKey = function (node) {
  return t.isLiteral(t.toComputedKey(node, node.key), { value: "__proto__" });
};

var isProtoAssignmentExpression = function (node) {
  var left = node.left;
  return t.isMemberExpression(left) && t.isLiteral(t.toComputedKey(left, left.property), { value: "__proto__" });
};

var buildDefaultsCallExpression = function (expr, ref, file) {
  return t.expressionStatement(t.callExpression(file.addHelper("defaults"), [ref, expr.right]));
};

exports.optional = true;
exports.secondPass = true;

exports.AssignmentExpression = function (node, parent, scope, file) {
  if (!isProtoAssignmentExpression(node)) return;

  var nodes = [];
  var left  = node.left.object;
  var temp  = scope.generateTempBasedOnNode(node.left.object);

  nodes.push(t.expressionStatement(t.assignmentExpression("=", temp, left)));
  nodes.push(buildDefaultsCallExpression(node, temp, file));
  if (temp) nodes.push(temp);

  return t.toSequenceExpression(nodes);
};

exports.ExpressionStatement = function (node, parent, scope, file) {
  var expr = node.expression;
  if (!t.isAssignmentExpression(expr, { operator: "=" })) return;

  if (isProtoAssignmentExpression(expr)) {
    return buildDefaultsCallExpression(expr, expr.left.object, file);
  }
};

exports.ObjectExpression = function (node, parent, scope, file) {
  var proto;

  for (var i = 0; i < node.properties.length; i++) {
    var prop = node.properties[i];

    if (isProtoKey(prop)) {
      proto = prop.value;
      pull(node.properties, prop);
    }
  }

  if (proto) {
    var args = [t.objectExpression([]), proto];
    if (node.properties.length) args.push(node);
    return t.callExpression(file.addHelper("extends"), args);
  }
};

},{"../../../types":122,"lodash/array/pull":169}],110:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.UnaryExpression = function (node, parent, scope, file) {
  this.skip();

  if (node.operator === "typeof") {
    var call = t.callExpression(file.addHelper("typeof"), [node.argument]);
    if (t.isIdentifier(node.argument)) {
      var undefLiteral = t.literal("undefined");
      return t.conditionalExpression(
        t.binaryExpression("===", t.unaryExpression("typeof", node.argument), undefLiteral),
        undefLiteral,
        call
      );
    } else {
      return call;
    }
  }
};

},{"../../../types":122}],111:[function(require,module,exports){
"use strict";

var t = require("../../../types");

exports.optional = true;

exports.Identifier = function (node, parent) {
  if (node.name === "undefined" && t.isReferenced(node, parent)) {
    return t.unaryExpression("void", t.literal(0), true);
  }
};

},{"../../../types":122}],112:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");
var t        = require("../../../types");

exports.check = t.isFor;

exports.ForInStatement =
exports.ForOfStatement = function (node, parent, scope, file) {
  var left = node.left;
  if (t.isVariableDeclaration(left)) {
    var declar = left.declarations[0];
    if (declar.init) throw file.errorWithNode(declar, messages.get("noAssignmentsInForHead"));
  }
};

},{"../../../messages":30,"../../../types":122}],113:[function(require,module,exports){
var messages = require("../../../messages");
var t        = require("../../../types");

// check if the input Literal `source` is an alternate casing of "react"
var check = function (source, file) {
  if (t.isLiteral(source)) {
    var name  = source.value;
    var lower = name.toLowerCase();

    if (lower === "react" && name !== lower) {
      throw file.errorWithNode(source, messages.get("didYouMean", "react"));
    }
  }
};

exports.CallExpression = function (node, parent, scope, file) {
  if (t.isIdentifier(node.callee, { name: "require" }) && node.arguments.length === 1) {
    check(node.arguments[0], file);
  }
};

exports.ImportDeclaration =
exports.ExportDeclaration = function (node, parent, scope, file) {
  check(node.source, file);
};

},{"../../../messages":30,"../../../types":122}],114:[function(require,module,exports){
"use strict";

var messages = require("../../../messages");

exports.check = function (node) {
  return node.kind === "set";
};

exports.MethodDefinition =
exports.Property = function (node, parent, scope, file) {
  if (node.kind === "set" && node.value.params.length !== 1) {
    throw file.errorWithNode(node.value, messages.get("settersInvalidParamLength"));
  }
};

},{"../../../messages":30}],115:[function(require,module,exports){
"use strict";

var levenshtein = require("leven");
var messages    = require("../../../messages");
var t           = require("../../../types");

exports.optional = true;

exports.Identifier = function (node, parent, scope, file) {
  if (!t.isReferenced(node, parent)) return;
  if (scope.hasBinding(node.name)) return;

  // get the closest declaration to offer as a suggestion
  // the variable name may have just been mistyped

  var bindings = scope.getAllBindings();

  var closest;
  var shortest = -1;

  for (var name in bindings) {
    var distance = levenshtein(node.name, name);
    if (distance <= 0 || distance > 3) continue;
    if (distance <= shortest) continue;

    closest = name;
    shortest = distance;
  }

  var msg;
  if (closest) {
    msg = messages.get("undeclaredVariableSuggestion", node.name, closest);
  } else {
    msg = messages.get("undeclaredVariable", node.name);
  }

  //

  throw file.errorWithNode(node, msg, ReferenceError);
};

},{"../../../messages":30,"../../../types":122,"leven":165}],116:[function(require,module,exports){
"use strict";

module.exports = TraversalContext;

var TraversalPath = require("./path");
var flatten       = require("lodash/array/flatten");
var compact       = require("lodash/array/compact");

function TraversalContext(scope, opts, state, parentPath) {
  this.shouldFlatten = false;
  this.parentPath    = parentPath;

  this.scope = scope;
  this.state = state;
  this.opts  = opts;
}

TraversalContext.prototype.flatten = function () {
  this.shouldFlatten = true;
};

TraversalContext.prototype.visitNode = function (node, obj, key) {
  var iteration = new TraversalPath(this, node, obj, key);
  return iteration.visit();
};

TraversalContext.prototype.visit = function (node, key) {
  var nodes = node[key];
  if (!nodes) return;

  if (!Array.isArray(nodes)) {
    return this.visitNode(node, node, key);
  }

  // nothing to traverse!
  if (nodes.length === 0) {
    return;
  }

  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] && this.visitNode(node, nodes, i)) {
      return true;
    }
  }

  if (this.shouldFlatten) {
    node[key] = flatten(node[key]);

    if (key === "body") {
      // we can safely compact this
      node[key] = compact(node[key]);
    }
  }
};

},{"./path":118,"lodash/array/compact":166,"lodash/array/flatten":167}],117:[function(require,module,exports){
"use strict";

module.exports = traverse;

var TraversalContext = require("./context");
var includes         = require("lodash/collection/includes");
var t                = require("../types");

function traverse(parent, opts, scope, state) {
  if (!parent) return;

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("Must pass a scope unless traversing a Program/File got a " + parent.type + " node");
    }
  }

  if (!opts) opts = {};
  if (!opts.enter) opts.enter = function () { };
  if (!opts.exit) opts.exit = function () { };

  // array of nodes
  if (Array.isArray(parent)) {
    for (var i = 0; i < parent.length; i++) {
      traverse.node(parent[i], opts, scope, state);
    }
  } else {
    traverse.node(parent, opts, scope, state);
  }
}

traverse.node = function (node, opts, scope, state, parentPath) {
  var keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;

  var context = new TraversalContext(scope, opts, state, parentPath);
  for (var i = 0; i < keys.length; i++) {
    if (context.visit(node, keys[i])) {
      return;
    }
  }
};

function clearNode(node) {
  node._declarations = null;
  node.extendedRange = null;
  node._scopeInfo = null;
  node.tokens = null;
  node.range = null;
  node.start = null;
  node.end = null;
  node.loc = null;
  node.raw = null;

  if (Array.isArray(node.trailingComments)) {
    clearComments(node.trailingComments);
  }

  if (Array.isArray(node.leadingComments)) {
    clearComments(node.leadingComments);
  }
}

var clearVisitor = {
  noScope: true,
  enter: clearNode
};

function clearComments(comments) {
  for (var i = 0; i < comments.length; i++) {
    clearNode(comments[i]);
  }
}

traverse.removeProperties = function (tree) {
  clearNode(tree);
  traverse(tree, clearVisitor);

  return tree;
};

traverse.explode = function (obj) {
  for (var type in obj) {
    var fns = obj[type];

    var aliases = t.FLIPPED_ALIAS_KEYS[type];
    if (aliases) {
      for (var i = 0; i < aliases.length; i++) {
        obj[aliases[i]] = fns;
      }
    }
  }
  return obj;
};

function hasBlacklistedType(node, parent, scope, state) {
  if (node.type === state.type) {
    state.has = true;
    this.skip();
  }
}

traverse.hasType = function (tree, scope, type, blacklistTypes) {
  // the node we're searching in is blacklisted
  if (includes(blacklistTypes, tree.type)) return false;

  // the type we're looking for is the same as the passed node
  if (tree.type === type) return true;

  var state = {
    has:  false,
    type: type
  };

  traverse(tree, {
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, scope, state);

  return state.has;
};

},{"../types":122,"./context":116,"lodash/collection/includes":175}],118:[function(require,module,exports){
"use strict";

module.exports = TraversalPath;

/* jshint maxparams:7 */

var traverse = require("./index");
var includes = require("lodash/collection/includes");
var Scope    = require("./scope");
var t        = require("../types");

function TraversalPath(context, parent, obj, key) {
  this.shouldRemove = false;
  this.shouldSkip   = false;
  this.shouldStop   = false;

  this.parentPath = context.parentPath;
  this.context    = context;
  this.state      = this.context.state;
  this.opts       = this.context.opts;

  this.key     = key;
  this.obj     = obj;

  this.parent = parent;
  this.scope  = TraversalPath.getScope(this.getNode(), parent, context.scope);
  this.state  = context.state;
}

TraversalPath.prototype.remove = function () {
  this.shouldRemove = true;
  this.shouldSkip   = true;
};

TraversalPath.prototype.skip = function () {
  this.shouldSkip = true;
};

TraversalPath.prototype.stop = function () {
  this.shouldStop = true;
  this.shouldSkip = true;
};

TraversalPath.prototype.flatten = function () {
  this.context.flatten();
};

TraversalPath.getScope = function (node, parent, scope) {
  var ourScope = scope;

  // we're entering a new scope so let's construct it!
  if (t.isScope(node, parent)) {
    ourScope = new Scope(node, parent, scope);
  }

  return ourScope;
};

TraversalPath.prototype.maybeRemove = function () {
  if (this.shouldRemove) {
    this.setNode(null);
    this.flatten();
  }
};

TraversalPath.prototype.setNode = function (val) {
  return this.obj[this.key] = val;
};

TraversalPath.prototype.getNode = function () {
  return this.obj[this.key];
};

TraversalPath.prototype.replaceNode = function (replacement) {
  var isArray = Array.isArray(replacement);

  // inherit comments from original node to the first replacement node
  var inheritTo = replacement;
  if (isArray) inheritTo = replacement[0];
  if (inheritTo) t.inheritsComments(inheritTo, this.getNode());

  // replace the node
  this.setNode(replacement);

  var file = this.scope && this.scope.file;
  if (file) {
    if (isArray) {
      for (var i = 0; i < replacement.length; i++) {
        file.checkNode(replacement[i], this.scope);
      }
    } else {
      file.checkNode(replacement, this.scope);
    }
  }

  // we're replacing a statement or block node with an array of statements so we better
  // ensure that it's a block
  if (isArray) {
    if (includes(t.STATEMENT_OR_BLOCK_KEYS, this.key) && !t.isBlockStatement(this.obj)) {
      t.ensureBlock(this.obj, this.key);
    }

    this.flatten();
  }
};

TraversalPath.prototype.call = function (key) {
  var node = this.getNode();
  if (!node) return;

  var opts = this.opts;
  var fn   = opts[key] || opts;
  if (opts[node.type]) fn = opts[node.type][key] || fn;

  var replacement = fn.call(this, node, this.parent, this.scope, this.state);

  if (replacement) {
    this.replaceNode(replacement);
    node = replacement;
  }

  this.maybeRemove();

  return node;
};

TraversalPath.prototype.visit = function () {
  var opts = this.opts;
  var node = this.getNode();

  // type is blacklisted
  if (opts.blacklist && opts.blacklist.indexOf(node.type) > -1) {
    return;
  }

  this.call("enter");

  if (this.shouldSkip) {
    return this.shouldStop;
  }

  node = this.getNode();

  if (Array.isArray(node)) {
    // traverse over these replacement nodes we purposely don't call exitNode
    // as the original node has been destroyed
    for (var i = 0; i < node.length; i++) {
      traverse.node(node[i], opts, this.scope, this.state, this);
    }
  } else {
    traverse.node(node, opts, this.scope, this.state, this);
    this.call("exit");
  }

  return this.shouldStop;
};

},{"../types":122,"./index":117,"./scope":119,"lodash/collection/includes":175}],119:[function(require,module,exports){
"use strict";

module.exports = Scope;

var includes = require("lodash/collection/includes");
var traverse = require("./index");
var defaults = require("lodash/object/defaults");
var messages = require("../messages");
var globals  = require("globals");
var flatten  = require("lodash/array/flatten");
var extend   = require("lodash/object/extend");
var object   = require("../helpers/object");
var each     = require("lodash/collection/each");
var t        = require("../types");

/**
 * This searches the current "scope" and collects all references/bindings
 * within.
 *
 * @param {Node} block
 * @param {Node} parentBlock
 * @param {Scope} [parent]
 * @param {File} [file]
 */

function Scope(block, parentBlock, parent, file) {
  this.parent = parent;
  this.file   = parent ? parent.file : file;

  this.parentBlock = parentBlock;
  this.block       = block;

  this.crawl();
}

Scope.globals = flatten([globals.builtin, globals.browser, globals.node].map(Object.keys));

/**
 * Description
 *
 * @param {Object} node
 * @param {Object} opts
 * @param [state]
 */

Scope.prototype.traverse = function (node, opts, state) {
  traverse(node, opts, this, state);
};

/**
 * Description
 *
 * @param {String} [name="temp"]
 */

Scope.prototype.generateTemp = function (name) {
  var id = this.generateUidIdentifier(name || "temp");
  this.push({
    key: id.name,
    id: id
  });
  return id;
};

/**
 * Description
 *
 * @param {String} name
 */

Scope.prototype.generateUidIdentifier = function (name) {
  var id = t.identifier(this.generateUid(name));
  this.getFunctionParent().registerBinding("uid", id);
  return id;
};

/**
 * Description
 *
 * @param {String} name
 */

Scope.prototype.generateUid = function (name) {
  name = t.toIdentifier(name).replace(/^_+/, "");

  var uid;
  var i = 0;
  do {
    uid = this._generateUid(name, i);
    i++;
  } while (this.hasBinding(uid) || this.hasGlobal(uid));
  return uid;
};

Scope.prototype._generateUid = function (name, i) {
  var id = name;
  if (i > 1) id += i;
  return "_" + id;
};

/*
 * Description
 *
 * @param {Object} parent
 * @returns {Object}
 */

Scope.prototype.generateUidBasedOnNode = function (parent) {
  var node = parent;

  if (t.isAssignmentExpression(parent)) {
    node = parent.left;
  } else if (t.isVariableDeclarator(parent)) {
    node = parent.id;
  } else if (t.isProperty(node)) {
    node = node.key;
  }

  var parts = [];

  var add = function (node) {
    if (t.isMemberExpression(node)) {
      add(node.object);
      add(node.property);
    } else if (t.isIdentifier(node)) {
      parts.push(node.name);
    } else if (t.isLiteral(node)) {
      parts.push(node.value);
    } else if (t.isCallExpression(node)) {
      add(node.callee);
    }
  };

  add(node);

  var id = parts.join("$");
  id = id.replace(/^_/, "") || "ref";

  return this.generateUidIdentifier(id);
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Object}
 */

Scope.prototype.generateTempBasedOnNode = function (node) {
  if (t.isIdentifier(node) && this.hasBinding(node.name)) {
    return null;
  }

  var id = this.generateUidBasedOnNode(node);
  this.push({
    key: id.name,
    id: id
  });
  return id;
};

Scope.prototype.checkBlockScopedCollisions = function (kind, name, id) {
  var local = this.getOwnBindingInfo(name);
  if (!local) return;

  if (kind === "param") return;
  if (kind === "hoisted" && local.kind === "let") return;

  if (local.kind === "let" || local.kind === "const" || local.kind === "module") {
    throw this.file.errorWithNode(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
  }
};

Scope.prototype.rename = function (oldName, newName) {
  newName = newName || this.generateUidIdentifier(oldName).name;

  var info = this.getBindingInfo(oldName);
  if (!info) return;

  var binding = info.identifier;
  var scope = info.scope;

  scope.traverse(scope.block, {
    enter: function (node, parent, scope) {
      if (t.isReferencedIdentifier(node, parent) && node.name === oldName) {
        node.name = newName;
      } else if (t.isDeclaration(node)) {
        var ids = t.getBindingIdentifiers(node);
        for (var name in ids) {
          if (name === oldName) ids[name].name = newName;
        }
      } else if (t.isScope(node, parent)) {
        if (!scope.bindingIdentifierEquals(oldName, binding)) {
          this.skip();
        }
      }
    }
  });

  this.clearOwnBinding(oldName);
  scope.bindings[newName] = info;

  binding.name = newName;
};

Scope.prototype.inferType = function (node) {
  var target;

  if (t.isVariableDeclarator(node)) {
    target = node.init;
  }

  if (t.isArrayExpression(target)) {
    return t.genericTypeAnnotation(t.identifier("Array"));
  }

  if (t.isObjectExpression(target)) {
    return;
  }

  if (t.isLiteral(target)) {
    return;
  }

  if (t.isCallExpression(target) && t.isIdentifier(target.callee)) {
    var funcInfo = this.getBindingInfo(target.callee.name);
    if (funcInfo) {
      var funcNode = funcInfo.node;
      return !funcInfo.reassigned && t.isFunction(funcNode) && node.returnType;
    }
  }

  if (t.isIdentifier(target)) {
    return;
  }
};

Scope.prototype.isTypeGeneric = function (name, genericName) {
  var info = this.getBindingInfo(name);
  if (!info) return false;

  var type = info.typeAnnotation;
  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });
};

Scope.prototype.assignTypeGeneric = function (name, type) {
  this.assignType(name, t.genericTypeAnnotation(t.identifier(type)));
};

Scope.prototype.assignType = function (name, type) {
  var info = this.getBindingInfo(name);
  if (!info) return;

  info.identifier.typeAnnotation = info.typeAnnotation = type;
};

Scope.prototype.getTypeAnnotation = function (name, id, node) {
  var info = {
    annotation: null,
    inferred: false
  };

  var type;

  if (id.typeAnnotation) {
    type = id.typeAnnotation;
  }

  if (!type) {
    info.inferred = true;
    type = this.inferType(node);
  }

  if (type) {
    if (t.isTypeAnnotation(type)) type = type.typeAnnotation;
    info.annotation = type;
  }

  return info;
};

Scope.prototype.toArray = function (node, i) {
  var file = this.file;

  if (t.isIdentifier(node) && this.isTypeGeneric(node.name, "Array")) {
    return node;
  }

  if (t.isArrayExpression(node)) {
    return node;
  }

  if (t.isIdentifier(node, { name: "arguments" })) {
    return t.callExpression(t.memberExpression(file.addHelper("slice"), t.identifier("call")), [node]);
  }

  var helperName = "to-array";
  var args = [node];
  if (i === true) {
    helperName = "to-consumable-array";
  } else if (i) {
    args.push(t.literal(i));
    helperName = "sliced-to-array";
  }
  return t.callExpression(file.addHelper(helperName), args);
};

Scope.prototype.clearOwnBinding = function (name) {
  delete this.bindings[name];
};

Scope.prototype.registerDeclaration = function (node) {
  if (t.isFunctionDeclaration(node)) {
    this.registerBinding("hoisted", node);
  } else if (t.isVariableDeclaration(node)) {
    for (var i = 0; i < node.declarations.length; i++) {
      this.registerBinding(node.kind, node.declarations[i]);
    }
  } else if (t.isClassDeclaration(node)) {
    this.registerBinding("let", node);
  } else if (t.isImportDeclaration(node) || t.isExportDeclaration(node)) {
    this.registerBinding("module", node);
  } else {
    this.registerBinding("unknown", node);
  }
};

Scope.prototype.registerBindingReassignment = function (node) {
  var ids = t.getBindingIdentifiers(node);
  for (var name in ids) {
    var info = this.getBindingInfo(name);
    if (info) {
      info.reassigned = true;

      if (info.typeAnnotationInferred) {
        // destroy the inferred typeAnnotation
        info.typeAnnotation = null;
      }
    }
  }
};

Scope.prototype.registerBinding = function (kind, node) {
  if (!kind) throw new ReferenceError("no `kind`");

  var ids = t.getBindingIdentifiers(node);

  for (var name in ids) {
    var id = ids[name];

    this.checkBlockScopedCollisions(kind, name, id);

    var typeInfo = this.getTypeAnnotation(name, id, node);

    this.bindings[name] = {
      typeAnnotationInferred: typeInfo.inferred,
      typeAnnotation:         typeInfo.annotation,
      reassigned:             false,
      identifier:             id,
      scope:                  this,
      node:                   node,
      kind:                   kind
    };
  }
};

Scope.prototype.registerVariableDeclaration = function (declar) {
  var declars = declar.declarations;
  for (var i = 0; i < declars.length; i++) {
    this.registerBinding(declars[i], declar.kind);
  }
};

var functionVariableVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isFor(node)) {
      each(t.FOR_INIT_KEYS, function (key) {
        var declar = node[key];
        if (t.isVar(declar)) state.scope.registerBinding("var", declar);
      });
    }

    // this block is a function so we'll stop since none of the variables
    // declared within are accessible
    if (t.isFunction(node)) return this.skip();

    // function identifier doesn't belong to this scope
    if (state.blockId && node === state.blockId) return;

    // delegate block scope handling to the `blockVariableVisitor`
    if (t.isBlockScoped(node)) return;

    // this will be hit again once we traverse into it after this iteration
    if (t.isExportDeclaration(node) && t.isDeclaration(node.declaration)) return;

    // we've ran into a declaration!
    if (t.isDeclaration(node)) state.scope.registerDeclaration(node);
  }
};

Scope.prototype.addGlobal = function (node) {
  this.globals[node.name] = node;
};

Scope.prototype.hasGlobal = function (name) {
  var scope = this;

  do {
    if (scope.globals[name]) return true;
  } while (scope = scope.parent);

  return false;
};

var programReferenceVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isReferencedIdentifier(node, parent) && !scope.hasBinding(node.name)) {
      state.addGlobal(node);
    } else if (t.isLabeledStatement(node)) {
      state.addGlobal(node);
    } else if (t.isAssignmentExpression(node) || t.isUpdateExpression(node) || (t.isUnaryExpression(node) && node.operator === "delete")) {
      scope.registerBindingReassignment(node);
    }
  }
};

var blockVariableVisitor = {
  enter: function (node, parent, scope, state) {
    if (t.isFunctionDeclaration(node) || t.isBlockScoped(node)) {
      state.registerDeclaration(node);
    } else if (t.isScope(node, parent)) {
      this.skip();
    }
  }
};

Scope.prototype.crawl = function () {
  var block  = this.block;
  var i;

  //

  var info = block._scopeInfo;
  if (info) {
    extend(this, info);
    return;
  }

  info = block._scopeInfo = {
    bindings: object(),
    globals:  object()
  };

  extend(this, info);

  // ForStatement - left, init

  if (t.isLoop(block)) {
    for (i = 0; i < t.FOR_INIT_KEYS.length; i++) {
      var node = block[t.FOR_INIT_KEYS[i]];
      if (t.isBlockScoped(node)) this.registerBinding("let", node);
    }

    if (t.isBlockStatement(block.body)) {
      block = block.body;
    }
  }

  // FunctionExpression - id

  if (t.isFunctionExpression(block) && block.id) {
    if (!t.isProperty(this.parentBlock, { method: true })) {
      this.registerBinding("var", block.id);
    }
  }

  // Function - params, rest

  if (t.isFunction(block)) {
    for (i = 0; i < block.params.length; i++) {
      this.registerBinding("param", block.params[i]);
    }
    this.traverse(block.body, blockVariableVisitor, this);
  }

  // Program, BlockStatement, Function - let variables

  if (t.isBlockStatement(block) || t.isProgram(block)) {
    this.traverse(block, blockVariableVisitor, this);
  }

  // CatchClause - param

  if (t.isCatchClause(block)) {
    this.registerBinding("let", block.param);
  }

  // ComprehensionExpression - blocks

  if (t.isComprehensionExpression(block)) {
    this.registerBinding("let", block);
  }

  // Program, Function - var variables

  if (t.isProgram(block) || t.isFunction(block)) {
    this.traverse(block, functionVariableVisitor, {
      blockId: block.id,
      scope:   this
    });
  }

  // Program

  if (t.isProgram(block)) {
    this.traverse(block, programReferenceVisitor, this);
  }
};

/**
 * Description
 *
 * @param {Object} opts
 */

Scope.prototype.push = function (opts) {
  var block = this.block;

  if (t.isLoop(block) || t.isCatchClause(block) || t.isFunction(block)) {
    t.ensureBlock(block);
    block = block.body;
  }

  if (t.isBlockStatement(block) || t.isProgram(block)) {
    block._declarations = block._declarations || {};
    block._declarations[opts.key] = {
      kind: opts.kind,
      id: opts.id,
      init: opts.init
    };
  } else {
    throw new TypeError("cannot add a declaration here in node type " + block.type);
  }
};

/**
 * Walk up the scope tree until we hit either a Function or reach the
 * very top and hit Program.
 */

Scope.prototype.getFunctionParent = function () {
  var scope = this;
  while (scope.parent && !t.isFunction(scope.block)) {
    scope = scope.parent;
  }
  return scope;
};

/**
 * Walks the scope tree and gathers **all** bindings.
 *
 * @returns {Object}
 */

Scope.prototype.getAllBindings = function () {
  var ids = object();

  var scope = this;
  do {
    defaults(ids, scope.bindings);
    scope = scope.parent;
  } while (scope);

  return ids;
};

/**
 * Walks the scope tree and gathers all declarations of `kind`.
 *
 * @param {String} kind
 * @returns {Object}
 */

Scope.prototype.getAllBindingsOfKind = function (kind) {
  var ids = object();

  var scope = this;
  do {
    for (var name in scope.bindings) {
      var binding = scope.bindings[name];
      if (binding.kind === kind) ids[name] = binding;
    }
    scope = scope.parent;
  } while (scope);

  return ids;
};

// misc

Scope.prototype.bindingIdentifierEquals = function (name, node) {
  return this.getBindingIdentifier(name) === node;
};

// get

Scope.prototype.getBindingInfo = function (name) {
  var scope = this;

  do {
    var binding = scope.getOwnBindingInfo(name);
    if (binding) return binding;
  } while (scope = scope.parent);
};

Scope.prototype.getOwnBindingInfo = function (name) {
  return this.bindings[name];
};

Scope.prototype.getBindingIdentifier = function (name) {
  var info = this.getBindingInfo(name);
  return info && info.identifier;
};

Scope.prototype.getOwnBindingIdentifier = function (name) {
  var binding = this.bindings[name];
  return binding && binding.identifier;
};

// has

Scope.prototype.hasOwnBinding = function (name) {
  return !!this.getOwnBindingInfo(name);
};

Scope.prototype.hasBinding = function (name) {
  if (!name) return false;
  if (this.hasOwnBinding(name)) return true;
  if (this.parentHasBinding(name)) return true;
  if (includes(Scope.globals, name)) return true;
  return false;
};

Scope.prototype.parentHasBinding = function (name) {
  return this.parent && this.parent.hasBinding(name);
};

},{"../helpers/object":27,"../messages":30,"../types":122,"./index":117,"globals":160,"lodash/array/flatten":167,"lodash/collection/each":172,"lodash/collection/includes":175,"lodash/object/defaults":259,"lodash/object/extend":260}],120:[function(require,module,exports){
module.exports={
  "ExpressionStatement": ["Statement"],
  "BreakStatement":      ["Statement"],
  "ContinueStatement":   ["Statement"],
  "DebuggerStatement":   ["Statement"],
  "DoWhileStatement":    ["Statement", "Loop", "While", "Scopable"],
  "IfStatement":         ["Statement"],
  "ReturnStatement":     ["Statement"],
  "SwitchStatement":     ["Statement"],
  "ThrowStatement":      ["Statement"],
  "TryStatement":        ["Statement"],
  "WhileStatement":      ["Statement", "Loop", "While", "Scopable"],
  "WithStatement":       ["Statement"],
  "EmptyStatement":      ["Statement"],
  "LabeledStatement":    ["Statement"],
  "VariableDeclaration": ["Statement", "Declaration"],
  "ExportDeclaration":   ["Statement", "Declaration"],
  "ImportDeclaration":   ["Statement", "Declaration"],
  "PrivateDeclaration":  ["Statement", "Declaration"],

  "ArrowFunctionExpression": ["Scopable", "Function", "Expression"],
  "FunctionDeclaration":     ["Statement", "Declaration", "Scopable", "Function"],
  "FunctionExpression":      ["Scopable", "Function", "Expression"],

  "ImportSpecifier": ["ModuleSpecifier"],
  "ExportSpecifier": ["ModuleSpecifier"],

  "BlockStatement": ["Statement", "Scopable"],
  "Program":        ["Scopable"],
  "CatchClause":    ["Scopable"],

  "LogicalExpression": ["Binary", "Expression"],
  "BinaryExpression":  ["Binary", "Expression"],

  "UnaryExpression": ["UnaryLike", "Expression"],
  "SpreadProperty":  ["UnaryLike"],
  "SpreadElement":   ["UnaryLike"],

  "ClassDeclaration": ["Statement", "Declaration", "Class"],
  "ClassExpression":  ["Class", "Expression"],

  "ForOfStatement": ["Statement", "For", "Scopable", "Loop"],
  "ForInStatement": ["Statement", "For", "Scopable", "Loop"],
  "ForStatement":   ["Statement", "For", "Scopable", "Loop"],

  "ObjectPattern":     ["Pattern"],
  "ArrayPattern":      ["Pattern"],
  "AssignmentPattern": ["Pattern"],

  "Property":   ["UserWhitespacable"],
  "JSXElement": ["UserWhitespacable", "Expression"],

  "ArrayExpression":           ["Expression"],
  "AssignmentExpression":      ["Expression"],
  "AwaitExpression":           ["Expression"],
  "BindFunctionExpression":    ["Expression"],
  "BindMemberExpression":      ["Expression"],
  "CallExpression":            ["Expression"],
  "ComprehensionExpression":   ["Expression", "Scopable"],
  "ConditionalExpression":     ["Expression"],
  "Identifier":                ["Expression"],
  "Literal":                   ["Expression"],
  "MemberExpression":          ["Expression"],
  "NewExpression":             ["Expression"],
  "ObjectExpression":          ["Expression"],
  "SequenceExpression":        ["Expression"],
  "TaggedTemplateExpression":  ["Expression"],
  "ThisExpression":            ["Expression"],
  "UpdateExpression":          ["Expression"],
  "VirtualPropertyExpression": ["Expression"],
  "JSXEmptyExpression":        ["Expression"],
  "JSXMemberExpression":       ["Expression"],
  "YieldExpression":           ["Expression"],

  "JSXAttribute":           ["JSX"],
  "JSXClosingElement":      ["JSX"],
  "JSXElement":             ["JSX"],
  "JSXEmptyExpression":     ["JSX"],
  "JSXExpressionContainer": ["JSX"],
  "JSXIdentifier":          ["JSX"],
  "JSXMemberExpression":    ["JSX"],
  "JSXNamespacedName":      ["JSX"],
  "JSXOpeningElement":      ["JSX"],
  "JSXSpreadAttribute":     ["JSX"]
}

},{}],121:[function(require,module,exports){
module.exports={
  "ArrayExpression": {
    "elements": null
  },

  "ArrowFunctionExpression": {
    "params": null,
    "body": null
  },

  "AssignmentExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "BinaryExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "BlockStatement": {
    "body": null
  },

  "CallExpression": {
    "callee": null,
    "arguments": null
  },

  "ConditionalExpression": {
    "test": null,
    "consequent": null,
    "alternate": null
  },

  "ExpressionStatement": {
    "expression": null
  },

  "File": {
    "program": null,
    "comments": null,
    "tokens": null
  },

  "FunctionExpression": {
    "id": null,
    "params": null,
    "body": null,
    "generator": false
  },

  "FunctionDeclaration": {
    "id": null,
    "params": null,
    "body": null,
    "generator": false
  },

  "GenericTypeAnnotation": {
    "id": null,
    "typeParameters": null
  },

  "Identifier": {
    "name": null
  },

  "IfStatement": {
    "test": null,
    "consequent": null,
    "alternate": null
  },

  "ImportDeclaration": {
    "specifiers": null,
    "source": null
  },

  "ImportSpecifier": {
    "id": null,
    "name": null
  },

  "Literal": {
    "value": null
  },

  "LogicalExpression": {
    "operator": null,
    "left": null,
    "right": null
  },

  "MemberExpression": {
    "object": null,
    "property": null,
    "computed": false
  },

  "MethodDefinition": {
    "key": null,
    "value": null,
    "computed": false,
    "static": false,
    "kind": null
  },

  "NewExpression": {
    "callee": null,
    "arguments": null
  },

  "ObjectExpression": {
    "properties": null
  },

  "Program": {
    "body": null
  },

  "Property": {
    "kind": null,
    "key": null,
    "value": null,
    "computed": false
  },

  "ReturnStatement": {
    "argument": null
  },

  "SequenceExpression": {
    "expressions": null
  },

  "ThrowExpression": {
    "argument": null
  },

  "UnaryExpression": {
    "operator": null,
    "argument": null,
    "prefix": null
  },

  "VariableDeclaration": {
    "kind": null,
    "declarations": null
  },

  "VariableDeclarator": {
    "id": null,
    "init": null
  },

  "WithStatement": {
    "object": null,
    "body": null
  },

  "YieldExpression": {
    "argument": null,
    "delegate": null
  }
}

},{}],122:[function(require,module,exports){
"use strict";

var toFastProperties = require("../helpers/to-fast-properties");
var isString         = require("lodash/lang/isString");
var compact          = require("lodash/array/compact");
var esutils          = require("esutils");
var object           = require("../helpers/object");
var each             = require("lodash/collection/each");
var uniq             = require("lodash/array/uniq");

var t = exports;

/**
 * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.
 * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.
 *
 * @param {String} type
 * @param {Boolean?} skipAliasCheck
 */

function registerType(type, skipAliasCheck) {
  var is = t["is" + type] = function (node, opts) {
    return t.is(type, node, opts, skipAliasCheck);
  };

  t["assert" + type] = function (node, opts) {
    opts = opts || {};
    if (!is(node, opts)) {
      throw new Error("Expected type " + JSON.stringify(type) + " with option " + JSON.stringify(opts));
    }
  };
}

t.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body"];
t.NATIVE_TYPE_NAMES       = ["Array", "Object", "Number", "Boolean", "Date", "Array", "String"];
t.FOR_INIT_KEYS           = ["left", "init"];

t.VISITOR_KEYS = require("./visitor-keys");
t.ALIAS_KEYS   = require("./alias-keys");

t.FLIPPED_ALIAS_KEYS = {};

each(t.VISITOR_KEYS, function (keys, type) {
  registerType(type, true);
});

each(t.ALIAS_KEYS, function (aliases, type) {
  each(aliases, function (alias) {
    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];
    types.push(type);
  });
});

each(t.FLIPPED_ALIAS_KEYS, function (types, type) {
  t[type.toUpperCase() + "_TYPES"] = types;
  registerType(type, false);
});

/**
 * Returns whether `node` is of given `type`.
 *
 * For better performance, use this instead of `is[Type]` when `type` is unknown.
 * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.
 *
 * @param {String} type
 * @param {Node} node
 * @param {Object?} opts
 * @param {Boolean?} skipAliasCheck
 * @returns {Boolean} isOfType
 */

t.is = function (type, node, opts, skipAliasCheck) {
  if (!node) return false;

  var typeMatches = type === node.type;

  if (!typeMatches && !skipAliasCheck) {
    var aliases = t.FLIPPED_ALIAS_KEYS[type];

    if (typeof aliases !== "undefined") {
      typeMatches = aliases.indexOf(node.type) > -1;
    }
  }

  if (!typeMatches) {
    return false;
  }

  if (typeof opts !== "undefined") {
    return t.shallowEqual(node, opts);
  }

  return true;
};

//

t.BUILDER_KEYS = require("./builder-keys");

each(t.VISITOR_KEYS, function (keys, type) {
  if (t.BUILDER_KEYS[type]) return;

  var defs = {};
  each(keys, function (key) {
    defs[key] = null;
  });
  t.BUILDER_KEYS[type] = defs;
});

each(t.BUILDER_KEYS, function (keys, type) {
  t[type[0].toLowerCase() + type.slice(1)] = function () {
    var node = {};
    node.start = null;
    node.type = type;

    var i = 0;

    for (var key in keys) {
      var arg = arguments[i++];
      if (arg === undefined) arg = keys[key];
      node[key] = arg;
    }

    return node;
  };
});

/**
 * Description
 *
 * @param {Object} node
 * @returns {Object}
 */

t.toComputedKey = function (node, key) {
  if (!node.computed) {
    if (t.isIdentifier(key)) key = t.literal(key.name);
  }
  return key;
};

/*
 * Shallowly checks to see if the passed `node` is falsy.
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isFalsyExpression = function (node) {
  if (t.isLiteral(node)) {
    return !node.value;
  } else if (t.isIdentifier(node)) {
    return node.name === "undefined";
  }
  return false;
};

/**
 * Turn an array of statement `nodes` into a `SequenceExpression`.
 *
 * Variable declarations are turned into simple assignments and their
 * declarations hoisted to the top of the current scope.
 *
 * Expression statements are just resolved to their standard expression.
 *
 * @param {Array} nodes
 * @param {Scope} scope
 */

t.toSequenceExpression = function (nodes, scope) {
  var exprs = [];

  each(nodes, function (node) {
    if (t.isExpression(node)) {
      exprs.push(node);
    } if (t.isExpressionStatement(node)) {
      exprs.push(node.expression);
    } else if (t.isVariableDeclaration(node)) {
      each(node.declarations, function (declar) {
        scope.push({
          kind: node.kind,
          key: declar.id.name,
          id: declar.id
        });
        exprs.push(t.assignmentExpression("=", declar.id, declar.init));
      });
    }
  });

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return t.sequenceExpression(exprs);
  }
};

/*
 * Description
 *
 * @param {Object} actual
 * @param {Object} expected
 * @returns {Boolean}
 */

t.shallowEqual = function (actual, expected) {
  var keys = Object.keys(expected);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
};

/**
 * Description
 *
 * @param {Object} member
 * @param {Object} append
 * @param {Boolean} [computed]
 * @returns {Object} member
 */

t.appendToMemberExpression = function (member, append, computed) {
  member.object   = t.memberExpression(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
};

/**
 * Description
 *
 * @param {Object} member
 * @param {Object} append
 * @returns {Object} member
 */

t.prependToMemberExpression = function (member, append) {
  member.object = t.memberExpression(append, member.object);
  return member;
};

/**
 * Check if the input `node` is a reference to a bound variable.
 *
 * @param {Object} node
 * @param {Object} parent
 * @returns {Boolean}
 */

t.isReferenced = function (node, parent) {
  // yes: PARENT[NODE]
  // yes: NODE.child
  // no: parent.CHILD
  if (t.isMemberExpression(parent)) {
    if (parent.property === node && parent.computed) {
      return true;
    } else if (parent.object === node) {
      return true;
    } else {
      return false;
    }
  }

  // yes: { [NODE]: "" }
  // no: { NODE: "" }
  if (t.isProperty(parent) && parent.key === node) {
    return parent.computed;
  }

  // no: var NODE = init;
  // yes: var id = NODE;
  if (t.isVariableDeclarator(parent)) {
    return parent.id !== node;
  }

  // no: function NODE() {}
  // no: function foo(NODE) {}
  if (t.isFunction(parent)) {
    for (var i = 0; i < parent.params.length; i++) {
      var param = parent.params[i];
      if (param === node) return false;
    }

    return parent.id !== node;
  }

  // no: class NODE {}
  if (t.isClass(parent)) {
    return parent.id !== node;
  }

  // yes: class { [NODE](){} }
  if (t.isMethodDefinition(parent)) {
    return parent.key === node && parent.computed;
  }

  // no: NODE: for (;;) {}
  if (t.isLabeledStatement(parent)) {
    return false;
  }

  // no: try {} catch (NODE) {}
  if (t.isCatchClause(parent)) {
    return parent.param !== node;
  }

  // no: function foo(...NODE) {}
  if (t.isRestElement(parent)) {
    return false;
  }

  // no: [NODE = foo] = [];
  // yes: [foo = NODE] = [];
  if (t.isAssignmentPattern(parent)) {
    return parent.right === node;
  }

  // no: [NODE] = [];
  // no: ({ NODE }) = [];
  if (t.isPattern(parent)) {
    return false;
  }

  // no: import NODE from "bar";
  if (t.isImportSpecifier(parent)) {
    return false;
  }

  // no: import * as NODE from "foo";
  if (t.isImportBatchSpecifier(parent)) {
    return false;
  }

  // no: class Foo { private NODE; }
  if (t.isPrivateDeclaration(parent)) {
    return false;
  }

  return true;
};

/**
 * Check if the input `node` is an `Identifier` and `isReferenced`.
 *
 * @param {Node} node
 * @parma {Node} parent
 * @returns {Boolean}
 */

t.isReferencedIdentifier = function (node, parent, opts) {
  return t.isIdentifier(node, opts) && t.isReferenced(node, parent);
};

/**
 * Check if the input `name` is a valid identifier name
 * and isn't a reserved word.
 *
 * @param {String} name
 * @returns {Boolean}
 */

t.isValidIdentifier = function (name) {
  return isString(name) && esutils.keyword.isIdentifierName(name) && !esutils.keyword.isReservedWordES6(name, true);
};

/*
 * Description
 *
 * @param {String} name
 * @returns {String}
 */

t.toIdentifier = function (name) {
  if (t.isIdentifier(name)) return name.name;

  name = name + "";

  // replace all non-valid identifiers with dashes
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");

  // remove all dashes and numbers from start of name
  name = name.replace(/^[-0-9]+/, "");

  // camel case
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!t.isValidIdentifier(name)) {
    name = "_" + name;
  }

  return name || "_";
};

/**
 * Description
 *
 * @param {Object} node
 * @param {String=} key
 */

t.ensureBlock = function (node, key) {
  key = key || "body";
  return node[key] = t.toBlock(node[key], node);
};

/**
 * Build a function that when called will return whether or not the
 * input `node` `MemberExpression` matches the input `match`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 *
 * @param {String} match Dot-delimited string
 * @param {Boolean} [allowPartial] Allow a partial match
 * @returns {Function}
 */

t.buildMatchMemberExpression = function (match, allowPartial) {
  var parts = match.split(".");

  return function (member) {
    // not a member expression
    if (!t.isMemberExpression(member)) return false;

    var search = [member];
    var i = 0;

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (t.isIdentifier(node)) {
        // this part doesn't match
        if (parts[i] !== node.name) return false;
      } else if (t.isLiteral(node)) {
        // this part doesn't match
        if (parts[i] !== node.value) return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isLiteral(node.property)) {
          // we can't deal with this
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        // we can't deal with this
        return false;
      }

      // too many parts
      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  };
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Boolean} [ignore]
 * @returns {Object|Boolean}
 */

t.toStatement = function (node, ignore) {
  if (t.isStatement(node)) {
    return node;
  }

  var mustHaveId = false;
  var newType;

  if (t.isClass(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if (t.isFunction(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if (t.isAssignmentExpression(node)) {
    return t.expressionStatement(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error("cannot turn " + node.type + " to a statement");
    }
  }

  node.type = newType;

  return node;
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Object}
 */

exports.toExpression = function (node) {
  if (t.isExpressionStatement(node)) {
    node = node.expression;
  }

  if (t.isClass(node)) {
    node.type = "ClassExpression";
  } else if (t.isFunction(node)) {
    node.type = "FunctionExpression";
  }

  if (t.isExpression(node)) {
    return node;
  } else {
    throw new Error("cannot turn " + node.type + " to an expression");
  }
};

/**
 * Description
 *
 * @param {Object} node
 * @param {Object} parent
 * @returns {Object}
 */

t.toBlock = function (node, parent) {
  if (t.isBlockStatement(node)) {
    return node;
  }

  if (t.isEmptyStatement(node)) {
    node = [];
  }

  if (!Array.isArray(node)) {
    if (!t.isStatement(node)) {
      if (t.isFunction(parent)) {
        node = t.returnStatement(node);
      } else {
        node = t.expressionStatement(node);
      }
    }

    node = [node];
  }

  return t.blockStatement(node);
};

/**
 * Return a list of binding identifiers associated with
 * the input `node`.
 *
 * @param {Object} node
 * @returns {Array|Object}
 */

t.getBindingIdentifiers = function (node) {
  var search = [].concat(node);
  var ids    = object();

  while (search.length) {
    var id = search.shift();
    if (!id) continue;

    var keys = t.getBindingIdentifiers.keys[id.type];

    if (t.isIdentifier(id)) {
      ids[id.name] = id;
    } else if (t.isImportSpecifier(id)) {
      search.push(id.name || id.id);
    } else if (t.isExportDeclaration(id)) {
      if (t.isDeclaration(node.declaration)) {
        search.push(node.declaration);
      }
    } else if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        search = search.concat(id[key] || []);
      }
    }
  }

  return ids;
};

t.getBindingIdentifiers.keys = {
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportBatchSpecifier: ["name"],
  VariableDeclarator: ["id"],
  FunctionDeclaration: ["id"],
  ClassDeclaration: ["id"],
  SpreadElement: ["argument"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  SpreadProperty: ["argument"],
  Property: ["value"],
  ComprehensionBlock: ["left"],
  AssignmentPattern: ["left"],
  PrivateDeclaration: ["declarations"],
  ComprehensionExpression: ["blocks"],
  ImportDeclaration: ["specifiers"],
  VariableDeclaration: ["declarations"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"]
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isLet = function (node) {
  return t.isVariableDeclaration(node) && (node.kind !== "var" || node._let);
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isBlockScoped = function (node) {
  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Boolean}
 */

t.isVar = function (node) {
  return t.isVariableDeclaration(node, { kind: "var" }) && !node._let;
};

//

t.COMMENT_KEYS = ["leadingComments", "trailingComments"];

/**
 * Description
 *
 * @param {Object} child
 * @returns {Object} child
 */

t.removeComments = function (child) {
  each(t.COMMENT_KEYS, function (key) {
    delete child[key];
  });
  return child;
};

/**
 * Description
 *
 * @param {Object} child
 * @param {Object} parent
 * @returns {Object} child
 */

t.inheritsComments = function (child, parent) {
  each(t.COMMENT_KEYS, function (key) {
    child[key]  = uniq(compact([].concat(child[key], parent[key])));
  });
  return child;
};

/**
 * Description
 *
 * @param {Object} child
 * @param {Object} parent
 * @returns {Object} child
 */

t.inherits = function (child, parent) {
  child._declarations = parent._declarations;
  child._scopeInfo    = parent._scopeInfo;
  child.range         = parent.range;
  child.start         = parent.start;
  child.loc           = parent.loc;
  child.end           = parent.end;
  t.inheritsComments(child, parent);
  return child;
};

/**
 * Description
 *
 * @param {Object} node
 * @returns {Array}
 */

t.getLastStatements = function (node) {
  var nodes = [];

  var add = function (node) {
    nodes = nodes.concat(t.getLastStatements(node));
  };

  if (t.isIfStatement(node)) {
    add(node.consequent);
    add(node.alternate);
  } else if (t.isFor(node) || t.isWhile(node)) {
    add(node.body);
  } else if (t.isProgram(node) || t.isBlockStatement(node)) {
    add(node.body[node.body.length - 1]);
  } else if (node) {
    nodes.push(node);
  }

  return nodes;
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {String}
 */

t.getSpecifierName = function (specifier) {
  return specifier.name || specifier.id;
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {String}
 */

t.getSpecifierId = function (specifier) {
  if (specifier.default) {
    return t.identifier("default");
  } else {
    return specifier.id;
  }
};

/**
 * Description
 *
 * @param {Object} specifier
 * @returns {Boolean}
 */

t.isSpecifierDefault = function (specifier) {
  return specifier.default || t.isIdentifier(specifier.id) && specifier.id.name === "default";
};

/**
 * Description
 *
 * @param {Node} node
 * @param {Node} parent
 * @returns {Boolean}
 */

t.isScope = function (node, parent) {
  if (t.isBlockStatement(node)) {
    if (t.isLoop(parent.block, { body: node })) {
      return false;
    }

    if (t.isFunction(parent.block, { body: node })) {
      return false;
    }
  }

  return t.isScopable(node);
};

toFastProperties(t);
toFastProperties(t.VISITOR_KEYS);

},{"../helpers/object":27,"../helpers/to-fast-properties":29,"./alias-keys":120,"./builder-keys":121,"./visitor-keys":123,"esutils":158,"lodash/array/compact":166,"lodash/array/uniq":170,"lodash/collection/each":172,"lodash/lang/isString":255}],123:[function(require,module,exports){
module.exports={
  "ArrayExpression":           ["elements"],
  "ArrayPattern":              ["elements"],
  "ArrowFunctionExpression":   ["params", "defaults", "rest", "body"],
  "AssignmentExpression":      ["left", "right"],
  "AssignmentPattern":         ["left", "right"],
  "AwaitExpression":           ["argument"],
  "BinaryExpression":          ["left", "right"],
  "BindFunctionExpression":    ["callee", "arguments"],
  "BindMemberExpression":      ["object", "property", "arguments"],
  "BlockStatement":            ["body"],
  "BreakStatement":            ["label"],
  "CallExpression":            ["callee", "arguments"],
  "CatchClause":               ["param", "body"],
  "ClassBody":                 ["body"],
  "ClassDeclaration":          ["id", "body", "superClass"],
  "ClassExpression":           ["id", "body", "superClass"],
  "ComprehensionBlock":        ["left", "right", "body"],
  "ComprehensionExpression":   ["filter", "blocks", "body"],
  "ConditionalExpression":     ["test", "consequent", "alternate"],
  "ContinueStatement":         ["label"],
  "DebuggerStatement":         [],
  "DoWhileStatement":          ["body", "test"],
  "EmptyStatement":            [],
  "ExportBatchSpecifier":      [],
  "ExportDeclaration":         ["declaration", "specifiers", "source"],
  "ExportSpecifier":           ["id", "name"],
  "ExpressionStatement":       ["expression"],
  "File":                      ["program"],
  "ForInStatement":            ["left", "right", "body"],
  "ForOfStatement":            ["left", "right", "body"],
  "ForStatement":              ["init", "test", "update", "body"],
  "FunctionDeclaration":       ["id", "params", "defaults", "rest", "body"],
  "FunctionExpression":        ["id", "params", "defaults", "rest", "body"],
  "Identifier":                [],
  "IfStatement":               ["test", "consequent", "alternate"],
  "ImportBatchSpecifier":      ["id"],
  "ImportDeclaration":         ["specifiers", "source"],
  "ImportSpecifier":           ["id", "name"],
  "LabeledStatement":          ["label", "body"],
  "Literal":                   [],
  "LogicalExpression":         ["left", "right"],
  "MemberExpression":          ["object", "property"],
  "MethodDefinition":          ["key", "value"],
  "NewExpression":             ["callee", "arguments"],
  "ObjectExpression":          ["properties"],
  "ObjectPattern":             ["properties"],
  "PrivateDeclaration":        ["declarations"],
  "Program":                   ["body"],
  "Property":                  ["key", "value"],
  "RestElement":               ["argument"],
  "ReturnStatement":           ["argument"],
  "SequenceExpression":        ["expressions"],
  "SpreadElement":             ["argument"],
  "SpreadProperty":            ["argument"],
  "SwitchCase":                ["test", "consequent"],
  "SwitchStatement":           ["discriminant", "cases"],
  "TaggedTemplateExpression":  ["tag", "quasi"],
  "TemplateElement":           [],
  "TemplateLiteral":           ["quasis", "expressions"],
  "ThisExpression":            [],
  "ThrowStatement":            ["argument"],
  "TryStatement":              ["block", "handlers", "handler", "guardedHandlers", "finalizer"],
  "UnaryExpression":           ["argument"],
  "UpdateExpression":          ["argument"],
  "VariableDeclaration":       ["declarations"],
  "VariableDeclarator":        ["id", "init"],
  "VirtualPropertyExpression": ["object", "property"],
  "WhileStatement":            ["test", "body"],
  "WithStatement":             ["object", "body"],
  "YieldExpression":           ["argument"],

  "AnyTypeAnnotation":           [],
  "ArrayTypeAnnotation":         [],
  "BooleanTypeAnnotation":       [],
  "ClassProperty":               ["key", "value"],
  "DeclareClass":                [],
  "DeclareFunction":             [],
  "DeclareModule":               [],
  "DeclareVariable":             [],
  "FunctionTypeAnnotation":      [],
  "FunctionTypeParam":           [],
  "GenericTypeAnnotation":       [],
  "InterfaceExtends":            [],
  "InterfaceDeclaration":        [],
  "IntersectionTypeAnnotation":  [],
  "NullableTypeAnnotation":      [],
  "NumberTypeAnnotation":        [],
  "StringLiteralTypeAnnotation": [],
  "StringTypeAnnotation":        [],
  "TupleTypeAnnotation":         [],
  "TypeofTypeAnnotation":        [],
  "TypeAlias":                   [],
  "TypeAnnotation":              [],
  "TypeCastExpression":          ["expression"],
  "TypeParameterDeclaration":    [],
  "TypeParameterInstantiation":  [],
  "ObjectTypeAnnotation":        [],
  "ObjectTypeCallProperty":      [],
  "ObjectTypeIndexer":           [],
  "ObjectTypeProperty":          [],
  "QualifiedTypeIdentifier":     [],
  "UnionTypeAnnotation":         [],
  "VoidTypeAnnotation":          [],

  "JSXAttribute":              ["name", "value"],
  "JSXClosingElement":         ["name"],
  "JSXElement":                ["openingElement", "closingElement", "children"],
  "JSXEmptyExpression":        [],
  "JSXExpressionContainer":    ["expression"],
  "JSXIdentifier":             [],
  "JSXMemberExpression":       ["object", "property"],
  "JSXNamespacedName":         ["namespace", "name"],
  "JSXOpeningElement":         ["name", "attributes"],
  "JSXSpreadAttribute":        ["argument"]
}

},{}],124:[function(require,module,exports){
(function (__dirname){
"use strict";

require("./patch");

var cloneDeep  = require("lodash/lang/cloneDeep");
var contains   = require("lodash/collection/contains");
var traverse   = require("./traversal");
var isString   = require("lodash/lang/isString");
var isRegExp   = require("lodash/lang/isRegExp");
var isEmpty    = require("lodash/lang/isEmpty");
var parse      = require("./helpers/parse");
var debug      = require("debug/node");
var path       = require("path");
var util       = require("util");
var each       = require("lodash/collection/each");
var has        = require("lodash/object/has");
var fs         = require("fs");
var t          = require("./types");

exports.inherits = util.inherits;

exports.debug = debug("babel");

exports.canCompile = function (filename, altExts) {
  var exts = altExts || exports.canCompile.EXTENSIONS;
  var ext = path.extname(filename);
  return contains(exts, ext);
};

exports.canCompile.EXTENSIONS = [".js", ".jsx", ".es6", ".es"];

exports.resolve = function (loc) {
  try {
    return require.resolve(loc);
  } catch (err) {
    return null;
  }
};

exports.list = function (val) {
  return val ? val.split(",") : [];
};

exports.regexify = function (val) {
  if (!val) return new RegExp(/.^/);
  if (Array.isArray(val)) val = val.join("|");
  if (isString(val)) return new RegExp(val);
  if (isRegExp(val)) return val;
  throw new TypeError("illegal type for regexify");
};

exports.arrayify = function (val) {
  if (!val) return [];
  if (isString(val)) return exports.list(val);
  if (Array.isArray(val)) return val;
  throw new TypeError("illegal type for arrayify");
};

var templateVisitor = {
  enter: function (node, parent, scope, nodes) {
    if (t.isExpressionStatement(node)) {
      node = node.expression;
    }
    if (t.isIdentifier(node) && has(nodes, node.name)) {
      this.skip();
      return nodes[node.name];
    }
  }
};

exports.template = function (name, nodes, keepExpression) {
  var template = exports.templates[name];
  if (!template) throw new ReferenceError("unknown template " + name);

  if (nodes === true) {
    keepExpression = true;
    nodes = null;
  }

  template = cloneDeep(template);

  if (!isEmpty(nodes)) {
    traverse(template, templateVisitor, null, nodes);
  }

  if (template.body.length > 1) return template.body;

  var node = template.body[0];

  if (!keepExpression && t.isExpressionStatement(node)) {
    return node.expression;
  } else {
    return node;
  }
};

exports.parseTemplate = function (loc, code) {
  var ast = parse({ filename: loc }, code).program;
  return traverse.removeProperties(ast);
};

var loadTemplates = function () {
  var templates = {};

  var templatesLoc = __dirname + "/transformation/templates";
  if (!fs.existsSync(templatesLoc)) {
    throw new Error("no templates directory - this is most likely the " +
                    "result of a broken `npm publish`. Please report to " +
                    "https://github.com/babel/babel/issues");
  }

  each(fs.readdirSync(templatesLoc), function (name) {
    if (name[0] === ".") return;

    var key  = path.basename(name, path.extname(name));
    var loc  = templatesLoc + "/" + name;
    var code = fs.readFileSync(loc, "utf8");

    templates[key] = exports.parseTemplate(loc, code);
  });

  return templates;
};

try {
  exports.templates = require("../../templates.json");
} catch (err) {
  if (err.code !== "MODULE_NOT_FOUND") throw err;

  exports.templates = loadTemplates();
}

}).call(this,"/node_modules/babel/lib/babel")

},{"../../templates.json":304,"./helpers/parse":28,"./patch":31,"./traversal":117,"./types":122,"debug/node":151,"fs":305,"lodash/collection/contains":171,"lodash/collection/each":172,"lodash/lang/cloneDeep":244,"lodash/lang/isEmpty":248,"lodash/lang/isRegExp":254,"lodash/lang/isString":255,"lodash/object/has":261,"path":314,"util":331}],125:[function(require,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke and various contributors and
// released under an MIT license. The Unicode regexps (for identifiers
// and whitespace) were taken from [Esprima](http://esprima.org) by
// Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/marijnh/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
  mod(root.acorn || (root.acorn = {})); // Plain browser env
})(this, function(exports) {
  "use strict";

  exports.version = "0.11.1";

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api], with the caveat that inline XML is not recognized.
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    var startPos = options.locations ? [tokPos, curPosition()] : tokPos;
    initParserState();
    if (options.strictMode) {
      strict = true;
    }
    return parseTopLevel(options.program || startNodeAt(startPos));
  };

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = exports.defaultOptions = {
    strictMode: false,
    playground: false,
    // `ecmaVersion` indicates the ECMAScript version to parse. Must
    // be either 3, or 5, or 6. This influences support for strict
    // mode, the set of reserved words, support for getters and
    // setters and other features.
    ecmaVersion: 5,
    // Turn on `strictSemicolons` to prevent the parser from doing
    // automatic semicolon insertion.
    strictSemicolons: false,
    // When `allowTrailingCommas` is false, the parser will not allow
    // trailing commas in array and object literals.
    allowTrailingCommas: true,
    // By default, reserved words are not enforced. Enable
    // `forbidReserved` to enforce them. When this option has the
    // value "everywhere", reserved words and keywords can also not be
    // used as property names.
    forbidReserved: false,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokenize() returns. Note that you are not
    // allowed to call the parser from the callback—that will
    // corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  exports.parseExpressionAt = function(inpt, pos, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState(pos);
    initParserState();
    return parseExpression();
  };

  var isArray = function (obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  function setOptions(opts) {
    options = {};
    for (var opt in defaultOptions)
      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    sourceFile = options.sourceFile || null;
    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) {
        tokens.push(token);
      };
    }
    if (isArray(options.onComment)) {
      var comments = options.onComment;
      options.onComment = function (block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? 'Block' : 'Line',
          value: text,
          start: start,
          end: end
        };
        if (options.locations) {
          comment.loc = new SourceLocation();
          comment.loc.start = startLoc;
          comment.loc.end = endLoc;
        }
        if (options.ranges)
          comment.range = [start, end];
        comments.push(comment);
      };
    }
    if (options.ecmaVersion >= 6) {
      isKeyword = isEcma6Keyword;
    } else {
      isKeyword = isEcma5AndLessKeyword;
    }
  }

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  var getLineInfo = exports.getLineInfo = function(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreak.lastIndex = cur;
      var match = lineBreak.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else break;
    }
    return {line: line, column: offset - cur};
  };

  function Token() {
    this.type = tokType;
    this.value = tokVal;
    this.start = tokStart;
    this.end = tokEnd;
    if (options.locations) {
      this.loc = new SourceLocation();
      this.loc.end = tokEndLoc;
    }
    if (options.ranges)
      this.range = [tokStart, tokEnd];
  }

  exports.Token = Token;

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenize` export provides an interface to the tokenizer.
  // Because the tokenizer is optimized for being efficiently used by
  // the Acorn parser itself, this interface is somewhat crude and not
  // very modular. Performing another parse or call to `tokenize` will
  // reset the internal state, and invalidate existing tokenizers.

  exports.tokenize = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    skipSpace();

    function getToken() {
      lastEnd = tokEnd;
      readToken();
      return new Token();
    }
    getToken.jumpTo = function(pos, exprAllowed) {
      tokPos = pos;
      if (options.locations) {
        tokCurLine = 1;
        tokLineStart = lineBreak.lastIndex = 0;
        var match;
        while ((match = lineBreak.exec(input)) && match.index < pos) {
          ++tokCurLine;
          tokLineStart = match.index + match[0].length;
        }
      }
      tokExprAllowed = !!exprAllowed;
      skipSpace();
    };
    getToken.current = function() { return new Token(); };
    if (typeof Symbol !== 'undefined') {
      getToken[Symbol.iterator] = function () {
        return {
          next: function () {
            var token = getToken();
            return {
              done: token.type === _eof,
              value: token
            };
          }
        };
      };
    }
    getToken.options = options;
    return getToken;
  };

  // State is kept in (closure-)global variables. We already saw the
  // `options`, `input`, and `inputLen` variables above.

  // The current position of the tokenizer in the input.

  var tokPos;

  // The start and end offsets of the current token.

  var tokStart, tokEnd;

  // When `options.locations` is true, these hold objects
  // containing the tokens start and end line/column pairs.

  var tokStartLoc, tokEndLoc;

  // The type and value of the current token. Token types are objects,
  // named by variables against which they can be compared, and
  // holding properties that describe them (indicating, for example,
  // the precedence of an infix operator, and the original name of a
  // keyword token). The kind of value that's held in `tokVal` depends
  // on the type of the token. For literals, it is the literal value,
  // for operators, the operator name, and so on.

  var tokType, tokVal;

  // Internal state for the tokenizer. To distinguish between division
  // operators and regular expressions, it remembers whether the last
  // token was one that is allowed to be followed by an expression. In
  // some cases, notably after ')' or '}' tokens, the situation
  // depends on the context before the matching opening bracket, so
  // tokContext keeps a stack of information about current bracketed
  // forms.

  var tokContext, tokExprAllowed;

  // When `options.locations` is true, these are used to keep
  // track of the current line, and know when a new line has been
  // entered.

  var tokCurLine, tokLineStart;

  // These store the position of the previous token, which is useful
  // when finishing a node and assigning its `end` position.

  var lastStart, lastEnd, lastEndLoc;

  // This is the parser's state. `inFunction` is used to reject
  // `return` statements outside of functions, `inGenerator` to
  // reject `yield`s outside of generators, `labels` to verify
  // that `break` and `continue` have somewhere to jump to, and
  // `strict` indicates whether strict mode is on.

  var inFunction, inGenerator, inAsync, labels, strict,
    inXJSChild, inXJSTag, inType;

  function initParserState() {
    lastStart = lastEnd = tokPos;
    if (options.locations) lastEndLoc = curPosition();
    inFunction = inGenerator = inAsync = false;
    labels = [];
    skipSpace();
    readToken();
  }

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  function raise(pos, message) {
    var loc = getLineInfo(input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
    throw err;
  }

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // These are the general types. The `type` property is only used to
  // make them recognizeable when debugging.

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};
  var _jsxName = {type: "jsxName"};

  // These are JSX-specific token types

  var _xjsName = {type: "xjsName"}, _xjsText = {type: "xjsText"};

  // Keyword tokens. The `keyword` property (also used in keyword-like
  // operators) indicates that the token originated from an
  // identifier-like word, which is used when parsing property names.
  //
  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _let = {keyword: "let"}, _const = {keyword: "const"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};
  var _class = {keyword: "class"}, _extends = {keyword: "extends", beforeExpr: true};
  var _export = {keyword: "export"}, _import = {keyword: "import"};
  var _yield = {keyword: "yield", beforeExpr: true};

  // The keywords that denote values.

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  // Some keywords are treated as regular operators. `in` sometimes
  // (when parsing `for`) needs to be tested against specifically, so
  // we assign a variable name to it for quick comparing.

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  // Map keyword names to token types.

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                      "continue": _continue, "debugger": _debugger, "default": _default,
                      "do": _do, "else": _else, "finally": _finally, "for": _for,
                      "function": _function, "if": _if, "return": _return, "switch": _switch,
                      "throw": _throw, "try": _try, "var": _var, "let": _let, "const": _const,
                      "while": _while, "with": _with,
                      "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                      "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                      "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                      "void": {keyword: "void", prefix: true, beforeExpr: true},
                      "delete": {keyword: "delete", prefix: true, beforeExpr: true},
                      "class": _class, "extends": _extends,
                      "export": _export, "import": _import, "yield": _yield};

  // Punctuation token types. Again, the `type` property is purely for debugging.

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};
  var _arrow = {type: "=>", beforeExpr: true}, _template = {type: "template"};
  var _ellipsis = {type: "...", beforeExpr: true};
  var _backQuote = {type: "`"}, _dollarBraceL = {type: "${", beforeExpr: true};
  var _jsxText = {type: "jsxText"};
  var _paamayimNekudotayim = { type: "::", beforeExpr: true };
  var _hash = { type: '#' };

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator. `isUpdate` specifies that the node produced by
  // the operator should be of type UpdateExpression rather than
  // simply UnaryExpression (`++` and `--`).
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _modulo = {binop: 10, beforeExpr: true};

  // '*' may be multiply or have special meaning in ES6
  var _star = {binop: 10, beforeExpr: true};
  var _exponent = {binop: 11, beforeExpr: true, rightAssociative: true};

  // JSX tag boundaries
  var _jsxTagStart = {type: "jsxTagStart"}, _jsxTagEnd = {type: "jsxTagEnd"};

  // Provide access to the token types for external users of the
  // tokenizer.

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                      dot: _dot, ellipsis: _ellipsis, question: _question, slash: _slash, eq: _eq,
                      name: _name, eof: _eof, num: _num, regexp: _regexp, string: _string,
                      paamayimNekudotayim: _paamayimNekudotayim, exponent: _exponent, hash: _hash,
                      arrow: _arrow, template: _template, star: _star, assign: _assign,
                      backQuote: _backQuote, dollarBraceL: _dollarBraceL, jsxName: _jsxName,
                      jsxText: _jsxText, jsxTagStart: _jsxTagStart, jsxTagEnd: _jsxTagEnd};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  // This is a trick taken from Esprima. It turns out that, on
  // non-Chrome browsers, to check whether a string is in a set, a
  // predicate containing a big ugly `switch` statement is faster than
  // a regular expression, and on Chrome the two are about on par.
  // This function uses `eval` (non-lexical) to produce such a
  // predicate from a space-separated string of words.
  //
  // It starts by sorting the words by length.

  // Removed to create an eval-free library

  // The ECMAScript 3 reserved word list.

  var isReservedWord3 = function anonymous(str
/**/) {
switch(str.length){case 6:switch(str){case "double":case "export":case "import":case "native":case "public":case "static":case "throws":return true}return false;case 4:switch(str){case "byte":case "char":case "enum":case "goto":case "long":return true}return false;case 5:switch(str){case "class":case "final":case "float":case "short":case "super":return true}return false;case 7:switch(str){case "boolean":case "extends":case "package":case "private":return true}return false;case 9:switch(str){case "interface":case "protected":case "transient":return true}return false;case 8:switch(str){case "abstract":case "volatile":return true}return false;case 10:return str === "implements";case 3:return str === "int";case 12:return str === "synchronized";}
};

  // ECMAScript 5 reserved words.

  var isReservedWord5 = function anonymous(str
/**/) {
switch(str.length){case 5:switch(str){case "class":case "super":case "const":return true}return false;case 6:switch(str){case "export":case "import":return true}return false;case 4:return str === "enum";case 7:return str === "extends";}
};

  // The additional reserved words in strict mode.

  var isStrictReservedWord = function anonymous(str
/**/) {
switch(str.length){case 9:switch(str){case "interface":case "protected":return true}return false;case 7:switch(str){case "package":case "private":return true}return false;case 6:switch(str){case "public":case "static":return true}return false;case 10:return str === "implements";case 3:return str === "let";case 5:return str === "yield";}
};

  // The forbidden variable names in strict mode.

  var isStrictBadIdWord = function anonymous(str
/**/) {
switch(str){case "eval":case "arguments":return true}return false;
};

  // And the keywords.

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var isEcma5AndLessKeyword = function anonymous(str
/**/) {
switch(str.length){case 4:switch(str){case "case":case "else":case "with":case "null":case "true":case "void":case "this":return true}return false;case 5:switch(str){case "break":case "catch":case "throw":case "while":case "false":return true}return false;case 3:switch(str){case "for":case "try":case "var":case "new":return true}return false;case 6:switch(str){case "return":case "switch":case "typeof":case "delete":return true}return false;case 8:switch(str){case "continue":case "debugger":case "function":return true}return false;case 2:switch(str){case "do":case "if":case "in":return true}return false;case 7:switch(str){case "default":case "finally":return true}return false;case 10:return str === "instanceof";}
};

  var ecma6AndLessKeywords = ecma5AndLessKeywords + " let const class extends export import yield";

  var isEcma6Keyword = function anonymous(str
/**/) {
switch(str.length){case 5:switch(str){case "break":case "catch":case "throw":case "while":case "false":case "const":case "class":case "yield":return true}return false;case 4:switch(str){case "case":case "else":case "with":case "null":case "true":case "void":case "this":return true}return false;case 6:switch(str){case "return":case "switch":case "typeof":case "delete":case "export":case "import":return true}return false;case 3:switch(str){case "for":case "try":case "var":case "new":case "let":return true}return false;case 8:switch(str){case "continue":case "debugger":case "function":return true}return false;case 7:switch(str){case "default":case "finally":case "extends":return true}return false;case 2:switch(str){case "do":case "if":case "in":return true}return false;case 10:return str === "instanceof";}
};

  var isKeyword = isEcma5AndLessKeyword;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `tools/generate-identifier-regex.js`.

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19B0-\u19C0\u19C8\u19C9\u19D0-\u19D9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var decimalNumber = /^\d+$/;
  var hexNumber = /^[\da-fA-F]+$/;

  // Whether a single character denotes a newline.

  var newline = /[\n\r\u2028\u2029]/;

  function isNewLine(code) {
    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
  }

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  // Test whether a given character code starts an identifier.

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  // Test whether a given character is part of an identifier.

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  // ## Tokenizer

  // These are used when `options.locations` is on, for the
  // `tokStartLoc` and `tokEndLoc` properties.

  function Position(line, col) {
    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function(n) {
    return new Position(this.line, this.column + n);
  };

  function curPosition() {
    return new Position(tokCurLine, tokPos - tokLineStart);
  }

  // Reset the token state. Used at the start of a parse.

  function initTokenState(pos) {
    if (pos) {
      tokPos = pos;
      tokLineStart = Math.max(0, input.lastIndexOf("\n", pos));
      tokCurLine = input.slice(0, tokLineStart).split(newline).length;
    } else {
      tokCurLine = 1;
      tokPos = tokLineStart = 0;
    }
    tokType = _eof;
    tokContext = [b_stat];
    tokExprAllowed = true;
    inType = strict = false;
    if (tokPos === 0 && options.allowHashBang && input.slice(0, 2) === '#!') {
      skipLineComment(2);
    }
  }

  // The algorithm used to determine whether a regexp can appear at a
  // given point in the program is loosely based on sweet.js' approach.
  // See https://github.com/mozilla/sweet.js/wiki/design

  var b_stat = {token: "{", isExpr: false}, b_expr = {token: "{", isExpr: true}, b_tmpl = {token: "${", isExpr: true};
  var p_stat = {token: "(", isExpr: false}, p_expr = {token: "(", isExpr: true};
  var q_tmpl = {token: "`", isExpr: true}, f_expr = {token: "function", isExpr: true};
  var j_oTag = {token: "<tag", isExpr: false}, j_cTag = {token: "</tag", isExpr: false}, j_expr = {token: "<tag>...</tag>", isExpr: true};

  function curTokContext() {
    return tokContext[tokContext.length - 1];
  }

  function braceIsBlock(prevType) {
    var parent;
    if (prevType === _colon && (parent = curTokContext()).token == "{")
      return !parent.isExpr;
    if (prevType === _return)
      return newline.test(input.slice(lastEnd, tokStart));
    if (prevType === _else || prevType === _semi || prevType === _eof)
      return true;
    if (prevType == _braceL)
      return curTokContext() === b_stat;
    return !tokExprAllowed;
  }

  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
  // maintains `tokContext` and `tokExprAllowed`, and skips the space
  // after the token, so that the next one's `tokStart` will point at
  // the right position.

  function finishToken(type, val) {
    tokEnd = tokPos;
    if (options.locations) tokEndLoc = curPosition();
    var prevType = tokType, preserveSpace = false;
    tokType = type;
    tokVal = val;

    // Update context info
    if (type === _parenR || type === _braceR) {
      var out = tokContext.pop();
      if (out === b_tmpl) {
        preserveSpace = tokExprAllowed = true;
      } else if (out === b_stat && curTokContext() === f_expr) {
        tokContext.pop();
        tokExprAllowed = false;
      } else {
        tokExprAllowed = !(out && out.isExpr);
      }
    } else if (type === _braceL) {
      switch (curTokContext()) {
        case j_oTag: tokContext.push(b_expr); break;
        case j_expr: tokContext.push(b_tmpl); break;
        default: tokContext.push(braceIsBlock(prevType) ? b_stat : b_expr);
      }
      tokExprAllowed = true;
    } else if (type === _dollarBraceL) {
      tokContext.push(b_tmpl);
      tokExprAllowed = true;
    } else if (type == _parenL) {
      var statementParens = prevType === _if || prevType === _for || prevType === _with || prevType === _while;
      tokContext.push(statementParens ? p_stat : p_expr);
      tokExprAllowed = true;
    } else if (type == _incDec) {
      // tokExprAllowed stays unchanged
    } else if (type.keyword && prevType == _dot) {
      tokExprAllowed = false;
    } else if (type == _function) {
      if (curTokContext() !== b_stat) {
        tokContext.push(f_expr);
      }
      tokExprAllowed = false;
    } else if (type === _backQuote) {
      if (curTokContext() === q_tmpl) {
        tokContext.pop();
      } else {
        tokContext.push(q_tmpl);
        preserveSpace = true;
      }
      tokExprAllowed = false;
    } else if (type === _jsxTagStart) {
      tokContext.push(j_expr); // treat as beginning of JSX expression
      tokContext.push(j_oTag); // start opening tag context
      tokExprAllowed = false;
    } else if (type === _jsxTagEnd) {
      var out = tokContext.pop();
      if (out === j_oTag && prevType === _slash || out === j_cTag) {
        tokContext.pop();
        preserveSpace = tokExprAllowed = curTokContext() === j_expr;
      } else {
        preserveSpace = tokExprAllowed = true;
      }
    } else if (type === _jsxText) {
      preserveSpace = tokExprAllowed = true;
    } else if (type === _slash && prevType === _jsxTagStart) {
      tokContext.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
      tokContext.push(j_cTag); // reconsider as closing tag context
      tokExprAllowed = false;
    } else {
      tokExprAllowed = type.beforeExpr;
    }

    if (!preserveSpace) skipSpace();
  }

  function skipBlockComment() {
    var startLoc = options.onComment && options.locations && curPosition();
    var start = tokPos, end = input.indexOf("*/", tokPos += 2);
    if (end === -1) raise(tokPos - 2, "Unterminated comment");
    tokPos = end + 2;
    if (options.locations) {
      lineBreak.lastIndex = start;
      var match;
      while ((match = lineBreak.exec(input)) && match.index < tokPos) {
        ++tokCurLine;
        tokLineStart = match.index + match[0].length;
      }
    }
    if (options.onComment)
      options.onComment(true, input.slice(start + 2, end), start, tokPos,
                        startLoc, options.locations && curPosition());
  }

  function skipLineComment(startSkip) {
    var start = tokPos;
    var startLoc = options.onComment && options.locations && curPosition();
    var ch = input.charCodeAt(tokPos+=startSkip);
    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++tokPos;
      ch = input.charCodeAt(tokPos);
    }
    if (options.onComment)
      options.onComment(false, input.slice(start + startSkip, tokPos), start, tokPos,
                        startLoc, options.locations && curPosition());
  }

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  function skipSpace() {
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (ch === 32) { // ' '
        ++tokPos;
      } else if (ch === 13) {
        ++tokPos;
        var next = input.charCodeAt(tokPos);
        if (next === 10) {
          ++tokPos;
        }
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch === 10 || ch === 8232 || ch === 8233) {
        ++tokPos;
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch > 8 && ch < 14) {
        ++tokPos;
      } else if (ch === 47) { // '/'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 42) { // '*'
          skipBlockComment();
        } else if (next === 47) { // '/'
          skipLineComment(2);
        } else break;
      } else if (ch === 160) { // '\xa0'
        ++tokPos;
      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++tokPos;
      } else {
        break;
      }
    }
  }

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  function readToken_dot() {
    var next = input.charCodeAt(tokPos + 1);
    if (next >= 48 && next <= 57) return readNumber(true);
    var next2 = input.charCodeAt(tokPos + 2);
    if (options.playground && next === 63) { // 63
      tokPos += 2;
      return finishToken(_dotQuestion);
    } else if (options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      tokPos += 3;
      return finishToken(_ellipsis);
    } else {
      ++tokPos;
      return finishToken(_dot);
    }
  }

  function readToken_slash() { // '/'
    var next = input.charCodeAt(tokPos + 1);
    if (tokExprAllowed) {++tokPos; return readRegexp();}
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_slash, 1);
  }

  function readToken_modulo() { // '%'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_modulo, 1);
  }

  function readToken_mult() { // '*'
    var type = _star;
    var width = 1;
    var next = input.charCodeAt(tokPos + 1);

    if (options.ecmaVersion >= 7 && next === 42) { // '*'
      width++;
      next = input.charCodeAt(tokPos + 2);
      type = _exponent;
    }

    if (next === 61) { // '='
      width++;
      type = _assign;
    }
    
    return finishOp(type, width);
  }

  function readToken_pipe_amp(code) { // '|&'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) {
      if (options.playground && input.charCodeAt(tokPos + 2) === 61) return finishOp(_assign, 3);
      return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
    }
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() { // '^'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) { // '+-'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) {
      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
          newline.test(input.slice(lastEnd, tokPos))) {
        // A `-->` line comment
        skipLineComment(3);
        skipSpace();
        return readToken();
      }
      return finishOp(_incDec, 2);
    }
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) { // '<>'
    var next = input.charCodeAt(tokPos + 1);
    var size = 1;
    if (!inType && next === code) {
      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
      return finishOp(_bitShift, size);
    }
    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
        input.charCodeAt(tokPos + 3) == 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      skipLineComment(4);
      skipSpace();
      return readToken();
    }
    if (!inType) {
      if (tokExprAllowed && code === 60) {
        ++tokPos;
        return finishToken(_jsxTagStart);
      }
      if (code === 62) {
        var context = curTokContext();
        if (context === j_oTag || context === j_cTag) {
          ++tokPos;
          return finishToken(_jsxTagEnd);
        }
      }
    }
    if (next === 61)
      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
    return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) { // '=!', '=>'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62 && options.ecmaVersion >= 6) { // '=>'
      tokPos += 2;
      return finishToken(_arrow);
    }
    return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  // Get token inside ES6 template (special rules work there).

  function getTemplateToken(code) {
    // '`' and '${' have special meanings, but they should follow
    // string (can be empty)
    if (tokType === _string) {
      if (code === 96) { // '`'
        ++tokPos;
        return finishToken(_bquote);
      } else if (code === 36 && input.charCodeAt(tokPos + 1) === 123) { // '${'
        tokPos += 2;
        return finishToken(_dollarBraceL);
      }
    }
    // anything else is considered string literal
    return readTmplString();
  }

  function getTokenFromCode(code) {
    switch(code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
    case 46: // '.'
      return readToken_dot();

      // Punctuation tokens.
    case 40: ++tokPos; return finishToken(_parenL);
    case 41: ++tokPos; return finishToken(_parenR);
    case 59: ++tokPos; return finishToken(_semi);
    case 44: ++tokPos; return finishToken(_comma);
    case 91: ++tokPos; return finishToken(_bracketL);
    case 93: ++tokPos; return finishToken(_bracketR);
    case 123: ++tokPos; return finishToken(_braceL);
    case 125: ++tokPos; return finishToken(_braceR);
    case 63: ++tokPos; return finishToken(_question);

    case 35:
      if (options.playground) {
        ++tokPos;
        return finishToken(_hash);
      }

    case 58:
      ++tokPos;
      if (options.ecmaVersion >= 7) {
        var next = input.charCodeAt(tokPos);
        if (next === 58) {
          ++tokPos;
          return finishToken(_paamayimNekudotayim);
        }
      }
      return finishToken(_colon);

    case 96: // '`'
      if (options.ecmaVersion >= 6) {
        ++tokPos;
        return finishToken(_backQuote);
      } else {
        return false;
      }

    case 48: // '0'
      var next = input.charCodeAt(tokPos + 1);
      if (next === 120 || next === 88) return readRadixNumber(16); // '0x', '0X' - hex number
      if (options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return readRadixNumber(2); // '0b', '0B' - binary number
      }
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return readNumber(false);

      // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return inXJSTag ? readXJSStringLiteral() : readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return readToken_slash();

    case 37: // '%'
      return readToken_modulo();

    case 42: // '*'
      return readToken_mult();

    case 124: case 38: // '|&'
      return readToken_pipe_amp(code);

    case 94: // '^'
      return readToken_caret();

    case 43: case 45: // '+-'
      return readToken_plus_min(code);

    case 60: case 62: // '<>'
      return readToken_lt_gt(code);

    case 61: case 33: // '=!'
      return readToken_eq_excl(code);

    case 126: // '~'
      return finishOp(_prefix, 1);
    }

    return false;
  }

  function readToken() {
    tokStart = tokPos;
    if (options.locations) tokStartLoc = curPosition();
    if (tokPos >= inputLen) return finishToken(_eof);

    var context = curTokContext();

    if (context === q_tmpl) {
      return readTmplToken();
    }

    if (context === j_expr) {
      return readJSXToken();
    }

    var code = input.charCodeAt(tokPos);
    if (context === j_oTag || context === j_cTag) {
      // JSX identifier
      if (isIdentifierStart(code)) return readJSXWord();
    } else if (context === j_expr) {
      return readJSXToken();
    } else {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();
    }

    var tok = getTokenFromCode(code);

    if (tok === false) {
      // If we are here, we either found a non-ASCII identifier
      // character, or something that's entirely disallowed.
      var ch = String.fromCharCode(code);
      if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
      raise(tokPos, "Unexpected character '" + ch + "'");
    }
    return tok;
  }

  function finishOp(type, size, shouldSkipSpace) {
    var str = input.slice(tokPos, tokPos + size);
    tokPos += size;
    finishToken(type, str, shouldSkipSpace);
  }

  var regexpUnicodeSupport = false;
  try { new RegExp("\uffff", "u"); regexpUnicodeSupport = true; }
  catch(e) {}

  // Parse a regular expression. Some context-awareness is necessary,
  // since a '/' inside a '[]' set does not end the expression.

  function readRegexp() {
    var content = "", escaped, inClass, start = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
      var ch = nextChar();
      if (newline.test(ch)) raise(start, "Unterminated regular expression");
      if (!escaped) {
        if (ch === "[") inClass = true;
        else if (ch === "]" && inClass) inClass = false;
        else if (ch === "/" && !inClass) break;
        escaped = ch === "\\";
      } else escaped = false;
      ++tokPos;
    }
    var content = input.slice(start, tokPos);
    ++tokPos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = readWord1();
    // Detect invalid regular expressions.
    var tmp = content;
    if (mods) {
      var validFlags = /^[gmsiy]*$/;
      if (options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) raise(start, "Invalid regular expression flag");
      if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
        // Replace each astral symbol and every Unicode code point
        // escape sequence that represents such a symbol with a single
        // ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        tmp = tmp
          .replace(/\\u\{([0-9a-fA-F]{5,6})\}/g, "x")
          .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
      }
    }
    // Detect invalid regular expressions.
    try {
      new RegExp(tmp);
    } catch (e) {
      if (e instanceof SyntaxError) raise(start, "Error parsing regular expression: " + e.message);
      raise(e);
    }
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    try {
      var value = new RegExp(content, mods);
    } catch (err) {
      value = null;
  }
    return finishToken(_regexp, {pattern: content, flags: mods, value: value});
  }

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  function readInt(radix, len) {
    var start = tokPos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(tokPos), val;
      if (code >= 97) val = code - 97 + 10; // a
      else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
      else val = Infinity;
      if (val >= radix) break;
      ++tokPos;
      total = total * radix + val;
    }
    if (tokPos === start || len != null && tokPos - start !== len) return null;

    return total;
  }

  function readRadixNumber(radix) {
    tokPos += 2; // 0x
    var val = readInt(radix);
    if (val == null) raise(tokStart + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    return finishToken(_num, val);
  }

  // Read an integer, octal integer, or floating-point number.

  function readNumber(startsWithDot) {
    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
    if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
    if (input.charCodeAt(tokPos) === 46) {
      ++tokPos;
      readInt(10);
      isFloat = true;
    }
    var next = input.charCodeAt(tokPos);
    if (next === 69 || next === 101) { // 'eE'
      next = input.charCodeAt(++tokPos);
      if (next === 43 || next === 45) ++tokPos; // '+-'
      if (readInt(10) === null) raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

    var str = input.slice(start, tokPos), val;
    if (isFloat) val = parseFloat(str);
    else if (!octal || str.length === 1) val = parseInt(str, 10);
    else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
    else val = parseInt(str, 8);
    return finishToken(_num, val);
  }

  // Read a string value, interpreting backslash-escapes.

  function readCodePoint() {
    var ch = input.charCodeAt(tokPos), code;
    
    if (ch === 123) {
      if (options.ecmaVersion < 6) unexpected();
      ++tokPos;
      code = readHexChar(input.indexOf('}', tokPos) - tokPos);
      ++tokPos;
      if (code > 0x10FFFF) unexpected();
    } else {
      code = readHexChar(4);
    }

    // UTF-16 Encoding
    if (code <= 0xFFFF) {
      return String.fromCharCode(code);
    }
    var cu1 = ((code - 0x10000) >> 10) + 0xD800;
    var cu2 = ((code - 0x10000) & 1023) + 0xDC00;
    return String.fromCharCode(cu1, cu2);
  }

  function readString(quote) {
    var isJSX = curTokContext() === j_oTag;
    var out = "", chunkStart = ++tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
      var ch = input.charCodeAt(tokPos);
      if (ch === quote) break;
      if (ch === 92 && !isJSX) { // '\'
        out += input.slice(chunkStart, tokPos);
        out += readEscapedChar();
        chunkStart = tokPos;
      } else if (ch === 38 && isJSX) { // '&'
        out += input.slice(chunkStart, tokPos);
        out += readJSXEntity();
        chunkStart = tokPos;
      } else {
        if (isNewLine(ch) && !isJSX) raise(tokStart, "Unterminated string constant");
        ++tokPos;
      }
    }
    out += input.slice(chunkStart, tokPos++);
    return finishToken(_string, out);
  }

  // Reads template string tokens.

  function readTmplToken() {
    var out = "", chunkStart = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated template");
      var ch = input.charCodeAt(tokPos);
      if (ch === 96 || ch === 36 && input.charCodeAt(tokPos + 1) === 123) { // '`', '${'
        if (tokPos === tokStart && tokType === _template) {
          if (ch === 36) {
            tokPos += 2;
            return finishToken(_dollarBraceL);
          } else {
            ++tokPos;
            return finishToken(_backQuote);
          }
        }
        out += input.slice(chunkStart, tokPos);
        return finishToken(_template, out);
      }
      if (ch === 92) { // '\'
        out += input.slice(chunkStart, tokPos);
        out += readEscapedChar();
        chunkStart = tokPos;
      } else if (isNewLine(ch)) {
        out += input.slice(chunkStart, tokPos);
        ++tokPos;
        if (ch === 13 && input.charCodeAt(tokPos) === 10) {
          ++tokPos;
          out += "\n";
        } else {
          out += String.fromCharCode(ch);
        }
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
        chunkStart = tokPos;
      } else {
        ++tokPos;
      }
    }
  }

  var XHTMLEntities = {
    quot: '\u0022',
    amp: '&',
    apos: '\u0027',
    lt: '<',
    gt: '>',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    'int': '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'
  };

  function readJSXEntity() {
    var str = '', count = 0, entity;
    var ch = input[tokPos];
    if (ch !== '&') raise(tokPos, "Entity must start with an ampersand");
    var startPos = ++tokPos;
    while (tokPos < inputLen && count++ < 10) {
      ch = input[tokPos++];
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 10));
            }
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      tokPos = startPos;
      return '&';
    }
    return entity;
  }

  // Reads inline JSX contents token.

  function readJSXToken() {
    var out = "", chunkStart = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated JSX contents");
      var ch = input.charCodeAt(tokPos);
      switch (ch) {
        case 123: // '{'
        case 60: // '<'
          if (tokPos === tokStart) {
            return getTokenFromCode(ch);
          }
          out += input.slice(chunkStart, tokPos);
          return finishToken(_jsxText, out);

        case 38: // '&'
          out += input.slice(chunkStart, tokPos);
          out += readJSXEntity();
          chunkStart = tokPos;
          break;

        default:
          if (isNewLine(ch)) {
            out += input.slice(chunkStart, tokPos);
            ++tokPos;
            if (ch === 13 && input.charCodeAt(tokPos) === 10) {
              ++tokPos;
              out += "\n";
            } else {
              out += String.fromCharCode(ch);
            }
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
            chunkStart = tokPos;
          } else {
            ++tokPos;
          }
      }
    }
  }

  // Used to read escaped characters

  function readEscapedChar() {
    var ch = input.charCodeAt(++tokPos);
    var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
    if (octal) octal = octal[0];
    while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
    if (octal === "0") octal = null;
    ++tokPos;
    if (octal) {
      if (strict) raise(tokPos - 2, "Octal literal in strict mode");
      tokPos += octal.length - 1;
      return String.fromCharCode(parseInt(octal, 8));
    } else {
      switch (ch) {
        case 110: return "\n"; // 'n' -> '\n'
        case 114: return "\r"; // 'r' -> '\r'
        case 120: return String.fromCharCode(readHexChar(2)); // 'x'
        case 117: return readCodePoint(); // 'u'
        case 116: return "\t"; // 't' -> '\t'
        case 98: return "\b"; // 'b' -> '\b'
        case 118: return "\u000b"; // 'v' -> '\u000b'
        case 102: return "\f"; // 'f' -> '\f'
        case 48: return "\0"; // 0 -> '\0'
        case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
        case 10: // ' \n'
          if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
          return "";
        default: return String.fromCharCode(ch);
      }
    }
  }

  var XHTMLEntities = {
    quot: '\u0022',
    amp: '&',
    apos: '\u0027',
    lt: '<',
    gt: '>',
    nbsp: '\u00A0',
    iexcl: '\u00A1',
    cent: '\u00A2',
    pound: '\u00A3',
    curren: '\u00A4',
    yen: '\u00A5',
    brvbar: '\u00A6',
    sect: '\u00A7',
    uml: '\u00A8',
    copy: '\u00A9',
    ordf: '\u00AA',
    laquo: '\u00AB',
    not: '\u00AC',
    shy: '\u00AD',
    reg: '\u00AE',
    macr: '\u00AF',
    deg: '\u00B0',
    plusmn: '\u00B1',
    sup2: '\u00B2',
    sup3: '\u00B3',
    acute: '\u00B4',
    micro: '\u00B5',
    para: '\u00B6',
    middot: '\u00B7',
    cedil: '\u00B8',
    sup1: '\u00B9',
    ordm: '\u00BA',
    raquo: '\u00BB',
    frac14: '\u00BC',
    frac12: '\u00BD',
    frac34: '\u00BE',
    iquest: '\u00BF',
    Agrave: '\u00C0',
    Aacute: '\u00C1',
    Acirc: '\u00C2',
    Atilde: '\u00C3',
    Auml: '\u00C4',
    Aring: '\u00C5',
    AElig: '\u00C6',
    Ccedil: '\u00C7',
    Egrave: '\u00C8',
    Eacute: '\u00C9',
    Ecirc: '\u00CA',
    Euml: '\u00CB',
    Igrave: '\u00CC',
    Iacute: '\u00CD',
    Icirc: '\u00CE',
    Iuml: '\u00CF',
    ETH: '\u00D0',
    Ntilde: '\u00D1',
    Ograve: '\u00D2',
    Oacute: '\u00D3',
    Ocirc: '\u00D4',
    Otilde: '\u00D5',
    Ouml: '\u00D6',
    times: '\u00D7',
    Oslash: '\u00D8',
    Ugrave: '\u00D9',
    Uacute: '\u00DA',
    Ucirc: '\u00DB',
    Uuml: '\u00DC',
    Yacute: '\u00DD',
    THORN: '\u00DE',
    szlig: '\u00DF',
    agrave: '\u00E0',
    aacute: '\u00E1',
    acirc: '\u00E2',
    atilde: '\u00E3',
    auml: '\u00E4',
    aring: '\u00E5',
    aelig: '\u00E6',
    ccedil: '\u00E7',
    egrave: '\u00E8',
    eacute: '\u00E9',
    ecirc: '\u00EA',
    euml: '\u00EB',
    igrave: '\u00EC',
    iacute: '\u00ED',
    icirc: '\u00EE',
    iuml: '\u00EF',
    eth: '\u00F0',
    ntilde: '\u00F1',
    ograve: '\u00F2',
    oacute: '\u00F3',
    ocirc: '\u00F4',
    otilde: '\u00F5',
    ouml: '\u00F6',
    divide: '\u00F7',
    oslash: '\u00F8',
    ugrave: '\u00F9',
    uacute: '\u00FA',
    ucirc: '\u00FB',
    uuml: '\u00FC',
    yacute: '\u00FD',
    thorn: '\u00FE',
    yuml: '\u00FF',
    OElig: '\u0152',
    oelig: '\u0153',
    Scaron: '\u0160',
    scaron: '\u0161',
    Yuml: '\u0178',
    fnof: '\u0192',
    circ: '\u02C6',
    tilde: '\u02DC',
    Alpha: '\u0391',
    Beta: '\u0392',
    Gamma: '\u0393',
    Delta: '\u0394',
    Epsilon: '\u0395',
    Zeta: '\u0396',
    Eta: '\u0397',
    Theta: '\u0398',
    Iota: '\u0399',
    Kappa: '\u039A',
    Lambda: '\u039B',
    Mu: '\u039C',
    Nu: '\u039D',
    Xi: '\u039E',
    Omicron: '\u039F',
    Pi: '\u03A0',
    Rho: '\u03A1',
    Sigma: '\u03A3',
    Tau: '\u03A4',
    Upsilon: '\u03A5',
    Phi: '\u03A6',
    Chi: '\u03A7',
    Psi: '\u03A8',
    Omega: '\u03A9',
    alpha: '\u03B1',
    beta: '\u03B2',
    gamma: '\u03B3',
    delta: '\u03B4',
    epsilon: '\u03B5',
    zeta: '\u03B6',
    eta: '\u03B7',
    theta: '\u03B8',
    iota: '\u03B9',
    kappa: '\u03BA',
    lambda: '\u03BB',
    mu: '\u03BC',
    nu: '\u03BD',
    xi: '\u03BE',
    omicron: '\u03BF',
    pi: '\u03C0',
    rho: '\u03C1',
    sigmaf: '\u03C2',
    sigma: '\u03C3',
    tau: '\u03C4',
    upsilon: '\u03C5',
    phi: '\u03C6',
    chi: '\u03C7',
    psi: '\u03C8',
    omega: '\u03C9',
    thetasym: '\u03D1',
    upsih: '\u03D2',
    piv: '\u03D6',
    ensp: '\u2002',
    emsp: '\u2003',
    thinsp: '\u2009',
    zwnj: '\u200C',
    zwj: '\u200D',
    lrm: '\u200E',
    rlm: '\u200F',
    ndash: '\u2013',
    mdash: '\u2014',
    lsquo: '\u2018',
    rsquo: '\u2019',
    sbquo: '\u201A',
    ldquo: '\u201C',
    rdquo: '\u201D',
    bdquo: '\u201E',
    dagger: '\u2020',
    Dagger: '\u2021',
    bull: '\u2022',
    hellip: '\u2026',
    permil: '\u2030',
    prime: '\u2032',
    Prime: '\u2033',
    lsaquo: '\u2039',
    rsaquo: '\u203A',
    oline: '\u203E',
    frasl: '\u2044',
    euro: '\u20AC',
    image: '\u2111',
    weierp: '\u2118',
    real: '\u211C',
    trade: '\u2122',
    alefsym: '\u2135',
    larr: '\u2190',
    uarr: '\u2191',
    rarr: '\u2192',
    darr: '\u2193',
    harr: '\u2194',
    crarr: '\u21B5',
    lArr: '\u21D0',
    uArr: '\u21D1',
    rArr: '\u21D2',
    dArr: '\u21D3',
    hArr: '\u21D4',
    forall: '\u2200',
    part: '\u2202',
    exist: '\u2203',
    empty: '\u2205',
    nabla: '\u2207',
    isin: '\u2208',
    notin: '\u2209',
    ni: '\u220B',
    prod: '\u220F',
    sum: '\u2211',
    minus: '\u2212',
    lowast: '\u2217',
    radic: '\u221A',
    prop: '\u221D',
    infin: '\u221E',
    ang: '\u2220',
    and: '\u2227',
    or: '\u2228',
    cap: '\u2229',
    cup: '\u222A',
    'int': '\u222B',
    there4: '\u2234',
    sim: '\u223C',
    cong: '\u2245',
    asymp: '\u2248',
    ne: '\u2260',
    equiv: '\u2261',
    le: '\u2264',
    ge: '\u2265',
    sub: '\u2282',
    sup: '\u2283',
    nsub: '\u2284',
    sube: '\u2286',
    supe: '\u2287',
    oplus: '\u2295',
    otimes: '\u2297',
    perp: '\u22A5',
    sdot: '\u22C5',
    lceil: '\u2308',
    rceil: '\u2309',
    lfloor: '\u230A',
    rfloor: '\u230B',
    lang: '\u2329',
    rang: '\u232A',
    loz: '\u25CA',
    spades: '\u2660',
    clubs: '\u2663',
    hearts: '\u2665',
    diams: '\u2666'
  };

  function readXJSEntity() {
    var str = '', count = 0, entity;
    var ch = nextChar();
    if (ch !== '&') raise(tokPos, "Entity must start with an ampersand");
    var startPos = ++tokPos;
    while (tokPos < inputLen && count++ < 10) {
      ch = nextChar();
      tokPos++;
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str)) {
              entity = String.fromCharCode(parseInt(str, 10));
            }
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      tokPos = startPos;
      return '&';
    }
    return entity;
  }

  function readXJSText(stopChars) {
    var str = '';
    while (tokPos < inputLen) {
      var ch = nextChar();
      if (stopChars.indexOf(ch) !== -1) {
        break;
      }
      if (ch === '&') {
        str += readXJSEntity();
      } else {
        ++tokPos;
        if (ch === '\r' && nextChar() === '\n') {
          str += ch;
          ++tokPos;
          ch = '\n';
        }
        if (ch === '\n' && options.locations) {
          tokLineStart = tokPos;
          ++tokCurLine;
        }
        str += ch;
      }
    }
    return finishToken(_xjsText, str);
  }

  function readXJSStringLiteral() {
    var quote = input.charCodeAt(tokPos);

    if (quote !== 34 && quote !== 39) {
      raise("String literal must starts with a quote");
    }

    ++tokPos;

    readXJSText([String.fromCharCode(quote)]);

    if (quote !== input.charCodeAt(tokPos)) {
      unexpected();
    }

    ++tokPos;

    return finishToken(tokType, tokVal);
  }

  // Used to read character escape sequences ('\x', '\u', '\U').

  function readHexChar(len) {
    var n = readInt(16, len);
    if (n === null) raise(tokStart, "Bad character escape sequence");
    return n;
  }

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  var containsEsc;

  // Read an identifier, and return it as a string. Sets `containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  function readWord1() {
    containsEsc = false;
    var word = "", first = true, chunkStart = tokPos;
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (isIdentifierChar(ch)) {
        ++tokPos;
      } else if (ch === 92) { // "\"
        containsEsc = true;
        word += input.slice(chunkStart, tokPos);
        if (input.charCodeAt(++tokPos) != 117) // "u"
          raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
        ++tokPos;
        var esc = readHexChar(4);
        var escStr = String.fromCharCode(esc);
        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
          raise(tokPos - 4, "Invalid Unicode escape");
        word += escStr;
        chunkStart = tokPos;
      } else {
        break;
      }
      first = false;
    }
    return word + input.slice(chunkStart, tokPos);
  }

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  function readWord() {
    var word = readWord1();
    var type = inXJSTag ? _xjsName : _name;
    if (!containsEsc && isKeyword(word))
      type = keywordTypes[word];
    return finishToken(type, word);
  }

  // Read a JSX identifier (valid tag or attribute name).
  //
  // Optimized version since JSX identifiers can't contain
  // escape characters and so can be read as single slice.
  // Also assumes that first character was already checked
  // by isIdentifierStart in readToken.

  function readJSXWord() {
    var ch, start = tokPos;
    do {
      ch = input.charCodeAt(++tokPos);
    } while (isIdentifierChar(ch) || ch === 45); // '-'
    return finishToken(_jsxName, input.slice(start, tokPos));
  }

  // ## Parser

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts — that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary operator node.
  //
  // Acorn uses an [operator precedence parser][opp] to handle binary
  // operator precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

  // ### Parser utilities

  // Continue to the next token.

  function next() {
    if (options.onToken)
      options.onToken(new Token());

    lastStart = tokStart;
    lastEnd = tokEnd;
    lastEndLoc = tokEndLoc;
    readToken();
  }

  // Enter strict mode. Re-reads the next number or string to
  // please pedantic tests ("use strict"; 010; -- should fail).

  function setStrict(strct) {
    strict = strct;
    if (tokType !== _num && tokType !== _string) return;
    tokPos = tokStart;
    if (options.locations) {
      while (tokPos < tokLineStart) {
        tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
        --tokCurLine;
      }
    }
    skipSpace();
    readToken();
  }

  // Start an AST node, attaching a start offset.

  function Node() {
    this.type = null;
    this.start = tokStart;
    this.end = null;
  }
  
  exports.Node = Node;

  function SourceLocation() {
    this.start = tokStartLoc;
    this.end = null;
    if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
    var node = new exports.Node();
    if (options.locations)
      node.loc = new SourceLocation();
    if (options.directSourceFile)
      node.sourceFile = options.directSourceFile;
    if (options.ranges)
      node.range = [tokStart, 0];
    return node;
  }

  // Sometimes, a node is only started *after* the token stream passed
  // its start position. The functions below help storing a position
  // and creating a node from a previous position.

  function storeCurrentPos() {
    return options.locations ? [tokStart, tokStartLoc] : tokStart;
  }

  function startNodeAt(pos) {
    var node = new exports.Node(), start = pos;
    if (options.locations) {
      node.loc = new SourceLocation();
      node.loc.start = start[1];
      start = pos[0];
    }
    node.start = start;
    if (options.directSourceFile)
      node.sourceFile = options.directSourceFile;
    if (options.ranges)
      node.range = [start, 0];

    return node;
  }

  // Finish an AST node, adding `type` and `end` properties.

  function finishNode(node, type) {
    node.type = type;
    node.end = lastEnd;
    if (options.locations)
      node.loc.end = lastEndLoc;
    if (options.ranges)
      node.range[1] = lastEnd;
    return node;
  }

  // Finish node at given position

  function finishNodeAt(node, type, pos) {
    if (options.locations) { node.loc.end = pos[1]; pos = pos[0]; }
    node.type = type;
    node.end = pos;
    if (options.ranges)
      node.range[1] = pos;
    return node;
  }

  // Test whether a statement node is the string literal `"use strict"`.

  function isUseStrict(stmt) {
    return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
      stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  function eat(type) {
    if (tokType === type) {
      next();
      return true;
    } else {
      return false;
    }
  }

  // Tests whether parsed token is a contextual keyword.

  function isContextual(name) {
    return tokType === _name && tokVal === name;
  }

  // Consumes contextual keyword if possible.

  function eatContextual(name) {
    return tokVal === name && eat(_name);
  }

  // Asserts that following token is given contextual keyword.

  function expectContextual(name) {
    if (!eatContextual(name)) unexpected();
  }

  // Test whether a semicolon can be inserted at the current position.

  function canInsertSemicolon() {
    return !options.strictSemicolons &&
      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  function semicolon() {
    if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  function expect(type) {
    eat(type) || unexpected();
  }

  // Get following char.

  function nextChar() {
    return input.charAt(tokPos);
  }

  // Raise an unexpected token error.

  function unexpected(pos) {
    raise(pos != null ? pos : tokStart, "Unexpected token");
  }

  // Checks if hash object has a property.

  function has(obj, propName) {
    return Object.prototype.hasOwnProperty.call(obj, propName);
  }

  // Convert existing expression atom to assignable pattern
  // if possible.

  function toAssignable(node, isBinding) {
    if (options.ecmaVersion >= 6 && node) {
      switch (node.type) {
        case "Identifier":
        case "VirtualPropertyExpression":
        case "MemberExpression":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (var i = 0; i < node.properties.length; i++) {
            var prop = node.properties[i];
            if (prop.kind !== "init") raise(prop.key.start, "Object pattern can't contain getter or setter");
            toAssignable(prop.value, isBinding);
          }
          break;

        case "ArrayExpression":
          node.type = "ArrayPattern";
          toAssignableList(node.elements, isBinding);
          break;

        case "AssignmentExpression":
          if (node.operator === "=") {
            node.type = "AssignmentPattern";
          } else {
            raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          }
          break;

        case "MemberExpression":
          if (!isBinding) break;

        default:
          raise(node.start, "Assigning to rvalue");
      }
    }
    return node;
  }

  // Convert list of expression atoms to binding list.

  function toAssignableList(exprList, isBinding) {
    if (exprList.length) {
      for (var i = 0; i < exprList.length - 1; i++) {
        toAssignable(exprList[i], isBinding);
      }
      var last = exprList[exprList.length - 1];
      switch (last.type) {
        case "RestElement":
          break;
        case "SpreadElement":
          last.type = "RestElement";
          var arg = last.argument;
          toAssignable(arg, isBinding);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
            unexpected(arg.start);
          break;
        default:
          toAssignable(last, isBinding);
      }
    }
    return exprList;
  }

  // Parses spread element.

  function parseSpread(refShorthandDefaultPos) {
    var node = startNode();
    next();
    node.argument = parseMaybeAssign(refShorthandDefaultPos);
    return finishNode(node, "SpreadElement");
  }

  function parseRest() {
    var node = startNode();
    next();
    node.argument = tokType === _name || tokType === _bracketL ? parseBindingAtom() : unexpected();
    return finishNode(node, "RestElement");
  }

  // Parses lvalue (assignable) atom.

  function parseBindingAtom() {
    if (options.ecmaVersion < 6) return parseIdent();
    switch (tokType) {
      case _name:
        return parseIdent();

      case _bracketL:
        var node = startNode();
        next();
        node.elements = parseBindingList(_bracketR, true);
        return finishNode(node, "ArrayPattern");

      case _braceL:
        return parseObj(true);

      default:
        unexpected();
    }
  }

  function parseBindingList(close, allowEmpty) {
    var elts = [], first = true;
    while (!eat(close)) {
      first ? first = false : expect(_comma);
      if (tokType === _ellipsis) {
        elts.push(parseAssignableListItemTypes(parseRest()));
        expect(close);
        break;
      }
      var elem;
      if (allowEmpty && tokType === _comma) {
        elem = null;
      } else {
        var left = parseMaybeDefault();
        parseAssignableListItemTypes(left);
        elem = parseMaybeDefault(null, left);
      }
      elts.push(elem);
    }
    return elts;
  }

  function parseAssignableListItemTypes(param) {
    if (eat(_question)) {
      param.optional = true;
    }
    if (tokType === _colon) {
      param.typeAnnotation = parseTypeAnnotation();
    }
    finishNode(param, param.type);
    return param;
  }

  // Parses assignment pattern around given atom if possible.

  function parseMaybeDefault(startPos, left) {
    startPos = startPos || storeCurrentPos();
    left = left || parseBindingAtom();
    if (!eat(_eq)) return left;
    var node = startNodeAt(startPos);
    node.operator = "=";
    node.left = left;
    node.right = parseMaybeAssign();
    return finishNode(node, "AssignmentPattern");
  }

  // Verify that argument names are not repeated, and it does not
  // try to bind the words `eval` or `arguments`.

  function checkFunctionParam(param, nameHash) {
    switch (param.type) {
      case "Identifier":
        if (isStrictReservedWord(param.name) || isStrictBadIdWord(param.name))
          raise(param.start, "Defining '" + param.name + "' in strict mode");
        if (has(nameHash, param.name))
          raise(param.start, "Argument name clash in strict mode");
        nameHash[param.name] = true;
        break;

      case "ObjectPattern":
        for (var i = 0; i < param.properties.length; i++) {
          var param2 = param.properties[i];
          if (param2.type === "SpreadProperty") {
            checkFunctionParam(param2.argument, nameHash);
          } else {
            checkFunctionParam(param2.value, nameHash);
          }
        }
        break;

      case "ArrayPattern":
        for (var i = 0; i < param.elements.length; i++) {
          var elem = param.elements[i];
          if (elem) checkFunctionParam(elem, nameHash);
        }
        break;

      case "RestElement":
        return checkFunctionParam(param.argument, nameHash);
    }
  }

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  function checkPropClash(prop, propHash) {
    if (options.ecmaVersion >= 6) return;
    var key = prop.key, name;
    switch (key.type) {
      case "Identifier": name = key.name; break;
      case "Literal": name = String(key.value); break;
      default: return;
    }
    var kind = prop.kind || "init", other;
    if (has(propHash, name)) {
      other = propHash[name];
      var isGetSet = kind !== "init";
      if ((strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
        raise(key.start, "Redefinition of property");
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  }

  // Verify that a node is an lval — something that can be assigned
  // to.

  function checkLVal(expr, isBinding) {
    switch (expr.type) {
      case "Identifier":
        if (strict && (isStrictBadIdWord(expr.name) || isStrictReservedWord(expr.name)))
          raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        break;
      
      case "MemberExpression":
        if (isBinding) raise(expr.start, "Binding to member expression");
        break;

      case "ObjectPattern":
        for (var i = 0; i < expr.properties.length; i++) {
          var prop = expr.properties[i];
          if (prop.type === "Property") prop = prop.value;
          checkLVal(prop, isBinding);
        }
        break;

      case "ArrayPattern":
        for (var i = 0; i < expr.elements.length; i++) {
          var elem = expr.elements[i];
          if (elem) checkLVal(elem, isBinding);
        }
        break;

      case "AssignmentPattern":
        checkLVal(expr.left);
        break;

      case "SpreadProperty":
      case "VirtualPropertyExpression":
        break;

      case "RestElement":
        checkLVal(expr.argument);
        break;

      default:
      raise(expr.start, "Assigning to rvalue");
  }
  }

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new exports.Node.

  function parseTopLevel(node) {
    var first = true;
    if (!node.body) node.body = [];
    while (tokType !== _eof) {
      var stmt = parseStatement(true, true);
      node.body.push(stmt);
      if (first && isUseStrict(stmt)) setStrict(true);
      first = false;
    }

    next();
    return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
  // does not help.

  function parseStatement(declaration, topLevel) {
    var starttype = tokType, node = startNode();

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case _break: case _continue: return parseBreakContinueStatement(node, starttype.keyword);
    case _debugger: return parseDebuggerStatement(node);
    case _do: return parseDoStatement(node);
    case _for: return parseForStatement(node);
    case _function:
      if (!declaration && options.ecmaVersion >= 6) unexpected();
      return parseFunctionStatement(node);
    case _class:
      if (!declaration) unexpected();
      return parseClass(node, true);
    case _if: return parseIfStatement(node);
    case _return: return parseReturnStatement(node);
    case _switch: return parseSwitchStatement(node);
    case _throw: return parseThrowStatement(node);
    case _try: return parseTryStatement(node);
    case _let: case _const: if (!declaration) unexpected(); // NOTE: falls through to _var
    case _var: return parseVarStatement(node, starttype.keyword);
    case _while: return parseWhileStatement(node);
    case _with: return parseWithStatement(node);
    case _braceL: return parseBlock(); // no point creating a function for this
    case _semi: return parseEmptyStatement(node);
    case _export:
    case _import:
      if (!topLevel && !options.allowImportExportEverywhere)
        raise(tokStart, "'import' and 'export' may only appear at the top level");
      return starttype === _import ? parseImport(node) : parseExport(node);

    case _name:
      if (options.ecmaVersion >= 7 && tokVal === "private") {
        next();
        return parsePrivate(node);
      } 

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      var maybeName = tokVal, expr = parseExpression();

      if (options.ecmaVersion >= 7 && starttype === _name && maybeName === "async" && tokType === _function && !canInsertSemicolon()) {
        next();
        var func = parseFunctionStatement(node);
        func.async = true;
        return func;
      }

      if (starttype === _name && expr.type === "Identifier") {
        if (eat(_colon)) {
          return parseLabeledStatement(node, maybeName, expr);
        }

        if (expr.name === "declare") {
          if (tokType === _class || tokType === _name || tokType === _function || tokType === _var) {
            return parseDeclare(node);
          }
        } else if (tokType === _name) {
          if (expr.name === "interface") {
            return parseInterface(node);
          } else if (expr.name === "type") {
            return parseTypeAlias(node);
          }
        }
      }

      if (expr.type === "FunctionExpression" && expr.async) {
        if (expr.id) {
          expr.type = "FunctionDeclaration";
          return expr;
        } else {
          unexpected(expr.start + "async function ".length); // this is such a hack
        }
      }

      return parseExpressionStatement(node, expr);
    }
  }
  
  function parseBreakContinueStatement(node, keyword) {
    var isBreak = keyword == "break";
    next();
    if (eat(_semi) || canInsertSemicolon()) node.label = null;
    else if (tokType !== _name) unexpected();
    else {
      node.label = parseIdent();
      semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    for (var i = 0; i < labels.length; ++i) {
      var lab = labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }
    if (i === labels.length) raise(node.start, "Unsyntactic " + keyword);
    return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }
  
  function parseDebuggerStatement(node) {
    next();
    semicolon();
    return finishNode(node, "DebuggerStatement");
  }
  
  function parseDoStatement(node) {
    next();
    labels.push(loopLabel);
    node.body = parseStatement(false);
    labels.pop();
    expect(_while);
    node.test = parseParenExpression();
    if (options.ecmaVersion >= 6)
      eat(_semi);
    else
      semicolon();
    return finishNode(node, "DoWhileStatement");
  }
  
  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.
  
  function parseForStatement(node) {
    next();
    labels.push(loopLabel);
    expect(_parenL);
    if (tokType === _semi) return parseFor(node, null);
    if (tokType === _var || tokType === _let) {
      var init = startNode(), varKind = tokType.keyword, isLet = tokType === _let;
      next();
      parseVar(init, true, varKind);
      finishNode(init, "VariableDeclaration");
      if ((tokType === _in || (options.ecmaVersion >= 6 && isContextual("of"))) && init.declarations.length === 1 &&
          !(isLet && init.declarations[0].init))
        return parseForIn(node, init);
      return parseFor(node, init);
    }
    var refShorthandDefaultPos = {start: 0};
    var init = parseExpression(true, refShorthandDefaultPos);
    if (tokType === _in || (options.ecmaVersion >= 6 && isContextual("of"))) {
      toAssignable(init);
      checkLVal(init);
      return parseForIn(node, init);
    } else if (refShorthandDefaultPos.start) {
      unexpected(refShorthandDefaultPos.start);
    }
    return parseFor(node, init);
  }
  
  function parseFunctionStatement(node) {
    next();
    return parseFunction(node, true, false);
  }
  
  function parseIfStatement(node) {
    next();
    node.test = parseParenExpression();
    node.consequent = parseStatement(false);
    node.alternate = eat(_else) ? parseStatement(false) : null;
    return finishNode(node, "IfStatement");
  }
  
  function parseReturnStatement(node) {
    if (!inFunction && !options.allowReturnOutsideFunction)
      raise(tokStart, "'return' outside of function");
    next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (eat(_semi) || canInsertSemicolon()) node.argument = null;
    else { node.argument = parseExpression(); semicolon(); }
    return finishNode(node, "ReturnStatement");
  }
  
  function parseSwitchStatement(node) {
    next();
    node.discriminant = parseParenExpression();
    node.cases = [];
    expect(_braceL);
    labels.push(switchLabel);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    for (var cur, sawDefault; tokType != _braceR;) {
      if (tokType === _case || tokType === _default) {
        var isCase = tokType === _case;
        if (cur) finishNode(cur, "SwitchCase");
        node.cases.push(cur = startNode());
        cur.consequent = [];
        next();
        if (isCase) cur.test = parseExpression();
        else {
          if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
          cur.test = null;
        }
        expect(_colon);
      } else {
        if (!cur) unexpected();
        cur.consequent.push(parseStatement(true));
      }
    }
    if (cur) finishNode(cur, "SwitchCase");
    next(); // Closing brace
    labels.pop();
    return finishNode(node, "SwitchStatement");
  }
  
  function parseThrowStatement(node) {
    next();
    if (newline.test(input.slice(lastEnd, tokStart)))
      raise(lastEnd, "Illegal newline after throw");
    node.argument = parseExpression();
    semicolon();
    return finishNode(node, "ThrowStatement");
  }
  
  function parseTryStatement(node) {
    next();
    node.block = parseBlock();
    node.handler = null;
    if (tokType === _catch) {
      var clause = startNode();
      next();
      expect(_parenL);
      clause.param = parseBindingAtom();
      checkLVal(clause.param, true);
      expect(_parenR);
      clause.guard = null;
      clause.body = parseBlock();
      node.handler = finishNode(clause, "CatchClause");
    }
    node.guardedHandlers = empty;
    node.finalizer = eat(_finally) ? parseBlock() : null;
    if (!node.handler && !node.finalizer)
      raise(node.start, "Missing catch or finally clause");
    return finishNode(node, "TryStatement");
  }
  
  function parseVarStatement(node, kind) {
    next();
    parseVar(node, false, kind);
    semicolon();
    return finishNode(node, "VariableDeclaration");
  }
  
  function parseWhileStatement(node) {
    next();
    node.test = parseParenExpression();
    labels.push(loopLabel);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, "WhileStatement");
  }
  
  function parseWithStatement(node) {
    if (strict) raise(tokStart, "'with' in strict mode");
    next();
    node.object = parseParenExpression();
    node.body = parseStatement(false);
    return finishNode(node, "WithStatement");
  }
  
  function parseEmptyStatement(node) {
    next();
    return finishNode(node, "EmptyStatement");
  }
  
  function parseLabeledStatement(node, maybeName, expr) {
    for (var i = 0; i < labels.length; ++i)
      if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
    var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
    labels.push({name: maybeName, kind: kind});
    node.body = parseStatement(true);
    labels.pop();
    node.label = expr;
    return finishNode(node, "LabeledStatement");
  }
  
  function parseExpressionStatement(node, expr) {
    node.expression = expr;
    semicolon();
    return finishNode(node, "ExpressionStatement");
  }

  // Used for constructs like `switch` and `if` that insist on
  // parentheses around their expression.

  function parseParenExpression() {
    expect(_parenL);
    var val = parseExpression();
    expect(_parenR);
    return val;
  }

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  function parseBlock(allowStrict) {
    var node = startNode(), first = true, oldStrict;
    node.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      var stmt = parseStatement(true);
      node.body.push(stmt);
      if (first && allowStrict && isUseStrict(stmt)) {
        oldStrict = strict;
        setStrict(strict = true);
      }
      first = false;
    }
    if (oldStrict === false) setStrict(false);
    return finishNode(node, "BlockStatement");
  }

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  function parseFor(node, init) {
    node.init = init;
    expect(_semi);
    node.test = tokType === _semi ? null : parseExpression();
    expect(_semi);
    node.update = tokType === _parenR ? null : parseExpression();
    expect(_parenR);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, "ForStatement");
  }

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  function parseForIn(node, init) {
    var type = tokType === _in ? "ForInStatement" : "ForOfStatement";
    next();
    node.left = init;
    node.right = parseExpression();
    expect(_parenR);
    node.body = parseStatement(false);
    labels.pop();
    return finishNode(node, type);
  }

  // Parse a list of variable declarations.

  function parseVar(node, noIn, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = startNode();
      decl.id = parseBindingAtom();
      checkLVal(decl.id, true);

      if (tokType === _colon) {
        decl.id.typeAnnotation = parseTypeAnnotation();
        finishNode(decl.id, decl.id.type);
      }

      decl.init = eat(_eq) ? parseMaybeAssign(noIn) : (kind === _const.keyword ? unexpected() : null);
      node.declarations.push(finishNode(decl, "VariableDeclarator"));
      if (!eat(_comma)) break;
    }
    return node;
  }

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  function parseExpression(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseMaybeAssign(noIn, refShorthandDefaultPos);
    if (tokType === _comma) {
      var node = startNodeAt(start);
      node.expressions = [expr];
      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn, refShorthandDefaultPos));
      return finishNode(node, "SequenceExpression");
    }
    return expr;
  }

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse) {
    var failOnShorthandAssign;
    if (!refShorthandDefaultPos) {
      refShorthandDefaultPos = {start: 0};
      failOnShorthandAssign = true;
    } else {
      failOnShorthandAssign = false;
    }
    var start = storeCurrentPos();
    var left = parseMaybeConditional(noIn, refShorthandDefaultPos);
    if (afterLeftParse) left = afterLeftParse(left, start);
    if (tokType.isAssign) {
      var node = startNodeAt(start);
      node.operator = tokVal;
      node.left = tokType === _eq ? toAssignable(left) : left;
      refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly
      checkLVal(left);
      next();
      node.right = parseMaybeAssign(noIn);
      return finishNode(node, "AssignmentExpression");
    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
      unexpected(refShorthandDefaultPos.start);
    }
    return left;
  }

  // Parse a ternary conditional (`?:`) operator.

  function parseMaybeConditional(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseExprOps(noIn, refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    if (eat(_question)) {
      var node = startNodeAt(start);
      if (options.playground && eat(_eq)) {
        var left = node.left = toAssignable(expr);
        if (left.type !== "MemberExpression") raise(left.start, "You can only use member expressions in memoization assignment");
        node.right = parseMaybeAssign(noIn);
        node.operator = "?=";
        return finishNode(node, "AssignmentExpression");
      }
      node.test = expr;
      node.consequent = parseMaybeAssign();
      expect(_colon);
      node.alternate = parseMaybeAssign(noIn);
      return finishNode(node, "ConditionalExpression");
    }
    return expr;
  }

  // Start the precedence parser.

  function parseExprOps(noIn, refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseMaybeUnary(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return parseExprOp(expr, start, -1, noIn);
  }

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  function parseExprOp(left, leftStart, minPrec, noIn) {
    var prec = tokType.binop;
    if (prec != null && (!noIn || tokType !== _in)) {
      if (prec > minPrec) {
        var node = startNodeAt(leftStart);
        node.left = left;
        node.operator = tokVal;
        var op = tokType;
        next();
        var start = storeCurrentPos();
        node.right = parseExprOp(parseMaybeUnary(), start, op.rightAssociative ? (prec - 1) : prec, noIn);
        finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
        return parseExprOp(node, leftStart, minPrec, noIn);
      }
    }
    return left;
  }

  // Parse unary operators, both prefix and postfix.

  function parseMaybeUnary(refShorthandDefaultPos) {
    if (tokType.prefix) {
      var node = startNode(), update = tokType.isUpdate;
      node.operator = tokVal;
      node.prefix = true;
      next();
      node.argument = parseMaybeUnary();
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) unexpected(refShorthandDefaultPos.start);
      if (update) checkLVal(node.argument);
      else if (strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        raise(node.start, "Deleting local variable in strict mode");
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var start = storeCurrentPos();
    var expr = parseExprSubscripts(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    while (tokType.postfix && !canInsertSemicolon()) {
      var node = startNodeAt(start);
      node.operator = tokVal;
      node.prefix = false;
      node.argument = expr;
      checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  // Parse call, dot, and `[]`-subscript expressions.

  function parseExprSubscripts(refShorthandDefaultPos) {
    var start = storeCurrentPos();
    var expr = parseExprAtom(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return parseSubscripts(expr, start);
  }

  function parseSubscripts(base, start, noCalls) {
    if (options.playground && eat(_hash)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      if (eat(_parenL)) {
        node.arguments = parseExprList(_parenR, false);
      } else {
        node.arguments = [];
      }
      return parseSubscripts(finishNode(node, "BindMemberExpression"), start, noCalls);
    } else if (eat(_paamayimNekudotayim)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      return parseSubscripts(finishNode(node, "VirtualPropertyExpression"), start, noCalls);
    } else if (eat(_dot)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseIdent(true);
      node.computed = false;
      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
    } else if (eat(_bracketL)) {
      var node = startNodeAt(start);
      node.object = base;
      node.property = parseExpression();
      node.computed = true;
      expect(_bracketR);
      return parseSubscripts(finishNode(node, "MemberExpression"), start, noCalls);
    } else if (!noCalls && eat(_parenL)) {
      var node = startNodeAt(start);
      node.callee = base;
      node.arguments = parseExprList(_parenR, false);
      return parseSubscripts(finishNode(node, "CallExpression"), start, noCalls);
    } else if (tokType === _backQuote) {
      var node = startNodeAt(start);
      node.tag = base;
      node.quasi = parseTemplate();
      return parseSubscripts(finishNode(node, "TaggedTemplateExpression"), start, noCalls);
    } return base;
  }

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  function parseExprAtom(refShorthandDefaultPos) {
    switch (tokType) {
    case _this:
      var node = startNode();
      next();
      return finishNode(node, "ThisExpression");
    
    case _yield:
      if (inGenerator) return parseYield();

    case _name:
      var start = storeCurrentPos();
      var node = startNode();
      var id = parseIdent(tokType !== _name);

      if (options.ecmaVersion >= 7) {
        // async functions!
        if (id.name === "async") {
          // arrow functions
          if (tokType === _parenL) {
            next();
            var exprList;
            if (tokType !== _parenR) {
              var val = parseExpression();
              exprList = val.type === "SequenceExpression" ? val.expressions : [val];
            } else {
              exprList = [];
            }
            expect(_parenR);
            // if '=>' follows '(...)', convert contents to arguments
            if (eat(_arrow)) {
              return parseArrowExpression(node, exprList, true);
            } else {
              node.callee = id;
              node.arguments = exprList;
              return parseSubscripts(finishNode(node, "CallExpression"), start);
            }
          } else if (tokType === _name) {
            id = parseIdent();
            if (eat(_arrow)) {
              return parseArrowExpression(node, [id], true);
            }
            return id;
          }

          // normal functions
          if (tokType === _function && !canInsertSemicolon()) {
            next();
            return parseFunction(node, false, true);
          }
        } else if (id.name === "await") {
          if (inAsync) return parseAwait(node);
        }
      }

      if (!canInsertSemicolon() && eat(_arrow)) {
        return parseArrowExpression(startNodeAt(start), [id]);
      }
      return id;
      
    case _regexp:
      var node = startNode();
      node.regex = {pattern: tokVal.pattern, flags: tokVal.flags};
      node.value = tokVal.value;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _num: case _string: case _jsxText:
      var node = startNode();
      node.value = tokVal;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _null: case _true: case _false:
      var node = startNode();
      node.value = tokType.atomValue;
      node.raw = tokType.keyword;
      next();
      return finishNode(node, "Literal");

    case _parenL:
      return parseParenAndDistinguishExpression();

    case _bracketL:
      var node = startNode();
      next();
      // check whether this is array comprehension or regular array
      if (options.ecmaVersion >= 7 && tokType === _for) {
        return parseComprehension(node, false);
      }
      node.elements = parseExprList(_bracketR, true, true, refShorthandDefaultPos);
      return finishNode(node, "ArrayExpression");

    case _braceL:
      return parseObj(false, refShorthandDefaultPos);

    case _function:
      var node = startNode();
      next();
      return parseFunction(node, false, false);

    case _class:
      return parseClass(startNode(), false);

    case _new:
      return parseNew();

    case _backQuote:
      return parseTemplate();

    case _hash:
      return parseBindFunctionExpression();

    case _jsxTagStart:
      return parseJSXElement();

    default:
      unexpected();
    }
  }

  function parseBindFunctionExpression() {
    var node = startNode();
    next();

    var start = storeCurrentPos();
    node.callee = parseSubscripts(parseExprAtom(), start, true);

    if (eat(_parenL)) {
      node.arguments = parseExprList(_parenR, false);
    } else {
      node.arguments = [];
    }

    return finishNode(node, "BindFunctionExpression");
  }

  function parseParenAndDistinguishExpression() {
    var start = storeCurrentPos(), val;
    if (options.ecmaVersion >= 6) {
      next();

      if (options.ecmaVersion >= 7 && tokType === _for) {
        return parseComprehension(startNodeAt(start), true);
      }

      var innerStart = storeCurrentPos(), exprList = [], first = true;
      var refShorthandDefaultPos = {start: 0}, spreadStart, innerParenStart, typeStart;

      var parseParenItem = function (node, start) {
        if (tokType === _colon) {
          var typeCastNode = startNodeAt(start);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = parseTypeAnnotation();
          return finishNode(typeCastNode, "TypeCastExpression");
        } else {
          return node;
        }
      };

      while (tokType !== _parenR) {
        first ? first = false : expect(_comma);
        if (tokType === _ellipsis) {
          var spreadNodeStart = storeCurrentPos();
          spreadStart = tokStart;
          exprList.push(parseParenItem(parseRest(), spreadNodeStart));
          break;
        } else {
          if (tokType === _parenL && !innerParenStart) {
            innerParenStart = tokStart;
          }
          exprList.push(parseMaybeAssign(false, refShorthandDefaultPos, parseParenItem));
        }
      }
      var innerEnd = storeCurrentPos();
      expect(_parenR);

      if (!canInsertSemicolon() && eat(_arrow)) {
        if (innerParenStart) unexpected(innerParenStart);

        for (var i = 0; i < exprList.length; i++) {
          var listItem = exprList[i];
          if (listItem.type === "TypeCastExpression") {
            var expr = listItem.expression;
            expr.returnType = listItem.typeAnnotation;
            exprList[i] = expr;
          }
        }

        return parseArrowExpression(startNodeAt(start), exprList);
      }

      if (!exprList.length) unexpected(lastStart);
      if (spreadStart) unexpected(spreadStart);
      if (refShorthandDefaultPos.start) unexpected(refShorthandDefaultPos.start);

      //

      if (exprList.length > 1) {
        val = startNodeAt(innerStart);
        val.expressions = exprList;
        finishNodeAt(val, "SequenceExpression", innerEnd);
      } else {
        val = exprList[0];
      }
    } else {
      val = parseParenExpression();
    }

    if (options.preserveParens) {
      var par = startNodeAt(start);
      par.expression = val;
      return finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  }

  // New's precedence is slightly tricky. It must allow its argument
  // to be a `[]` or dot subscript expression, but not a call — at
  // least, not without wrapping it in parentheses. Thus, it uses the

  function parseNew() {
    var node = startNode();
    next();
    var start = storeCurrentPos();
    node.callee = parseSubscripts(parseExprAtom(), start, true);
    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
    else node.arguments = empty;
    return finishNode(node, "NewExpression");
  }

  // Parse template expression.

  function parseTemplateElement() {
    var elem = startNode();
    elem.value = {
      raw: input.slice(tokStart, tokEnd),
      cooked: tokVal
    };
    next();
    elem.tail = tokType === _backQuote;
    return finishNode(elem, "TemplateElement");
  }

  function parseTemplate() {
    var node = startNode();
    next();
    node.expressions = [];
    var curElt = parseTemplateElement();
    node.quasis = [curElt];
    while (!curElt.tail) {
      expect(_dollarBraceL);
      node.expressions.push(parseExpression());
      expect(_braceR);
      node.quasis.push(curElt = parseTemplateElement());
    }
    next();
    return finishNode(node, "TemplateLiteral");
  }

  // Parse an object literal or binding pattern.

  function parseObj(isPattern, refShorthandDefaultPos) {
    var node = startNode(), first = true, propHash = {};
    node.properties = [];
    next();
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var prop = startNode(), start, isGenerator = false, isAsync = false;
      if (options.ecmaVersion >= 7 && tokType === _ellipsis) {
        prop = parseSpread();
        prop.type = "SpreadProperty";
        node.properties.push(prop);
        continue;
      }
      if (options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refShorthandDefaultPos) {
          start = storeCurrentPos();
        }
        if (!isPattern) {
          isGenerator = eat(_star);
        }
      }
      if (options.ecmaVersion >= 7 && isContextual("async")) {
        var asyncId = parseIdent();
        if (tokType === _colon || tokType === _parenL) {
          prop.key = asyncId;
        } else {
          isAsync = true;
          parsePropertyName(prop);
        }
      } else {
        parsePropertyName(prop);
      }
      var typeParameters
      if (isRelational("<")) {
        typeParameters = parseTypeParameterDeclaration();
        if (tokType !== _parenL) unexpected();
      }
      if (eat(_colon)) {
        prop.value = isPattern ? parseMaybeDefault() : parseMaybeAssign(false, refShorthandDefaultPos);
        prop.kind = "init";
      } else if (options.ecmaVersion >= 6 && tokType === _parenL) {
        if (isPattern) unexpected();
        prop.kind = "init";
        prop.method = true;
        prop.value = parseMethod(isGenerator, isAsync);
      } else if (options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set" || (options.playground && prop.key.name === "memo")) &&
                 (tokType != _comma && tokType != _braceR)) {
        if (isGenerator || isAsync || isPattern) unexpected();
        prop.kind = prop.key.name;
        parsePropertyName(prop);
        prop.value = parseMethod(false, false);
      } else if (options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        prop.kind = "init";
        if (isPattern) {
          prop.value = parseMaybeDefault(start, prop.key);
        } else if (tokType === _eq && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start)
            refShorthandDefaultPos.start = tokStart;
          prop.value = parseMaybeDefault(start, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else unexpected();

      prop.value.typeParameters = typeParameters;
      checkPropClash(prop, propHash);
      node.properties.push(finishNode(prop, "Property"));
    }
    return finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  }

  function parsePropertyName(prop) {
    if (options.ecmaVersion >= 6) {
      if (eat(_bracketL)) {
        prop.computed = true;
        prop.key = parseExpression();
        expect(_bracketR);
        return;
      } else {
        prop.computed = false;
      }
    }
    prop.key = (tokType === _num || tokType === _string) ? parseExprAtom() : parseIdent(true);
  }

  // Initialize empty function node.

  function initFunction(node, isAsync) {
    node.id = null;
    if (options.ecmaVersion >= 6) {
      node.generator = false;
      node.expression = false;
    }
    if (options.ecmaVersion >= 7) {
      node.async = isAsync;
    }
  }

  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).

  function parseFunction(node, isStatement, isAsync, allowExpressionBody) {
    initFunction(node, isAsync);
    if (options.ecmaVersion >= 6) {
      node.generator = eat(_star);
    }
    if (isStatement || tokType === _name) {
      node.id = parseIdent();
    }
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }
    parseFunctionParams(node);
    parseFunctionBody(node, allowExpressionBody);
    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  // Parse object or class method.

  function parseMethod(isGenerator, isAsync) {
    var node = startNode();
    initFunction(node, isAsync);
    parseFunctionParams(node);
    var allowExpressionBody;
    if (options.ecmaVersion >= 6) {
      node.generator = isGenerator;
      allowExpressionBody = true;
    } else {
      allowExpressionBody = false;
    }
    parseFunctionBody(node, allowExpressionBody);
    return finishNode(node, "FunctionExpression");
  }

  function parseFunctionParams(node) {
    expect(_parenL);
    node.params = parseBindingList(_parenR, false);
    if (tokType === _colon) {
      node.returnType = parseTypeAnnotation();
    }
  }

  // Parse arrow function expression with given parameters.

  function parseArrowExpression(node, params, isAsync) {
    initFunction(node, isAsync);
    node.params = toAssignableList(params, true);
    parseFunctionBody(node, true);
    return finishNode(node, "ArrowFunctionExpression");
  }

  // Parse function body and check parameters.

  function parseFunctionBody(node, allowExpression) {
    var isExpression = allowExpression && tokType !== _braceL;

    var oldInAsync = inAsync;
    inAsync = node.async;
    if (isExpression) {
      node.body = parseMaybeAssign();
      node.expression = true;
    } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
      var oldInFunc = inFunction, oldInGen = inGenerator, oldLabels = labels;
      inFunction = true; inGenerator = node.generator; labels = [];
      node.body = parseBlock(true);
      node.expression = false;
      inFunction = oldInFunc; inGenerator = oldInGen; labels = oldLabels;
    }
    inAsync = oldInAsync;

    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (strict || !isExpression && node.body.body.length && isUseStrict(node.body.body[0])) {
      var nameHash = {};
      if (node.id)
        checkFunctionParam(node.id, {});
      for (var i = 0; i < node.params.length; i++)
        checkFunctionParam(node.params[i], nameHash);
    }
  }

  function parsePrivate(node) {
    node.declarations = [];
    do {
      node.declarations.push(parseIdent());
    } while (eat(_comma));
    semicolon();
    return finishNode(node, "PrivateDeclaration");
  }

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).
  
  function parseClass(node, isStatement) {
    next();
    node.id = tokType === _name ? parseIdent() : isStatement ? unexpected() : null;
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }
    node.superClass = eat(_extends) ? parseExprSubscripts() : null;
    if (node.superClass && isRelational("<")) {
      node.superTypeParameters = parseTypeParameterInstantiation();
    }
    if (isContextual("implements")) {
      next();
      node.implements = parseClassImplements();
    }
    var classBody = startNode();
    classBody.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      if (eat(_semi)) continue;
      var method = startNode();
      if (options.ecmaVersion >= 7 && isContextual("private")) {
        next();
        classBody.body.push(parsePrivate(method));
        continue;
      }
      var isGenerator = eat(_star);
      var isAsync = false;
      parsePropertyName(method);
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          method.key.name === "static") {
        if (isGenerator || isAsync) unexpected();
        method['static'] = true;
        isGenerator = eat(_star);
        parsePropertyName(method);
      } else {
        method['static'] = false;
      }
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          method.key.name === "async") {
        isAsync = true;
        parsePropertyName(method);
      }
      if (tokType !== _parenL && !method.computed && method.key.type === "Identifier" &&
          (method.key.name === "get" || method.key.name === "set") || (options.playground && method.key.name === "memo")) {
        if (isGenerator || isAsync) unexpected();
        method.kind = method.key.name;
        parsePropertyName(method);
      } else {
        method.kind = "";
      }

      var classProperty = false;

      if (tokType === _colon) {
        method.typeAnnotation = parseTypeAnnotation();
        classProperty = true;
      }

      if (options.playground && eat(_eq)) {
        method.value = parseMaybeAssign();
        classProperty = true;
      }

      if (classProperty) {
        semicolon();
        classBody.body.push(finishNode(method, "ClassProperty"));
      } else {
        var typeParameters;
        if (isRelational("<")) {
          typeParameters = parseTypeParameterDeclaration();
        }
        method.value = parseMethod(isGenerator, isAsync);
        method.value.typeParameters = typeParameters;
        classBody.body.push(finishNode(method, "MethodDefinition"));
        eat(_semi);
      }
    }
    node.body = finishNode(classBody, "ClassBody");
    return finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }

  function parseClassImplements() {
      var implemented = [];

      do {
        var node = startNode();
        node.id = parseIdent();
        if (isRelational("<")) {
            node.typeParameters = parseTypeParameterInstantiation();
        } else {
            node.typeParameters = null;
        }
        implemented.push(finishNode(node, "ClassImplements"));
      } while(eat(_comma));

      return implemented;
  }

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  function parseExprList(close, allowTrailingComma, allowEmpty, refShorthandDefaultPos) {
    var elts = [], first = true;
    while (!eat(close)) {
      if (!first) {
        expect(_comma);
        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
      } else first = false;

      if (allowEmpty && tokType === _comma) {
        elts.push(null);
      } else {
        if (tokType === _ellipsis)
          elts.push(parseSpread(refShorthandDefaultPos));
        else
          elts.push(parseMaybeAssign(false, refShorthandDefaultPos));
      }
    }
    return elts;
  }

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  function parseIdent(liberal) {
    var node = startNode();
    if (liberal && options.forbidReserved == "everywhere") liberal = false;
    if (tokType === _name) {
      if (!liberal &&
          (options.forbidReserved &&
           (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
           strict && isStrictReservedWord(tokVal)) &&
          input.slice(tokStart, tokEnd).indexOf("\\") == -1)
        raise(tokStart, "The keyword '" + tokVal + "' is reserved");
      node.name = tokVal;
    } else if (liberal && tokType.keyword) {
      node.name = tokType.keyword;
    } else {
      unexpected();
    }
    next();
    return finishNode(node, "Identifier");
  }

  // Parses module export declaration.

  function parseExport(node) {
    next();
    // export var|const|let|function|class ...;
    if (tokType === _var || tokType === _const || tokType === _let || tokType === _function || tokType === _class || isContextual("async") || isContextual("type")) {
      node.declaration = parseStatement(true);
      node['default'] = false;
      node.specifiers = null;
      node.source = null;
    } else
    // export default ...;
    if (eat(_default)) {
      var expr = parseMaybeAssign();
      if (expr.id) {
        switch (expr.type) {
          case "FunctionExpression": expr.type = "FunctionDeclaration"; break;
          case "ClassExpression": expr.type = "ClassDeclaration"; break;
        }
      }
      node.declaration = expr;
      node['default'] = true;
      node.specifiers = null;
      node.source = null;
      semicolon();
    } else {
      // export * from '...';
      // export { x, y as z } [from '...'];
      var isBatch = tokType === _star;
      node.declaration = null;
      node['default'] = false;
      node.specifiers = parseExportSpecifiers();
      if (eatContextual("from")) {
        node.source = tokType === _string ? parseExprAtom() : unexpected();
      } else {
        if (isBatch) unexpected();
        node.source = null;
      }
      semicolon();
    }
    return finishNode(node, "ExportDeclaration");
  }

  // Parses a comma-separated list of module exports.

  function parseExportSpecifiers() {
    var nodes = [], first = true;
    if (tokType === _star) {
      // export * from '...'
      var node = startNode();
      next();
      nodes.push(finishNode(node, "ExportBatchSpecifier"));
    } else {
      // export { x, y as z } [from '...']
      expect(_braceL);
      while (!eat(_braceR)) {
        if (!first) {
          expect(_comma);
          if (options.allowTrailingCommas && eat(_braceR)) break;
        } else first = false;

        var node = startNode();
        node.id = parseIdent(tokType === _default);
        node.name = eatContextual("as") ? parseIdent(true) : null;
        nodes.push(finishNode(node, "ExportSpecifier"));
      }
    }
    return nodes;
  }

  // Parses import declaration.

  function parseImport(node) {
    next();
    
    node.isType = false;
    node.specifiers = [];

    var typeId;
    if (isContextual('type')) {
      var start = storeCurrentPos();
      typeId = parseIdent();
      if ((tokType === _name && tokVal !== "from") || tokType === _braceL || tokType === _star) {
        node.isType = true;
      } else {
        node.specifiers.push(parseImportSpecifierDefault(typeId, start));
        eat(_comma);
      }
    }

    
    // import '...';
    if (tokType === _string) {
      if (typeId) unexpected(typeId.start);
      node.source = parseExprAtom();
    } else {
      if (!isContextual("from")) parseImportSpecifiers(node.specifiers);
      expectContextual("from");
      node.source = tokType === _string ? parseExprAtom() : unexpected();
    }
    semicolon();
    return finishNode(node, "ImportDeclaration");
  }

  // Parses a comma-separated list of module imports.

  function parseImportSpecifiers(nodes) {
    var first = true;
    if (tokType === _name) {
      // import defaultObj, { x, y as z } from '...'
      var start = storeCurrentPos();
      var id = parseIdent();
      nodes.push(parseImportSpecifierDefault(id, start));
      if (!eat(_comma)) return nodes;
    }
    if (tokType === _star) {
      var node = startNode();
      next();
      expectContextual("as");
      node.name = parseIdent();
      checkLVal(node.name, true);
      nodes.push(finishNode(node, "ImportBatchSpecifier"));
      return nodes;
    }
    expect(_braceL);
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var node = startNode();
      node.id = parseIdent(true);
      node.name = eatContextual("as") ? parseIdent() : null;
      checkLVal(node.name || node.id, true);
      node['default'] = false;
      nodes.push(finishNode(node, "ImportSpecifier"));
    }
    return nodes;
  }

  function parseImportSpecifierDefault(id, start) {
    var node = startNodeAt(start);
    node.id = id;
    checkLVal(node.id, true);
    node.name = null;
    node['default'] = true;
    return finishNode(node, "ImportSpecifier");
  }

  // Parses yield expression inside generator.

  function parseYield() {
    var node = startNode();
    next();
    if (eat(_semi) || canInsertSemicolon()) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = eat(_star);
      node.argument = parseMaybeAssign();
    }
    return finishNode(node, "YieldExpression");
  }

  // Parses await expression inside async function.

  function parseAwait(node) {
    if (eat(_semi) || canInsertSemicolon()) {
      unexpected();
    }
    node.all = eat(_star);
    node.argument = parseMaybeAssign(true);
    return finishNode(node, "AwaitExpression");
  }

  // Parses array and generator comprehensions.

  function parseComprehension(node, isGenerator) {
    node.blocks = [];
    while (tokType === _for) {
      var block = startNode();
      next();
      expect(_parenL);
      block.left = parseBindingAtom();
      checkLVal(block.left, true);
      expectContextual("of");
      block.right = parseExpression();
      expect(_parenR);
      node.blocks.push(finishNode(block, "ComprehensionBlock"));
    }
    node.filter = eat(_if) ? parseParenExpression() : null;
    node.body = parseExpression();
    expect(isGenerator ? _parenR : _bracketR);
    node.generator = isGenerator;
    return finishNode(node, "ComprehensionExpression");
  }

  // Transforms JSX element name to string.

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ':' + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return (
        getQualifiedJSXName(object.object) + '.' +
        getQualifiedJSXName(object.property)
      );
    }
  }

  // Parse next token as JSX identifier

  function parseJSXIdentifier() {
    var node = startNode();
    if (tokType === _jsxName) {
      node.name = tokVal;
    } else if (tokType.keyword) {
      node.name = tokType.keyword;
    } else {
      unexpected();
    }
    next();
    return finishNode(node, "JSXIdentifier");
  }

  // Parse namespaced identifier.

  function parseJSXNamespacedName() {
    var start = storeCurrentPos();
    var name = parseJSXIdentifier();
    if (!eat(_colon)) return name;
    var node = startNodeAt(start);
    node.namespace = name;
    node.name = parseJSXIdentifier();
    return finishNode(node, "JSXNamespacedName");
  }

  // Parses element name in any form - namespaced, member
  // or single identifier.

  function parseJSXElementName() {
    var start = storeCurrentPos();
    var node = parseJSXNamespacedName();
    while (eat(_dot)) {
      var newNode = startNodeAt(start);
      newNode.object = node;
      newNode.property = parseJSXIdentifier();
      node = finishNode(newNode, "JSXMemberExpression");
    }
    return node;
  }

  // Parses any type of JSX attribute value.

  function parseJSXAttributeValue() {
    switch (tokType) {
      case _braceL:
        var node = parseJSXExpressionContainer();
        if (node.expression.type === "JSXEmptyExpression") {
          raise(
            node.start,
              'JSX attributes must only be assigned a non-empty ' +
              'expression'
          );
        }
        return node;

      case _jsxTagStart:
        return parseJSXElement();

      case _jsxText:
      case _string:
        return parseExprAtom();

      default:
        raise(tokStart, "JSX value should be either an expression or a quoted JSX text");
    }
  }

  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
  // and so it should start at the end of last read token (left brace) and finish
  // at the beginning of the next one (right brace).

  function parseJSXEmptyExpression() {
    if (tokType !== _braceR) {
      unexpected();
    }

    var tmp;

    tmp = tokStart;
    tokStart = lastEnd;
    lastEnd = tmp;

    tmp = tokStartLoc;
    tokStartLoc = lastEndLoc;
    lastEndLoc = tmp;

    return finishNode(startNode(), "JSXEmptyExpression");
  }

  // Parses JSX expression enclosed into curly brackets.

  function parseJSXExpressionContainer() {
    var node = startNode();
    next();
    node.expression = tokType === _braceR ? parseJSXEmptyExpression() : parseExpression();
    expect(_braceR);
    return finishNode(node, "JSXExpressionContainer");
  }

  // Parses following JSX attribute name-value pair.

  function parseJSXAttribute() {
    var node = startNode();
    if (eat(_braceL)) {
      expect(_ellipsis);
      node.argument = parseMaybeAssign();
      expect(_braceR);
      return finishNode(node, "JSXSpreadAttribute");
    }
    node.name = parseJSXNamespacedName();
    node.value = eat(_eq) ? parseJSXAttributeValue() : null;
    return finishNode(node, "JSXAttribute");
  }

  // Parses JSX opening tag starting after '<'.

  function parseJSXOpeningElementAt(start) {
    var node = startNodeAt(start);
    node.attributes = [];
    node.name = parseJSXElementName();
    while (tokType !== _slash && tokType !== _jsxTagEnd) {
      node.attributes.push(parseJSXAttribute());
    }
    node.selfClosing = eat(_slash);
    expect(_jsxTagEnd);
    return finishNode(node, "JSXOpeningElement");
  }

  // Parses JSX closing tag starting after '</'.

  function parseJSXClosingElementAt(start) {
    var node = startNodeAt(start);
    node.name = parseJSXElementName();
    expect(_jsxTagEnd);
    return finishNode(node, "JSXClosingElement");
  }

  // Parses entire JSX element, including it's opening tag
  // (starting after '<'), attributes, contents and closing tag.

  function parseJSXElementAt(start) {
    var node = startNodeAt(start);
    var children = [];
    var openingElement = parseJSXOpeningElementAt(start);
    var closingElement = null;

    if (!openingElement.selfClosing) {
      contents:for (;;) {
        switch (tokType) {
          case _jsxTagStart:
            start = storeCurrentPos();
            next();
            if (eat(_slash)) {
              closingElement = parseJSXClosingElementAt(start);
              break contents;
            }
            children.push(parseJSXElementAt(start));
            break;

          case _jsxText:
            children.push(parseExprAtom());
            break;

          case _braceL:
            children.push(parseJSXExpressionContainer());
            break;

          default:
            unexpected();
        }
      }
      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
        raise(
          closingElement.start,
          "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
        );
      }
    }

    node.openingElement = openingElement;
    node.closingElement = closingElement;
    node.children = children;
    return finishNode(node, "JSXElement");
  }

  function isRelational(op) {
    return tokType === _relational && tokVal === op;
  }

  function expectRelational(op) {
    if (isRelational(op)) {
      next();
    } else {
      unexpected();
    }
  }

  // Parses entire JSX element from current position.

  function parseJSXElement() {
    var start = storeCurrentPos();
    next();
    return parseJSXElementAt(start);
  }

  // Declare
  
  function parseDeclareClass(node) {
    next();
    parseInterfaceish(node, true);
    return finishNode(node, "DeclareClass");
  }

  function parseDeclareFunction(node) {
    next();

    var id = node.id = parseIdent();

    var typeNode = startNode();
    var typeContainer = startNode();

    if (isRelational("<")) {
      typeNode.typeParameters = parseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }

    expect(_parenL);
    var tmp = parseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    expect(_parenR);

    expect(_colon);
    typeNode.returnType = parseType();

    typeContainer.typeAnnotation = finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = finishNode(typeContainer, "TypeAnnotation");

    finishNode(id, id.type);

    semicolon();

    return finishNode(node, "DeclareFunction");
  }

  function parseDeclare(node) {
    if (tokType === _class) {
      return parseDeclareClass(node);
    } else if (tokType === _function) {
      return parseDeclareFunction(node);
    } else if (tokType === _var) {
      return parseDeclareVariable(node);
    } else if (isContextual("module")) {
      return parseDeclareModule(node);
    } else {
      unexpected();
    }
  }

  function parseDeclareVariable(node) {
    next();
    node.id = parseTypeAnnotatableIdentifier();
    semicolon();
    return finishNode(node, "DeclareVariable");
  }

  function parseDeclareModule(node) {
    next();

    if (tokType === _string) {
      node.id = parseExprAtom();
    } else {
      node.id = parseIdent();
    }

    var bodyNode = node.body = startNode();
    var body = bodyNode.body = [];
    expect(_braceL);
    while (tokType !== _braceR) {
      var node2 = startNode();

      // todo: declare check
      next();

      body.push(parseDeclare(node2));
    }
    expect(_braceR);

    finishNode(bodyNode, "BlockStatement");
    return finishNode(node, "DeclareModule");
  }


  // Interfaces

  function parseInterfaceish(node, allowStatic) {
    node.id = parseIdent();
    
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.extends = [];

    if (eat(_extends)) {
      do {
        node.extends.push(parseInterfaceExtends());
      } while(eat(_comma));
    }

    node.body = parseObjectType(allowStatic);
  }

  function parseInterfaceExtends() {
    var node = startNode();

    node.id = parseIdent();
    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }

    return finishNode(node, "InterfaceExtends");
  }

  function parseInterface(node) {
    parseInterfaceish(node, false);
    return finishNode(node, "InterfaceDeclaration");
  }

  // Type aliases
  
  function parseTypeAlias(node) {
    node.id = parseIdent();

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    expect(_eq);

    node.right = parseType();

    semicolon();

    return finishNode(node, "TypeAlias");
  }

  // Type annotations

  function parseTypeParameterDeclaration() {
    var node = startNode();
    node.params = [];

    expectRelational("<");
    while (!isRelational(">")) {
      node.params.push(parseIdent());
      if (!isRelational(">")) {
        expect(_comma);
      }
    }
    expectRelational(">");

    return finishNode(node, "TypeParameterDeclaration");
  }

  function parseTypeParameterInstantiation() {
    var node = startNode(), oldInType = inType;
    node.params = [];

    inType = true;

    expectRelational("<");
    while (!isRelational(">")) {
      node.params.push(parseType());
      if (!isRelational(">")) {
        expect(_comma);
      }
    }
    expectRelational(">");

    inType = oldInType;

    return finishNode(node, "TypeParameterInstantiation");
  }

  function parseObjectPropertyKey() {
    return (tokType === _num || tokType === _string) ? parseExprAtom() : parseIdent(true);
  }

  function parseObjectTypeIndexer(node, isStatic) {
    node.static = isStatic;

    expect(_bracketL);
    node.id = parseObjectPropertyKey();
    expect(_colon);
    node.key = parseType();
    expect(_bracketR);
    expect(_colon);
    node.value = parseType();

    return finishNode(node, "ObjectTypeIndexer");
  }

  function parseObjectTypeMethodish(node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterDeclaration();
    }

    expect(_parenL);
    while (tokType === _name) {
      node.params.push(parseFunctionTypeParam());
      if (tokType !== _parenR) {
        expect(_comma);
      }
    }

    if (eat(_ellipsis)) {
      node.rest = parseFunctionTypeParam();
    }
    expect(_parenR);
    expect(_colon);
    node.returnType = parseType();

    return finishNode(node, "FunctionTypeAnnotation");
  }

  function parseObjectTypeMethod(start, isStatic, key) {
    var node = startNodeAt(start);
    node.value = parseObjectTypeMethodish(startNodeAt(start));
    node.static = isStatic;
    node.key = key;
    node.optional = false;
    return finishNode(node, "ObjectTypeProperty");
  }

  function parseObjectTypeCallProperty(node, isStatic) {
    var valueNode = startNode();
    node.static = isStatic;
    node.value = parseObjectTypeMethodish(valueNode);
    return finishNode(node, "ObjectTypeCallProperty");
  }

  function parseObjectType(allowStatic) {
    var nodeStart = startNode();
    var node;
    var optional = false;
    var property;
    var propertyKey;
    var propertyTypeAnnotation;
    var token;
    var isStatic;

    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];

    expect(_braceL);

    while (tokType !== _braceR) {
      var start = storeCurrentPos();
      node = startNode();
      if (allowStatic && isContextual("static")) {
        next();
        isStatic = true;
      }

      if (tokType === _bracketL) {
        nodeStart.indexers.push(parseObjectTypeIndexer(node, isStatic));
      } else if (tokType === _parenL || isRelational("<")) {
        nodeStart.callProperties.push(parseObjectTypeCallProperty(node, allowStatic));
      } else {
        if (isStatic && tokType === _colon) {
          propertyKey = parseIdent();
        } else {
          propertyKey = parseObjectPropertyKey();
        }
        if (isRelational("<") || tokType === _parenL) {
          // This is a method property
          nodeStart.properties.push(parseObjectTypeMethod(start, isStatic, propertyKey));
        } else {
          if (eat(_question)) {
            optional = true;
          }
          expect(_colon);
          node.key = propertyKey;
          node.value = parseType();
          node.optional = optional;
          node.static = isStatic;
          nodeStart.properties.push(finishNode(node, "ObjectTypeProperty"));
        }
      }

      if (!eat(_semi) && tokType !== _braceR) {
        unexpected();
      }
    }

    expect(_braceR);

    return finishNode(nodeStart, "ObjectTypeAnnotation")
  }

  function parseGenericType(start, id) {
    var node = startNodeAt(start);

    node.typeParameters = null;
    node.id = id;

    while (eat(_dot)) {
      var node2 = startNodeAt(start);
      node2.qualification = node.id;
      node2.id = parseIdent();
      node.id = finishNode(node2, "QualifiedTypeIdentifier");
    }

    if (isRelational("<")) {
      node.typeParameters = parseTypeParameterInstantiation();
    }

    return finishNode(node, "GenericTypeAnnotation");
  }

  function parseVoidType() {
    var node = startNode();
    expect(keywordTypes["void"]);
    return finishNode(node, "VoidTypeAnnotation");
  }

  function parseTypeofType() {
    var node = startNode();
    expect(keywordTypes["typeof"]);
    node.argument = parsePrimaryType();
    return finishNode(node, "TypeofTypeAnnotation");
  }

  function parseTupleType() {
    var node = startNode();
    node.types = [];
    expect(_bracketL);
    // We allow trailing commas
    while (tokPos < inputLen && tokType !== _bracketR) {
      node.types.push(parseType());
      if (tokType === _bracketR) break;
      expect(_comma);
    }
    expect(_bracketR);
    return finishNode(node, "TupleTypeAnnotation");
  }

  function parseFunctionTypeParam() {
    var optional = false;
    var node = startNode();
    node.name = parseIdent();
    if (eat(_question)) {
      optional = true;
    }
    expect(_colon);
    node.optional = optional;
    node.typeAnnotation = parseType();
    return finishNode(node, "FunctionTypeParam");
  }

  function parseFunctionTypeParams() {
    var ret = { params: [], rest: null };
    while (tokType === _name) {
      ret.params.push(parseFunctionTypeParam());
      if (tokType !== _parenR) {
        expect(_comma);
      }
    }

    if (eat(_ellipsis)) {
      ret.rest = parseFunctionTypeParam();
    }
    return ret;
  }

  function identToTypeAnnotation(start, node, id) {
    switch (id.name) {
      case 'any':
        return finishNode(node, "AnyTypeAnnotation");

      case 'bool':
      case 'boolean':
        return finishNode(node, "BooleanTypeAnnotation");

      case 'number':
        return finishNode(node, "NumberTypeAnnotation");

      case 'string':
        return finishNode(node, "StringTypeAnnotation");

      default:
        return parseGenericType(start, id);
    }
  }

  // The parsing of types roughly parallels the parsing of expressions, and
  // primary types are kind of like primary expressions...they're the
  // primitives with which other types are constructed.
  function parsePrimaryType() {
    var typeIdentifier = null;
    var params = null;
    var returnType = null;
    var start = storeCurrentPos();
    var node = startNode();
    var rest = null;
    var tmp;
    var typeParameters;
    var token;
    var type;
    var isGroupedType = false;

    switch (tokType) {
      case _name:
        return identToTypeAnnotation(start, node, parseIdent());

      case _braceL:
        return parseObjectType();

      case _bracketL:
        return parseTupleType();

      case _relational:
        if (tokVal === "<") {
          node.typeParameters = parseTypeParameterDeclaration();
          expect(_parenL);
          tmp = parseFunctionTypeParams();
          node.params = tmp.params;
          node.rest = tmp.rest;
          expect(_parenR);

          expect(_arrow);

          node.returnType = parseType();

          return finishNode(node, "FunctionTypeAnnotation");
        }

      case _parenL:
        next();

        var tmpId;

        // Check to see if this is actually a grouped type
        if (tokType !== _parenR && tokType !== _ellipsis) {
          if (tokType === _name) {
            //raise(tokStart, "Grouped types are currently the only flow feature not supported, request it?");
            //tmpId = identToTypeAnnotation(start, node, parseIdent());
            //next();
            //isGroupedType = tokType !== _question && tokType !== _colon;
          } else {
            isGroupedType = true;
          }
        }

        if (isGroupedType) {
          if (tmpId && _parenR) {
            type = tmpId;
          } else {
            type = parseType();
            expect(_parenR);
          }

          // If we see a => next then someone was probably confused about
          // function types, so we can provide a better error message
          if (eat(_arrow)) {
            raise(node,
              'Unexpected token =>. It looks like ' +
              'you are trying to write a function type, but you ended up ' +
              'writing a grouped type followed by an =>, which is a syntax ' +
              'error. Remember, function type parameters are named so function ' +
              'types look like (name1: type1, name2: type2) => returnType. You ' +
              'probably wrote (type1) => returnType'
            );
          }

          return type;
        }

        tmp = parseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;

        expect(_parenR);

        expect(_arrow);

        node.returnType = parseType();
        node.typeParameters = null;

        return finishNode(node, "FunctionTypeAnnotation");

      case _string:
        node.value = tokVal;
        node.raw = input.slice(tokStart, tokEnd);
        next();
        return finishNode(node, "StringLiteralTypeAnnotation");

      default:
        if (tokType.keyword) {
          switch (tokType.keyword) {
            case 'void':
              return parseVoidType();

            case 'typeof':
              return parseTypeofType();
          }
        }
    }

    unexpected();
  }

  function parsePostfixType() {
    var node = startNode();
    var type = node.elementType = parsePrimaryType();
    if (tokType === _bracketL) {
      expect(_bracketL);
      expect(_bracketR);
      return finishNode(node, "ArrayTypeAnnotation");
    }
    return type;
  }

  function parsePrefixType() {
    var node = startNode();
    if (eat(_question)) {
      node.typeAnnotation = parsePrefixType();
      return finishNode(node, "NullableTypeAnnotation");
    }
    return parsePostfixType();
  }

  function parseIntersectionType() {
    var node = startNode();
    var type = parsePrefixType();
    node.types = [type];
    while (eat(_bitwiseAND)) {
      node.types.push(parsePrefixType());
    }
    return node.types.length === 1 ? type : finishNode(node, "IntersectionTypeAnnotation");
  }

  function parseUnionType() {
    var node = startNode();
    var type = parseIntersectionType();
    node.types = [type];
    while (eat(_bitwiseOR)) {
      node.types.push(parseIntersectionType());
    }
    return node.types.length === 1 ? type : finishNode(node, "UnionTypeAnnotation");
  }

  function parseType() {
    var oldInType = inType;
    inType = true;
    var type = parseUnionType();
    inType = oldInType;
    return type;
  }

  function parseTypeAnnotation() {
    var node = startNode();

    var oldInType = inType;
    inType = true;
    expect(_colon);
    node.typeAnnotation = parseType();
    inType = oldInType;

    return finishNode(node, "TypeAnnotation");
  }

  function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
    var node = startNode();
    var ident = parseIdent();
    var isOptionalParam = false;

    if (canBeOptionalParam && eat(_question)) {
      expect(_question);
      isOptionalParam = true;
    }

    if (requireTypeAnnotation || tokType === _colon) {
      ident.typeAnnotation = parseTypeAnnotation();
      finishNode(ident, ident.type);
    }

    if (isOptionalParam) {
      ident.optional = true;
      finishNode(ident, ident.type);
    }

    return ident;
  }
});

},{}],126:[function(require,module,exports){
var types = require("../lib/types");
var Type = types.Type;
var def = Type.def;
var or = Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isNumber = builtin.number;
var isBoolean = builtin.boolean;
var isRegExp = builtin.RegExp;
var shared = require("../lib/shared");
var defaults = shared.defaults;
var geq = shared.geq;

// Abstract supertype of all syntactic entities that are allowed to have a
// .loc field.
def("Printable")
    .field("loc", or(
        def("SourceLocation"),
        null
    ), defaults["null"], true);

def("Node")
    .bases("Printable")
    .field("type", isString)
    .field("comments", or(
        [def("Comment")],
        null
    ), defaults["null"], true);

def("SourceLocation")
    .build("start", "end", "source")
    .field("start", def("Position"))
    .field("end", def("Position"))
    .field("source", or(isString, null), defaults["null"]);

def("Position")
    .build("line", "column")
    .field("line", geq(1))
    .field("column", geq(0));

def("Program")
    .bases("Node")
    .build("body")
    .field("body", [def("Statement")]);

def("Function")
    .bases("Node")
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("params", [def("Pattern")])
    .field("body", or(def("BlockStatement"), def("Expression")));

def("Statement").bases("Node");

// The empty .build() here means that an EmptyStatement can be constructed
// (i.e. it's not abstract) but that it needs no arguments.
def("EmptyStatement").bases("Statement").build();

def("BlockStatement")
    .bases("Statement")
    .build("body")
    .field("body", [def("Statement")]);

// TODO Figure out how to silently coerce Expressions to
// ExpressionStatements where a Statement was expected.
def("ExpressionStatement")
    .bases("Statement")
    .build("expression")
    .field("expression", def("Expression"));

def("IfStatement")
    .bases("Statement")
    .build("test", "consequent", "alternate")
    .field("test", def("Expression"))
    .field("consequent", def("Statement"))
    .field("alternate", or(def("Statement"), null), defaults["null"]);

def("LabeledStatement")
    .bases("Statement")
    .build("label", "body")
    .field("label", def("Identifier"))
    .field("body", def("Statement"));

def("BreakStatement")
    .bases("Statement")
    .build("label")
    .field("label", or(def("Identifier"), null), defaults["null"]);

def("ContinueStatement")
    .bases("Statement")
    .build("label")
    .field("label", or(def("Identifier"), null), defaults["null"]);

def("WithStatement")
    .bases("Statement")
    .build("object", "body")
    .field("object", def("Expression"))
    .field("body", def("Statement"));

def("SwitchStatement")
    .bases("Statement")
    .build("discriminant", "cases", "lexical")
    .field("discriminant", def("Expression"))
    .field("cases", [def("SwitchCase")])
    .field("lexical", isBoolean, defaults["false"]);

def("ReturnStatement")
    .bases("Statement")
    .build("argument")
    .field("argument", or(def("Expression"), null));

def("ThrowStatement")
    .bases("Statement")
    .build("argument")
    .field("argument", def("Expression"));

def("TryStatement")
    .bases("Statement")
    .build("block", "handler", "finalizer")
    .field("block", def("BlockStatement"))
    .field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
    })
    .field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
    }, true) // Indicates this field is hidden from eachField iteration.
    .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
    .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);

def("CatchClause")
    .bases("Node")
    .build("param", "guard", "body")
    .field("param", def("Pattern"))
    .field("guard", or(def("Expression"), null), defaults["null"])
    .field("body", def("BlockStatement"));

def("WhileStatement")
    .bases("Statement")
    .build("test", "body")
    .field("test", def("Expression"))
    .field("body", def("Statement"));

def("DoWhileStatement")
    .bases("Statement")
    .build("body", "test")
    .field("body", def("Statement"))
    .field("test", def("Expression"));

def("ForStatement")
    .bases("Statement")
    .build("init", "test", "update", "body")
    .field("init", or(
        def("VariableDeclaration"),
        def("Expression"),
        null))
    .field("test", or(def("Expression"), null))
    .field("update", or(def("Expression"), null))
    .field("body", def("Statement"));

def("ForInStatement")
    .bases("Statement")
    .build("left", "right", "body", "each")
    .field("left", or(
        def("VariableDeclaration"),
        def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"))
    .field("each", isBoolean);

def("DebuggerStatement").bases("Statement").build();

def("Declaration").bases("Statement");

def("FunctionDeclaration")
    .bases("Function", "Declaration")
    .build("id", "params", "body")
    .field("id", def("Identifier"));

def("FunctionExpression")
    .bases("Function", "Expression")
    .build("id", "params", "body");

def("VariableDeclaration")
    .bases("Declaration")
    .build("kind", "declarations")
    .field("kind", or("var", "let", "const"))
    .field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier") // TODO Esprima deviation.
    )]);

def("VariableDeclarator")
    .bases("Node")
    .build("id", "init")
    .field("id", def("Pattern"))
    .field("init", or(def("Expression"), null));

// TODO Are all Expressions really Patterns?
def("Expression").bases("Node", "Pattern");

def("ThisExpression").bases("Expression").build();

def("ArrayExpression")
    .bases("Expression")
    .build("elements")
    .field("elements", [or(def("Expression"), null)]);

def("ObjectExpression")
    .bases("Expression")
    .build("properties")
    .field("properties", [def("Property")]);

// TODO Not in the Mozilla Parser API, but used by Esprima.
def("Property")
    .bases("Node") // Want to be able to visit Property Nodes.
    .build("kind", "key", "value")
    .field("kind", or("init", "get", "set"))
    .field("key", or(def("Literal"), def("Identifier")))
    // esprima allows Pattern
    .field("value", or(def("Expression"), def("Pattern")));

def("SequenceExpression")
    .bases("Expression")
    .build("expressions")
    .field("expressions", [def("Expression")]);

var UnaryOperator = or(
    "-", "+", "!", "~",
    "typeof", "void", "delete");

def("UnaryExpression")
    .bases("Expression")
    .build("operator", "argument", "prefix")
    .field("operator", UnaryOperator)
    .field("argument", def("Expression"))
    // TODO Esprima doesn't bother with this field, presumably because
    // it's always true for unary operators.
    .field("prefix", isBoolean, defaults["true"]);

var BinaryOperator = or(
    "==", "!=", "===", "!==",
    "<", "<=", ">", ">=",
    "<<", ">>", ">>>",
    "+", "-", "*", "/", "%",
    "&", // TODO Missing from the Parser API.
    "|", "^", "in",
    "instanceof", "..");

def("BinaryExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", BinaryOperator)
    .field("left", def("Expression"))
    .field("right", def("Expression"));

var AssignmentOperator = or(
    "=", "+=", "-=", "*=", "/=", "%=",
    "<<=", ">>=", ">>>=",
    "|=", "^=", "&=");

def("AssignmentExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", AssignmentOperator)
    .field("left", def("Pattern"))
    .field("right", def("Expression"));

var UpdateOperator = or("++", "--");

def("UpdateExpression")
    .bases("Expression")
    .build("operator", "argument", "prefix")
    .field("operator", UpdateOperator)
    .field("argument", def("Expression"))
    .field("prefix", isBoolean);

var LogicalOperator = or("||", "&&");

def("LogicalExpression")
    .bases("Expression")
    .build("operator", "left", "right")
    .field("operator", LogicalOperator)
    .field("left", def("Expression"))
    .field("right", def("Expression"));

def("ConditionalExpression")
    .bases("Expression")
    .build("test", "consequent", "alternate")
    .field("test", def("Expression"))
    .field("consequent", def("Expression"))
    .field("alternate", def("Expression"));

def("NewExpression")
    .bases("Expression")
    .build("callee", "arguments")
    .field("callee", def("Expression"))
    // The Mozilla Parser API gives this type as [or(def("Expression"),
    // null)], but null values don't really make sense at the call site.
    // TODO Report this nonsense.
    .field("arguments", [def("Expression")]);

def("CallExpression")
    .bases("Expression")
    .build("callee", "arguments")
    .field("callee", def("Expression"))
    // See comment for NewExpression above.
    .field("arguments", [def("Expression")]);

def("MemberExpression")
    .bases("Expression")
    .build("object", "property", "computed")
    .field("object", def("Expression"))
    .field("property", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("Pattern").bases("Node");

def("ObjectPattern")
    .bases("Pattern")
    .build("properties")
    // TODO File a bug to get PropertyPattern added to the interfaces API.
    // esprima uses Property
    .field("properties", [or(def("PropertyPattern"), def("Property"))]);

def("PropertyPattern")
    .bases("Pattern")
    .build("key", "pattern")
    .field("key", or(def("Literal"), def("Identifier")))
    .field("pattern", def("Pattern"));

def("ArrayPattern")
    .bases("Pattern")
    .build("elements")
    .field("elements", [or(def("Pattern"), null)]);

def("SwitchCase")
    .bases("Node")
    .build("test", "consequent")
    .field("test", or(def("Expression"), null))
    .field("consequent", [def("Statement")]);

def("Identifier")
    // But aren't Expressions and Patterns already Nodes? TODO Report this.
    .bases("Node", "Expression", "Pattern")
    .build("name")
    .field("name", isString);

def("Literal")
    // But aren't Expressions already Nodes? TODO Report this.
    .bases("Node", "Expression")
    .build("value")
    .field("value", or(
        isString,
        isBoolean,
        null, // isNull would also work here.
        isNumber,
        isRegExp
    ));

// Abstract (non-buildable) comment supertype. Not a Node.
def("Comment")
    .bases("Printable")
    .field("value", isString)
    // A .leading comment comes before the node, whereas a .trailing
    // comment comes after it. These two fields should not both be true,
    // but they might both be false when the comment falls inside a node
    // and the node has no children for the comment to lead or trail,
    // e.g. { /*dangling*/ }.
    .field("leading", isBoolean, defaults["true"])
    .field("trailing", isBoolean, defaults["false"]);

// Block comment. The .type really should be BlockComment rather than
// Block, but that's what we're stuck with for now.
def("Block")
    .bases("Comment")
    .build("value", /*optional:*/ "leading", "trailing");

// Single line comment. The .type really should be LineComment rather than
// Line, but that's what we're stuck with for now.
def("Line")
    .bases("Comment")
    .build("value", /*optional:*/ "leading", "trailing");

},{"../lib/shared":137,"../lib/types":138}],127:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isBoolean = builtin.boolean;

// Note that none of these types are buildable because the Mozilla Parser
// API doesn't specify any builder functions, and nobody uses E4X anymore.

def("XMLDefaultDeclaration")
    .bases("Declaration")
    .field("namespace", def("Expression"));

def("XMLAnyName").bases("Expression");

def("XMLQualifiedIdentifier")
    .bases("Expression")
    .field("left", or(def("Identifier"), def("XMLAnyName")))
    .field("right", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("XMLFunctionQualifiedIdentifier")
    .bases("Expression")
    .field("right", or(def("Identifier"), def("Expression")))
    .field("computed", isBoolean);

def("XMLAttributeSelector")
    .bases("Expression")
    .field("attribute", def("Expression"));

def("XMLFilterExpression")
    .bases("Expression")
    .field("left", def("Expression"))
    .field("right", def("Expression"));

def("XMLElement")
    .bases("XML", "Expression")
    .field("contents", [def("XML")]);

def("XMLList")
    .bases("XML", "Expression")
    .field("contents", [def("XML")]);

def("XML").bases("Node");

def("XMLEscape")
    .bases("XML")
    .field("expression", def("Expression"));

def("XMLText")
    .bases("XML")
    .field("text", isString);

def("XMLStartTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLEndTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLPointTag")
    .bases("XML")
    .field("contents", [def("XML")]);

def("XMLName")
    .bases("XML")
    .field("contents", or(isString, [def("XML")]));

def("XMLAttribute")
    .bases("XML")
    .field("value", isString);

def("XMLCdata")
    .bases("XML")
    .field("contents", isString);

def("XMLComment")
    .bases("XML")
    .field("contents", isString);

def("XMLProcessingInstruction")
    .bases("XML")
    .field("target", isString)
    .field("contents", or(isString, null));

},{"../lib/types":138,"./core":126}],128:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isBoolean = builtin.boolean;
var isObject = builtin.object;
var isString = builtin.string;
var defaults = require("../lib/shared").defaults;

def("Function")
    .field("generator", isBoolean, defaults["false"])
    .field("expression", isBoolean, defaults["false"])
    .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
    // TODO This could be represented as a SpreadElementPattern in .params.
    .field("rest", or(def("Identifier"), null), defaults["null"]);

def("FunctionDeclaration")
    .build("id", "params", "body", "generator", "expression");

def("FunctionExpression")
    .build("id", "params", "body", "generator", "expression");

// TODO The Parser API calls this ArrowExpression, but Esprima uses
// ArrowFunctionExpression.
def("ArrowFunctionExpression")
    .bases("Function", "Expression")
    .build("params", "body", "expression")
    // The forced null value here is compatible with the overridden
    // definition of the "id" field in the Function interface.
    .field("id", null, defaults["null"])
    // The current spec forbids arrow generators, so I have taken the
    // liberty of enforcing that. TODO Report this.
    .field("generator", false);

def("YieldExpression")
    .bases("Expression")
    .build("argument", "delegate")
    .field("argument", or(def("Expression"), null))
    .field("delegate", isBoolean, defaults["false"]);

def("GeneratorExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

def("ComprehensionExpression")
    .bases("Expression")
    .build("body", "blocks", "filter")
    .field("body", def("Expression"))
    .field("blocks", [def("ComprehensionBlock")])
    .field("filter", or(def("Expression"), null));

def("ComprehensionBlock")
    .bases("Node")
    .build("left", "right", "each")
    .field("left", def("Pattern"))
    .field("right", def("Expression"))
    .field("each", isBoolean);

def("ModuleSpecifier")
    .bases("Literal")
    .build("value")
    .field("value", isString);

def("Property")
    // Esprima extensions not mentioned in the Mozilla Parser API:
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("method", isBoolean, defaults["false"])
    .field("shorthand", isBoolean, defaults["false"])
    .field("computed", isBoolean, defaults["false"]);

def("PropertyPattern")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("computed", isBoolean, defaults["false"]);

def("MethodDefinition")
    .bases("Declaration")
    .build("kind", "key", "value")
    .field("kind", or("init", "get", "set", ""))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", def("Function"))
    .field("computed", isBoolean, defaults["false"]);

def("SpreadElement")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

def("ArrayExpression")
    .field("elements", [or(def("Expression"), def("SpreadElement"), null)]);

def("NewExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

def("CallExpression")
    .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

def("SpreadElementPattern")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

def("ArrayPattern")
    .field("elements", [or(
        def("Pattern"),
        null,
        // used by esprima
        def("SpreadElement")
    )]);

var ClassBodyElement = or(
    def("MethodDefinition"),
    def("VariableDeclarator"),
    def("ClassPropertyDefinition"),
    def("ClassProperty")
);

def("ClassProperty")
  .bases("Declaration")
  .build("key")
  .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
  .field("computed", isBoolean, defaults["false"]);

def("ClassPropertyDefinition") // static property
    .bases("Declaration")
    .build("definition")
    // Yes, Virginia, circular definitions are permitted.
    .field("definition", ClassBodyElement);

def("ClassBody")
    .bases("Declaration")
    .build("body")
    .field("body", [ClassBodyElement]);

def("ClassDeclaration")
    .bases("Declaration")
    .build("id", "body", "superClass")
    .field("id", def("Identifier"))
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

def("ClassExpression")
    .bases("Expression")
    .build("id", "body", "superClass")
    .field("id", or(def("Identifier"), null), defaults["null"])
    .field("body", def("ClassBody"))
    .field("superClass", or(def("Expression"), null), defaults["null"])
    .field("implements", [def("ClassImplements")], defaults.emptyArray);

def("ClassImplements")
    .bases("Node")
    .build("id")
    .field("id", def("Identifier"))
    .field("superClass", or(def("Expression"), null), defaults["null"]);

// Specifier and NamedSpecifier are abstract non-standard types that I
// introduced for definitional convenience.
def("Specifier").bases("Node");
def("NamedSpecifier")
    .bases("Specifier")
    // Note: this abstract type is intentionally not buildable.
    .field("id", def("Identifier"))
    .field("name", or(def("Identifier"), null), defaults["null"]);

// Like NamedSpecifier, except type:"ExportSpecifier" and buildable.
// export {<id [as name]>} [from ...];
def("ExportSpecifier")
    .bases("NamedSpecifier")
    .build("id", "name");

// export <*> from ...;
def("ExportBatchSpecifier")
    .bases("Specifier")
    .build();

// Like NamedSpecifier, except type:"ImportSpecifier" and buildable.
// import {<id [as name]>} from ...;
def("ImportSpecifier")
    .bases("NamedSpecifier")
    .build("id", "name");

// import <* as id> from ...;
def("ImportNamespaceSpecifier")
    .bases("Specifier")
    .build("id")
    .field("id", def("Identifier"));

// import <id> from ...;
def("ImportDefaultSpecifier")
    .bases("Specifier")
    .build("id")
    .field("id", def("Identifier"));

def("ExportDeclaration")
    .bases("Declaration")
    .build("default", "declaration", "specifiers", "source")
    .field("default", isBoolean)
    .field("declaration", or(
        def("Declaration"),
        def("Expression"), // Implies default.
        null
    ))
    .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
    )], defaults.emptyArray)
    .field("source", or(def("ModuleSpecifier"), null), defaults["null"]);

def("ImportDeclaration")
    .bases("Declaration")
    .build("specifiers", "source")
    .field("specifiers", [or(
        def("ImportSpecifier"),
        def("ImportNamespaceSpecifier"),
        def("ImportDefaultSpecifier")
    )], defaults.emptyArray)
    .field("source", def("ModuleSpecifier"));

def("TaggedTemplateExpression")
    .bases("Expression")
    .field("tag", def("Expression"))
    .field("quasi", def("TemplateLiteral"));

def("TemplateLiteral")
    .bases("Expression")
    .build("quasis", "expressions")
    .field("quasis", [def("TemplateElement")])
    .field("expressions", [def("Expression")]);

def("TemplateElement")
    .bases("Node")
    .build("value", "tail")
    .field("value", {"cooked": isString, "raw": isString})
    .field("tail", isBoolean);

},{"../lib/shared":137,"../lib/types":138,"./core":126}],129:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isBoolean = builtin.boolean;
var defaults = require("../lib/shared").defaults;

def("Function")
    .field("async", isBoolean, defaults["false"]);

def("SpreadProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

def("ObjectExpression")
    .field("properties", [or(def("Property"), def("SpreadProperty"))]);

def("SpreadPropertyPattern")
    .bases("Pattern")
    .build("argument")
    .field("argument", def("Pattern"));

def("ObjectPattern")
    .field("properties", [or(
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        // used by esprima
        def("Property"),
        def("SpreadProperty")
    )]);

def("AwaitExpression")
    .bases("Expression")
    .build("argument", "all")
    .field("argument", or(def("Expression"), null))
    .field("all", isBoolean, defaults["false"]);

},{"../lib/shared":137,"../lib/types":138,"./core":126}],130:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var builtin = types.builtInTypes;
var isString = builtin.string;
var isBoolean = builtin.boolean;
var defaults = require("../lib/shared").defaults;

def("XJSAttribute")
    .bases("Node")
    .build("name", "value")
    .field("name", or(def("XJSIdentifier"), def("XJSNamespacedName")))
    .field("value", or(
        def("Literal"), // attr="value"
        def("XJSExpressionContainer"), // attr={value}
        null // attr= or just attr
    ), defaults["null"]);

def("XJSIdentifier")
    .bases("Node")
    .build("name")
    .field("name", isString);

def("XJSNamespacedName")
    .bases("Node")
    .build("namespace", "name")
    .field("namespace", def("XJSIdentifier"))
    .field("name", def("XJSIdentifier"));

def("XJSMemberExpression")
    .bases("MemberExpression")
    .build("object", "property")
    .field("object", or(def("XJSIdentifier"), def("XJSMemberExpression")))
    .field("property", def("XJSIdentifier"))
    .field("computed", isBoolean, defaults.false);

var XJSElementName = or(
    def("XJSIdentifier"),
    def("XJSNamespacedName"),
    def("XJSMemberExpression")
);

def("XJSSpreadAttribute")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

var XJSAttributes = [or(
    def("XJSAttribute"),
    def("XJSSpreadAttribute")
)];

def("XJSExpressionContainer")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));

def("XJSElement")
    .bases("Expression")
    .build("openingElement", "closingElement", "children")
    .field("openingElement", def("XJSOpeningElement"))
    .field("closingElement", or(def("XJSClosingElement"), null), defaults["null"])
    .field("children", [or(
        def("XJSElement"),
        def("XJSExpressionContainer"),
        def("XJSText"),
        def("Literal") // TODO Esprima should return XJSText instead.
    )], defaults.emptyArray)
    .field("name", XJSElementName, function() {
        // Little-known fact: the `this` object inside a default function
        // is none other than the partially-built object itself, and any
        // fields initialized directly from builder function arguments
        // (like openingElement, closingElement, and children) are
        // guaranteed to be available.
        return this.openingElement.name;
    })
    .field("selfClosing", isBoolean, function() {
        return this.openingElement.selfClosing;
    })
    .field("attributes", XJSAttributes, function() {
        return this.openingElement.attributes;
    });

def("XJSOpeningElement")
    .bases("Node") // TODO Does this make sense? Can't really be an XJSElement.
    .build("name", "attributes", "selfClosing")
    .field("name", XJSElementName)
    .field("attributes", XJSAttributes, defaults.emptyArray)
    .field("selfClosing", isBoolean, defaults["false"]);

def("XJSClosingElement")
    .bases("Node") // TODO Same concern.
    .build("name")
    .field("name", XJSElementName);

def("XJSText")
    .bases("Literal")
    .build("value")
    .field("value", isString);

def("XJSEmptyExpression").bases("Expression").build();

// Type Annotations
def("Type")
  .bases("Node");

def("AnyTypeAnnotation")
  .bases("Type");

def("VoidTypeAnnotation")
  .bases("Type");

def("NumberTypeAnnotation")
  .bases("Type");

def("StringTypeAnnotation")
  .bases("Type");

def("StringLiteralTypeAnnotation")
  .bases("Type")
  .build("value", "raw")
  .field("value", isString)
  .field("raw", isString);

def("BooleanTypeAnnotation")
  .bases("Type");

def("TypeAnnotation")
  .bases("Node")
  .build("typeAnnotation")
  .field("typeAnnotation", def("Type"));

def("NullableTypeAnnotation")
  .bases("Type")
  .build("typeAnnotation")
  .field("typeAnnotation", def("Type"));

def("FunctionTypeAnnotation")
  .bases("Type")
  .build("params", "returnType", "rest", "typeParameters")
  .field("params", [def("FunctionTypeParam")])
  .field("returnType", def("Type"))
  .field("rest", or(def("FunctionTypeParam"), null))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null));

def("FunctionTypeParam")
  .bases("Node")
  .build("name", "typeAnnotation", "optional")
  .field("name", def("Identifier"))
  .field("typeAnnotation", def("Type"))
  .field("optional", isBoolean);
  
def("ArrayTypeAnnotation")
  .bases("Type")
  .build("elementType")
  .field("elementType", def("Type"));

def("ObjectTypeAnnotation")
  .bases("Type")
  .build("properties")
  .field("properties", [def("ObjectTypeProperty")])
  .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
  .field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray);

def("ObjectTypeProperty")
  .bases("Node")
  .build("key", "value", "optional")
  .field("key", or(def("Literal"), def("Identifier")))
  .field("value", def("Type"))
  .field("optional", isBoolean);

def("ObjectTypeIndexer")
  .bases("Node")
  .build("id", "key", "value")
  .field("id", def("Identifier"))
  .field("key", def("Type"))
  .field("value", def("Type"));

def("ObjectTypeCallProperty")
  .bases("Node")
  .build("value")
  .field("value", def("FunctionTypeAnnotation"))
  .field("static", isBoolean, false);

def("QualifiedTypeIdentifier")
  .bases("Node")
  .build("qualification", "id")
  .field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier")))
  .field("id", def("Identifier"));

def("GenericTypeAnnotation")
  .bases("Type")
  .build("id", "typeParameters")
  .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
  .field("typeParameters", or(def("TypeParameterInstantiation"), null));

def("MemberTypeAnnotation")
  .bases("Type")
  .build("object", "property")
  .field("object", def("Identifier"))
  .field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));

def("UnionTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("IntersectionTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("TypeofTypeAnnotation")
  .bases("Type")
  .build("argument")
  .field("argument", def("Type"));

def("Identifier")
  .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

def("TypeParameterDeclaration")
  .bases("Node")
  .build("params")
  .field("params", [def("Identifier")]);

def("TypeParameterInstantiation")
  .bases("Node")
  .build("params")
  .field("params", [def("Type")]);

def("Function")
  .field("returnType", or(def("TypeAnnotation"), null), defaults["null"])
  .field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]);

def("ClassProperty")
  .build("key", "typeAnnotation")
  .field("typeAnnotation", def("TypeAnnotation"))
  .field("static", isBoolean, false);

def("ClassImplements")
  .field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);

def("InterfaceDeclaration")
  .bases("Statement")
  .build("id", "body", "extends")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"])
  .field("body", def("ObjectTypeAnnotation"))
  .field("extends", [def("InterfaceExtends")]);

def("InterfaceExtends")
  .bases("Node")
  .build("id")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterInstantiation"), null));

def("TypeAlias")
  .bases("Statement")
  .build("id", "typeParameters", "right")
  .field("id", def("Identifier"))
  .field("typeParameters", or(def("TypeParameterDeclaration"), null))
  .field("right", def("Type"));
  
def("TypeCastExpression")
  .bases("Expression")
  .build("expression", "typeAnnotation")
  .field("expression", def("Expression"))
  .field("typeAnnotation", def("TypeAnnotation"));

def("TupleTypeAnnotation")
  .bases("Type")
  .build("types")
  .field("types", [def("Type")]);

def("DeclareVariable")
  .bases("Statement")
  .build("id")
  .field("id", def("Identifier"));

def("DeclareFunction")
  .bases("Statement")
  .build("id")
  .field("id", def("Identifier"));

def("DeclareClass")
  .bases("InterfaceDeclaration")
  .build("id");

def("DeclareModule")
  .bases("Statement")
  .build("id", "body")
  .field("id", or(def("Identifier"), def("Literal")))
  .field("body", def("BlockStatement"));

},{"../lib/shared":137,"../lib/types":138,"./core":126}],131:[function(require,module,exports){
require("./core");
var types = require("../lib/types");
var def = types.Type.def;
var or = types.Type.or;
var geq = require("../lib/shared").geq;

def("ForOfStatement")
    .bases("Statement")
    .build("left", "right", "body")
    .field("left", or(
        def("VariableDeclaration"),
        def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"));

def("LetStatement")
    .bases("Statement")
    .build("head", "body")
    // TODO Deviating from the spec by reusing VariableDeclarator here.
    .field("head", [def("VariableDeclarator")])
    .field("body", def("Statement"));

def("LetExpression")
    .bases("Expression")
    .build("head", "body")
    // TODO Deviating from the spec by reusing VariableDeclarator here.
    .field("head", [def("VariableDeclarator")])
    .field("body", def("Expression"));

def("GraphExpression")
    .bases("Expression")
    .build("index", "expression")
    .field("index", geq(0))
    .field("expression", def("Literal"));

def("GraphIndexExpression")
    .bases("Expression")
    .build("index")
    .field("index", geq(0));

},{"../lib/shared":137,"../lib/types":138,"./core":126}],132:[function(require,module,exports){
var assert = require("assert");
var types = require("../main");
var getFieldNames = types.getFieldNames;
var getFieldValue = types.getFieldValue;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var isDate = types.builtInTypes.Date;
var isRegExp = types.builtInTypes.RegExp;
var hasOwn = Object.prototype.hasOwnProperty;

function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}

astNodesAreEquivalent.assert = function(a, b) {
    var problemPath = [];
    if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
            assert.strictEqual(a, b);
        } else {
            assert.ok(
                false,
                "Nodes differ in the following path: " +
                    problemPath.map(subscriptForProperty).join("")
            );
        }
    }
};

function subscriptForProperty(property) {
    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
        return "." + property;
    }
    return "[" + JSON.stringify(property) + "]";
}

function areEquivalent(a, b, problemPath) {
    if (a === b) {
        return true;
    }

    if (isArray.check(a)) {
        return arraysAreEquivalent(a, b, problemPath);
    }

    if (isObject.check(a)) {
        return objectsAreEquivalent(a, b, problemPath);
    }

    if (isDate.check(a)) {
        return isDate.check(b) && (+a === +b);
    }

    if (isRegExp.check(a)) {
        return isRegExp.check(b) && (
            a.source === b.source &&
            a.global === b.global &&
            a.multiline === b.multiline &&
            a.ignoreCase === b.ignoreCase
        );
    }

    return a == b;
}

function arraysAreEquivalent(a, b, problemPath) {
    isArray.assert(a);
    var aLength = a.length;

    if (!isArray.check(b) || b.length !== aLength) {
        if (problemPath) {
            problemPath.push("length");
        }
        return false;
    }

    for (var i = 0; i < aLength; ++i) {
        if (problemPath) {
            problemPath.push(i);
        }

        if (i in a !== i in b) {
            return false;
        }

        if (!areEquivalent(a[i], b[i], problemPath)) {
            return false;
        }

        if (problemPath) {
            assert.strictEqual(problemPath.pop(), i);
        }
    }

    return true;
}

function objectsAreEquivalent(a, b, problemPath) {
    isObject.assert(a);
    if (!isObject.check(b)) {
        return false;
    }

    // Fast path for a common property of AST nodes.
    if (a.type !== b.type) {
        if (problemPath) {
            problemPath.push("type");
        }
        return false;
    }

    var aNames = getFieldNames(a);
    var aNameCount = aNames.length;

    var bNames = getFieldNames(b);
    var bNameCount = bNames.length;

    if (aNameCount === bNameCount) {
        for (var i = 0; i < aNameCount; ++i) {
            var name = aNames[i];
            var aChild = getFieldValue(a, name);
            var bChild = getFieldValue(b, name);

            if (problemPath) {
                problemPath.push(name);
            }

            if (!areEquivalent(aChild, bChild, problemPath)) {
                return false;
            }

            if (problemPath) {
                assert.strictEqual(problemPath.pop(), name);
            }
        }

        return true;
    }

    if (!problemPath) {
        return false;
    }

    // Since aNameCount !== bNameCount, we need to find some name that's
    // missing in aNames but present in bNames, or vice-versa.

    var seenNames = Object.create(null);

    for (i = 0; i < aNameCount; ++i) {
        seenNames[aNames[i]] = true;
    }

    for (i = 0; i < bNameCount; ++i) {
        name = bNames[i];

        if (!hasOwn.call(seenNames, name)) {
            problemPath.push(name);
            return false;
        }

        delete seenNames[name];
    }

    for (name in seenNames) {
        problemPath.push(name);
        break;
    }

    return false;
}

module.exports = astNodesAreEquivalent;

},{"../main":139,"assert":306}],133:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var n = types.namedTypes;
var b = types.builders;
var isNumber = types.builtInTypes.number;
var isArray = types.builtInTypes.array;
var Path = require("./path");
var Scope = require("./scope");

function NodePath(value, parentPath, name) {
    assert.ok(this instanceof NodePath);
    Path.call(this, value, parentPath, name);
}

require("util").inherits(NodePath, Path);
var NPp = NodePath.prototype;

Object.defineProperties(NPp, {
    node: {
        get: function() {
            Object.defineProperty(this, "node", {
                configurable: true, // Enable deletion.
                value: this._computeNode()
            });

            return this.node;
        }
    },

    parent: {
        get: function() {
            Object.defineProperty(this, "parent", {
                configurable: true, // Enable deletion.
                value: this._computeParent()
            });

            return this.parent;
        }
    },

    scope: {
        get: function() {
            Object.defineProperty(this, "scope", {
                configurable: true, // Enable deletion.
                value: this._computeScope()
            });

            return this.scope;
        }
    }
});

NPp.replace = function() {
    delete this.node;
    delete this.parent;
    delete this.scope;
    return Path.prototype.replace.apply(this, arguments);
};

NPp.prune = function() {
    var remainingNodePath = this.parent;

    this.replace();

    return cleanUpNodesAfterPrune(remainingNodePath);
};

// The value of the first ancestor Path whose value is a Node.
NPp._computeNode = function() {
    var value = this.value;
    if (n.Node.check(value)) {
        return value;
    }

    var pp = this.parentPath;
    return pp && pp.node || null;
};

// The first ancestor Path whose value is a Node distinct from this.node.
NPp._computeParent = function() {
    var value = this.value;
    var pp = this.parentPath;

    if (!n.Node.check(value)) {
        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        if (pp) {
            pp = pp.parentPath;
        }
    }

    while (pp && !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    return pp || null;
};

// The closest enclosing scope that governs this node.
NPp._computeScope = function() {
    var value = this.value;
    var pp = this.parentPath;
    var scope = pp && pp.scope;

    if (n.Node.check(value) &&
        Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
    }

    return scope || null;
};

NPp.getValueProperty = function(name) {
    return types.getFieldValue(this.value, name);
};

/**
 * Determine whether this.node needs to be wrapped in parentheses in order
 * for a parser to reproduce the same local AST structure.
 *
 * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
 * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
 * parse differently.
 *
 * If assumeExpressionContext === true, we don't worry about edge cases
 * like an anonymous FunctionExpression appearing lexically first in its
 * enclosing statement and thus needing parentheses to avoid being parsed
 * as a FunctionDeclaration with a missing name.
 */
NPp.needsParens = function(assumeExpressionContext) {
    var pp = this.parentPath;
    if (!pp) {
        return false;
    }

    var node = this.value;

    // Only expressions need parentheses.
    if (!n.Expression.check(node)) {
        return false;
    }

    // Identifiers never need parentheses.
    if (node.type === "Identifier") {
        return false;
    }

    while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
            return false;
        }
    }

    var parent = pp.value;

    switch (node.type) {
    case "UnaryExpression":
    case "SpreadElement":
    case "SpreadProperty":
        return parent.type === "MemberExpression"
            && this.name === "object"
            && parent.object === node;

    case "BinaryExpression":
    case "LogicalExpression":
        switch (parent.type) {
        case "CallExpression":
            return this.name === "callee"
                && parent.callee === node;

        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
            return true;

        case "MemberExpression":
            return this.name === "object"
                && parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
            var po = parent.operator;
            var pp = PRECEDENCE[po];
            var no = node.operator;
            var np = PRECEDENCE[no];

            if (pp > np) {
                return true;
            }

            if (pp === np && this.name === "right") {
                assert.strictEqual(parent.right, node);
                return true;
            }

        default:
            return false;
        }

    case "SequenceExpression":
        switch (parent.type) {
        case "ForStatement":
            // Although parentheses wouldn't hurt around sequence
            // expressions in the head of for loops, traditional style
            // dictates that e.g. i++, j++ should not be wrapped with
            // parentheses.
            return false;

        case "ExpressionStatement":
            return this.name !== "expression";

        default:
            // Otherwise err on the side of overparenthesization, adding
            // explicit exceptions above if this proves overzealous.
            return true;
        }

    case "YieldExpression":
        switch (parent.type) {
        case "BinaryExpression":
        case "LogicalExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "CallExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ConditionalExpression":
        case "YieldExpression":
            return true;

        default:
            return false;
        }

    case "Literal":
        return parent.type === "MemberExpression"
            && isNumber.check(node.value)
            && this.name === "object"
            && parent.object === node;

    case "AssignmentExpression":
    case "ConditionalExpression":
        switch (parent.type) {
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
            return true;

        case "CallExpression":
            return this.name === "callee"
                && parent.callee === node;

        case "ConditionalExpression":
            return this.name === "test"
                && parent.test === node;

        case "MemberExpression":
            return this.name === "object"
                && parent.object === node;

        default:
            return false;
        }

    default:
        if (parent.type === "NewExpression" &&
            this.name === "callee" &&
            parent.callee === node) {
            return containsCallExpression(node);
        }
    }

    if (assumeExpressionContext !== true &&
        !this.canBeFirstInStatement() &&
        this.firstInStatement())
        return true;

    return false;
};

function isBinary(node) {
    return n.BinaryExpression.check(node)
        || n.LogicalExpression.check(node);
}

function isUnaryLike(node) {
    return n.UnaryExpression.check(node)
        // I considered making SpreadElement and SpreadProperty subtypes
        // of UnaryExpression, but they're not really Expression nodes.
        || (n.SpreadElement && n.SpreadElement.check(node))
        || (n.SpreadProperty && n.SpreadProperty.check(node));
}

var PRECEDENCE = {};
[["||"],
 ["&&"],
 ["|"],
 ["^"],
 ["&"],
 ["==", "===", "!=", "!=="],
 ["<", ">", "<=", ">=", "in", "instanceof"],
 [">>", "<<", ">>>"],
 ["+", "-"],
 ["*", "/", "%"]
].forEach(function(tier, i) {
    tier.forEach(function(op) {
        PRECEDENCE[op] = i;
    });
});

function containsCallExpression(node) {
    if (n.CallExpression.check(node)) {
        return true;
    }

    if (isArray.check(node)) {
        return node.some(containsCallExpression);
    }

    if (n.Node.check(node)) {
        return types.someField(node, function(name, child) {
            return containsCallExpression(child);
        });
    }

    return false;
}

NPp.canBeFirstInStatement = function() {
    var node = this.node;
    return !n.FunctionExpression.check(node)
        && !n.ObjectExpression.check(node);
};

NPp.firstInStatement = function() {
    return firstInStatement(this);
};

function firstInStatement(path) {
    for (var node, parent; path.parent; path = path.parent) {
        node = path.node;
        parent = path.parent.node;

        if (n.BlockStatement.check(parent) &&
            path.parent.name === "body" &&
            path.name === 0) {
            assert.strictEqual(parent.body[0], node);
            return true;
        }

        if (n.ExpressionStatement.check(parent) &&
            path.name === "expression") {
            assert.strictEqual(parent.expression, node);
            return true;
        }

        if (n.SequenceExpression.check(parent) &&
            path.parent.name === "expressions" &&
            path.name === 0) {
            assert.strictEqual(parent.expressions[0], node);
            continue;
        }

        if (n.CallExpression.check(parent) &&
            path.name === "callee") {
            assert.strictEqual(parent.callee, node);
            continue;
        }

        if (n.MemberExpression.check(parent) &&
            path.name === "object") {
            assert.strictEqual(parent.object, node);
            continue;
        }

        if (n.ConditionalExpression.check(parent) &&
            path.name === "test") {
            assert.strictEqual(parent.test, node);
            continue;
        }

        if (isBinary(parent) &&
            path.name === "left") {
            assert.strictEqual(parent.left, node);
            continue;
        }

        if (n.UnaryExpression.check(parent) &&
            !parent.prefix &&
            path.name === "argument") {
            assert.strictEqual(parent.argument, node);
            continue;
        }

        return false;
    }

    return true;
}

/**
 * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
 */
function cleanUpNodesAfterPrune(remainingNodePath) {
    if (n.VariableDeclaration.check(remainingNodePath.node)) {
        var declarations = remainingNodePath.get('declarations').value;
        if (!declarations || declarations.length === 0) {
            return remainingNodePath.prune();
        }
    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
        if (!remainingNodePath.get('expression').value) {
            return remainingNodePath.prune();
        }
    } else if (n.IfStatement.check(remainingNodePath.node)) {
        cleanUpIfStatementAfterPrune(remainingNodePath);
    }

    return remainingNodePath;
}

function cleanUpIfStatementAfterPrune(ifStatement) {
    var testExpression = ifStatement.get('test').value;
    var alternate = ifStatement.get('alternate').value;
    var consequent = ifStatement.get('consequent').value;

    if (!consequent && !alternate) {
        var testExpressionStatement = b.expressionStatement(testExpression);

        ifStatement.replace(testExpressionStatement);
    } else if (!consequent && alternate) {
        var negatedTestExpression = b.unaryExpression('!', testExpression, true);

        if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
            negatedTestExpression = testExpression.argument;
        }

        ifStatement.get("test").replace(negatedTestExpression);
        ifStatement.get("consequent").replace(alternate);
        ifStatement.get("alternate").replace();
    }
}

module.exports = NodePath;

},{"./path":135,"./scope":136,"./types":138,"assert":306,"util":331}],134:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var NodePath = require("./node-path");
var Node = types.namedTypes.Node;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var isFunction = types.builtInTypes.function;
var hasOwn = Object.prototype.hasOwnProperty;
var undefined;

function PathVisitor() {
    assert.ok(this instanceof PathVisitor);

    // Permanent state.
    this._reusableContextStack = [];
    this._methodNameTable = computeMethodNameTable(this);
    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}

function computeMethodNameTable(visitor) {
    var typeNames = Object.create(null);

    for (var methodName in visitor) {
        if (/^visit[A-Z]/.test(methodName)) {
            typeNames[methodName.slice("visit".length)] = true;
        }
    }

    var supertypeTable = types.computeSupertypeLookupTable(typeNames);
    var methodNameTable = Object.create(null);

    var typeNames = Object.keys(supertypeTable);
    var typeNameCount = typeNames.length;
    for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        methodName = "visit" + supertypeTable[typeName];
        if (isFunction.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
        }
    }

    return methodNameTable;
}

PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
    if (methods instanceof PathVisitor) {
        return methods;
    }

    if (!isObject.check(methods)) {
        // An empty visitor?
        return new PathVisitor;
    }

    function Visitor() {
        assert.ok(this instanceof Visitor);
        PathVisitor.call(this);
    }

    var Vp = Visitor.prototype = Object.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    return new Visitor;
};

function extend(target, source) {
    for (var property in source) {
        if (hasOwn.call(source, property)) {
            target[property] = source[property];
        }
    }

    return target;
}

PathVisitor.visit = function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
};

var PVp = PathVisitor.prototype;

var recursiveVisitWarning = [
    "Recursively calling visitor.visit(path) resets visitor state.",
    "Try this.visit(path) or this.traverse(path) instead."
].join(" ");

PVp.visit = function() {
    assert.ok(!this._visiting, recursiveVisitWarning);

    // Private state that needs to be reset before every traversal.
    this._visiting = true;
    this._changeReported = false;
    this._abortRequested = false;

    var argc = arguments.length;
    var args = new Array(argc)
    for (var i = 0; i < argc; ++i) {
        args[i] = arguments[i];
    }

    if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({ root: args[0] }).get("root");
    }

    // Called with the same arguments as .visit.
    this.reset.apply(this, args);

    try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
    } finally {
        this._visiting = false;

        if (!didNotThrow && this._abortRequested) {
            // If this.visitWithoutReset threw an exception and
            // this._abortRequested was set to true, return the root of
            // the AST instead of letting the exception propagate, so that
            // client code does not have to provide a try-catch block to
            // intercept the AbortRequest exception.  Other kinds of
            // exceptions will propagate without being intercepted and
            // rethrown by a catch block, so their stacks will accurately
            // reflect the original throwing context.
            return args[0].value;
        }
    }

    return root;
};

PVp.AbortRequest = function AbortRequest() {};
PVp.abort = function() {
    var visitor = this;
    visitor._abortRequested = true;
    var request = new visitor.AbortRequest();

    // If you decide to catch this exception and stop it from propagating,
    // make sure to call its cancel method to avoid silencing other
    // exceptions that might be thrown later in the traversal.
    request.cancel = function() {
        visitor._abortRequested = false;
    };

    throw request;
};

PVp.reset = function(path/*, additional arguments */) {
    // Empty stub; may be reassigned or overridden by subclasses.
};

PVp.visitWithoutReset = function(path) {
    if (this instanceof this.Context) {
        // Since this.Context.prototype === this, there's a chance we
        // might accidentally call context.visitWithoutReset. If that
        // happens, re-invoke the method against context.visitor.
        return this.visitor.visitWithoutReset(path);
    }

    assert.ok(path instanceof NodePath);
    var value = path.value;

    var methodName = Node.check(value) && this._methodNameTable[value.type];
    if (methodName) {
        var context = this.acquireContext(path);
        try {
            return context.invokeVisitorMethod(methodName);
        } finally {
            this.releaseContext(context);
        }

    } else {
        // If there was no visitor method to call, visit the children of
        // this node generically.
        return visitChildren(path, this);
    }
};

function visitChildren(path, visitor) {
    assert.ok(path instanceof NodePath);
    assert.ok(visitor instanceof PathVisitor);

    var value = path.value;

    if (isArray.check(value)) {
        path.each(visitor.visitWithoutReset, visitor);
    } else if (!isObject.check(value)) {
        // No children to visit.
    } else {
        var childNames = types.getFieldNames(value);
        var childCount = childNames.length;
        var childPaths = [];

        for (var i = 0; i < childCount; ++i) {
            var childName = childNames[i];
            if (!hasOwn.call(value, childName)) {
                value[childName] = types.getFieldValue(value, childName);
            }
            childPaths.push(path.get(childName));
        }

        for (var i = 0; i < childCount; ++i) {
            visitor.visitWithoutReset(childPaths[i]);
        }
    }

    return path.value;
}

PVp.acquireContext = function(path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().reset(path);
};

PVp.releaseContext = function(context) {
    assert.ok(context instanceof this.Context);
    this._reusableContextStack.push(context);
    context.currentPath = null;
};

PVp.reportChanged = function() {
    this._changeReported = true;
};

PVp.wasChangeReported = function() {
    return this._changeReported;
};

function makeContextConstructor(visitor) {
    function Context(path) {
        assert.ok(this instanceof Context);
        assert.ok(this instanceof PathVisitor);
        assert.ok(path instanceof NodePath);

        Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: false,
            enumerable: true,
            configurable: false
        });

        this.currentPath = path;
        this.needToCallTraverse = true;

        Object.seal(this);
    }

    assert.ok(visitor instanceof PathVisitor);

    // Note that the visitor object is the prototype of Context.prototype,
    // so all visitor methods are inherited by context objects.
    var Cp = Context.prototype = Object.create(visitor);

    Cp.constructor = Context;
    extend(Cp, sharedContextProtoMethods);

    return Context;
}

// Every PathVisitor has a different this.Context constructor and
// this.Context.prototype object, but those prototypes can all use the
// same reset, invokeVisitorMethod, and traverse function objects.
var sharedContextProtoMethods = Object.create(null);

sharedContextProtoMethods.reset =
function reset(path) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);

    this.currentPath = path;
    this.needToCallTraverse = true;

    return this;
};

sharedContextProtoMethods.invokeVisitorMethod =
function invokeVisitorMethod(methodName) {
    assert.ok(this instanceof this.Context);
    assert.ok(this.currentPath instanceof NodePath);

    var result = this.visitor[methodName].call(this, this.currentPath);

    if (result === false) {
        // Visitor methods return false to indicate that they have handled
        // their own traversal needs, and we should not complain if
        // this.needToCallTraverse is still true.
        this.needToCallTraverse = false;

    } else if (result !== undefined) {
        // Any other non-undefined value returned from the visitor method
        // is interpreted as a replacement value.
        this.currentPath = this.currentPath.replace(result)[0];

        if (this.needToCallTraverse) {
            // If this.traverse still hasn't been called, visit the
            // children of the replacement node.
            this.traverse(this.currentPath);
        }
    }

    assert.strictEqual(
        this.needToCallTraverse, false,
        "Must either call this.traverse or return false in " + methodName
    );

    var path = this.currentPath;
    return path && path.value;
};

sharedContextProtoMethods.traverse =
function traverse(path, newVisitor) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);
    assert.ok(this.currentPath instanceof NodePath);

    this.needToCallTraverse = false;

    return visitChildren(path, PathVisitor.fromMethodsObject(
        newVisitor || this.visitor
    ));
};

sharedContextProtoMethods.visit =
function visit(path, newVisitor) {
    assert.ok(this instanceof this.Context);
    assert.ok(path instanceof NodePath);
    assert.ok(this.currentPath instanceof NodePath);

    this.needToCallTraverse = false;

    return PathVisitor.fromMethodsObject(
        newVisitor || this.visitor
    ).visitWithoutReset(path);
};

sharedContextProtoMethods.reportChanged = function reportChanged() {
    this.visitor.reportChanged();
};

sharedContextProtoMethods.abort = function abort() {
    this.needToCallTraverse = false;
    this.visitor.abort();
};

module.exports = PathVisitor;

},{"./node-path":133,"./types":138,"assert":306}],135:[function(require,module,exports){
var assert = require("assert");
var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var types = require("./types");
var isArray = types.builtInTypes.array;
var isNumber = types.builtInTypes.number;
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;

function Path(value, parentPath, name) {
    assert.ok(this instanceof Path);

    if (parentPath) {
        assert.ok(parentPath instanceof Path);
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path's value was reached.
    this.name = name;

    // Calling path.get("child") multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}

var Pp = Path.prototype;

function getChildCache(path) {
    // Lazily create the child cache. This also cheapens cache
    // invalidation, since you can just reset path.__childCache to null.
    return path.__childCache || (path.__childCache = Object.create(null));
}

function getChildPath(path, name) {
    var cache = getChildCache(path);
    var actualChildValue = path.getValueProperty(name);
    var childPath = cache[name];
    if (!hasOwn.call(cache, name) ||
        // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) {
        childPath = cache[name] = new path.constructor(
            actualChildValue, path, name
        );
    }
    return childPath;
}

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
Pp.getValueProperty = function getValueProperty(name) {
    return this.value[name];
};

Pp.get = function get(name) {
    var path = this;
    var names = arguments;
    var count = names.length;

    for (var i = 0; i < count; ++i) {
        path = getChildPath(path, names[i]);
    }

    return path;
};

Pp.each = function each(callback, context) {
    var childPaths = [];
    var len = this.value.length;
    var i = 0;

    // Collect all the original child paths before invoking the callback.
    for (var i = 0; i < len; ++i) {
        if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
        }
    }

    // Invoke the callback on just the original child paths, regardless of
    // any modifications made to the array by the callback. I chose these
    // semantics over cleverly invoking the callback on new elements because
    // this way is much easier to reason about.
    context = context || this;
    for (i = 0; i < len; ++i) {
        if (hasOwn.call(childPaths, i)) {
            callback.call(context, childPaths[i]);
        }
    }
};

Pp.map = function map(callback, context) {
    var result = [];

    this.each(function(childPath) {
        result.push(callback.call(this, childPath));
    }, context);

    return result;
};

Pp.filter = function filter(callback, context) {
    var result = [];

    this.each(function(childPath) {
        if (callback.call(this, childPath)) {
            result.push(childPath);
        }
    }, context);

    return result;
};

function emptyMoves() {}
function getMoves(path, offset, start, end) {
    isArray.assert(path.value);

    if (offset === 0) {
        return emptyMoves;
    }

    var length = path.value.length;
    if (length < 1) {
        return emptyMoves;
    }

    var argc = arguments.length;
    if (argc === 2) {
        start = 0;
        end = length;
    } else if (argc === 3) {
        start = Math.max(start, 0);
        end = length;
    } else {
        start = Math.max(start, 0);
        end = Math.min(end, length);
    }

    isNumber.assert(start);
    isNumber.assert(end);

    var moves = Object.create(null);
    var cache = getChildCache(path);

    for (var i = start; i < end; ++i) {
        if (hasOwn.call(path.value, i)) {
            var childPath = path.get(i);
            assert.strictEqual(childPath.name, i);
            var newIndex = i + offset;
            childPath.name = newIndex;
            moves[newIndex] = childPath;
            delete cache[i];
        }
    }

    delete cache.length;

    return function() {
        for (var newIndex in moves) {
            var childPath = moves[newIndex];
            assert.strictEqual(childPath.name, +newIndex);
            cache[newIndex] = childPath;
            path.value[newIndex] = childPath.value;
        }
    };
}

Pp.shift = function shift() {
    var move = getMoves(this, -1);
    var result = this.value.shift();
    move();
    return result;
};

Pp.unshift = function unshift(node) {
    var move = getMoves(this, arguments.length);
    var result = this.value.unshift.apply(this.value, arguments);
    move();
    return result;
};

Pp.push = function push(node) {
    isArray.assert(this.value);
    delete getChildCache(this).length
    return this.value.push.apply(this.value, arguments);
};

Pp.pop = function pop() {
    isArray.assert(this.value);
    var cache = getChildCache(this);
    delete cache[this.value.length - 1];
    delete cache.length;
    return this.value.pop();
};

Pp.insertAt = function insertAt(index, node) {
    var argc = arguments.length;
    var move = getMoves(this, argc - 1, index);
    if (move === emptyMoves) {
        return this;
    }

    index = Math.max(index, 0);

    for (var i = 1; i < argc; ++i) {
        this.value[index + i - 1] = arguments[i];
    }

    move();

    return this;
};

Pp.insertBefore = function insertBefore(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name];
    for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
};

Pp.insertAfter = function insertAfter(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name + 1];
    for (var i = 0; i < argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
};

function repairRelationshipWithParent(path) {
    assert.ok(path instanceof Path);

    var pp = path.parentPath;
    if (!pp) {
        // Orphan paths have no relationship to repair.
        return path;
    }

    var parentValue = pp.value;
    var parentCache = getChildCache(pp);

    // Make sure parentCache[path.name] is populated.
    if (parentValue[path.name] === path.value) {
        parentCache[path.name] = path;
    } else if (isArray.check(parentValue)) {
        // Something caused path.name to become out of date, so attempt to
        // recover by searching for path.value in parentValue.
        var i = parentValue.indexOf(path.value);
        if (i >= 0) {
            parentCache[path.name = i] = path;
        }
    } else {
        // If path.value disagrees with parentValue[path.name], and
        // path.name is not an array index, let path.value become the new
        // parentValue[path.name] and update parentCache accordingly.
        parentValue[path.name] = path.value;
        parentCache[path.name] = path;
    }

    assert.strictEqual(parentValue[path.name], path.value);
    assert.strictEqual(path.parentPath.get(path.name), path);

    return path;
}

Pp.replace = function replace(replacement) {
    var results = [];
    var parentValue = this.parentPath.value;
    var parentCache = getChildCache(this.parentPath);
    var count = arguments.length;

    repairRelationshipWithParent(this);

    if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);

        var spliceArgs = [this.name, 1];
        for (var i = 0; i < count; ++i) {
            spliceArgs.push(arguments[i]);
        }

        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

        assert.strictEqual(splicedOut[0], this.value);
        assert.strictEqual(
            parentValue.length,
            originalLength - 1 + count
        );

        move();

        if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;

        } else {
            assert.strictEqual(parentValue[this.name], replacement);

            if (this.value !== replacement) {
                this.value = replacement;
                this.__childCache = null;
            }

            for (i = 0; i < count; ++i) {
                results.push(this.parentPath.get(this.name + i));
            }

            assert.strictEqual(results[0], this);
        }

    } else if (count === 1) {
        if (this.value !== replacement) {
            this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);

    } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;

        // Leave this path cached as parentCache[this.name], even though
        // it no longer has a value defined.

    } else {
        assert.ok(false, "Could not replace path");
    }

    return results;
};

module.exports = Path;

},{"./types":138,"assert":306}],136:[function(require,module,exports){
var assert = require("assert");
var types = require("./types");
var Type = types.Type;
var namedTypes = types.namedTypes;
var Node = namedTypes.Node;
var Expression = namedTypes.Expression;
var isArray = types.builtInTypes.array;
var hasOwn = Object.prototype.hasOwnProperty;
var b = types.builders;

function Scope(path, parentScope) {
    assert.ok(this instanceof Scope);
    assert.ok(path instanceof require("./node-path"));
    ScopeType.assert(path.value);

    var depth;

    if (parentScope) {
        assert.ok(parentScope instanceof Scope);
        depth = parentScope.depth + 1;
    } else {
        parentScope = null;
        depth = 0;
    }

    Object.defineProperties(this, {
        path: { value: path },
        node: { value: path.value },
        isGlobal: { value: !parentScope, enumerable: true },
        depth: { value: depth },
        parent: { value: parentScope },
        bindings: { value: {} }
    });
}

var scopeTypes = [
    // Program nodes introduce global scopes.
    namedTypes.Program,

    // Function is the supertype of FunctionExpression,
    // FunctionDeclaration, ArrowExpression, etc.
    namedTypes.Function,

    // In case you didn't know, the caught parameter shadows any variable
    // of the same name in an outer scope.
    namedTypes.CatchClause
];

var ScopeType = Type.or.apply(Type, scopeTypes);

Scope.isEstablishedBy = function(node) {
    return ScopeType.check(node);
};

var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
Sp.didScan = false;

Sp.declares = function(name) {
    this.scan();
    return hasOwn.call(this.bindings, name);
};

Sp.declareTemporary = function(prefix) {
    if (prefix) {
        assert.ok(/^[a-z$_]/i.test(prefix), prefix);
    } else {
        prefix = "t$";
    }

    // Include this.depth in the name to make sure the name does not
    // collide with any variables in nested/enclosing scopes.
    prefix += this.depth.toString(36) + "$";

    this.scan();

    var index = 0;
    while (this.declares(prefix + index)) {
        ++index;
    }

    var name = prefix + index;
    return this.bindings[name] = types.builders.identifier(name);
};

Sp.injectTemporary = function(identifier, init) {
    identifier || (identifier = this.declareTemporary());

    var bodyPath = this.path.get("body");
    if (namedTypes.BlockStatement.check(bodyPath.value)) {
        bodyPath = bodyPath.get("body");
    }

    bodyPath.unshift(
        b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
        )
    );

    return identifier;
};

Sp.scan = function(force) {
    if (force || !this.didScan) {
        for (var name in this.bindings) {
            // Empty out this.bindings, just in cases.
            delete this.bindings[name];
        }
        scanScope(this.path, this.bindings);
        this.didScan = true;
    }
};

Sp.getBindings = function () {
    this.scan();
    return this.bindings;
};

function scanScope(path, bindings) {
    var node = path.value;
    ScopeType.assert(node);

    if (namedTypes.CatchClause.check(node)) {
        // A catch clause establishes a new scope but the only variable
        // bound in that scope is the catch parameter. Any other
        // declarations create bindings in the outer scope.
        addPattern(path.get("param"), bindings);

    } else {
        recursiveScanScope(path, bindings);
    }
}

function recursiveScanScope(path, bindings) {
    var node = path.value;

    if (path.parent &&
        namedTypes.FunctionExpression.check(path.parent.node) &&
        path.parent.node.id) {
        addPattern(path.parent.get("id"), bindings);
    }

    if (!node) {
        // None of the remaining cases matter if node is falsy.

    } else if (isArray.check(node)) {
        path.each(function(childPath) {
            recursiveScanChild(childPath, bindings);
        });

    } else if (namedTypes.Function.check(node)) {
        path.get("params").each(function(paramPath) {
            addPattern(paramPath, bindings);
        });

        recursiveScanChild(path.get("body"), bindings);

    } else if (namedTypes.VariableDeclarator.check(node)) {
        addPattern(path.get("id"), bindings);
        recursiveScanChild(path.get("init"), bindings);

    } else if (node.type === "ImportSpecifier" ||
               node.type === "ImportNamespaceSpecifier" ||
               node.type === "ImportDefaultSpecifier") {
        addPattern(
            node.name ? path.get("name") : path.get("id"),
            bindings
        );

    } else if (Node.check(node) && !Expression.check(node)) {
        types.eachField(node, function(name, child) {
            var childPath = path.get(name);
            assert.strictEqual(childPath.value, child);
            recursiveScanChild(childPath, bindings);
        });
    }
}

function recursiveScanChild(path, bindings) {
    var node = path.value;

    if (!node || Expression.check(node)) {
        // Ignore falsy values and Expressions.

    } else if (namedTypes.FunctionDeclaration.check(node)) {
        addPattern(path.get("id"), bindings);

    } else if (namedTypes.ClassDeclaration &&
               namedTypes.ClassDeclaration.check(node)) {
        addPattern(path.get("id"), bindings);

    } else if (ScopeType.check(node)) {
        if (namedTypes.CatchClause.check(node)) {
            var catchParamName = node.param.name;
            var hadBinding = hasOwn.call(bindings, catchParamName);

            // Any declarations that occur inside the catch body that do
            // not have the same name as the catch parameter should count
            // as bindings in the outer scope.
            recursiveScanScope(path.get("body"), bindings);

            // If a new binding matching the catch parameter name was
            // created while scanning the catch body, ignore it because it
            // actually refers to the catch parameter and not the outer
            // scope that we're currently scanning.
            if (!hadBinding) {
                delete bindings[catchParamName];
            }
        }

    } else {
        recursiveScanScope(path, bindings);
    }
}

function addPattern(patternPath, bindings) {
    var pattern = patternPath.value;
    namedTypes.Pattern.assert(pattern);

    if (namedTypes.Identifier.check(pattern)) {
        if (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
        } else {
            bindings[pattern.name] = [patternPath];
        }

    } else if (namedTypes.ObjectPattern &&
               namedTypes.ObjectPattern.check(pattern)) {
        patternPath.get('properties').each(function(propertyPath) {
            var property = propertyPath.value;
            if (namedTypes.Pattern.check(property)) {
                addPattern(propertyPath, bindings);
            } else  if (namedTypes.Property.check(property)) {
                addPattern(propertyPath.get('value'), bindings);
            } else if (namedTypes.SpreadProperty &&
                       namedTypes.SpreadProperty.check(property)) {
                addPattern(propertyPath.get('argument'), bindings);
            }
        });

    } else if (namedTypes.ArrayPattern &&
               namedTypes.ArrayPattern.check(pattern)) {
        patternPath.get('elements').each(function(elementPath) {
            var element = elementPath.value;
            if (namedTypes.Pattern.check(element)) {
                addPattern(elementPath, bindings);
            } else if (namedTypes.SpreadElement &&
                       namedTypes.SpreadElement.check(element)) {
                addPattern(elementPath.get("argument"), bindings);
            }
        });

    } else if (namedTypes.PropertyPattern &&
               namedTypes.PropertyPattern.check(pattern)) {
        addPattern(patternPath.get('pattern'), bindings);

    } else if ((namedTypes.SpreadElementPattern &&
                namedTypes.SpreadElementPattern.check(pattern)) ||
               (namedTypes.SpreadPropertyPattern &&
                namedTypes.SpreadPropertyPattern.check(pattern))) {
        addPattern(patternPath.get('argument'), bindings);
    }
}

Sp.lookup = function(name) {
    for (var scope = this; scope; scope = scope.parent)
        if (scope.declares(name))
            break;
    return scope;
};

Sp.getGlobalScope = function() {
    var scope = this;
    while (!scope.isGlobal)
        scope = scope.parent;
    return scope;
};

module.exports = Scope;

},{"./node-path":133,"./types":138,"assert":306}],137:[function(require,module,exports){
var types = require("../lib/types");
var Type = types.Type;
var builtin = types.builtInTypes;
var isNumber = builtin.number;

// An example of constructing a new type with arbitrary constraints from
// an existing type.
exports.geq = function(than) {
    return new Type(function(value) {
        return isNumber.check(value) && value >= than;
    }, isNumber + " >= " + than);
};

// Default value-returning functions that may optionally be passed as a
// third argument to Def.prototype.field.
exports.defaults = {
    // Functions were used because (among other reasons) that's the most
    // elegant way to allow for the emptyArray one always to give a new
    // array instance.
    "null": function() { return null },
    "emptyArray": function() { return [] },
    "false": function() { return false },
    "true": function() { return true },
    "undefined": function() {}
};

var naiveIsPrimitive = Type.or(
    builtin.string,
    builtin.number,
    builtin.boolean,
    builtin.null,
    builtin.undefined
);

exports.isPrimitive = new Type(function(value) {
    if (value === null)
        return true;
    var type = typeof value;
    return !(type === "object" ||
             type === "function");
}, naiveIsPrimitive.toString());

},{"../lib/types":138}],138:[function(require,module,exports){
var assert = require("assert");
var Ap = Array.prototype;
var slice = Ap.slice;
var map = Ap.map;
var each = Ap.forEach;
var Op = Object.prototype;
var objToStr = Op.toString;
var funObjStr = objToStr.call(function(){});
var strObjStr = objToStr.call("");
var hasOwn = Op.hasOwnProperty;

// A type is an object with a .check method that takes a value and returns
// true or false according to whether the value matches the type.

function Type(check, name) {
    var self = this;
    assert.ok(self instanceof Type, self);

    // Unfortunately we can't elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    assert.strictEqual(objToStr.call(check), funObjStr,
                       check + " is not a function");

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    assert.ok(nameObjStr === funObjStr ||
              nameObjStr === strObjStr,
              name + " is neither a function nor a string");

    Object.defineProperties(self, {
        name: { value: name },
        check: {
            value: function(value, deep) {
                var result = check.call(self, value, deep);
                if (!result && deep && objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}

var Tp = Type.prototype;

// Throughout this file we use Object.defineProperty to prevent
// redefinition of exported properties.
exports.Type = Type;

// Like .check, except that failure triggers an AssertionError.
Tp.assert = function(value, deep) {
    if (!this.check(value, deep)) {
        var str = shallowStringify(value);
        assert.ok(false, str + " does not match type " + this);
        return false;
    }
    return true;
};

function shallowStringify(value) {
    if (isObject.check(value))
        return "{" + Object.keys(value).map(function(key) {
            return key + ": " + value[key];
        }).join(", ") + "}";

    if (isArray.check(value))
        return "[" + value.map(shallowStringify).join(", ") + "]";

    return JSON.stringify(value);
}

Tp.toString = function() {
    var name = this.name;

    if (isString.check(name))
        return name;

    if (isFunction.check(name))
        return name.call(this) + "";

    return name + " type";
};

var builtInTypes = {};
exports.builtInTypes = builtInTypes;

function defBuiltInType(example, name) {
    var objStr = objToStr.call(example);

    Object.defineProperty(builtInTypes, name, {
        enumerable: true,
        value: new Type(function(value) {
            return objToStr.call(value) === objStr;
        }, name)
    });

    return builtInTypes[name];
}

// These types check the underlying [[Class]] attribute of the given
// value, rather than using the problematic typeof operator. Note however
// that no subtyping is considered; so, for instance, isObject.check
// returns false for [], /./, new Date, and null.
var isString = defBuiltInType("", "string");
var isFunction = defBuiltInType(function(){}, "function");
var isArray = defBuiltInType([], "array");
var isObject = defBuiltInType({}, "object");
var isRegExp = defBuiltInType(/./, "RegExp");
var isDate = defBuiltInType(new Date, "Date");
var isNumber = defBuiltInType(3, "number");
var isBoolean = defBuiltInType(true, "boolean");
var isNull = defBuiltInType(null, "null");
var isUndefined = defBuiltInType(void 0, "undefined");

// There are a number of idiomatic ways of expressing types, so this
// function serves to coerce them all to actual Type objects. Note that
// providing the name argument is not necessary in most cases.
function toType(from, name) {
    // The toType function should of course be idempotent.
    if (from instanceof Type)
        return from;

    // The Def type is used as a helper for constructing compound
    // interface types for AST nodes.
    if (from instanceof Def)
        return from.type;

    // Support [ElemType] syntax.
    if (isArray.check(from))
        return Type.fromArray(from);

    // Support { someField: FieldType, ... } syntax.
    if (isObject.check(from))
        return Type.fromObject(from);

    // If isFunction.check(from), assume that from is a binary predicate
    // function we can use to define the type.
    if (isFunction.check(from))
        return new Type(from, name);

    // As a last resort, toType returns a type that matches any value that
    // is === from. This is primarily useful for literal values like
    // toType(null), but it has the additional advantage of allowing
    // toType to be a total function.
    return new Type(function(value) {
        return value === from;
    }, isUndefined.check(name) ? function() {
        return from + "";
    } : name);
}

// Returns a type that matches the given value iff any of type1, type2,
// etc. match the value.
Type.or = function(/* type1, type2, ... */) {
    var types = [];
    var len = arguments.length;
    for (var i = 0; i < len; ++i)
        types.push(toType(arguments[i]));

    return new Type(function(value, deep) {
        for (var i = 0; i < len; ++i)
            if (types[i].check(value, deep))
                return true;
        return false;
    }, function() {
        return types.join(" | ");
    });
};

Type.fromArray = function(arr) {
    assert.ok(isArray.check(arr));
    assert.strictEqual(
        arr.length, 1,
        "only one element type is permitted for typed arrays");
    return toType(arr[0]).arrayOf();
};

Tp.arrayOf = function() {
    var elemType = this;
    return new Type(function(value, deep) {
        return isArray.check(value) && value.every(function(elem) {
            return elemType.check(elem, deep);
        });
    }, function() {
        return "[" + elemType + "]";
    });
};

Type.fromObject = function(obj) {
    var fields = Object.keys(obj).map(function(name) {
        return new Field(name, obj[name]);
    });

    return new Type(function(value, deep) {
        return isObject.check(value) && fields.every(function(field) {
            return field.type.check(value[field.name], deep);
        });
    }, function() {
        return "{ " + fields.join(", ") + " }";
    });
};

function Field(name, type, defaultFn, hidden) {
    var self = this;

    assert.ok(self instanceof Field);
    isString.assert(name);

    type = toType(type);

    var properties = {
        name: { value: name },
        type: { value: type },
        hidden: { value: !!hidden }
    };

    if (isFunction.check(defaultFn)) {
        properties.defaultFn = { value: defaultFn };
    }

    Object.defineProperties(self, properties);
}

var Fp = Field.prototype;

Fp.toString = function() {
    return JSON.stringify(this.name) + ": " + this.type;
};

Fp.getValue = function(obj) {
    var value = obj[this.name];

    if (!isUndefined.check(value))
        return value;

    if (this.defaultFn)
        value = this.defaultFn.call(obj);

    return value;
};

// Define a type whose name is registered in a namespace (the defCache) so
// that future definitions will return the same type given the same name.
// In particular, this system allows for circular and forward definitions.
// The Def object d returned from Type.def may be used to configure the
// type d.type by calling methods such as d.bases, d.build, and d.field.
Type.def = function(typeName) {
    isString.assert(typeName);
    return hasOwn.call(defCache, typeName)
        ? defCache[typeName]
        : defCache[typeName] = new Def(typeName);
};

// In order to return the same Def instance every time Type.def is called
// with a particular name, those instances need to be stored in a cache.
var defCache = Object.create(null);

function Def(typeName) {
    var self = this;
    assert.ok(self instanceof Def);

    Object.defineProperties(self, {
        typeName: { value: typeName },
        baseNames: { value: [] },
        ownFields: { value: Object.create(null) },

        // These two are populated during finalization.
        allSupertypes: { value: Object.create(null) }, // Includes own typeName.
        supertypeList: { value: [] }, // Linear inheritance hierarchy.
        allFields: { value: Object.create(null) }, // Includes inherited fields.
        fieldNames: { value: [] }, // Non-hidden keys of allFields.

        type: {
            value: new Type(function(value, deep) {
                return self.check(value, deep);
            }, typeName)
        }
    });
}

Def.fromValue = function(value) {
    if (value && typeof value === "object") {
        var type = value.type;
        if (typeof type === "string" &&
            hasOwn.call(defCache, type)) {
            var d = defCache[type];
            if (d.finalized) {
                return d;
            }
        }
    }

    return null;
};

var Dp = Def.prototype;

Dp.isSupertypeOf = function(that) {
    if (that instanceof Def) {
        assert.strictEqual(this.finalized, true);
        assert.strictEqual(that.finalized, true);
        return hasOwn.call(that.allSupertypes, this.typeName);
    } else {
        assert.ok(false, that + " is not a Def");
    }
};

// Note that the list returned by this function is a copy of the internal
// supertypeList, *without* the typeName itself as the first element.
exports.getSupertypeNames = function(typeName) {
    assert.ok(hasOwn.call(defCache, typeName));
    var d = defCache[typeName];
    assert.strictEqual(d.finalized, true);
    return d.supertypeList.slice(1);
};

// Returns an object mapping from every known type in the defCache to the
// most specific supertype whose name is an own property of the candidates
// object.
exports.computeSupertypeLookupTable = function(candidates) {
    var table = {};
    var typeNames = Object.keys(defCache);
    var typeNameCount = typeNames.length;

    for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        var d = defCache[typeName];
        assert.strictEqual(d.finalized, true);
        for (var j = 0; j < d.supertypeList.length; ++j) {
            var superTypeName = d.supertypeList[j];
            if (hasOwn.call(candidates, superTypeName)) {
                table[typeName] = superTypeName;
                break;
            }
        }
    }

    return table;
};

Dp.checkAllFields = function(value, deep) {
    var allFields = this.allFields;
    assert.strictEqual(this.finalized, true);

    function checkFieldByName(name) {
        var field = allFields[name];
        var type = field.type;
        var child = field.getValue(value);
        return type.check(child, deep);
    }

    return isObject.check(value)
        && Object.keys(allFields).every(checkFieldByName);
};

Dp.check = function(value, deep) {
    assert.strictEqual(
        this.finalized, true,
        "prematurely checking unfinalized type " + this.typeName);

    // A Def type can only match an object value.
    if (!isObject.check(value))
        return false;

    var vDef = Def.fromValue(value);
    if (!vDef) {
        // If we couldn't infer the Def associated with the given value,
        // and we expected it to be a SourceLocation or a Position, it was
        // probably just missing a "type" field (because Esprima does not
        // assign a type property to such nodes). Be optimistic and let
        // this.checkAllFields make the final decision.
        if (this.typeName === "SourceLocation" ||
            this.typeName === "Position") {
            return this.checkAllFields(value, deep);
        }

        // Calling this.checkAllFields for any other type of node is both
        // bad for performance and way too forgiving.
        return false;
    }

    // If checking deeply and vDef === this, then we only need to call
    // checkAllFields once. Calling checkAllFields is too strict when deep
    // is false, because then we only care about this.isSupertypeOf(vDef).
    if (deep && vDef === this)
        return this.checkAllFields(value, deep);

    // In most cases we rely exclusively on isSupertypeOf to make O(1)
    // subtyping determinations. This suffices in most situations outside
    // of unit tests, since interface conformance is checked whenever new
    // instances are created using builder functions.
    if (!this.isSupertypeOf(vDef))
        return false;

    // The exception is when deep is true; then, we recursively check all
    // fields.
    if (!deep)
        return true;

    // Use the more specific Def (vDef) to perform the deep check, but
    // shallow-check fields defined by the less specific Def (this).
    return vDef.checkAllFields(value, deep)
        && this.checkAllFields(value, false);
};

Dp.bases = function() {
    var bases = this.baseNames;

    assert.strictEqual(this.finalized, false);

    each.call(arguments, function(baseName) {
        isString.assert(baseName);

        // This indexOf lookup may be O(n), but the typical number of base
        // names is very small, and indexOf is a native Array method.
        if (bases.indexOf(baseName) < 0)
            bases.push(baseName);
    });

    return this; // For chaining.
};

// False by default until .build(...) is called on an instance.
Object.defineProperty(Dp, "buildable", { value: false });

var builders = {};
exports.builders = builders;

// This object is used as prototype for any node created by a builder.
var nodePrototype = {};

// Call this function to define a new method to be shared by all AST
// nodes. The replaced method (if any) is returned for easy wrapping.
exports.defineMethod = function(name, func) {
    var old = nodePrototype[name];

    // Pass undefined as func to delete nodePrototype[name].
    if (isUndefined.check(func)) {
        delete nodePrototype[name];

    } else {
        isFunction.assert(func);

        Object.defineProperty(nodePrototype, name, {
            enumerable: true, // For discoverability.
            configurable: true, // For delete proto[name].
            value: func
        });
    }

    return old;
};

// Calling the .build method of a Def simultaneously marks the type as
// buildable (by defining builders[getBuilderName(typeName)]) and
// specifies the order of arguments that should be passed to the builder
// function to create an instance of the type.
Dp.build = function(/* param1, param2, ... */) {
    var self = this;

    // Calling Def.prototype.build multiple times has the effect of merely
    // redefining this property.
    Object.defineProperty(self, "buildParams", {
        value: slice.call(arguments),
        writable: false,
        enumerable: false,
        configurable: true
    });

    assert.strictEqual(self.finalized, false);
    isString.arrayOf().assert(self.buildParams);

    if (self.buildable) {
        // If this Def is already buildable, update self.buildParams and
        // continue using the old builder function.
        return self;
    }

    // Every buildable type will have its "type" field filled in
    // automatically. This includes types that are not subtypes of Node,
    // like SourceLocation, but that seems harmless (TODO?).
    self.field("type", self.typeName, function() { return self.typeName });

    // Override Dp.buildable for this Def instance.
    Object.defineProperty(self, "buildable", { value: true });

    Object.defineProperty(builders, getBuilderName(self.typeName), {
        enumerable: true,

        value: function() {
            var args = arguments;
            var argc = args.length;
            var built = Object.create(nodePrototype);

            assert.ok(
                self.finalized,
                "attempting to instantiate unfinalized type " + self.typeName);

            function add(param, i) {
                if (hasOwn.call(built, param))
                    return;

                var all = self.allFields;
                assert.ok(hasOwn.call(all, param), param);

                var field = all[param];
                var type = field.type;
                var value;

                if (isNumber.check(i) && i < argc) {
                    value = args[i];
                } else if (field.defaultFn) {
                    // Expose the partially-built object to the default
                    // function as its `this` object.
                    value = field.defaultFn.call(built);
                } else {
                    var message = "no value or default function given for field " +
                        JSON.stringify(param) + " of " + self.typeName + "(" +
                            self.buildParams.map(function(name) {
                                return all[name];
                            }).join(", ") + ")";
                    assert.ok(false, message);
                }

                if (!type.check(value)) {
                    assert.ok(
                        false,
                        shallowStringify(value) +
                            " does not match field " + field +
                            " of type " + self.typeName
                    );
                }

                // TODO Could attach getters and setters here to enforce
                // dynamic type safety.
                built[param] = value;
            }

            self.buildParams.forEach(function(param, i) {
                add(param, i);
            });

            Object.keys(self.allFields).forEach(function(param) {
                add(param); // Use the default value.
            });

            // Make sure that the "type" field was filled automatically.
            assert.strictEqual(built.type, self.typeName);

            return built;
        }
    });

    return self; // For chaining.
};

function getBuilderName(typeName) {
    return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
        var len = upperCasePrefix.length;
        switch (len) {
        case 0: return "";
        // If there's only one initial capital letter, just lower-case it.
        case 1: return upperCasePrefix.toLowerCase();
        default:
            // If there's more than one initial capital letter, lower-case
            // all but the last one, so that XMLDefaultDeclaration (for
            // example) becomes xmlDefaultDeclaration.
            return upperCasePrefix.slice(
                0, len - 1).toLowerCase() +
                upperCasePrefix.charAt(len - 1);
        }
    });
}

// The reason fields are specified using .field(...) instead of an object
// literal syntax is somewhat subtle: the object literal syntax would
// support only one key and one value, but with .field(...) we can pass
// any number of arguments to specify the field.
Dp.field = function(name, type, defaultFn, hidden) {
    assert.strictEqual(this.finalized, false);
    this.ownFields[name] = new Field(name, type, defaultFn, hidden);
    return this; // For chaining.
};

var namedTypes = {};
exports.namedTypes = namedTypes;

// Like Object.keys, but aware of what fields each AST type should have.
function getFieldNames(object) {
    var d = Def.fromValue(object);
    if (d) {
        return d.fieldNames.slice(0);
    }

    if ("type" in object) {
        assert.ok(
            false,
            "did not recognize object of type " +
                JSON.stringify(object.type)
        );
    }

    return Object.keys(object);
}
exports.getFieldNames = getFieldNames;

// Get the value of an object property, taking object.type and default
// functions into account.
function getFieldValue(object, fieldName) {
    var d = Def.fromValue(object);
    if (d) {
        var field = d.allFields[fieldName];
        if (field) {
            return field.getValue(object);
        }
    }

    return object[fieldName];
}
exports.getFieldValue = getFieldValue;

// Iterate over all defined fields of an object, including those missing
// or undefined, passing each field name and effective value (as returned
// by getFieldValue) to the callback. If the object has no corresponding
// Def, the callback will never be called.
exports.eachField = function(object, callback, context) {
    getFieldNames(object).forEach(function(name) {
        callback.call(this, name, getFieldValue(object, name));
    }, context);
};

// Similar to eachField, except that iteration stops as soon as the
// callback returns a truthy value. Like Array.prototype.some, the final
// result is either true or false to indicates whether the callback
// returned true for any element or not.
exports.someField = function(object, callback, context) {
    return getFieldNames(object).some(function(name) {
        return callback.call(this, name, getFieldValue(object, name));
    }, context);
};

// This property will be overridden as true by individual Def instances
// when they are finalized.
Object.defineProperty(Dp, "finalized", { value: false });

Dp.finalize = function() {
    // It's not an error to finalize a type more than once, but only the
    // first call to .finalize does anything.
    if (!this.finalized) {
        var allFields = this.allFields;
        var allSupertypes = this.allSupertypes;

        this.baseNames.forEach(function(name) {
            var def = defCache[name];
            def.finalize();
            extend(allFields, def.allFields);
            extend(allSupertypes, def.allSupertypes);
        });

        // TODO Warn if fields are overridden with incompatible types.
        extend(allFields, this.ownFields);
        allSupertypes[this.typeName] = this;

        this.fieldNames.length = 0;
        for (var fieldName in allFields) {
            if (hasOwn.call(allFields, fieldName) &&
                !allFields[fieldName].hidden) {
                this.fieldNames.push(fieldName);
            }
        }

        // Types are exported only once they have been finalized.
        Object.defineProperty(namedTypes, this.typeName, {
            enumerable: true,
            value: this.type
        });

        Object.defineProperty(this, "finalized", { value: true });

        // A linearization of the inheritance hierarchy.
        populateSupertypeList(this.typeName, this.supertypeList);
    }
};

function populateSupertypeList(typeName, list) {
    list.length = 0;
    list.push(typeName);

    var lastSeen = Object.create(null);

    for (var pos = 0; pos < list.length; ++pos) {
        typeName = list[pos];
        var d = defCache[typeName];
        assert.strictEqual(d.finalized, true);

        // If we saw typeName earlier in the breadth-first traversal,
        // delete the last-seen occurrence.
        if (hasOwn.call(lastSeen, typeName)) {
            delete list[lastSeen[typeName]];
        }

        // Record the new index of the last-seen occurrence of typeName.
        lastSeen[typeName] = pos;

        // Enqueue the base names of this type.
        list.push.apply(list, d.baseNames);
    }

    // Compaction loop to remove array holes.
    for (var to = 0, from = to, len = list.length; from < len; ++from) {
        if (hasOwn.call(list, from)) {
            list[to++] = list[from];
        }
    }

    list.length = to;
}

function extend(into, from) {
    Object.keys(from).forEach(function(name) {
        into[name] = from[name];
    });

    return into;
};

exports.finalize = function() {
    Object.keys(defCache).forEach(function(name) {
        defCache[name].finalize();
    });
};

},{"assert":306}],139:[function(require,module,exports){
var types = require("./lib/types");

// This core module of AST types captures ES5 as it is parsed today by
// git://github.com/ariya/esprima.git#master.
require("./def/core");

// Feel free to add to or remove from this list of extension modules to
// configure the precise type hierarchy that you need.
require("./def/es6");
require("./def/es7");
require("./def/mozilla");
require("./def/e4x");
require("./def/fb-harmony");

types.finalize();

exports.Type = types.Type;
exports.builtInTypes = types.builtInTypes;
exports.namedTypes = types.namedTypes;
exports.builders = types.builders;
exports.defineMethod = types.defineMethod;
exports.getFieldNames = types.getFieldNames;
exports.getFieldValue = types.getFieldValue;
exports.eachField = types.eachField;
exports.someField = types.someField;
exports.getSupertypeNames = types.getSupertypeNames;
exports.astNodesAreEquivalent = require("./lib/equiv");
exports.finalize = types.finalize;
exports.NodePath = require("./lib/node-path");
exports.PathVisitor = require("./lib/path-visitor");
exports.visit = exports.PathVisitor.visit;

},{"./def/core":126,"./def/e4x":127,"./def/es6":128,"./def/es7":129,"./def/fb-harmony":130,"./def/mozilla":131,"./lib/equiv":132,"./lib/node-path":133,"./lib/path-visitor":134,"./lib/types":138}],140:[function(require,module,exports){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var chalk = module.exports;

function build(_styles) {
	var builder = function builder() {
		return applyStyle.apply(builder, arguments);
	};
	builder._styles = _styles;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	builder.__proto__ = proto;
	return builder;
}

var styles = (function () {
	var ret = {};

	ansiStyles.grey = ansiStyles.gray;

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build(this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);
	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!chalk.enabled || !str) {
		return str;
	}

	/*jshint validthis: true*/
	var nestedStyles = this._styles;

	for (var i = 0; i < nestedStyles.length; i++) {
		var code = ansiStyles[nestedStyles[i]];
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build([name]);
			}
		};
	});

	return ret;
}

defineProps(chalk, init());

chalk.styles = ansiStyles;
chalk.hasColor = hasAnsi;
chalk.stripColor = stripAnsi;
chalk.supportsColor = supportsColor;

// detect mode if not set manually
if (chalk.enabled === undefined) {
	chalk.enabled = chalk.supportsColor;
}

},{"ansi-styles":141,"escape-string-regexp":142,"has-ansi":143,"strip-ansi":145,"supports-color":147}],141:[function(require,module,exports){
'use strict';
var styles = module.exports;

var codes = {
	reset: [0, 0],

	bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
	dim: [2, 22],
	italic: [3, 23],
	underline: [4, 24],
	inverse: [7, 27],
	hidden: [8, 28],
	strikethrough: [9, 29],

	black: [30, 39],
	red: [31, 39],
	green: [32, 39],
	yellow: [33, 39],
	blue: [34, 39],
	magenta: [35, 39],
	cyan: [36, 39],
	white: [37, 39],
	gray: [90, 39],

	bgBlack: [40, 49],
	bgRed: [41, 49],
	bgGreen: [42, 49],
	bgYellow: [43, 49],
	bgBlue: [44, 49],
	bgMagenta: [45, 49],
	bgCyan: [46, 49],
	bgWhite: [47, 49]
};

Object.keys(codes).forEach(function (key) {
	var val = codes[key];
	var style = styles[key] = {};
	style.open = '\u001b[' + val[0] + 'm';
	style.close = '\u001b[' + val[1] + 'm';
});

},{}],142:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe,  '\\$&');
};

},{}],143:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":144}],144:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /\u001b\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]/g;
};

},{}],145:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":146}],146:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"dup":144}],147:[function(require,module,exports){
(function (process){
'use strict';
module.exports = (function () {
	if (process.argv.indexOf('--no-color') !== -1) {
		return false;
	}

	if (process.argv.indexOf('--color') !== -1) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":315}],148:[function(require,module,exports){
/**
 * Core.js 0.5.4
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.'
  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md
  , CONSOLE_METHODS = 'assert,clear,count,debug,dir,dirxml,error,exception,' +
      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +
      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +
      'timelineEnd,timeStamp,trace,warn';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}
function construct(target, argumentsList /*, newTarget*/){
  var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
    , instance = create(isObject(proto) ? proto : ObjectProto)
    , result   = apply.call(target, instance, argumentsList);
  return isObject(result) ? result : instance;
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_SPECIES     = getWellKnownSymbol('species');
function setSpecies(C){
  if(framework || !isNative(C))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

// Iterators
var SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR)
  , SYMBOL_TAG      = getWellKnownSymbol(TO_STRING_TAG)
  , SUPPORT_FF_ITER = FF_ITERATOR in ArrayProto
  , ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
  , NATIVE_ITERATORS = SYMBOL_ITERATOR in ArrayProto
    // Safari define byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  SUPPORT_FF_ITER && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function forOf(iterable, entries, fn, that){
  var iterator = getIterator(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false)return;
}

// core
var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32
  , SIMPLE = 64;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal || type & SIMPLE)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR,
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object                                                        *
 ******************************************************************************/

!function(tmp){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
  
  if(framework){
    // 19.1.3.6 Object.prototype.toString()
    tmp[SYMBOL_TAG] = DOT;
    if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
      return '[object ' + classof(this) + ']';
    });
  }
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.number                                                        *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array                                                         *
 ******************************************************************************/

!function(){
  $define(STATIC, ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, iter, step;
      if(isIterable(O))for(iter = getIterator(O), result = new (generic(this, Array)); !(step = iter.next()).done; index++){
        result[index] = mapping ? f(step.value, index) : step.value;
      } else for(result = new (generic(this, Array))(length = toLength(O.length)); length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
      result.length = index;
      return result;
    },
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }  
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, DEF){
    function isThenable(o){
      var then;
      if(isObject(o))then = o.then;
      return isFunction(then) ? then : false;
    }
    function notify(def){
      var chain = def.chain;
      chain.length && asap(function(){
        var msg = def.msg
          , ok  = def.state == 1
          , i   = 0;
        while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              ret = cb === true ? msg : cb(msg);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(msg);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(msg){
      var def = this
        , then, wrapper;
      if(def.done)return;
      def.done = true;
      def = def.def || def; // unwrap
      try {
        if(then = isThenable(msg)){
          wrapper = {def: def, done: false}; // wrap
          then.call(msg, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          def.msg = msg;
          def.state = 1;
          notify(def);
        }
      } catch(err){
        reject.call(wrapper || {def: def, done: false}, err); // wrap
      }
    }
    function reject(msg){
      var def = this;
      if(def.done)return;
      def.done = true;
      def = def.def || def; // unwrap
      def.msg = msg;
      def.state = 2;
      notify(def);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var def = {chain: [], state: 0, done: false, msg: undefined};
      hidden(this, DEF, def);
      try {
        executor(ctx(resolve, def, 1), ctx(reject, def, 1));
      } catch(err){
        reject.call(def, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), def = this[DEF];
        def.chain.push(react);
        def.state && notify(def);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && DEF in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('def'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(!NATIVE_ITERATORS || !C.length){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: construct,
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values: createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : core.dict                                                         *
 ******************************************************************************/

!function(DICT){
  Dict = function(iterable){
    var dict = create(null);
    if(iterable != undefined){
      if(isIterable(iterable)){
        for(var iter = getIterator(iterable), step, value; !(step = iter.next()).done;){
          value = step.value;
          dict[value[0]] = value[1];
        }
      } else assign(dict, iterable);
    }
    return dict;
  }
  Dict[PROTOTYPE] = null;
  
  function DictIterator(iterated, kind){
    set(this, ITER, {o: toObject(iterated), a: getKeys(iterated), i: 0, k: kind});
  }
  createIterator(DictIterator, DICT, function(){
    var iter = this[ITER]
      , O    = iter.o
      , keys = iter.a
      , kind = iter.k
      , key;
    do {
      if(iter.i >= keys.length){
        iter.o = undefined;
        return iterResult(1);
      }
    } while(!has(O, key = keys[iter.i++]));
    if(kind == KEY)  return iterResult(0, key);
    if(kind == VALUE)return iterResult(0, O[key]);
                     return iterResult(0, [key, O[key]]);
  });
  function createDictIter(kind){
    return function(it){
      return new DictIterator(it, kind);
    }
  }
  
  /*
   * 0 -> forEach
   * 1 -> map
   * 2 -> filter
   * 3 -> some
   * 4 -> every
   * 5 -> find
   * 6 -> findKey
   * 7 -> mapPairs
   */
  function createDictMethod(type){
    var isMap    = type == 1
      , isEvery  = type == 4;
    return function(object, callbackfn, that /* = undefined */){
      var f      = ctx(callbackfn, that, 3)
        , O      = toObject(object)
        , result = isMap || type == 7 || type == 2 ? new (generic(this, Dict)) : undefined
        , key, val, res;
      for(key in O)if(has(O, key)){
        val = O[key];
        res = f(val, key, object);
        if(type){
          if(isMap)result[key] = res;             // map
          else if(res)switch(type){
            case 2: result[key] = val; break      // filter
            case 3: return true;                  // some
            case 5: return val;                   // find
            case 6: return key;                   // findKey
            case 7: result[res[0]] = res[1];      // mapPairs
          } else if(isEvery)return false;         // every
        }
      }
      return type == 3 || isEvery ? isEvery : result;
    }
  }
  function createDictReduce(isTurn){
    return function(object, mapfn, init){
      assertFunction(mapfn);
      var O      = toObject(object)
        , keys   = getKeys(O)
        , length = keys.length
        , i      = 0
        , memo, key, result;
      if(isTurn)memo = init == undefined ? new (generic(this, Dict)) : Object(init);
      else if(arguments.length < 3){
        assert(length, REDUCE_ERROR);
        memo = O[keys[i++]];
      } else memo = Object(init);
      while(length > i)if(has(O, key = keys[i++])){
        result = mapfn(memo, O[key], key, object);
        if(isTurn){
          if(result === false)break;
        } else memo = result;
      }
      return memo;
    }
  }
  var findKey = createDictMethod(6);
  function includes(object, el){
    return (el == el ? keyOf(object, el) : findKey(object, sameNaN)) !== undefined;
  }
  
  var dictMethods = {
    keys:    createDictIter(KEY),
    values:  createDictIter(VALUE),
    entries: createDictIter(KEY+VALUE),
    forEach: createDictMethod(0),
    map:     createDictMethod(1),
    filter:  createDictMethod(2),
    some:    createDictMethod(3),
    every:   createDictMethod(4),
    find:    createDictMethod(5),
    findKey: findKey,
    mapPairs:createDictMethod(7),
    reduce:  createDictReduce(false),
    turn:    createDictReduce(true),
    keyOf:   keyOf,
    includes:includes,
    // Has / get / set own property
    has: has,
    get: get,
    set: createDefiner(0),
    isDict: function(it){
      return isObject(it) && getPrototypeOf(it) === Dict[PROTOTYPE];
    }
  };
  
  if(REFERENCE_GET)for(var key in dictMethods)!function(fn){
    function method(){
      for(var args = [this], i = 0; i < arguments.length;)args.push(arguments[i++]);
      return invoke(fn, args);
    }
    fn[REFERENCE_GET] = function(){
      return method;
    }
  }(dictMethods[key]);
  
  $define(GLOBAL + FORCED, {Dict: assignHidden(Dict, dictMethods)});
}('Dict');

/******************************************************************************
 * Module : core.$for                                                         *
 ******************************************************************************/

!function(ENTRIES, FN){  
  function $for(iterable, entries){
    if(!(this instanceof $for))return new $for(iterable, entries);
    this[ITER]    = getIterator(iterable);
    this[ENTRIES] = !!entries;
  }
  
  createIterator($for, 'Wrapper', function(){
    return this[ITER].next();
  });
  var $forProto = $for[PROTOTYPE];
  setIterator($forProto, function(){
    return this[ITER]; // unwrap
  });
  
  function createChainIterator(next){
    function Iter(I, fn, that){
      this[ITER]    = getIterator(I);
      this[ENTRIES] = I[ENTRIES];
      this[FN]      = ctx(fn, that, I[ENTRIES] ? 2 : 1);
    }
    createIterator(Iter, 'Chain', next, $forProto);
    setIterator(Iter[PROTOTYPE], returnThis); // override $forProto iterator
    return Iter;
  }
  
  var MapIter = createChainIterator(function(){
    var step = this[ITER].next();
    return step.done ? step : iterResult(0, stepCall(this[FN], step.value, this[ENTRIES]));
  });
  
  var FilterIter = createChainIterator(function(){
    for(;;){
      var step = this[ITER].next();
      if(step.done || stepCall(this[FN], step.value, this[ENTRIES]))return step;
    }
  });
  
  assignHidden($forProto, {
    of: function(fn, that){
      forOf(this, this[ENTRIES], fn, that);
    },
    array: function(fn, that){
      var result = [];
      forOf(fn != undefined ? this.map(fn, that) : this, false, push, result);
      return result;
    },
    filter: function(fn, that){
      return new FilterIter(this, fn, that);
    },
    map: function(fn, that){
      return new MapIter(this, fn, that);
    }
  });
  
  $for.isIterable  = isIterable;
  $for.getIterator = getIterator;
  
  $define(GLOBAL + FORCED, {$for: $for});
}('entries', safeSymbol('fn'));

/******************************************************************************
 * Module : core.delay                                                        *
 ******************************************************************************/

// https://esdiscuss.org/topic/promise-returning-delay-function
$define(GLOBAL + FORCED, {
  delay: function(time){
    return new Promise(function(resolve){
      setTimeout(resolve, time, true);
    });
  }
});

/******************************************************************************
 * Module : core.binding                                                      *
 ******************************************************************************/

!function(_, toLocaleString){
  // Placeholder
  core._ = path._ = path._ || {};

  $define(PROTO + FORCED, FUNCTION, {
    part: part,
    only: function(numberArguments, that /* = @ */){
      var fn     = assertFunction(this)
        , n      = toLength(numberArguments)
        , isThat = arguments.length > 1;
      return function(/* ...args */){
        var length = min(n, arguments.length)
          , args   = Array(length)
          , i      = 0;
        while(length > i)args[i] = arguments[i++];
        return invoke(fn, args, isThat ? that : this);
      }
    }
  });
  
  function tie(key){
    var that  = this
      , bound = {};
    return hidden(that, _, function(key){
      if(key === undefined || !(key in that))return toLocaleString.call(that);
      return has(bound, key) ? bound[key] : (bound[key] = ctx(that[key], that, -1));
    })[_](key);
  }
  
  hidden(path._, TO_STRING, function(){
    return _;
  });
  
  hidden(ObjectProto, _, tie);
  DESC || hidden(ArrayProto, _, tie);
  // IE8- dirty hack - redefined toLocaleString is not enumerable
}(DESC ? uid('tie') : TO_LOCALE, ObjectProto[TO_LOCALE]);

/******************************************************************************
 * Module : core.object                                                       *
 ******************************************************************************/

!function(){
  function define(target, mixin){
    var keys   = ownKeys(toObject(mixin))
      , length = keys.length
      , i = 0, key;
    while(length > i)defineProperty(target, key = keys[i++], getOwnDescriptor(mixin, key));
    return target;
  };
  $define(STATIC + FORCED, OBJECT, {
    isObject: isObject,
    classof: classof,
    define: define,
    make: function(proto, mixin){
      return define(create(proto), mixin);
    }
  });
}();

/******************************************************************************
 * Module : core.array                                                        *
 ******************************************************************************/

$define(PROTO + FORCED, ARRAY, {
  turn: function(fn, target /* = [] */){
    assertFunction(fn);
    var memo   = target == undefined ? [] : Object(target)
      , O      = ES5Object(this)
      , length = toLength(O.length)
      , index  = 0;
    while(length > index)if(fn(memo, O[index], index++, this) === false)break;
    return memo;
  }
});
if(framework)ArrayUnscopables.turn = true;

/******************************************************************************
 * Module : core.number                                                       *
 ******************************************************************************/

!function(numberMethods){  
  function NumberIterator(iterated){
    set(this, ITER, {l: toLength(iterated), i: 0});
  }
  createIterator(NumberIterator, NUMBER, function(){
    var iter = this[ITER]
      , i    = iter.i++;
    return i < iter.l ? iterResult(0, i) : iterResult(1);
  });
  defineIterator(Number, NUMBER, function(){
    return new NumberIterator(this);
  });
  
  numberMethods.random = function(lim /* = 0 */){
    var a = +this
      , b = lim == undefined ? 0 : +lim
      , m = min(a, b);
    return random() * (max(a, b) - m) + m;
  };

  forEach.call(array(
      // ES3:
      'round,floor,ceil,abs,sin,asin,cos,acos,tan,atan,exp,sqrt,max,min,pow,atan2,' +
      // ES6:
      'acosh,asinh,atanh,cbrt,clz32,cosh,expm1,hypot,imul,log1p,log10,log2,sign,sinh,tanh,trunc'
    ), function(key){
      var fn = Math[key];
      if(fn)numberMethods[key] = function(/* ...args */){
        // ie9- dont support strict mode & convert `this` to object -> convert it to number
        var args = [+this]
          , i    = 0;
        while(arguments.length > i)args.push(arguments[i++]);
        return invoke(fn, args);
      }
    }
  );
  
  $define(PROTO + FORCED, NUMBER, numberMethods);
}({});

/******************************************************************************
 * Module : core.string                                                       *
 ******************************************************************************/

!function(){
  var escapeHTMLDict = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  }, unescapeHTMLDict = {}, key;
  for(key in escapeHTMLDict)unescapeHTMLDict[escapeHTMLDict[key]] = key;
  $define(PROTO + FORCED, STRING, {
    escapeHTML:   createReplacer(/[&<>"']/g, escapeHTMLDict),
    unescapeHTML: createReplacer(/&(?:amp|lt|gt|quot|apos);/g, unescapeHTMLDict)
  });
}();

/******************************************************************************
 * Module : core.date                                                         *
 ******************************************************************************/

!function(formatRegExp, flexioRegExp, locales, current, SECONDS, MINUTES, HOURS, MONTH, YEAR){
  function createFormat(prefix){
    return function(template, locale /* = current */){
      var that = this
        , dict = locales[has(locales, locale) ? locale : current];
      function get(unit){
        return that[prefix + unit]();
      }
      return String(template).replace(formatRegExp, function(part){
        switch(part){
          case 's'  : return get(SECONDS);                  // Seconds : 0-59
          case 'ss' : return lz(get(SECONDS));              // Seconds : 00-59
          case 'm'  : return get(MINUTES);                  // Minutes : 0-59
          case 'mm' : return lz(get(MINUTES));              // Minutes : 00-59
          case 'h'  : return get(HOURS);                    // Hours   : 0-23
          case 'hh' : return lz(get(HOURS));                // Hours   : 00-23
          case 'D'  : return get(DATE);                     // Date    : 1-31
          case 'DD' : return lz(get(DATE));                 // Date    : 01-31
          case 'W'  : return dict[0][get('Day')];           // Day     : Понедельник
          case 'N'  : return get(MONTH) + 1;                // Month   : 1-12
          case 'NN' : return lz(get(MONTH) + 1);            // Month   : 01-12
          case 'M'  : return dict[2][get(MONTH)];           // Month   : Январь
          case 'MM' : return dict[1][get(MONTH)];           // Month   : Января
          case 'Y'  : return get(YEAR);                     // Year    : 2014
          case 'YY' : return lz(get(YEAR) % 100);           // Year    : 14
        } return part;
      });
    }
  }
  function addLocale(lang, locale){
    function split(index){
      var result = [];
      forEach.call(array(locale.months), function(it){
        result.push(it.replace(flexioRegExp, '$' + index));
      });
      return result;
    }
    locales[lang] = [array(locale.weekdays), split(1), split(2)];
    return core;
  }
  $define(PROTO + FORCED, DATE, {
    format:    createFormat('get'),
    formatUTC: createFormat('getUTC')
  });
  addLocale(current, {
    weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday',
    months: 'January,February,March,April,May,June,July,August,September,October,November,December'
  });
  addLocale('ru', {
    weekdays: 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',
    months: 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,' +
            'Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь'
  });
  core.locale = function(locale){
    return has(locales, locale) ? current = locale : current;
  };
  core.addLocale = addLocale;
}(/\b\w\w?\b/g, /:(.*)\|(.*)$/, {}, 'en', 'Seconds', 'Minutes', 'Hours', 'Month', 'FullYear');

/******************************************************************************
 * Module : core.global                                                       *
 ******************************************************************************/

$define(GLOBAL + FORCED, {global: global});

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);

/******************************************************************************
 * Module : core.log                                                          *
 ******************************************************************************/

!function(log, console, enabled){
  forEach.call(array(CONSOLE_METHODS), function(key){
    log[key] = function(){
      if(enabled && key in console)return apply.call(console[key], console, arguments);
    };
  });
  $define(GLOBAL + FORCED, {log: assign(log.log, log, {
    enable: function(){
      enabled = true;
    },
    disable: function(){
      enabled = false;
    }
  })});
}({}, global.console || {}, true);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), false);
},{}],149:[function(require,module,exports){
/**
 * Core.js 0.5.4
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.'
  // Methods from https://github.com/DeveloperToolsWG/console-object/blob/master/api.md
  , CONSOLE_METHODS = 'assert,clear,count,debug,dir,dirxml,error,exception,' +
      'group,groupCollapsed,groupEnd,info,isIndependentlyComposed,log,' +
      'markTimeline,profile,profileEnd,table,time,timeEnd,timeline,' +
      'timelineEnd,timeStamp,trace,warn';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}
function construct(target, argumentsList /*, newTarget*/){
  var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
    , instance = create(isObject(proto) ? proto : ObjectProto)
    , result   = apply.call(target, instance, argumentsList);
  return isObject(result) ? result : instance;
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_SPECIES     = getWellKnownSymbol('species');
function setSpecies(C){
  if(framework || !isNative(C))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

// Iterators
var SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR)
  , SYMBOL_TAG      = getWellKnownSymbol(TO_STRING_TAG)
  , SUPPORT_FF_ITER = FF_ITERATOR in ArrayProto
  , ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
  , NATIVE_ITERATORS = SYMBOL_ITERATOR in ArrayProto
    // Safari define byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  SUPPORT_FF_ITER && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function forOf(iterable, entries, fn, that){
  var iterator = getIterator(iterable)
    , f        = ctx(fn, that, entries ? 2 : 1)
    , step;
  while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false)return;
}

// core
var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32
  , SIMPLE = 64;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal || type & SIMPLE)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR,
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object                                                        *
 ******************************************************************************/

!function(tmp){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
  
  if(framework){
    // 19.1.3.6 Object.prototype.toString()
    tmp[SYMBOL_TAG] = DOT;
    if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
      return '[object ' + classof(this) + ']';
    });
  }
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.function                                                      *
 ******************************************************************************/

!function(NAME){
  // 19.2.4.2 name
  NAME in FunctionProto || defineProperty(FunctionProto, NAME, {
    configurable: true,
    get: function(){
      var match = String(this).match(/^\s*function ([^ (]*)/)
        , name  = match ? match[1] : '';
      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));
      return name;
    },
    set: function(value){
      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));
    }
  });
}('name');

/******************************************************************************
 * Module : es6.number.constructor                                            *
 ******************************************************************************/

Number('0o1') && Number('0b1') || function(_Number, NumberProto){
  function toNumber(it){
    if(isObject(it))it = toPrimitive(it);
    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
      var binary = false;
      switch(it.charCodeAt(1)){
        case 66 : case 98  : binary = true;
        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
      }
    } return +it;
  }
  function toPrimitive(it){
    var fn, val;
    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to number");
  }
  Number = function Number(it){
    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);
  }
  forEach.call(DESC ? getNames(_Number)
  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){
    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));
  });
  Number[PROTOTYPE] = NumberProto;
  NumberProto[CONSTRUCTOR] = Number;
  hidden(global, NUMBER, Number);
}(Number, Number[PROTOTYPE]);

/******************************************************************************
 * Module : es6.number                                                        *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array                                                         *
 ******************************************************************************/

!function(){
  $define(STATIC, ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, iter, step;
      if(isIterable(O))for(iter = getIterator(O), result = new (generic(this, Array)); !(step = iter.next()).done; index++){
        result[index] = mapping ? f(step.value, index) : step.value;
      } else for(result = new (generic(this, Array))(length = toLength(O.length)); length > index; index++){
        result[index] = mapping ? f(O[index], index) : O[index];
      }
      result.length = index;
      return result;
    },
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }  
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : es6.regexp                                                        *
 ******************************************************************************/

!function(RegExpProto, _RegExp){
  function assertRegExpWrapper(fn){
    return function(){
      assert(cof(this) === REGEXP);
      return fn(this);
    }
  }
  
  // RegExp allows a regex with flags as the pattern
  if(DESC && !function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){
    RegExp = function RegExp(pattern, flags){
      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined
        ? pattern.source : pattern, flags);
    }
    forEach.call(getNames(_RegExp), function(key){
      key in RegExp || defineProperty(RegExp, key, {
        configurable: true,
        get: function(){ return _RegExp[key] },
        set: function(it){ _RegExp[key] = it }
      });
    });
    RegExpProto[CONSTRUCTOR] = RegExp;
    RegExp[PROTOTYPE] = RegExpProto;
    hidden(global, REGEXP, RegExp);
  }
  
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {
    configurable: true,
    get: assertRegExpWrapper(createReplacer(/^.*\/(\w*)$/, '$1', true))
  });
  
  // 21.2.5.12 get RegExp.prototype.sticky()
  // 21.2.5.15 get RegExp.prototype.unicode()
  forEach.call(array('sticky,unicode'), function(key){
    key in /./ || defineProperty(RegExpProto, key, DESC ? {
      configurable: true,
      get: assertRegExpWrapper(function(){
        return false;
      })
    } : descriptor(5, false));
  });
  
  setSpecies(RegExp);
}(RegExp[PROTOTYPE], RegExp);

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, DEF){
    function isThenable(o){
      var then;
      if(isObject(o))then = o.then;
      return isFunction(then) ? then : false;
    }
    function notify(def){
      var chain = def.chain;
      chain.length && asap(function(){
        var msg = def.msg
          , ok  = def.state == 1
          , i   = 0;
        while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              ret = cb === true ? msg : cb(msg);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(msg);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(msg){
      var def = this
        , then, wrapper;
      if(def.done)return;
      def.done = true;
      def = def.def || def; // unwrap
      try {
        if(then = isThenable(msg)){
          wrapper = {def: def, done: false}; // wrap
          then.call(msg, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          def.msg = msg;
          def.state = 1;
          notify(def);
        }
      } catch(err){
        reject.call(wrapper || {def: def, done: false}, err); // wrap
      }
    }
    function reject(msg){
      var def = this;
      if(def.done)return;
      def.done = true;
      def = def.def || def; // unwrap
      def.msg = msg;
      def.state = 2;
      notify(def);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var def = {chain: [], state: 0, done: false, msg: undefined};
      hidden(this, DEF, def);
      try {
        executor(ctx(resolve, def, 1), ctx(reject, def, 1));
      } catch(err){
        reject.call(def, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), def = this[DEF];
        def.chain.push(react);
        def.state && notify(def);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && DEF in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('def'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(!NATIVE_ITERATORS || !C.length){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: construct,
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values: createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);
},{}],150:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":152}],151:[function(require,module,exports){
(function (process){

/**
 * Module dependencies.
 */

var tty = require('tty');
var util = require('util');

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
  if (0 === debugColors.length) {
    return tty.isatty(fd);
  } else {
    return '0' !== debugColors
        && 'no' !== debugColors
        && 'false' !== debugColors
        && 'disabled' !== debugColors;
  }
}

/**
 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
 */

var inspect = (4 === util.inspect.length ?
  // node <= 0.8.x
  function (v, colors) {
    return util.inspect(v, void 0, void 0, colors);
  } :
  // node > 0.8.x
  function (v, colors) {
    return util.inspect(v, { colors: colors });
  }
);

exports.formatters.o = function(v) {
  return inspect(v, this.useColors)
    .replace(/\s*\n\s*/g, ' ');
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;
  var name = this.namespace;

  if (useColors) {
    var c = this.color;

    args[0] = '  \u001b[9' + c + 'm' + name + ' '
      + '\u001b[0m'
      + args[0] + '\u001b[3' + c + 'm'
      + ' +' + exports.humanize(this.diff) + '\u001b[0m';
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
  return args;
}

/**
 * Invokes `console.error()` with the specified arguments.
 */

function log() {
  return stream.write(util.format.apply(this, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = require('fs');
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require('net');
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());

}).call(this,require('_process'))

},{"./debug":150,"_process":315,"fs":305,"net":305,"tty":329,"util":331}],152:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],153:[function(require,module,exports){
'use strict';
var repeating = require('repeating');

// detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment
var INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
	var result = 0;
	var maxUsed = 0;
	var maxWeight = 0;

	for (var n in indents) {
		var indent = indents[n];
		var u = indent[0];
		var w = indent[1];

		if (u > maxUsed || u === maxUsed && w > maxWeight) {
			maxUsed = u;
			maxWeight = w;
			result = +n;
		}
	}

	return result;
}

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	// used to see if tabs or spaces are the most used
	var tabs = 0;
	var spaces = 0;

	// remember the size of previous line's indentation
	var prev = 0;

	// remember how many indents/unindents as occurred for a given size
	// and how much lines follow a given indentation
	//
	// indents = {
	//    3: [1, 0],
	//    4: [1, 5],
	//    5: [1, 0],
	//   12: [1, 0],
	// }
	var indents = {};

	// pointer to the array of last used indent
	var current;

	// whether the last action was an indent (opposed to an unindent)
	var isIndent;

	str.split(/\n/g).forEach(function (line) {
		if (!line) {
			// ignore empty lines
			return;
		}

		var indent;
		var matches = line.match(INDENT_RE);

		if (!matches) {
			indent = 0;
		} else {
			indent = matches[0].length;

			if (matches[1]) {
				spaces++;
			} else {
				tabs++;
			}
		}

		var diff = indent - prev;
		prev = indent;

		if (diff) {
			// an indent or unindent has been detected

			isIndent = diff > 0;

			current = indents[isIndent ? diff : -diff];

			if (current) {
				current[0]++;
			} else {
				current = indents[diff] = [1, 0];
			}
		} else if (current) {
			// if the last action was an indent, increment the weight
			current[1] += +isIndent;
		}
	});

	var amount = getMostUsed(indents);

	var type;
	var actual;
	if (!amount) {
		type = null;
		actual = '';
	} else if (spaces >= tabs) {
		type = 'space';
		actual = repeating(' ', amount);
	} else {
		type = 'tab';
		actual = repeating('\t', amount);
	}

	return {
		amount: amount,
		type: type,
		indent: actual
	};
};

},{"repeating":286}],154:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        objectKeys(from).forEach(function (key) {
            to[key] = from[key];
        });
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportDeclaration: 'ExportDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportBatchSpecifier: [],
        ExportDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['id', 'name'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['id'],
        ImportNamespaceSpecifier: ['id'],
        ImportSpecifier: ['id', 'name'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],155:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],156:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    // See `tools/generate-identifier-regex.js`.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],157:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":156}],158:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":155,"./code":156,"./keyword":157}],159:[function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"nonstandard": {
		"escape": false,
		"unescape": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"applicationCache": false,
		"atob": false,
		"Audio": false,
		"AudioProcessingEvent": false,
		"BeforeUnloadEvent": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": false,
		"closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"crypto": false,
		"CSS": false,
		"CustomEvent": false,
		"DataView": false,
		"Debug": false,
		"defaultStatus": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DOMParser": false,
		"DragEvent": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"FileReader": false,
		"find": false,
		"focus": false,
		"FocusEvent": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"history": false,
		"HTMLAnchorElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPreElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLUListElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"Intl": false,
		"KeyboardEvent": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"matchMedia": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MouseEvent": false,
		"moveBy": false,
		"moveTo": false,
		"MutationObserver": false,
		"name": false,
		"navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		"open": false,
		"openDatabase": false,
		"opener": false,
		"opera": false,
		"Option": false,
		"outerHeight": false,
		"outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		"parent": false,
		"PopStateEvent": false,
		"postMessage": false,
		"print": false,
		"ProgressEvent": false,
		"prompt": false,
		"Range": false,
		"removeEventListener": false,
		"requestAnimationFrame": false,
		"resizeBy": false,
		"resizeTo": false,
		"screen": false,
		"screenX": false,
		"screenY": false,
		"scroll": false,
		"scrollbars": false,
		"scrollBy": false,
		"scrollTo": false,
		"scrollX": false,
		"scrollY": false,
		"self": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"status": false,
		"stop": false,
		"StorageEvent": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TimeEvent": false,
		"top": false,
		"TouchEvent": false,
		"UIEvent": false,
		"URL": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLHttpRequest": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false
	},
	"worker": {
		"importScripts": true,
		"postMessage": true,
		"self": true
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"DataView": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"module": false,
		"process": false,
		"require": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"ObjectId": false,
		"PlanCache": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	}
}

},{}],160:[function(require,module,exports){
module.exports = require('./globals.json');

},{"./globals.json":159}],161:[function(require,module,exports){
// https://github.com/paulmillr/es6-shim
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isinteger
var isNaN = require("is-nan");
var isFinite = require("is-finite");
module.exports = Number.isInteger || function(val) {
	return typeof val === "number" &&
		! isNaN(val) &&
		isFinite(val) &&
		parseInt(val, 10) === val;
};

},{"is-finite":162,"is-nan":163}],162:[function(require,module,exports){
'use strict';
module.exports = Number.isFinite || function (val) {
	// Number.isNaN() => val !== val
	if (typeof val !== 'number' || val !== val || val === Infinity || val === -Infinity) {
		return false;
	}

	return true;
};

},{}],163:[function(require,module,exports){
"use strict";

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


},{}],164:[function(require,module,exports){
function combine () {
  return new RegExp('('+[].slice.call(arguments).map(function (e) {
    var e = e.toString()
    return '(?:' + e.substring(1, e.length - 1) + ')'
  }).join('|')+')')
}

function makeTester (rx) {
  var s = rx.toString()
  return new RegExp('^' + s.substring(1, s.length -1) + '$')
//  return new RegExp('('+[].slice.call(arguments).map(function (e) {
//    var e = e.toString()
//    return '(?:' + e.substring(1, e.length - 1) + ')'
//  }).join('|')+')')  
}

var pattern = {
  string1    : /"(?:(?:\\\n|\\"|[^"\n]))*?"/
, string2    : /'(?:(?:\\\n|\\'|[^'\n]))*?'/
//, string2    : /'(?:(?:\\'|[^']))*?'/
, comment1   : /\/\*[\s\S]*?\*\//
, comment2   : /\/\/.*?\n/
, whitespace : /\s+/
, keyword    : /\b(?:var|let|for|if|else|in|class|function|return|with|case|break|switch|export|new|while|do|throw|catch)\b/
, regexp     : /\/(?:(?:\\\/|[^\n\/]))*?\//
, name       : /[a-zA-Z_\$][a-zA-Z_\$0-9]*/
, number     : /\d+(?:\.\d+)?(?:e[+-]?\d+)?/
, parens     : /[\(\)]/
, curly      : /[{}]/
, square     : /[\[\]]/
, punct      : /[;.:\?\^%<>=!&|+\-,~]/
}

var match = combine(
  pattern.string1
, pattern.string2
, pattern.comment1
, pattern.comment2
, pattern.regexp
, pattern.whitespace
, pattern.name
, pattern.number
, pattern.parens
, pattern.curly
, pattern.square
, pattern.punct
)

var tester = {}

for(var k in pattern) {
  tester[k] = makeTester(pattern[k])
}

module.exports = function (str, doNotThrow) {
  return str.split(match).filter(function (e, i) {
    if(i % 2)
      return true

    if(e !== '') {
      if(!doNotThrow)
        throw new Error('invalid token:'+JSON.stringify(e))
      return true
    }
  })
}

module.exports.type = function (e) {
  for (var type in pattern)
    if(tester[type].test(e))
      return type
  return 'invalid'
}

},{}],165:[function(require,module,exports){
// intentionally commented out as it makes it slower...
//'use strict';

var arr = [];
var charCodeCache = [];

module.exports = function (a, b) {
	if (a === b) {
		return 0;
	}

	var aLen = a.length;
	var bLen = b.length;

	if (aLen === 0) {
		return bLen;
	}

	if (bLen === 0) {
		return aLen;
	}

	var bCharCode;
	var ret;
	var tmp;
	var tmp2;
	var i = 0;
	var j = 0;

	while (i < aLen) {
		charCodeCache[i] = a.charCodeAt(i);
		arr[i] = ++i;
	}

	while (j < bLen) {
		bCharCode = b.charCodeAt(j);
		tmp = j++;
		ret = j;

		for (i = 0; i < aLen; i++) {
			tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + 1;
			tmp = arr[i];
			ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
		}
	}

	return ret;
};

},{}],166:[function(require,module,exports){
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = compact;

},{}],167:[function(require,module,exports){
var baseFlatten = require('../internal/baseFlatten'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Flattens a nested array. If `isDeep` is `true` the array is recursively
 * flattened, otherwise it is only flattened a single level.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2], [3, [[4]]]]);
 * // => [1, 2, 3, [[4]]];
 *
 * // using `isDeep`
 * _.flatten([1, [2], [3, [[4]]]], true);
 * // => [1, 2, 3, 4];
 */
function flatten(array, isDeep, guard) {
  var length = array ? array.length : 0;
  if (guard && isIterateeCall(array, isDeep, guard)) {
    isDeep = false;
  }
  return length ? baseFlatten(array, isDeep) : [];
}

module.exports = flatten;

},{"../internal/baseFlatten":194,"../internal/isIterateeCall":234}],168:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],169:[function(require,module,exports){
var baseIndexOf = require('../internal/baseIndexOf');

/** Used for native method references. */
var arrayProto = Array.prototype;

/** Native method references. */
var splice = arrayProto.splice;

/**
 * Removes all provided values from `array` using `SameValueZero` for equality
 * comparisons.
 *
 * **Notes:**
 *  - Unlike `_.without`, this method mutates `array`.
 *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
 *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 *    for more details.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 * _.pull(array, 2, 3);
 * console.log(array);
 * // => [1, 1]
 */
function pull() {
  var array = arguments[0];
  if (!(array && array.length)) {
    return array;
  }
  var index = 0,
      indexOf = baseIndexOf,
      length = arguments.length;

  while (++index < length) {
    var fromIndex = 0,
        value = arguments[index];

    while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
      splice.call(array, fromIndex, 1);
    }
  }
  return array;
}

module.exports = pull;

},{"../internal/baseIndexOf":200}],170:[function(require,module,exports){
var baseCallback = require('../internal/baseCallback'),
    baseUniq = require('../internal/baseUniq'),
    isIterateeCall = require('../internal/isIterateeCall'),
    sortedUniq = require('../internal/sortedUniq');

/**
 * Creates a duplicate-value-free version of an array using `SameValueZero`
 * for equality comparisons. Providing `true` for `isSorted` performs a faster
 * search algorithm for sorted arrays. If an iteratee function is provided it
 * is invoked for each value in the array to generate the criterion by which
 * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
 * with three arguments; (value, index, array).
 *
 * If a property name is provided for `predicate` the created "_.property"
 * style callback returns the property value of the given element.
 *
 * If value is also provided for `thisArg` the created "_.matchesProperty"
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created "_.matches" style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
 * e.g. `===`, except that `NaN` matches `NaN`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * for more details.
 *
 * @static
 * @memberOf _
 * @alias unique
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {boolean} [isSorted] Specify the array is sorted.
 * @param {Function|Object|string} [iteratee] The function invoked per iteration.
 *  If a property name or object is provided it is used to create a "_.property"
 *  or "_.matches" style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new duplicate-value-free array.
 * @example
 *
 * _.uniq([1, 2, 1]);
 * // => [1, 2]
 *
 * // using `isSorted`
 * _.uniq([1, 1, 2], true);
 * // => [1, 2]
 *
 * // using an iteratee function
 * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);
 * // => [1, 2.5]
 *
 * // using the "_.property" callback shorthand
 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniq(array, isSorted, iteratee, thisArg) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  // Juggle arguments.
  if (typeof isSorted != 'boolean' && isSorted != null) {
    thisArg = iteratee;
    iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
    isSorted = false;
  }
  iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
  return (isSorted)
    ? sortedUniq(array, iteratee)
    : baseUniq(array, iteratee);
}

module.exports = uniq;

},{"../internal/baseCallback":188,"../internal/baseUniq":215,"../internal/isIterateeCall":234,"../internal/sortedUniq":241}],171:[function(require,module,exports){
module.exports = require('./includes');

},{"./includes":175}],172:[function(require,module,exports){
module.exports = require('./forEach');

},{"./forEach":173}],173:[function(require,module,exports){
var arrayEach = require('../internal/arrayEach'),
    baseEach = require('../internal/baseEach'),
    bindCallback = require('../internal/bindCallback'),
    isArray = require('../lang/isArray');

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection). Iterator functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a `length` property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
function forEach(collection, iteratee, thisArg) {
  return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
    ? arrayEach(collection, iteratee)
    : baseEach(collection, bindCallback(iteratee, thisArg, 3));
}

module.exports = forEach;

},{"../internal/arrayEach":182,"../internal/baseEach":192,"../internal/bindCallback":217,"../lang/isArray":246}],174:[function(require,module,exports){
var createAggregator = require('../internal/createAggregator');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` through `iteratee`. The corresponding value
 * of each key is an array of the elements responsible for generating the key.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created "_.property"
 * style callback returns the property value of the given element.
 *
 * If value is also provided for `thisArg` the created "_.matchesProperty"
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created "_.matches" style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration. If a property name or object is provided it is used to
 *  create a "_.property" or "_.matches" style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });
 * // => { '4': [4.2], '6': [6.1, 6.4] }
 *
 * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
 * // => { '4': [4.2], '6': [6.1, 6.4] }
 *
 * // using the "_.property" callback shorthand
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    result[key] = [value];
  }
});

module.exports = groupBy;

},{"../internal/createAggregator":222}],175:[function(require,module,exports){
var baseIndexOf = require('../internal/baseIndexOf'),
    isArray = require('../lang/isArray'),
    isLength = require('../internal/isLength'),
    isString = require('../lang/isString'),
    values = require('../object/values');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection` using `SameValueZero` for equality
 * comparisons. If `fromIndex` is negative, it is used as the offset from
 * the end of `collection`.
 *
 * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
 * e.g. `===`, except that `NaN` matches `NaN`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
 * for more details.
 *
 * @static
 * @memberOf _
 * @alias contains, include
 * @category Collection
 * @param {Array|Object|string} collection The collection to search.
 * @param {*} target The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {boolean} Returns `true` if a matching element is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
 * // => true
 *
 * _.includes('pebbles', 'eb');
 * // => true
 */
function includes(collection, target, fromIndex) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    collection = values(collection);
    length = collection.length;
  }
  if (!length) {
    return false;
  }
  if (typeof fromIndex == 'number') {
    fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
  } else {
    fromIndex = 0;
  }
  return (typeof collection == 'string' || !isArray(collection) && isString(collection))
    ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
    : (baseIndexOf(collection, target, fromIndex) > -1);
}

module.exports = includes;

},{"../internal/baseIndexOf":200,"../internal/isLength":235,"../lang/isArray":246,"../lang/isString":255,"../object/values":265}],176:[function(require,module,exports){
var arrayMap = require('../internal/arrayMap'),
    baseCallback = require('../internal/baseCallback'),
    baseMap = require('../internal/baseMap'),
    isArray = require('../lang/isArray');

/**
 * Creates an array of values by running each element in `collection` through
 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
 * arguments; (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created "_.property"
 * style callback returns the property value of the given element.
 *
 * If value is also provided for `thisArg` the created "_.matchesProperty"
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created "_.matches" style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * Many lodash methods are guarded to work as interatees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
 * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
 * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
 * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
 *
 * @static
 * @memberOf _
 * @alias collect
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration. If a property name or object is provided it is used to
 *  create a "_.property" or "_.matches" style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * _.map([1, 2, 3], function(n) { return n * 3; });
 * // => [3, 6, 9]
 *
 * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });
 * // => [3, 6, 9] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // using the "_.property" callback shorthand
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee, thisArg) {
  var func = isArray(collection) ? arrayMap : baseMap;
  iteratee = baseCallback(iteratee, thisArg, 3);
  return func(collection, iteratee);
}

module.exports = map;

},{"../internal/arrayMap":183,"../internal/baseCallback":188,"../internal/baseMap":204,"../lang/isArray":246}],177:[function(require,module,exports){
var arrayReduceRight = require('../internal/arrayReduceRight'),
    baseCallback = require('../internal/baseCallback'),
    baseEachRight = require('../internal/baseEachRight'),
    baseReduce = require('../internal/baseReduce'),
    isArray = require('../lang/isArray');

/**
 * This method is like `_.reduce` except that it iterates over elements of
 * `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @alias foldr
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * var array = [[0, 1], [2, 3], [4, 5]];
 * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);
 * // => [4, 5, 2, 3, 0, 1]
 */
function reduceRight(collection, iteratee, accumulator, thisArg) {
  var func = isArray(collection) ? arrayReduceRight : baseReduce;
  return func(collection, baseCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
}

module.exports = reduceRight;

},{"../internal/arrayReduceRight":184,"../internal/baseCallback":188,"../internal/baseEachRight":193,"../internal/baseReduce":210,"../lang/isArray":246}],178:[function(require,module,exports){
var arraySome = require('../internal/arraySome'),
    baseCallback = require('../internal/baseCallback'),
    baseSome = require('../internal/baseSome'),
    isArray = require('../lang/isArray');

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * The function returns as soon as it finds a passing value and does not iterate
 * over the entire collection. The predicate is bound to `thisArg` and invoked
 * with three arguments; (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created "_.property"
 * style callback returns the property value of the given element.
 *
 * If value is also provided for `thisArg` the created "_.matchesProperty"
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created "_.matches" style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @alias any
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [predicate=_.identity] The function invoked
 *  per iteration. If a property name or object is provided it is used to
 *  create a "_.property" or "_.matches" style callback respectively.
 * @param {*} [thisArg] The `this` binding of `predicate`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * // using the "_.matches" callback shorthand
 * _.some(users, { 'age': 1, 'active': true });
 * // => false
 *
 * // using the "_.matchesProperty" callback shorthand
 * _.some(users, 'active', false);
 * // => true
 *
 * // using the "_.property" callback shorthand
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, thisArg) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
    predicate = baseCallback(predicate, thisArg, 3);
  }
  return func(collection, predicate);
}

module.exports = some;

},{"../internal/arraySome":185,"../internal/baseCallback":188,"../internal/baseSome":212,"../lang/isArray":246}],179:[function(require,module,exports){
var baseCallback = require('../internal/baseCallback'),
    baseEach = require('../internal/baseEach'),
    baseSortBy = require('../internal/baseSortBy'),
    compareAscending = require('../internal/compareAscending'),
    isIterateeCall = require('../internal/isIterateeCall'),
    isLength = require('../internal/isLength');

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through `iteratee`. This method performs
 * a stable sort, that is, it preserves the original sort order of equal elements.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created "_.property"
 * style callback returns the property value of the given element.
 *
 * If value is also provided for `thisArg` the created "_.matchesProperty"
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created "_.matches" style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity] The function
 *  invoked per iteration. If a property name or an object is provided it is
 *  used to create a "_.property" or "_.matches" style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });
 * // => [3, 1, 2]
 *
 * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);
 * // => [3, 1, 2]
 *
 * var users = [
 *   { 'user': 'fred' },
 *   { 'user': 'pebbles' },
 *   { 'user': 'barney' }
 * ];
 *
 * // using the "_.property" callback shorthand
 * _.pluck(_.sortBy(users, 'user'), 'user');
 * // => ['barney', 'fred', 'pebbles']
 */
function sortBy(collection, iteratee, thisArg) {
  var index = -1,
      length = collection ? collection.length : 0,
      result = isLength(length) ? Array(length) : [];

  if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
    iteratee = null;
  }
  iteratee = baseCallback(iteratee, thisArg, 3);
  baseEach(collection, function(value, key, collection) {
    result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
  });
  return baseSortBy(result, compareAscending);
}

module.exports = sortBy;

},{"../internal/baseCallback":188,"../internal/baseEach":192,"../internal/baseSortBy":213,"../internal/compareAscending":221,"../internal/isIterateeCall":234,"../internal/isLength":235}],180:[function(require,module,exports){
(function (global){
var cachePush = require('./cachePush'),
    isNative = require('../lang/isNative');

/** Native method references. */
var Set = isNative(Set = global.Set) && Set;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;

/**
 *
 * Creates a cache object to store unique values.
 *
 * @private
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var length = values ? values.length : 0;

  this.data = { 'hash': nativeCreate(null), 'set': new Set };
  while (length--) {
    this.push(values[length]);
  }
}

// Add functions to the `Set` cache.
SetCache.prototype.push = cachePush;

module.exports = SetCache;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":250,"./cachePush":220}],181:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function arrayCopy(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = arrayCopy;

},{}],182:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],183:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],184:[function(require,module,exports){
/**
 * A specialized version of `_.reduceRight` for arrays without support for
 * callback shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initFromArray] Specify using the last element of `array`
 *  as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
  var length = array.length;
  if (initFromArray && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee(accumulator, array[length], length, array);
  }
  return accumulator;
}

module.exports = arrayReduceRight;

},{}],185:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],186:[function(require,module,exports){
/**
 * Used by `_.defaults` to customize its `_.assign` use.
 *
 * @private
 * @param {*} objectValue The destination object property value.
 * @param {*} sourceValue The source object property value.
 * @returns {*} Returns the value to assign to the destination object.
 */
function assignDefaults(objectValue, sourceValue) {
  return typeof objectValue == 'undefined' ? sourceValue : objectValue;
}

module.exports = assignDefaults;

},{}],187:[function(require,module,exports){
var baseCopy = require('./baseCopy'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize assigning values.
 * @returns {Object} Returns the destination object.
 */
function baseAssign(object, source, customizer) {
  var props = keys(source);
  if (!customizer) {
    return baseCopy(source, object, props);
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? result !== value : value === value) ||
        (typeof value == 'undefined' && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

module.exports = baseAssign;

},{"../object/keys":262,"./baseCopy":191}],188:[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    baseProperty = require('./baseProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    isBindable = require('./isBindable');

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return (typeof thisArg != 'undefined' && isBindable(func))
      ? bindCallback(func, thisArg, argCount)
      : func;
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return typeof thisArg == 'undefined'
    ? baseProperty(func + '')
    : baseMatchesProperty(func + '', thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":269,"./baseMatches":205,"./baseMatchesProperty":206,"./baseProperty":209,"./bindCallback":217,"./isBindable":232}],189:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    arrayEach = require('./arrayEach'),
    baseCopy = require('./baseCopy'),
    baseForOwn = require('./baseForOwn'),
    initCloneArray = require('./initCloneArray'),
    initCloneByTag = require('./initCloneByTag'),
    initCloneObject = require('./initCloneObject'),
    isArray = require('../lang/isArray'),
    isObject = require('../lang/isObject'),
    keys = require('../object/keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
cloneableTags[dateTag] = cloneableTags[float32Tag] =
cloneableTags[float64Tag] = cloneableTags[int8Tag] =
cloneableTags[int16Tag] = cloneableTags[int32Tag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[stringTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[mapTag] = cloneableTags[setTag] =
cloneableTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * The base implementation of `_.clone` without support for argument juggling
 * and `this` binding `customizer` functions.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The object `value` belongs to.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates clones with source counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object) : customizer(value);
  }
  if (typeof result != 'undefined') {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return arrayCopy(value, result);
    }
  } else {
    var tag = objToString.call(value),
        isFunc = tag == funcTag;

    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return baseCopy(value, result, keys(value));
      }
    } else {
      return cloneableTags[tag]
        ? initCloneByTag(value, tag, isDeep)
        : (object ? value : {});
    }
  }
  // Check for circular references and return corresponding clone.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == value) {
      return stackB[length];
    }
  }
  // Add the source value to the stack of traversed objects and associate it with its clone.
  stackA.push(value);
  stackB.push(result);

  // Recursively populate clone (susceptible to call stack limits).
  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
  });
  return result;
}

module.exports = baseClone;

},{"../lang/isArray":246,"../lang/isObject":252,"../object/keys":262,"./arrayCopy":181,"./arrayEach":182,"./baseCopy":191,"./baseForOwn":197,"./initCloneArray":229,"./initCloneByTag":230,"./initCloneObject":231}],190:[function(require,module,exports){
/**
 * The base implementation of `compareAscending` which compares values and
 * sorts them in ascending order without guaranteeing a stable sort.
 *
 * @private
 * @param {*} value The value to compare to `other`.
 * @param {*} other The value to compare to `value`.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function baseCompareAscending(value, other) {
  if (value !== other) {
    var valIsReflexive = value === value,
        othIsReflexive = other === other;

    if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
      return 1;
    }
    if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
      return -1;
    }
  }
  return 0;
}

module.exports = baseCompareAscending;

},{}],191:[function(require,module,exports){
/**
 * Copies the properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Array} props The property names to copy.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, object, props) {
  if (!props) {
    props = object;
    object = {};
  }
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],192:[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
function baseEach(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwn(collection, iteratee);
  }
  var index = -1,
      iterable = toObject(collection);

  while (++index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEach;

},{"./baseForOwn":197,"./isLength":235,"./toObject":242}],193:[function(require,module,exports){
var baseForOwnRight = require('./baseForOwnRight'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.forEachRight` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
function baseEachRight(collection, iteratee) {
  var length = collection ? collection.length : 0;
  if (!isLength(length)) {
    return baseForOwnRight(collection, iteratee);
  }
  var iterable = toObject(collection);
  while (length--) {
    if (iteratee(iterable[length], length, iterable) === false) {
      break;
    }
  }
  return collection;
}

module.exports = baseEachRight;

},{"./baseForOwnRight":198,"./isLength":235,"./toObject":242}],194:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
 * @param {number} [fromIndex=0] The index to start from.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, fromIndex) {
  var index = (fromIndex || 0) - 1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        value = baseFlatten(value, isDeep, isStrict);
      }
      var valIndex = -1,
          valLength = value.length;

      result.length += valLength;
      while (++valIndex < valLength) {
        result[++resIndex] = value[valIndex];
      }
    } else if (!isStrict) {
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"../lang/isArguments":245,"../lang/isArray":246,"./isLength":235,"./isObjectLike":236}],195:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iterator functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
function baseFor(object, iteratee, keysFunc) {
  var index = -1,
      iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (++index < length) {
    var key = props[index];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseFor;

},{"./toObject":242}],196:[function(require,module,exports){
var baseFor = require('./baseFor'),
    keysIn = require('../object/keysIn');

/**
 * The base implementation of `_.forIn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForIn(object, iteratee) {
  return baseFor(object, iteratee, keysIn);
}

module.exports = baseForIn;

},{"../object/keysIn":263,"./baseFor":195}],197:[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":262,"./baseFor":195}],198:[function(require,module,exports){
var baseForRight = require('./baseForRight'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwnRight` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwnRight(object, iteratee) {
  return baseForRight(object, iteratee, keys);
}

module.exports = baseForOwnRight;

},{"../object/keys":262,"./baseForRight":199}],199:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * This function is like `baseFor` except that it iterates over properties
 * in the opposite order.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
function baseForRight(object, iteratee, keysFunc) {
  var iterable = toObject(object),
      props = keysFunc(object),
      length = props.length;

  while (length--) {
    var key = props[length];
    if (iteratee(iterable[key], key, iterable) === false) {
      break;
    }
  }
  return object;
}

module.exports = baseForRight;

},{"./toObject":242}],200:[function(require,module,exports){
var indexOfNaN = require('./indexOfNaN');

/**
 * The base implementation of `_.indexOf` without support for binary searches.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = (fromIndex || 0) - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = baseIndexOf;

},{"./indexOfNaN":228}],201:[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep');

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
  // Exit early for identical values.
  if (value === other) {
    // Treat `+0` vs. `-0` as not equal.
    return value !== 0 || (1 / value == 1 / other);
  }
  var valType = typeof value,
      othType = typeof other;

  // Exit early for unlike primitive values.
  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
      value == null || other == null) {
    // Return `false` unless both values are `NaN`.
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
}

module.exports = baseIsEqual;

},{"./baseIsEqualDeep":202}],202:[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
      othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  if (valWrapped || othWrapped) {
    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":246,"../lang/isTypedArray":256,"./equalArrays":225,"./equalByTag":226,"./equalObjects":227}],203:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The source property names to match.
 * @param {Array} values The source values to match.
 * @param {Array} strictCompareFlags Strict comparison flags for source values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  var index = -1,
      noCustomizer = !customizer;

  while (++index < length) {
    if ((noCustomizer && strictCompareFlags[index])
          ? values[index] !== object[props[index]]
          : !hasOwnProperty.call(object, props[index])
        ) {
      return false;
    }
  }
  index = -1;
  while (++index < length) {
    var key = props[index];
    if (noCustomizer && strictCompareFlags[index]) {
      var result = hasOwnProperty.call(object, key);
    } else {
      var objValue = object[key],
          srcValue = values[index];

      result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (typeof result == 'undefined') {
        result = baseIsEqual(srcValue, objValue, customizer, true);
      }
    }
    if (!result) {
      return false;
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":201}],204:[function(require,module,exports){
var baseEach = require('./baseEach');

/**
 * The base implementation of `_.map` without support for callback shorthands
 * or `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var result = [];
  baseEach(collection, function(value, key, collection) {
    result.push(iteratee(value, key, collection));
  });
  return result;
}

module.exports = baseMap;

},{"./baseEach":192}],205:[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    isStrictComparable = require('./isStrictComparable'),
    keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var props = keys(source),
      length = props.length;

  if (length == 1) {
    var key = props[0],
        value = source[key];

    if (isStrictComparable(value)) {
      return function(object) {
        return object != null && value === object[key] && hasOwnProperty.call(object, key);
      };
    }
  }
  var values = Array(length),
      strictCompareFlags = Array(length);

  while (length--) {
    value = source[props[length]];
    values[length] = value;
    strictCompareFlags[length] = isStrictComparable(value);
  }
  return function(object) {
    return baseIsMatch(object, props, values, strictCompareFlags);
  };
}

module.exports = baseMatches;

},{"../object/keys":262,"./baseIsMatch":203,"./isStrictComparable":237}],206:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    isStrictComparable = require('./isStrictComparable');

/**
 * The base implementation of `_.matchesProperty` which does not coerce `key`
 * to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} value The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(key, value) {
  if (isStrictComparable(value)) {
    return function(object) {
      return object != null && object[key] === value;
    };
  }
  return function(object) {
    return object != null && baseIsEqual(value, object[key], null, true);
  };
}

module.exports = baseMatchesProperty;

},{"./baseIsEqual":201,"./isStrictComparable":237}],207:[function(require,module,exports){
var arrayEach = require('./arrayEach'),
    baseForOwn = require('./baseForOwn'),
    baseMergeDeep = require('./baseMergeDeep'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike'),
    isTypedArray = require('../lang/isTypedArray');

/**
 * The base implementation of `_.merge` without support for argument juggling,
 * multiple sources, and `this` binding `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {Object} Returns the destination object.
 */
function baseMerge(object, source, customizer, stackA, stackB) {
  var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));

  (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
    if (isObjectLike(srcValue)) {
      stackA || (stackA = []);
      stackB || (stackB = []);
      return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
    }
    var value = object[key],
        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
        isCommon = typeof result == 'undefined';

    if (isCommon) {
      result = srcValue;
    }
    if ((isSrcArr || typeof result != 'undefined') &&
        (isCommon || (result === result ? result !== value : value === value))) {
      object[key] = result;
    }
  });
  return object;
}

module.exports = baseMerge;

},{"../lang/isArray":246,"../lang/isTypedArray":256,"./arrayEach":182,"./baseForOwn":197,"./baseMergeDeep":208,"./isLength":235,"./isObjectLike":236}],208:[function(require,module,exports){
var arrayCopy = require('./arrayCopy'),
    isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isLength = require('./isLength'),
    isPlainObject = require('../lang/isPlainObject'),
    isTypedArray = require('../lang/isTypedArray'),
    toPlainObject = require('../lang/toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
  var length = stackA.length,
      srcValue = source[key];

  while (length--) {
    if (stackA[length] == srcValue) {
      object[key] = stackB[length];
      return;
    }
  }
  var value = object[key],
      result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
      isCommon = typeof result == 'undefined';

  if (isCommon) {
    result = srcValue;
    if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
      result = isArray(value)
        ? value
        : (value ? arrayCopy(value) : []);
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      result = isArguments(value)
        ? toPlainObject(value)
        : (isPlainObject(value) ? value : {});
    }
    else {
      isCommon = false;
    }
  }
  // Add the source value to the stack of traversed objects and associate
  // it with its merged value.
  stackA.push(srcValue);
  stackB.push(result);

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
  } else if (result === result ? result !== value : value === value) {
    object[key] = result;
  }
}

module.exports = baseMergeDeep;

},{"../lang/isArguments":245,"../lang/isArray":246,"../lang/isPlainObject":253,"../lang/isTypedArray":256,"../lang/toPlainObject":257,"./arrayCopy":181,"./isLength":235}],209:[function(require,module,exports){
/**
 * The base implementation of `_.property` which does not coerce `key` to a string.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],210:[function(require,module,exports){
/**
 * The base implementation of `_.reduce` and `_.reduceRight` without support
 * for callback shorthands or `this` binding, which iterates over `collection`
 * using the provided `eachFunc`.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initFromCollection Specify using the first or last element
 *  of `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initFromCollection
      ? (initFromCollection = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

},{}],211:[function(require,module,exports){
var identity = require('../utility/identity'),
    metaMap = require('./metaMap');

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"../utility/identity":269,"./metaMap":238}],212:[function(require,module,exports){
var baseEach = require('./baseEach');

/**
 * The base implementation of `_.some` without support for callback shorthands
 * or `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;

},{"./baseEach":192}],213:[function(require,module,exports){
/**
 * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
 * to define the sort order of `array` and replaces criteria objects with their
 * corresponding values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

},{}],214:[function(require,module,exports){
/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],215:[function(require,module,exports){
var baseIndexOf = require('./baseIndexOf'),
    cacheIndexOf = require('./cacheIndexOf'),
    createCache = require('./createCache');

/**
 * The base implementation of `_.uniq` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function baseUniq(array, iteratee) {
  var index = -1,
      indexOf = baseIndexOf,
      length = array.length,
      isCommon = true,
      isLarge = isCommon && length >= 200,
      seen = isLarge && createCache(),
      result = [];

  if (seen) {
    indexOf = cacheIndexOf;
    isCommon = false;
  } else {
    isLarge = false;
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (isCommon && value === value) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (indexOf(seen, computed) < 0) {
      if (iteratee || isLarge) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./baseIndexOf":200,"./cacheIndexOf":219,"./createCache":224}],216:[function(require,module,exports){
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * returned by `keysFunc`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  var index = -1,
      length = props.length,
      result = Array(length);

  while (++index < length) {
    result[index] = object[props[index]];
  }
  return result;
}

module.exports = baseValues;

},{}],217:[function(require,module,exports){
var identity = require('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (typeof thisArg == 'undefined') {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":269}],218:[function(require,module,exports){
(function (global){
var constant = require('../utility/constant'),
    isNative = require('../lang/isNative');

/** Native method references. */
var ArrayBuffer = isNative(ArrayBuffer = global.ArrayBuffer) && ArrayBuffer,
    bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
    floor = Math.floor,
    Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/** Used to clone array buffers. */
var Float64Array = (function() {
  // Safari 5 errors when using an array buffer to initialize a typed array
  // where the array buffer's `byteLength` is not a multiple of the typed
  // array's `BYTES_PER_ELEMENT`.
  try {
    var func = isNative(func = global.Float64Array) && func,
        result = new func(new ArrayBuffer(10), 0, 1) && func;
  } catch(e) {}
  return result;
}());

/** Used as the size, in bytes, of each `Float64Array` element. */
var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

/**
 * Creates a clone of the given array buffer.
 *
 * @private
 * @param {ArrayBuffer} buffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function bufferClone(buffer) {
  return bufferSlice.call(buffer, 0);
}
if (!bufferSlice) {
  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
    var byteLength = buffer.byteLength,
        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
        result = new ArrayBuffer(byteLength);

    if (floatLength) {
      var view = new Float64Array(result, 0, floatLength);
      view.set(new Float64Array(buffer, 0, floatLength));
    }
    if (byteLength != offset) {
      view = new Uint8Array(result, offset);
      view.set(new Uint8Array(buffer, offset));
    }
    return result;
  };
}

module.exports = bufferClone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":250,"../utility/constant":268}],219:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is in `cache` mimicking the return signature of
 * `_.indexOf` by returning `0` if the value is found, else `-1`.
 *
 * @private
 * @param {Object} cache The cache to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns `0` if `value` is found, else `-1`.
 */
function cacheIndexOf(cache, value) {
  var data = cache.data,
      result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

  return result ? 0 : -1;
}

module.exports = cacheIndexOf;

},{"../lang/isObject":252}],220:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Adds `value` to the cache.
 *
 * @private
 * @name push
 * @memberOf SetCache
 * @param {*} value The value to cache.
 */
function cachePush(value) {
  var data = this.data;
  if (typeof value == 'string' || isObject(value)) {
    data.set.add(value);
  } else {
    data.hash[value] = true;
  }
}

module.exports = cachePush;

},{"../lang/isObject":252}],221:[function(require,module,exports){
var baseCompareAscending = require('./baseCompareAscending');

/**
 * Used by `_.sortBy` to compare transformed elements of a collection and stable
 * sort them in ascending order.
 *
 * @private
 * @param {Object} object The object to compare to `other`.
 * @param {Object} other The object to compare to `object`.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareAscending(object, other) {
  return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
}

module.exports = compareAscending;

},{"./baseCompareAscending":190}],222:[function(require,module,exports){
var baseCallback = require('./baseCallback'),
    baseEach = require('./baseEach'),
    isArray = require('../lang/isArray');

/**
 * Creates a function that aggregates a collection, creating an accumulator
 * object composed from the results of running each element in the collection
 * through an iteratee.
 *
 * @private
 * @param {Function} setter The function to set keys and values of the accumulator object.
 * @param {Function} [initializer] The function to initialize the accumulator object.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee, thisArg) {
    var result = initializer ? initializer() : {};
    iteratee = baseCallback(iteratee, thisArg, 3);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        var value = collection[index];
        setter(result, value, iteratee(value, index, collection), collection);
      }
    } else {
      baseEach(collection, function(value, key, collection) {
        setter(result, value, iteratee(value, key, collection), collection);
      });
    }
    return result;
  };
}

module.exports = createAggregator;

},{"../lang/isArray":246,"./baseCallback":188,"./baseEach":192}],223:[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return function() {
    var length = arguments.length,
        object = arguments[0];

    if (length < 2 || object == null) {
      return object;
    }
    if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
      length = 2;
    }
    // Juggle arguments.
    if (length > 3 && typeof arguments[length - 2] == 'function') {
      var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
    } else if (length > 2 && typeof arguments[length - 1] == 'function') {
      customizer = arguments[--length];
    }
    var index = 0;
    while (++index < length) {
      var source = arguments[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  };
}

module.exports = createAssigner;

},{"./bindCallback":217,"./isIterateeCall":234}],224:[function(require,module,exports){
(function (global){
var SetCache = require('./SetCache'),
    constant = require('../utility/constant'),
    isNative = require('../lang/isNative');

/** Native method references. */
var Set = isNative(Set = global.Set) && Set;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;

/**
 * Creates a `Set` cache object to optimize linear searches of large arrays.
 *
 * @private
 * @param {Array} [values] The values to cache.
 * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
 */
var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
  return new SetCache(values);
};

module.exports = createCache;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":250,"../utility/constant":268,"./SetCache":180}],225:[function(require,module,exports){
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length,
      result = true;

  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
    return false;
  }
  // Deep compare the contents, ignoring non-numeric properties.
  while (result && ++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    result = undefined;
    if (customizer) {
      result = isWhere
        ? customizer(othValue, arrValue, index)
        : customizer(arrValue, othValue, index);
    }
    if (typeof result == 'undefined') {
      // Recursively compare arrays (susceptible to call stack limits).
      if (isWhere) {
        var othIndex = othLength;
        while (othIndex--) {
          othValue = other[othIndex];
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          if (result) {
            break;
          }
        }
      } else {
        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
  }
  return !!result;
}

module.exports = equalArrays;

},{}],226:[function(require,module,exports){
/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        // But, treat `-0` vs. `+0` as not equal.
        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],227:[function(require,module,exports){
var keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isWhere] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isWhere) {
    return false;
  }
  var hasCtor,
      index = -1;

  while (++index < objLength) {
    var key = objProps[index],
        result = hasOwnProperty.call(other, key);

    if (result) {
      var objValue = object[key],
          othValue = other[key];

      result = undefined;
      if (customizer) {
        result = isWhere
          ? customizer(othValue, objValue, key)
          : customizer(objValue, othValue, key);
      }
      if (typeof result == 'undefined') {
        // Recursively compare objects (susceptible to call stack limits).
        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
      }
    }
    if (!result) {
      return false;
    }
    hasCtor || (hasCtor = key == 'constructor');
  }
  if (!hasCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":262}],228:[function(require,module,exports){
/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 * If `fromRight` is provided elements of `array` are iterated from right to left.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} [fromIndex] The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

module.exports = indexOfNaN;

},{}],229:[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add array properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],230:[function(require,module,exports){
var bufferClone = require('./bufferClone');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return bufferClone(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      var buffer = object.buffer;
      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      var result = new Ctor(object.source, reFlags.exec(object));
      result.lastIndex = object.lastIndex;
  }
  return result;
}

module.exports = initCloneByTag;

},{"./bufferClone":218}],231:[function(require,module,exports){
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  var Ctor = object.constructor;
  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
    Ctor = Object;
  }
  return new Ctor;
}

module.exports = initCloneObject;

},{}],232:[function(require,module,exports){
var baseSetData = require('./baseSetData'),
    isNative = require('../lang/isNative'),
    support = require('../support');

/** Used to detect named functions. */
var reFuncName = /^\s*function[ \n\r\t]+\w/;

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Checks if `func` is eligible for `this` binding.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
 */
function isBindable(func) {
  var result = !(support.funcNames ? func.name : support.funcDecomp);

  if (!result) {
    var source = fnToString.call(func);
    if (!support.funcNames) {
      result = !reFuncName.test(source);
    }
    if (!result) {
      // Check if `func` references the `this` keyword and store the result.
      result = reThis.test(source) || isNative(func);
      baseSetData(func, result);
    }
  }
  return result;
}

module.exports = isBindable;

},{"../lang/isNative":250,"../support":267,"./baseSetData":211}],233:[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = +value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],234:[function(require,module,exports){
var isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    isObject = require('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number') {
    var length = object.length,
        prereq = isLength(length) && isIndex(index, length);
  } else {
    prereq = type == 'string' && index in object;
  }
  return prereq && object[index] === value;
}

module.exports = isIterateeCall;

},{"../lang/isObject":252,"./isIndex":233,"./isLength":235}],235:[function(require,module,exports){
/**
 * Used as the maximum length of an array-like value.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * for more details.
 */
var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on ES `ToLength`. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
 * for more details.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],236:[function(require,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return (value && typeof value == 'object') || false;
}

module.exports = isObjectLike;

},{}],237:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
}

module.exports = isStrictComparable;

},{"../lang/isObject":252}],238:[function(require,module,exports){
(function (global){
var isNative = require('../lang/isNative');

/** Native method references. */
var WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lang/isNative":250}],239:[function(require,module,exports){
var baseForIn = require('./baseForIn'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * A fallback implementation of `_.isPlainObject` which checks if `value`
 * is an object created by the `Object` constructor or has a `[[Prototype]]`
 * of `null`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 */
function shimIsPlainObject(value) {
  var Ctor;

  // Exit early for non `Object` objects.
  if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
      (!hasOwnProperty.call(value, 'constructor') &&
        (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
    return false;
  }
  // IE < 9 iterates inherited properties before own properties. If the first
  // iterated property is an object's own property then there are no inherited
  // enumerable properties.
  var result;
  // In most environments an object's own properties are iterated before
  // its inherited properties. If the last iterated property is an object's
  // own property then there are no inherited enumerable properties.
  baseForIn(value, function(subValue, key) {
    result = key;
  });
  return typeof result == 'undefined' || hasOwnProperty.call(value, result);
}

module.exports = shimIsPlainObject;

},{"./baseForIn":196,"./isObjectLike":236}],240:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object)));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":245,"../lang/isArray":246,"../object/keysIn":263,"../support":267,"./isIndex":233,"./isLength":235}],241:[function(require,module,exports){
/**
 * An implementation of `_.uniq` optimized for sorted arrays without support
 * for callback shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The function invoked per iteration.
 * @returns {Array} Returns the new duplicate-value-free array.
 */
function sortedUniq(array, iteratee) {
  var seen,
      index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value, index, array) : value;

    if (!index || seen !== computed) {
      seen = computed;
      result[++resIndex] = value;
    }
  }
  return result;
}

module.exports = sortedUniq;

},{}],242:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Converts `value` to an object if it is not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":252}],243:[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
 * otherwise they are assigned by reference. If `customizer` is provided it is
 * invoked to produce the cloned values. If `customizer` returns `undefined`
 * cloning is handled by the method instead. The `customizer` is bound to
 * `thisArg` and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var shallow = _.clone(users);
 * shallow[0] === users[0];
 * // => true
 *
 * var deep = _.clone(users, true);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var body = _.clone(document.body, function(value) {
 *   return _.isElement(value) ? value.cloneNode(false) : undefined;
 * });
 *
 * body === document.body
 * // => false
 * body.nodeName
 * // => BODY
 * body.childNodes.length;
 * // => 0
 */
function clone(value, isDeep, customizer, thisArg) {
  // Juggle arguments.
  if (typeof isDeep != 'boolean' && isDeep != null) {
    thisArg = customizer;
    customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;
    isDeep = false;
  }
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, isDeep, customizer);
}

module.exports = clone;

},{"../internal/baseClone":189,"../internal/bindCallback":217,"../internal/isIterateeCall":234}],244:[function(require,module,exports){
var baseClone = require('../internal/baseClone'),
    bindCallback = require('../internal/bindCallback');

/**
 * Creates a deep clone of `value`. If `customizer` is provided it is invoked
 * to produce the cloned values. If `customizer` returns `undefined` cloning
 * is handled by the method instead. The `customizer` is bound to `thisArg`
 * and invoked with two argument; (value [, index|key, object]).
 *
 * **Note:** This method is loosely based on the structured clone algorithm.
 * The enumerable properties of `arguments` objects and objects created by
 * constructors other than `Object` are cloned to plain `Object` objects. An
 * empty object is returned for uncloneable values such as functions, DOM nodes,
 * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to deep clone.
 * @param {Function} [customizer] The function to customize cloning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {*} Returns the deep cloned value.
 * @example
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * var deep = _.cloneDeep(users);
 * deep[0] === users[0];
 * // => false
 *
 * // using a customizer callback
 * var el = _.cloneDeep(document.body, function(value) {
 *   return _.isElement(value) ? value.cloneNode(true) : undefined;
 * });
 *
 * body === document.body
 * // => false
 * body.nodeName
 * // => BODY
 * body.childNodes.length;
 * // => 20
 */
function cloneDeep(value, customizer, thisArg) {
  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
  return baseClone(value, true, customizer);
}

module.exports = cloneDeep;

},{"../internal/baseClone":189,"../internal/bindCallback":217}],245:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * (function() { return _.isArguments(arguments); })();
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  var length = isObjectLike(value) ? value.length : undefined;
  return (isLength(length) && objToString.call(value) == argsTag) || false;
}

module.exports = isArguments;

},{"../internal/isLength":235,"../internal/isObjectLike":236}],246:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('./isNative'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * (function() { return _.isArray(arguments); })();
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
};

module.exports = isArray;

},{"../internal/isLength":235,"../internal/isObjectLike":236,"./isNative":250}],247:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
}

module.exports = isBoolean;

},{"../internal/isObjectLike":236}],248:[function(require,module,exports){
var isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isFunction = require('./isFunction'),
    isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike'),
    isString = require('./isString'),
    keys = require('../object/keys');

/**
 * Checks if a value is empty. A value is considered empty unless it is an
 * `arguments` object, array, string, or jQuery-like collection with a length
 * greater than `0` or an object with own enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {Array|Object|string} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  var length = value.length;
  if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
      (isObjectLike(value) && isFunction(value.splice)))) {
    return !length;
  }
  return !keys(value).length;
}

module.exports = isEmpty;

},{"../internal/isLength":235,"../internal/isObjectLike":236,"../object/keys":262,"./isArguments":245,"./isArray":246,"./isFunction":249,"./isString":255}],249:[function(require,module,exports){
(function (global){
var isNative = require('./isNative');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Native method references. */
var Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // Avoid a Chakra JIT bug in compatibility modes of IE 11.
  // See https://github.com/jashkenas/underscore/issues/1621 for more details.
  return typeof value == 'function' || false;
}
// Fallback for environments that return incorrect `typeof` operator results.
if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {
  isFunction = function(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in older versions of Chrome and Safari which return 'function' for regexes
    // and Safari 8 equivalents which return 'object' for typed array constructors.
    return objToString.call(value) == funcTag;
  };
}

module.exports = isFunction;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./isNative":250}],250:[function(require,module,exports){
var escapeRegExp = require('../string/escapeRegExp'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reNative = RegExp('^' +
  escapeRegExp(objToString)
  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (objToString.call(value) == funcTag) {
    return reNative.test(fnToString.call(value));
  }
  return (isObjectLike(value) && reHostCtor.test(value)) || false;
}

module.exports = isNative;

},{"../internal/isObjectLike":236,"../string/escapeRegExp":266}],251:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(8.4);
 * // => true
 *
 * _.isNumber(NaN);
 * // => true
 *
 * _.isNumber('8.4');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
}

module.exports = isNumber;

},{"../internal/isObjectLike":236}],252:[function(require,module,exports){
/**
 * Checks if `value` is the language type of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return type == 'function' || (value && type == 'object') || false;
}

module.exports = isObject;

},{}],253:[function(require,module,exports){
var isNative = require('./isNative'),
    shimIsPlainObject = require('../internal/shimIsPlainObject');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/** Native method references. */
var getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * **Note:** This method assumes objects created by the `Object` constructor
 * have no inherited enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
  if (!(value && objToString.call(value) == objectTag)) {
    return false;
  }
  var valueOf = value.valueOf,
      objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

  return objProto
    ? (value == objProto || getPrototypeOf(value) == objProto)
    : shimIsPlainObject(value);
};

module.exports = isPlainObject;

},{"../internal/shimIsPlainObject":239,"./isNative":250}],254:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
function isRegExp(value) {
  return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
}

module.exports = isRegExp;

},{"../internal/isObjectLike":236}],255:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
}

module.exports = isString;

},{"../internal/isObjectLike":236}],256:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the `toStringTag` of values.
 * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * for more details.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
}

module.exports = isTypedArray;

},{"../internal/isLength":235,"../internal/isObjectLike":236}],257:[function(require,module,exports){
var baseCopy = require('../internal/baseCopy'),
    keysIn = require('../object/keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable
 * properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return baseCopy(value, keysIn(value));
}

module.exports = toPlainObject;

},{"../internal/baseCopy":191,"../object/keysIn":263}],258:[function(require,module,exports){
var baseAssign = require('../internal/baseAssign'),
    createAssigner = require('../internal/createAssigner');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments;
 * (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigning values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return typeof value == 'undefined' ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(baseAssign);

module.exports = assign;

},{"../internal/baseAssign":187,"../internal/createAssigner":223}],259:[function(require,module,exports){
var arrayCopy = require('../internal/arrayCopy'),
    assign = require('./assign'),
    assignDefaults = require('../internal/assignDefaults');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object for all destination properties that resolve to `undefined`. Once a
 * property is set, additional defaults of the same property are ignored.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
function defaults(object) {
  if (object == null) {
    return object;
  }
  var args = arrayCopy(arguments);
  args.push(assignDefaults);
  return assign.apply(undefined, args);
}

module.exports = defaults;

},{"../internal/arrayCopy":181,"../internal/assignDefaults":186,"./assign":258}],260:[function(require,module,exports){
module.exports = require('./assign');

},{"./assign":258}],261:[function(require,module,exports){
/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `key` exists as a direct property of `object` instead of an
 * inherited property.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {string} key The key to check.
 * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
 * @example
 *
 * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
 * // => true
 */
function has(object, key) {
  return object ? hasOwnProperty.call(object, key) : false;
}

module.exports = has;

},{}],262:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isNative = require('../lang/isNative'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  if (object) {
    var Ctor = object.constructor,
        length = object.length;
  }
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
     (typeof object != 'function' && (length && isLength(length)))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/isLength":235,"../internal/shimKeys":240,"../lang/isNative":250,"../lang/isObject":252}],263:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject'),
    support = require('../support');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":233,"../internal/isLength":235,"../lang/isArguments":245,"../lang/isArray":246,"../lang/isObject":252,"../support":267}],264:[function(require,module,exports){
var baseMerge = require('../internal/baseMerge'),
    createAssigner = require('../internal/createAssigner');

/**
 * Recursively merges own enumerable properties of the source object(s), that
 * don't resolve to `undefined` into the destination object. Subsequent sources
 * overwrite property assignments of previous sources. If `customizer` is
 * provided it is invoked to produce the merged values of the destination and
 * source properties. If `customizer` returns `undefined` merging is handled
 * by the method instead. The `customizer` is bound to `thisArg` and invoked
 * with five arguments; (objectValue, sourceValue, key, object, source).
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize merging properties.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var users = {
 *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
 * };
 *
 * var ages = {
 *   'data': [{ 'age': 36 }, { 'age': 40 }]
 * };
 *
 * _.merge(users, ages);
 * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
 *
 * // using a customizer callback
 * var object = {
 *   'fruits': ['apple'],
 *   'vegetables': ['beet']
 * };
 *
 * var other = {
 *   'fruits': ['banana'],
 *   'vegetables': ['carrot']
 * };
 *
 * _.merge(object, other, function(a, b) {
 *   return _.isArray(a) ? a.concat(b) : undefined;
 * });
 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
 */
var merge = createAssigner(baseMerge);

module.exports = merge;

},{"../internal/baseMerge":207,"../internal/createAssigner":223}],265:[function(require,module,exports){
var baseValues = require('../internal/baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return baseValues(object, keys(object));
}

module.exports = values;

},{"../internal/baseValues":216,"./keys":262}],266:[function(require,module,exports){
var baseToString = require('../internal/baseToString');

/**
 * Used to match `RegExp` special characters.
 * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
 * for more details.
 */
var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
    reHasRegExpChars = RegExp(reRegExpChars.source);

/**
 * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
 * "+", "(", ")", "[", "]", "{" and "}" in `string`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = baseToString(string);
  return (string && reHasRegExpChars.test(string))
    ? string.replace(reRegExpChars, '\\$&')
    : string;
}

module.exports = escapeRegExp;

},{"../internal/baseToString":214}],267:[function(require,module,exports){
(function (global){
var isNative = require('./lang/isNative');

/** Used to detect functions containing a `this` reference. */
var reThis = /\bthis\b/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to detect DOM support. */
var document = (document = global.window) && document.document;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * An object environment feature flags.
 *
 * @static
 * @memberOf _
 * @type Object
 */
var support = {};

(function(x) {

  /**
   * Detect if functions can be decompiled by `Function#toString`
   * (all but Firefox OS certified apps, older Opera mobile browsers, and
   * the PlayStation 3; forced `false` for Windows 8 apps).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });

  /**
   * Detect if `Function#name` is supported (all but IE).
   *
   * @memberOf _.support
   * @type boolean
   */
  support.funcNames = typeof Function.name == 'string';

  /**
   * Detect if the DOM is supported.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.dom = document.createDocumentFragment().nodeType === 11;
  } catch(e) {
    support.dom = false;
  }

  /**
   * Detect if `arguments` object indexes are non-enumerable.
   *
   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
   * checks for indexes that exceed their function's formal parameters with
   * associated values of `0`.
   *
   * @memberOf _.support
   * @type boolean
   */
  try {
    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
  } catch(e) {
    support.nonEnumArgs = true;
  }
}(0, 0));

module.exports = support;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lang/isNative":250}],268:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],269:[function(require,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],270:[function(require,module,exports){
"use strict";

var originalObject = Object;
var originalDefProp = Object.defineProperty;
var originalCreate = Object.create;

function defProp(obj, name, value) {
  if (originalDefProp) try {
    originalDefProp.call(originalObject, obj, name, { value: value });
  } catch (definePropertyIsBrokenInIE8) {
    obj[name] = value;
  } else {
    obj[name] = value;
  }
}

// For functions that will be invoked using .call or .apply, we need to
// define those methods on the function objects themselves, rather than
// inheriting them from Function.prototype, so that a malicious or clumsy
// third party cannot interfere with the functionality of this module by
// redefining Function.prototype.call or .apply.
function makeSafeToCall(fun) {
  if (fun) {
    defProp(fun, "call", fun.call);
    defProp(fun, "apply", fun.apply);
  }
  return fun;
}

makeSafeToCall(originalDefProp);
makeSafeToCall(originalCreate);

var hasOwn = makeSafeToCall(Object.prototype.hasOwnProperty);
var numToStr = makeSafeToCall(Number.prototype.toString);
var strSlice = makeSafeToCall(String.prototype.slice);

var cloner = function(){};
function create(prototype) {
  if (originalCreate) {
    return originalCreate.call(originalObject, prototype);
  }
  cloner.prototype = prototype || null;
  return new cloner;
}

var rand = Math.random;
var uniqueKeys = create(null);

function makeUniqueKey() {
  // Collisions are highly unlikely, but this module is in the business of
  // making guarantees rather than safe bets.
  do var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
  while (hasOwn.call(uniqueKeys, uniqueKey));
  return uniqueKeys[uniqueKey] = uniqueKey;
}

function internString(str) {
  var obj = {};
  obj[str] = true;
  return Object.keys(obj)[0];
}

// External users might find this function useful, but it is not necessary
// for the typical use of this module.
defProp(exports, "makeUniqueKey", makeUniqueKey);

// Object.getOwnPropertyNames is the only way to enumerate non-enumerable
// properties, so if we wrap it to ignore our secret keys, there should be
// no way (except guessing) to access those properties.
var originalGetOPNs = Object.getOwnPropertyNames;
Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
  for (var names = originalGetOPNs(object),
           src = 0,
           dst = 0,
           len = names.length;
       src < len;
       ++src) {
    if (!hasOwn.call(uniqueKeys, names[src])) {
      if (src > dst) {
        names[dst] = names[src];
      }
      ++dst;
    }
  }
  names.length = dst;
  return names;
};

function defaultCreatorFn(object) {
  return create(null);
}

function makeAccessor(secretCreatorFn) {
  var brand = makeUniqueKey();
  var passkey = create(null);

  secretCreatorFn = secretCreatorFn || defaultCreatorFn;

  function register(object) {
    var secret; // Created lazily.

    function vault(key, forget) {
      // Only code that has access to the passkey can retrieve (or forget)
      // the secret object.
      if (key === passkey) {
        return forget
          ? secret = null
          : secret || (secret = secretCreatorFn(object));
      }
    }

    defProp(object, brand, vault);
  }

  function accessor(object) {
    if (!hasOwn.call(object, brand))
      register(object);
    return object[brand](passkey);
  }

  accessor.forget = function(object) {
    if (hasOwn.call(object, brand))
      object[brand](passkey, true);
  };

  return accessor;
}

defProp(exports, "makeAccessor", makeAccessor);

},{}],271:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var isArray = types.builtInTypes.array;
var b = types.builders;
var n = types.namedTypes;
var leap = require("./leap");
var meta = require("./meta");
var util = require("./util");
var hasOwn = Object.prototype.hasOwnProperty;

function Emitter(contextId) {
  assert.ok(this instanceof Emitter);
  n.Identifier.assert(contextId);

  Object.defineProperties(this, {
    // In order to make sure the context object does not collide with
    // anything in the local scope, we might have to rename it, so we
    // refer to it symbolically instead of just assuming that it will be
    // called "context".
    contextId: { value: contextId },

    // An append-only list of Statements that grows each time this.emit is
    // called.
    listing: { value: [] },

    // A sparse array whose keys correspond to locations in this.listing
    // that have been marked as branch/jump targets.
    marked: { value: [true] },

    // The last location will be marked when this.getDispatchLoop is
    // called.
    finalLoc: { value: loc() },

    // A list of all leap.TryEntry statements emitted.
    tryEntries: { value: [] }
  });

  // The .leapManager property needs to be defined by a separate
  // defineProperties call so that .finalLoc will be visible to the
  // leap.LeapManager constructor.
  Object.defineProperties(this, {
    // Each time we evaluate the body of a loop, we tell this.leapManager
    // to enter a nested loop context that determines the meaning of break
    // and continue statements therein.
    leapManager: { value: new leap.LeapManager(this) }
  });
}

var Ep = Emitter.prototype;
exports.Emitter = Emitter;

// Offsets into this.listing that could be used as targets for branches or
// jumps are represented as numeric Literal nodes. This representation has
// the amazingly convenient benefit of allowing the exact value of the
// location to be determined at any time, even after generating code that
// refers to the location.
function loc() {
  return b.literal(-1);
}

// Sets the exact value of the given location to the offset of the next
// Statement emitted.
Ep.mark = function(loc) {
  n.Literal.assert(loc);
  var index = this.listing.length;
  if (loc.value === -1) {
    loc.value = index;
  } else {
    // Locations can be marked redundantly, but their values cannot change
    // once set the first time.
    assert.strictEqual(loc.value, index);
  }
  this.marked[index] = true;
  return loc;
};

Ep.emit = function(node) {
  if (n.Expression.check(node))
    node = b.expressionStatement(node);
  n.Statement.assert(node);
  this.listing.push(node);
};

// Shorthand for emitting assignment statements. This will come in handy
// for assignments to temporary variables.
Ep.emitAssign = function(lhs, rhs) {
  this.emit(this.assign(lhs, rhs));
  return lhs;
};

// Shorthand for an assignment statement.
Ep.assign = function(lhs, rhs) {
  return b.expressionStatement(
    b.assignmentExpression("=", lhs, rhs));
};

// Convenience function for generating expressions like context.next,
// context.sent, and context.rval.
Ep.contextProperty = function(name, computed) {
  return b.memberExpression(
    this.contextId,
    computed ? b.literal(name) : b.identifier(name),
    !!computed
  );
};

var volatileContextPropertyNames = {
  prev: true,
  next: true,
  sent: true,
  rval: true
};

// A "volatile" context property is a MemberExpression like context.sent
// that should probably be stored in a temporary variable when there's a
// possibility the property will get overwritten.
Ep.isVolatileContextProperty = function(expr) {
  if (n.MemberExpression.check(expr)) {
    if (expr.computed) {
      // If it's a computed property such as context[couldBeAnything],
      // assume the worst in terms of volatility.
      return true;
    }

    if (n.Identifier.check(expr.object) &&
        n.Identifier.check(expr.property) &&
        expr.object.name === this.contextId.name &&
        hasOwn.call(volatileContextPropertyNames,
                    expr.property.name)) {
      return true;
    }
  }

  return false;
};

// Shorthand for setting context.rval and jumping to `context.stop()`.
Ep.stop = function(rval) {
  if (rval) {
    this.setReturnValue(rval);
  }

  this.jump(this.finalLoc);
};

Ep.setReturnValue = function(valuePath) {
  n.Expression.assert(valuePath.value);

  this.emitAssign(
    this.contextProperty("rval"),
    this.explodeExpression(valuePath)
  );
};

Ep.clearPendingException = function(tryLoc, assignee) {
  n.Literal.assert(tryLoc);

  var catchCall = b.callExpression(
    this.contextProperty("catch", true),
    [tryLoc]
  );

  if (assignee) {
    this.emitAssign(assignee, catchCall);
  } else {
    this.emit(catchCall);
  }
};

// Emits code for an unconditional jump to the given location, even if the
// exact value of the location is not yet known.
Ep.jump = function(toLoc) {
  this.emitAssign(this.contextProperty("next"), toLoc);
  this.emit(b.breakStatement());
};

// Conditional jump.
Ep.jumpIf = function(test, toLoc) {
  n.Expression.assert(test);
  n.Literal.assert(toLoc);

  this.emit(b.ifStatement(
    test,
    b.blockStatement([
      this.assign(this.contextProperty("next"), toLoc),
      b.breakStatement()
    ])
  ));
};

// Conditional jump, with the condition negated.
Ep.jumpIfNot = function(test, toLoc) {
  n.Expression.assert(test);
  n.Literal.assert(toLoc);

  var negatedTest;
  if (n.UnaryExpression.check(test) &&
      test.operator === "!") {
    // Avoid double negation.
    negatedTest = test.argument;
  } else {
    negatedTest = b.unaryExpression("!", test);
  }

  this.emit(b.ifStatement(
    negatedTest,
    b.blockStatement([
      this.assign(this.contextProperty("next"), toLoc),
      b.breakStatement()
    ])
  ));
};

// Returns a unique MemberExpression that can be used to store and
// retrieve temporary values. Since the object of the member expression is
// the context object, which is presumed to coexist peacefully with all
// other local variables, and since we just increment `nextTempId`
// monotonically, uniqueness is assured.
var nextTempId = 0;
Ep.makeTempVar = function() {
  return this.contextProperty("t" + nextTempId++);
};

Ep.getContextFunction = function(id) {
  var func = b.functionExpression(
    id || null/*Anonymous*/,
    [this.contextId],
    b.blockStatement([this.getDispatchLoop()]),
    false, // Not a generator anymore!
    false // Nor an expression.
  );
  func._aliasFunction = true;
  return func;
};

// Turns this.listing into a loop of the form
//
//   while (1) switch (context.next) {
//   case 0:
//   ...
//   case n:
//     return context.stop();
//   }
//
// Each marked location in this.listing will correspond to one generated
// case statement.
Ep.getDispatchLoop = function() {
  var self = this;
  var cases = [];
  var current;

  // If we encounter a break, continue, or return statement in a switch
  // case, we can skip the rest of the statements until the next case.
  var alreadyEnded = false;

  self.listing.forEach(function(stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(b.switchCase(
        b.literal(i),
        current = []));
      alreadyEnded = false;
    }

    if (!alreadyEnded) {
      current.push(stmt);
      if (isSwitchCaseEnder(stmt))
        alreadyEnded = true;
    }
  });

  // Now that we know how many statements there will be in this.listing,
  // we can finally resolve this.finalLoc.value.
  this.finalLoc.value = this.listing.length;

  cases.push(
    b.switchCase(this.finalLoc, [
      // Intentionally fall through to the "end" case...
    ]),

    // So that the runtime can jump to the final location without having
    // to know its offset, we provide the "end" case as a synonym.
    b.switchCase(b.literal("end"), [
      // This will check/clear both context.thrown and context.rval.
      b.returnStatement(
        b.callExpression(this.contextProperty("stop"), [])
      )
    ])
  );

  return b.whileStatement(
    b.literal(1),
    b.switchStatement(
      b.assignmentExpression(
        "=",
        this.contextProperty("prev"),
        this.contextProperty("next")
      ),
      cases
    )
  );
};

// See comment above re: alreadyEnded.
function isSwitchCaseEnder(stmt) {
  return n.BreakStatement.check(stmt)
      || n.ContinueStatement.check(stmt)
      || n.ReturnStatement.check(stmt)
      || n.ThrowStatement.check(stmt);
}

Ep.getTryLocsList = function() {
  if (this.tryEntries.length === 0) {
    // To avoid adding a needless [] to the majority of runtime.wrap
    // argument lists, force the caller to handle this case specially.
    return null;
  }

  var lastLocValue = 0;

  return b.arrayExpression(
    this.tryEntries.map(function(tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;
      assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
      lastLocValue = thisLocValue;

      var ce = tryEntry.catchEntry;
      var fe = tryEntry.finallyEntry;

      var locs = [
        tryEntry.firstLoc,
        // The null here makes a hole in the array.
        ce ? ce.firstLoc : null
      ];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return b.arrayExpression(locs);
    })
  );
};

// All side effects must be realized in order.

// If any subexpression harbors a leap, all subexpressions must be
// neutered of side effects.

// No destructive modification of AST nodes.

Ep.explode = function(path, ignoreResult) {
  assert.ok(path instanceof types.NodePath);

  var node = path.value;
  var self = this;

  n.Node.assert(node);

  if (n.Statement.check(node))
    return self.explodeStatement(path);

  if (n.Expression.check(node))
    return self.explodeExpression(path, ignoreResult);

  if (n.Declaration.check(node))
    throw getDeclError(node);

  switch (node.type) {
  case "Program":
    return path.get("body").map(
      self.explodeStatement,
      self
    );

  case "VariableDeclarator":
    throw getDeclError(node);

  // These node types should be handled by their parent nodes
  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).
  case "Property":
  case "SwitchCase":
  case "CatchClause":
    throw new Error(
      node.type + " nodes should be handled by their parents");

  default:
    throw new Error(
      "unknown Node of type " +
        JSON.stringify(node.type));
  }
};

function getDeclError(node) {
  return new Error(
    "all declarations should have been transformed into " +
    "assignments before the Exploder began its work: " +
    JSON.stringify(node));
}

Ep.explodeStatement = function(path, labelId) {
  assert.ok(path instanceof types.NodePath);

  var stmt = path.value;
  var self = this;

  n.Statement.assert(stmt);

  if (labelId) {
    n.Identifier.assert(labelId);
  } else {
    labelId = null;
  }

  // Explode BlockStatement nodes even if they do not contain a yield,
  // because we don't want or need the curly braces.
  if (n.BlockStatement.check(stmt)) {
    return path.get("body").each(
      self.explodeStatement,
      self
    );
  }

  if (!meta.containsLeap(stmt)) {
    // Technically we should be able to avoid emitting the statement
    // altogether if !meta.hasSideEffects(stmt), but that leads to
    // confusing generated code (for instance, `while (true) {}` just
    // disappears) and is probably a more appropriate job for a dedicated
    // dead code elimination pass.
    self.emit(stmt);
    return;
  }

  switch (stmt.type) {
  case "ExpressionStatement":
    self.explodeExpression(path.get("expression"), true);
    break;

  case "LabeledStatement":
    var after = loc();

    // Did you know you can break from any labeled block statement or
    // control structure? Well, you can! Note: when a labeled loop is
    // encountered, the leap.LabeledEntry created here will immediately
    // enclose a leap.LoopEntry on the leap manager's stack, and both
    // entries will have the same label. Though this works just fine, it
    // may seem a bit redundant. In theory, we could check here to
    // determine if stmt knows how to handle its own label; for example,
    // stmt happens to be a WhileStatement and so we know it's going to
    // establish its own LoopEntry when we explode it (below). Then this
    // LabeledEntry would be unnecessary. Alternatively, we might be
    // tempted not to pass stmt.label down into self.explodeStatement,
    // because we've handled the label here, but that's a mistake because
    // labeled loops may contain labeled continue statements, which is not
    // something we can handle in this generic case. All in all, I think a
    // little redundancy greatly simplifies the logic of this case, since
    // it's clear that we handle all possible LabeledStatements correctly
    // here, regardless of whether they interact with the leap manager
    // themselves. Also remember that labels and break/continue-to-label
    // statements are rare, and all of this logic happens at transform
    // time, so it has no additional runtime cost.
    self.leapManager.withEntry(
      new leap.LabeledEntry(after, stmt.label),
      function() {
        self.explodeStatement(path.get("body"), stmt.label);
      }
    );

    self.mark(after);

    break;

  case "WhileStatement":
    var before = loc();
    var after = loc();

    self.mark(before);
    self.jumpIfNot(self.explodeExpression(path.get("test")), after);
    self.leapManager.withEntry(
      new leap.LoopEntry(after, before, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );
    self.jump(before);
    self.mark(after);

    break;

  case "DoWhileStatement":
    var first = loc();
    var test = loc();
    var after = loc();

    self.mark(first);
    self.leapManager.withEntry(
      new leap.LoopEntry(after, test, labelId),
      function() { self.explode(path.get("body")); }
    );
    self.mark(test);
    self.jumpIf(self.explodeExpression(path.get("test")), first);
    self.mark(after);

    break;

  case "ForStatement":
    var head = loc();
    var update = loc();
    var after = loc();

    if (stmt.init) {
      // We pass true here to indicate that if stmt.init is an expression
      // then we do not care about its result.
      self.explode(path.get("init"), true);
    }

    self.mark(head);

    if (stmt.test) {
      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
    } else {
      // No test means continue unconditionally.
    }

    self.leapManager.withEntry(
      new leap.LoopEntry(after, update, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );

    self.mark(update);

    if (stmt.update) {
      // We pass true here to indicate that if stmt.update is an
      // expression then we do not care about its result.
      self.explode(path.get("update"), true);
    }

    self.jump(head);

    self.mark(after);

    break;

  case "ForInStatement":
    n.Identifier.assert(stmt.left);

    var head = loc();
    var after = loc();

    var keyIterNextFn = self.makeTempVar();
    self.emitAssign(
      keyIterNextFn,
      b.callExpression(
        util.runtimeProperty("keys"),
        [self.explodeExpression(path.get("right"))]
      )
    );

    self.mark(head);

    var keyInfoTmpVar = self.makeTempVar();
    self.jumpIf(
      b.memberExpression(
        b.assignmentExpression(
          "=",
          keyInfoTmpVar,
          b.callExpression(keyIterNextFn, [])
        ),
        b.identifier("done"),
        false
      ),
      after
    );

    self.emitAssign(
      stmt.left,
      b.memberExpression(
        keyInfoTmpVar,
        b.identifier("value"),
        false
      )
    );

    self.leapManager.withEntry(
      new leap.LoopEntry(after, head, labelId),
      function() { self.explodeStatement(path.get("body")); }
    );

    self.jump(head);

    self.mark(after);

    break;

  case "BreakStatement":
    self.emitAbruptCompletion({
      type: "break",
      target: self.leapManager.getBreakLoc(stmt.label)
    });

    break;

  case "ContinueStatement":
    self.emitAbruptCompletion({
      type: "continue",
      target: self.leapManager.getContinueLoc(stmt.label)
    });

    break;

  case "SwitchStatement":
    // Always save the discriminant into a temporary variable in case the
    // test expressions overwrite values like context.sent.
    var disc = self.emitAssign(
      self.makeTempVar(),
      self.explodeExpression(path.get("discriminant"))
    );

    var after = loc();
    var defaultLoc = loc();
    var condition = defaultLoc;
    var caseLocs = [];

    // If there are no cases, .cases might be undefined.
    var cases = stmt.cases || [];

    for (var i = cases.length - 1; i >= 0; --i) {
      var c = cases[i];
      n.SwitchCase.assert(c);

      if (c.test) {
        condition = b.conditionalExpression(
          b.binaryExpression("===", disc, c.test),
          caseLocs[i] = loc(),
          condition
        );
      } else {
        caseLocs[i] = defaultLoc;
      }
    }

    self.jump(self.explodeExpression(
      new types.NodePath(condition, path, "discriminant")
    ));

    self.leapManager.withEntry(
      new leap.SwitchEntry(after),
      function() {
        path.get("cases").each(function(casePath) {
          var c = casePath.value;
          var i = casePath.name;

          self.mark(caseLocs[i]);

          casePath.get("consequent").each(
            self.explodeStatement,
            self
          );
        });
      }
    );

    self.mark(after);
    if (defaultLoc.value === -1) {
      self.mark(defaultLoc);
      assert.strictEqual(after.value, defaultLoc.value);
    }

    break;

  case "IfStatement":
    var elseLoc = stmt.alternate && loc();
    var after = loc();

    self.jumpIfNot(
      self.explodeExpression(path.get("test")),
      elseLoc || after
    );

    self.explodeStatement(path.get("consequent"));

    if (elseLoc) {
      self.jump(after);
      self.mark(elseLoc);
      self.explodeStatement(path.get("alternate"));
    }

    self.mark(after);

    break;

  case "ReturnStatement":
    self.emitAbruptCompletion({
      type: "return",
      value: self.explodeExpression(path.get("argument"))
    });

    break;

  case "WithStatement":
    throw new Error(
      node.type + " not supported in generator functions.");

  case "TryStatement":
    var after = loc();

    var handler = stmt.handler;
    if (!handler && stmt.handlers) {
      handler = stmt.handlers[0] || null;
    }

    var catchLoc = handler && loc();
    var catchEntry = catchLoc && new leap.CatchEntry(
      catchLoc,
      handler.param
    );

    var finallyLoc = stmt.finalizer && loc();
    var finallyEntry = finallyLoc &&
      new leap.FinallyEntry(finallyLoc, after);

    var tryEntry = new leap.TryEntry(
      self.getUnmarkedCurrentLoc(),
      catchEntry,
      finallyEntry
    );

    self.tryEntries.push(tryEntry);
    self.updateContextPrevLoc(tryEntry.firstLoc);

    self.leapManager.withEntry(tryEntry, function() {
      self.explodeStatement(path.get("block"));

      if (catchLoc) {
        if (finallyLoc) {
          // If we have both a catch block and a finally block, then
          // because we emit the catch block first, we need to jump over
          // it to the finally block.
          self.jump(finallyLoc);

        } else {
          // If there is no finally block, then we need to jump over the
          // catch block to the fall-through location.
          self.jump(after);
        }

        self.updateContextPrevLoc(self.mark(catchLoc));

        var bodyPath = path.get("handler", "body");
        var safeParam = self.makeTempVar();
        self.clearPendingException(tryEntry.firstLoc, safeParam);

        var catchScope = bodyPath.scope;
        var catchParamName = handler.param.name;
        n.CatchClause.assert(catchScope.node);
        assert.strictEqual(catchScope.lookup(catchParamName), catchScope);

        types.visit(bodyPath, {
          visitIdentifier: function(path) {
            if (util.isReference(path, catchParamName) &&
                path.scope.lookup(catchParamName) === catchScope) {
              return safeParam;
            }

            this.traverse(path);
          },

          visitFunction: function(path) {
            if (path.scope.declares(catchParamName)) {
              // Don't descend into nested scopes that shadow the catch
              // parameter with their own declarations. This isn't
              // logically necessary because of the path.scope.lookup we
              // do in visitIdentifier, but it saves time.
              return false;
            }

            this.traverse(path);
          }
        });

        self.leapManager.withEntry(catchEntry, function() {
          self.explodeStatement(bodyPath);
        });
      }

      if (finallyLoc) {
        self.updateContextPrevLoc(self.mark(finallyLoc));

        self.leapManager.withEntry(finallyEntry, function() {
          self.explodeStatement(path.get("finalizer"));
        });

        self.emit(b.returnStatement(b.callExpression(
          self.contextProperty("finish"),
          [finallyEntry.firstLoc]
        )));
      }
    });

    self.mark(after);

    break;

  case "ThrowStatement":
    self.emit(b.throwStatement(
      self.explodeExpression(path.get("argument"))
    ));

    break;

  default:
    throw new Error(
      "unknown Statement of type " +
        JSON.stringify(stmt.type));
  }
};

Ep.emitAbruptCompletion = function(record) {
  if (!isValidCompletion(record)) {
    assert.ok(
      false,
      "invalid completion record: " +
        JSON.stringify(record)
    );
  }

  assert.notStrictEqual(
    record.type, "normal",
    "normal completions are not abrupt"
  );

  var abruptArgs = [b.literal(record.type)];

  if (record.type === "break" ||
      record.type === "continue") {
    n.Literal.assert(record.target);
    abruptArgs[1] = record.target;
  } else if (record.type === "return" ||
             record.type === "throw") {
    if (record.value) {
      n.Expression.assert(record.value);
      abruptArgs[1] = record.value;
    }
  }

  this.emit(
    b.returnStatement(
      b.callExpression(
        this.contextProperty("abrupt"),
        abruptArgs
      )
    )
  );
};

function isValidCompletion(record) {
  var type = record.type;

  if (type === "normal") {
    return !hasOwn.call(record, "target");
  }

  if (type === "break" ||
      type === "continue") {
    return !hasOwn.call(record, "value")
        && n.Literal.check(record.target);
  }

  if (type === "return" ||
      type === "throw") {
    return hasOwn.call(record, "value")
        && !hasOwn.call(record, "target");
  }

  return false;
}


// Not all offsets into emitter.listing are potential jump targets. For
// example, execution typically falls into the beginning of a try block
// without jumping directly there. This method returns the current offset
// without marking it, so that a switch case will not necessarily be
// generated for this offset (I say "not necessarily" because the same
// location might end up being marked in the process of emitting other
// statements). There's no logical harm in marking such locations as jump
// targets, but minimizing the number of switch cases keeps the generated
// code shorter.
Ep.getUnmarkedCurrentLoc = function() {
  return b.literal(this.listing.length);
};

// The context.prev property takes the value of context.next whenever we
// evaluate the switch statement discriminant, which is generally good
// enough for tracking the last location we jumped to, but sometimes
// context.prev needs to be more precise, such as when we fall
// successfully out of a try block and into a finally block without
// jumping. This method exists to update context.prev to the freshest
// available location. If we were implementing a full interpreter, we
// would know the location of the current instruction with complete
// precision at all times, but we don't have that luxury here, as it would
// be costly and verbose to set context.prev before every statement.
Ep.updateContextPrevLoc = function(loc) {
  if (loc) {
    n.Literal.assert(loc);

    if (loc.value === -1) {
      // If an uninitialized location literal was passed in, set its value
      // to the current this.listing.length.
      loc.value = this.listing.length;
    } else {
      // Otherwise assert that the location matches the current offset.
      assert.strictEqual(loc.value, this.listing.length);
    }

  } else {
    loc = this.getUnmarkedCurrentLoc();
  }

  // Make sure context.prev is up to date in case we fell into this try
  // statement without jumping to it. TODO Consider avoiding this
  // assignment when we know control must have jumped here.
  this.emitAssign(this.contextProperty("prev"), loc);
};

Ep.explodeExpression = function(path, ignoreResult) {
  assert.ok(path instanceof types.NodePath);

  var expr = path.value;
  if (expr) {
    n.Expression.assert(expr);
  } else {
    return expr;
  }

  var self = this;
  var result; // Used optionally by several cases below.

  function finish(expr) {
    n.Expression.assert(expr);
    if (ignoreResult) {
      self.emit(expr);
    } else {
      return expr;
    }
  }

  // If the expression does not contain a leap, then we either emit the
  // expression as a standalone statement or return it whole.
  if (!meta.containsLeap(expr)) {
    return finish(expr);
  }

  // If any child contains a leap (such as a yield or labeled continue or
  // break statement), then any sibling subexpressions will almost
  // certainly have to be exploded in order to maintain the order of their
  // side effects relative to the leaping child(ren).
  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);

  // In order to save the rest of explodeExpression from a combinatorial
  // trainwreck of special cases, explodeViaTempVar is responsible for
  // deciding when a subexpression needs to be "exploded," which is my
  // very technical term for emitting the subexpression as an assignment
  // to a temporary variable and the substituting the temporary variable
  // for the original subexpression. Think of exploded view diagrams, not
  // Michael Bay movies. The point of exploding subexpressions is to
  // control the precise order in which the generated code realizes the
  // side effects of those subexpressions.
  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
    assert.ok(childPath instanceof types.NodePath);

    assert.ok(
      !ignoreChildResult || !tempVar,
      "Ignoring the result of a child expression but forcing it to " +
        "be assigned to a temporary variable?"
    );

    var result = self.explodeExpression(childPath, ignoreChildResult);

    if (ignoreChildResult) {
      // Side effects already emitted above.

    } else if (tempVar || (hasLeapingChildren &&
                           (self.isVolatileContextProperty(result) ||
                            meta.hasSideEffects(result)))) {
      // If tempVar was provided, then the result will always be assigned
      // to it, even if the result does not otherwise need to be assigned
      // to a temporary variable.  When no tempVar is provided, we have
      // the flexibility to decide whether a temporary variable is really
      // necessary.  In general, temporary assignment is required only
      // when some other child contains a leap and the child in question
      // is a context property like $ctx.sent that might get overwritten
      // or an expression with side effects that need to occur in proper
      // sequence relative to the leap.
      result = self.emitAssign(
        tempVar || self.makeTempVar(),
        result
      );
    }
    return result;
  }

  // If ignoreResult is true, then we must take full responsibility for
  // emitting the expression with all its side effects, and we should not
  // return a result.

  switch (expr.type) {
  case "MemberExpression":
    return finish(b.memberExpression(
      self.explodeExpression(path.get("object")),
      expr.computed
        ? explodeViaTempVar(null, path.get("property"))
        : expr.property,
      expr.computed
    ));

  case "CallExpression":
    var oldCalleePath = path.get("callee");
    var newCallee = self.explodeExpression(oldCalleePath);

    // If the callee was not previously a MemberExpression, then the
    // CallExpression was "unqualified," meaning its `this` object should
    // be the global object. If the exploded expression has become a
    // MemberExpression, then we need to force it to be unqualified by
    // using the (0, object.property)(...) trick; otherwise, it will
    // receive the object of the MemberExpression as its `this` object.
    if (!n.MemberExpression.check(oldCalleePath.node) &&
        n.MemberExpression.check(newCallee)) {
      newCallee = b.sequenceExpression([
        b.literal(0),
        newCallee
      ]);
    }

    return finish(b.callExpression(
      newCallee,
      path.get("arguments").map(function(argPath) {
        return explodeViaTempVar(null, argPath);
      })
    ));

  case "NewExpression":
    return finish(b.newExpression(
      explodeViaTempVar(null, path.get("callee")),
      path.get("arguments").map(function(argPath) {
        return explodeViaTempVar(null, argPath);
      })
    ));

  case "ObjectExpression":
    return finish(b.objectExpression(
      path.get("properties").map(function(propPath) {
        return b.property(
          propPath.value.kind,
          propPath.value.key,
          explodeViaTempVar(null, propPath.get("value"))
        );
      })
    ));

  case "ArrayExpression":
    return finish(b.arrayExpression(
      path.get("elements").map(function(elemPath) {
        return explodeViaTempVar(null, elemPath);
      })
    ));

  case "SequenceExpression":
    var lastIndex = expr.expressions.length - 1;

    path.get("expressions").each(function(exprPath) {
      if (exprPath.name === lastIndex) {
        result = self.explodeExpression(exprPath, ignoreResult);
      } else {
        self.explodeExpression(exprPath, true);
      }
    });

    return result;

  case "LogicalExpression":
    var after = loc();

    if (!ignoreResult) {
      result = self.makeTempVar();
    }

    var left = explodeViaTempVar(result, path.get("left"));

    if (expr.operator === "&&") {
      self.jumpIfNot(left, after);
    } else {
      assert.strictEqual(expr.operator, "||");
      self.jumpIf(left, after);
    }

    explodeViaTempVar(result, path.get("right"), ignoreResult);

    self.mark(after);

    return result;

  case "ConditionalExpression":
    var elseLoc = loc();
    var after = loc();
    var test = self.explodeExpression(path.get("test"));

    self.jumpIfNot(test, elseLoc);

    if (!ignoreResult) {
      result = self.makeTempVar();
    }

    explodeViaTempVar(result, path.get("consequent"), ignoreResult);
    self.jump(after);

    self.mark(elseLoc);
    explodeViaTempVar(result, path.get("alternate"), ignoreResult);

    self.mark(after);

    return result;

  case "UnaryExpression":
    return finish(b.unaryExpression(
      expr.operator,
      // Can't (and don't need to) break up the syntax of the argument.
      // Think about delete a[b].
      self.explodeExpression(path.get("argument")),
      !!expr.prefix
    ));

  case "BinaryExpression":
    return finish(b.binaryExpression(
      expr.operator,
      explodeViaTempVar(null, path.get("left")),
      explodeViaTempVar(null, path.get("right"))
    ));

  case "AssignmentExpression":
    return finish(b.assignmentExpression(
      expr.operator,
      self.explodeExpression(path.get("left")),
      self.explodeExpression(path.get("right"))
    ));

  case "UpdateExpression":
    return finish(b.updateExpression(
      expr.operator,
      self.explodeExpression(path.get("argument")),
      expr.prefix
    ));

  case "YieldExpression":
    var after = loc();
    var arg = expr.argument && self.explodeExpression(path.get("argument"));

    if (arg && expr.delegate) {
      var result = self.makeTempVar();

      self.emit(b.returnStatement(b.callExpression(
        self.contextProperty("delegateYield"), [
          arg,
          b.literal(result.property.name),
          after
        ]
      )));

      self.mark(after);

      return result;
    }

    self.emitAssign(self.contextProperty("next"), after);
    self.emit(b.returnStatement(arg || null));
    self.mark(after);

    return self.contextProperty("sent");

  default:
    throw new Error(
      "unknown Expression of type " +
        JSON.stringify(expr.type));
  }
};

},{"./leap":273,"./meta":274,"./util":275,"assert":306,"ast-types":139}],272:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var hasOwn = Object.prototype.hasOwnProperty;

// The hoist function takes a FunctionExpression or FunctionDeclaration
// and replaces any Declaration nodes in its body with assignments, then
// returns a VariableDeclaration containing just the names of the removed
// declarations.
exports.hoist = function(funPath) {
  assert.ok(funPath instanceof types.NodePath);
  n.Function.assert(funPath.value);

  var vars = {};

  function varDeclToExpr(vdec, includeIdentifiers) {
    n.VariableDeclaration.assert(vdec);
    var exprs = [];

    vdec.declarations.forEach(function(dec) {
      vars[dec.id.name] = dec.id;

      if (dec.init) {
        exprs.push(b.assignmentExpression(
          "=", dec.id, dec.init
        ));
      } else if (includeIdentifiers) {
        exprs.push(dec.id);
      }
    });

    if (exprs.length === 0)
      return null;

    if (exprs.length === 1)
      return exprs[0];

    return b.sequenceExpression(exprs);
  }

  types.visit(funPath.get("body"), {
    visitVariableDeclaration: function(path) {
      var expr = varDeclToExpr(path.value, false);
      if (expr === null) {
        path.replace();
      } else {
        // We don't need to traverse this expression any further because
        // there can't be any new declarations inside an expression.
        return b.expressionStatement(expr);
      }

      // Since the original node has been either removed or replaced,
      // avoid traversing it any further.
      return false;
    },

    visitForStatement: function(path) {
      var init = path.value.init;
      if (n.VariableDeclaration.check(init)) {
        path.get("init").replace(varDeclToExpr(init, false));
      }
      this.traverse(path);
    },

    visitForInStatement: function(path) {
      var left = path.value.left;
      if (n.VariableDeclaration.check(left)) {
        path.get("left").replace(varDeclToExpr(left, true));
      }
      this.traverse(path);
    },

    visitFunctionDeclaration: function(path) {
      var node = path.value;
      vars[node.id.name] = node.id;

      var parentNode = path.parent.node;
      var assignment = b.expressionStatement(
        b.assignmentExpression(
          "=",
          node.id,
          b.functionExpression(
            node.id,
            node.params,
            node.body,
            node.generator,
            node.expression
          )
        )
      );

      if (n.BlockStatement.check(path.parent.node)) {
        // Insert the assignment form before the first statement in the
        // enclosing block.
        path.parent.get("body").unshift(assignment);

        // Remove the function declaration now that we've inserted the
        // equivalent assignment form at the beginning of the block.
        path.replace();

      } else {
        // If the parent node is not a block statement, then we can just
        // replace the declaration with the equivalent assignment form
        // without worrying about hoisting it.
        path.replace(assignment);
      }

      // Don't hoist variables out of inner functions.
      return false;
    },

    visitFunctionExpression: function(path) {
      // Don't descend into nested function expressions.
      return false;
    }
  });

  var paramNames = {};
  funPath.get("params").each(function(paramPath) {
    var param = paramPath.value;
    if (n.Identifier.check(param)) {
      paramNames[param.name] = param;
    } else {
      // Variables declared by destructuring parameter patterns will be
      // harmlessly re-declared.
    }
  });

  var declarations = [];

  Object.keys(vars).forEach(function(name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(b.variableDeclarator(vars[name], null));
    }
  });

  if (declarations.length === 0) {
    return null; // Be sure to handle this case!
  }

  return b.variableDeclaration("var", declarations);
};

},{"assert":306,"ast-types":139}],273:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var inherits = require("util").inherits;
var hasOwn = Object.prototype.hasOwnProperty;

function Entry() {
  assert.ok(this instanceof Entry);
}

function FunctionEntry(returnLoc) {
  Entry.call(this);
  n.Literal.assert(returnLoc);
  this.returnLoc = returnLoc;
}

inherits(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;

function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);

  n.Literal.assert(breakLoc);
  n.Literal.assert(continueLoc);

  if (label) {
    n.Identifier.assert(label);
  } else {
    label = null;
  }

  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}

inherits(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;

function SwitchEntry(breakLoc) {
  Entry.call(this);
  n.Literal.assert(breakLoc);
  this.breakLoc = breakLoc;
}

inherits(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;

function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);

  n.Literal.assert(firstLoc);

  if (catchEntry) {
    assert.ok(catchEntry instanceof CatchEntry);
  } else {
    catchEntry = null;
  }

  if (finallyEntry) {
    assert.ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  }

  // Have to have one or the other (or both).
  assert.ok(catchEntry || finallyEntry);

  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}

inherits(TryEntry, Entry);
exports.TryEntry = TryEntry;

function CatchEntry(firstLoc, paramId) {
  Entry.call(this);

  n.Literal.assert(firstLoc);
  n.Identifier.assert(paramId);

  this.firstLoc = firstLoc;
  this.paramId = paramId;
}

inherits(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;

function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  n.Literal.assert(firstLoc);
  n.Literal.assert(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}

inherits(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;

function LabeledEntry(breakLoc, label) {
  Entry.call(this);

  n.Literal.assert(breakLoc);
  n.Identifier.assert(label);

  this.breakLoc = breakLoc;
  this.label = label;
}

inherits(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;

function LeapManager(emitter) {
  assert.ok(this instanceof LeapManager);

  var Emitter = require("./emit").Emitter;
  assert.ok(emitter instanceof Emitter);

  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}

var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;

LMp.withEntry = function(entry, callback) {
  assert.ok(entry instanceof Entry);
  this.entryStack.push(entry);
  try {
    callback.call(this.emitter);
  } finally {
    var popped = this.entryStack.pop();
    assert.strictEqual(popped, entry);
  }
};

LMp._findLeapLocation = function(property, label) {
  for (var i = this.entryStack.length - 1; i >= 0; --i) {
    var entry = this.entryStack[i];
    var loc = entry[property];
    if (loc) {
      if (label) {
        if (entry.label &&
            entry.label.name === label.name) {
          return loc;
        }
      } else if (entry instanceof LabeledEntry) {
        // Ignore LabeledEntry entries unless we are actually breaking to
        // a label.
      } else {
        return loc;
      }
    }
  }

  return null;
};

LMp.getBreakLoc = function(label) {
  return this._findLeapLocation("breakLoc", label);
};

LMp.getContinueLoc = function(label) {
  return this._findLeapLocation("continueLoc", label);
};

},{"./emit":271,"assert":306,"ast-types":139,"util":331}],274:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var m = require("private").makeAccessor();
var types = require("ast-types");
var isArray = types.builtInTypes.array;
var n = types.namedTypes;
var hasOwn = Object.prototype.hasOwnProperty;

function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    n.Node.assert(node);

    // Assume no side effects until we find out otherwise.
    var result = false;

    function check(child) {
      if (result) {
        // Do nothing.
      } else if (isArray.check(child)) {
        child.some(check);
      } else if (n.Node.check(child)) {
        assert.strictEqual(result, false);
        result = predicate(child);
      }
      return result;
    }

    types.eachField(node, function(name, child) {
      check(child);
    });

    return result;
  }

  function predicate(node) {
    n.Node.assert(node);

    var meta = m(node);
    if (hasOwn.call(meta, propertyName))
      return meta[propertyName];

    // Certain types are "opaque," which means they have no side
    // effects or leaps and we don't care about their subexpressions.
    if (hasOwn.call(opaqueTypes, node.type))
      return meta[propertyName] = false;

    if (hasOwn.call(knownTypes, node.type))
      return meta[propertyName] = true;

    return meta[propertyName] = onlyChildren(node);
  }

  predicate.onlyChildren = onlyChildren;

  return predicate;
}

var opaqueTypes = {
  FunctionExpression: true
};

// These types potentially have side effects regardless of what side
// effects their subexpressions have.
var sideEffectTypes = {
  CallExpression: true, // Anything could happen!
  ForInStatement: true, // Modifies the key variable.
  UnaryExpression: true, // Think delete.
  BinaryExpression: true, // Might invoke .toString() or .valueOf().
  AssignmentExpression: true, // Side-effecting by definition.
  UpdateExpression: true, // Updates are essentially assignments.
  NewExpression: true // Similar to CallExpression.
};

// These types are the direct cause of all leaps in control flow.
var leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
};

// All leap types are also side effect types.
for (var type in leapTypes) {
  if (hasOwn.call(leapTypes, type)) {
    sideEffectTypes[type] = leapTypes[type];
  }
}

exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
exports.containsLeap = makePredicate("containsLeap", leapTypes);

},{"assert":306,"ast-types":139,"private":270}],275:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var hasOwn = Object.prototype.hasOwnProperty;

exports.defaults = function(obj) {
  var len = arguments.length;
  var extension;

  for (var i = 1; i < len; ++i) {
    if ((extension = arguments[i])) {
      for (var key in extension) {
        if (hasOwn.call(extension, key) && !hasOwn.call(obj, key)) {
          obj[key] = extension[key];
        }
      }
    }
  }

  return obj;
};

exports.runtimeProperty = function(name) {
  return b.memberExpression(
    b.identifier("regeneratorRuntime"),
    b.identifier(name),
    false
  );
};

// Inspired by the isReference function from ast-util:
// https://github.com/eventualbuddha/ast-util/blob/9bf91c5ce8/lib/index.js#L466-L506
exports.isReference = function(path, name) {
  var node = path.value;

  if (!n.Identifier.check(node)) {
    return false;
  }

  if (name && node.name !== name) {
    return false;
  }

  var parent = path.parent.value;

  switch (parent.type) {
  case "VariableDeclarator":
    return path.name === "init";

  case "MemberExpression":
    return path.name === "object" || (
      parent.computed && path.name === "property"
    );

  case "FunctionExpression":
  case "FunctionDeclaration":
  case "ArrowFunctionExpression":
    if (path.name === "id") {
      return false;
    }

    if (parent.params === path.parentPath &&
        parent.params[path.name] === node) {
      return false;
    }

    return true;

  case "ClassDeclaration":
  case "ClassExpression":
    return path.name !== "id";

  case "CatchClause":
    return path.name !== "param";

  case "Property":
  case "MethodDefinition":
    return path.name !== "key";

  case "ImportSpecifier":
  case "ImportDefaultSpecifier":
  case "ImportNamespaceSpecifier":
  case "LabeledStatement":
    return false;

  default:
    return true;
  }
};

},{"assert":306,"ast-types":139}],276:[function(require,module,exports){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var fs = require("fs");
var types = require("ast-types");
var n = types.namedTypes;
var b = types.builders;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var NodePath = types.NodePath;
var hoist = require("./hoist").hoist;
var Emitter = require("./emit").Emitter;
var runtimeProperty = require("./util").runtimeProperty;

exports.transform = function transform(node, options) {
  options = options || {};

  var path = node instanceof NodePath ? node : new NodePath(node);
  visitor.visit(path, options);
  node = path.value;

  options.madeChanges = visitor.wasChangeReported();

  return node;
};

var visitor = types.PathVisitor.fromMethodsObject({
  reset: function(node, options) {
    this.options = options;
  },

  visitFunction: function(path) {
    // Calling this.traverse(path) first makes for a post-order traversal.
    this.traverse(path);

    var node = path.value;
    var shouldTransformAsync = node.async && !this.options.disableAsync;

    if (!node.generator && !shouldTransformAsync) {
      return;
    }

    this.reportChanged();

    node.generator = false;

    if (node.expression) {
      // Transform expression lambdas into normal functions.
      node.expression = false;
      node.body = b.blockStatement([
        b.returnStatement(node.body)
      ]);
    }

    if (shouldTransformAsync) {
      awaitVisitor.visit(path.get("body"));
    }

    var outerFnId = node.id || (
      node.id = path.scope.parent.declareTemporary("callee$")
    );

    var outerBody = [];
    var bodyBlock = path.value.body;
    bodyBlock.body = bodyBlock.body.filter(function (node) {
      if (node && node._blockHoist != null) {
        outerBody.push(node);
        return false;
      } else {
        return true;
      }
    });

    var innerFnId = b.identifier(node.id.name + "$");
    var contextId = path.scope.declareTemporary("context$");
    var vars = hoist(path);

    var emitter = new Emitter(contextId);
    emitter.explode(path.get("body"));

    if (vars && vars.declarations.length > 0) {
      outerBody.push(vars);
    }

    var wrapArgs = [
      emitter.getContextFunction(innerFnId),
      // Async functions don't care about the outer function because they
      // don't need it to be marked and don't inherit from its .prototype.
      shouldTransformAsync ? b.literal(null) : outerFnId,
      b.thisExpression()
    ];

    var tryLocsList = emitter.getTryLocsList();
    if (tryLocsList) {
      wrapArgs.push(tryLocsList);
    }

    var wrapCall = b.callExpression(
      shouldTransformAsync ? runtimeProperty("async") : runtimeProperty("wrap"),
      wrapArgs
    );

    outerBody.push(b.returnStatement(wrapCall));
    node.body = b.blockStatement(outerBody);
    node.body._declarations = bodyBlock._declarations;

    if (shouldTransformAsync) {
      node.async = false;
      return;
    }

    if (n.FunctionDeclaration.check(node)) {
      var pp = path.parent;

      while (pp && !(n.BlockStatement.check(pp.value) ||
                     n.Program.check(pp.value))) {
        pp = pp.parent;
      }

      if (!pp) {
        return;
      }

      // Here we turn the FunctionDeclaration into a named
      // FunctionExpression that will be assigned to a variable of the
      // same name at the top of the enclosing block. This is important
      // for a very subtle reason: named function expressions can refer to
      // themselves by name without fear that the binding may change due
      // to code executing outside the function, whereas function
      // declarations are vulnerable to the following rebinding:
      //
      //   function f() { return f }
      //   var g = f;
      //   f = "asdf";
      //   g(); // "asdf"
      //
      // One way to prevent the problem illustrated above is to transform
      // the function declaration thus:
      //
      //   var f = function f() { return f };
      //   var g = f;
      //   f = "asdf";
      //   g(); // f
      //   g()()()()(); // f
      //
      // In the code below, we transform generator function declarations
      // in the following way:
      //
      //   gen().next(); // { value: gen, done: true }
      //   function *gen() {
      //     return gen;
      //   }
      //
      // becomes something like
      //
      //   var gen = runtime.mark(function *gen() {
      //     return gen;
      //   });
      //   gen().next(); // { value: gen, done: true }
      //
      // which ensures that the generator body can always reliably refer
      // to gen by name.

      // Remove the FunctionDeclaration so that we can add it back as a
      // FunctionExpression passed to runtime.mark.
      path.replace();

      // Change the type of the function to be an expression instead of a
      // declaration. Note that all the other fields are the same.
      node.type = "FunctionExpression";

      var varDecl = b.variableDeclaration("var", [
        b.variableDeclarator(
          node.id,
          b.callExpression(runtimeProperty("mark"), [node])
        )
      ]);

      if (node.comments) {
        // Copy any comments preceding the function declaration to the
        // variable declaration, to avoid weird formatting consequences.
        varDecl.leadingComments = node.leadingComments;
        varDecl.trailingComments = node.trailingComments;
        node.leadingComments = null;
        node.trailingComments = null;
      }

      varDecl._blockHoist = 3;

      var bodyPath = pp.get("body");
      var bodyLen = bodyPath.value.length;

      bodyPath.push(varDecl);

    } else {
      n.FunctionExpression.assert(node);
      return b.callExpression(runtimeProperty("mark"), [node]);
    }
  }
});

function shouldNotHoistAbove(stmtPath) {
  var value = stmtPath.value;
  n.Statement.assert(value);

  // If the first statement is a "use strict" declaration, make sure to
  // insert hoisted declarations afterwards.
  if (n.ExpressionStatement.check(value) &&
      n.Literal.check(value.expression) &&
      value.expression.value === "use strict") {
    return true;
  }

  if (n.VariableDeclaration.check(value)) {
    for (var i = 0; i < value.declarations.length; ++i) {
      var decl = value.declarations[i];
      if (n.CallExpression.check(decl.init) &&
          types.astNodesAreEquivalent(decl.init.callee,
                                      runtimeProperty("mark"))) {
        return true;
      }
    }
  }

  return false;
}

var awaitVisitor = types.PathVisitor.fromMethodsObject({
  visitFunction: function(path) {
    return false; // Don't descend into nested function scopes.
  },

  visitAwaitExpression: function(path) {
    // Convert await and await* expressions to yield expressions.
    var argument = path.value.argument;

    // If the parser supports await* syntax using a boolean .all property
    // (#171), desugar that syntax to yield Promise.all(argument).
    if (path.value.all) {
      argument = b.callExpression(
        b.memberExpression(
          b.identifier("Promise"),
          b.identifier("all"),
          false
        ),
        [argument]
      );
    }

    return b.yieldExpression(argument, false);
  }
});

},{"./emit":271,"./hoist":272,"./util":275,"assert":306,"ast-types":139,"fs":305}],277:[function(require,module,exports){
(function (__dirname){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var path = require("path");
var fs = require("fs");
var through = require("through");
var transform = require("./lib/visit").transform;
var utils = require("./lib/util");
var types = require("ast-types");
var genOrAsyncFunExp = /\bfunction\s*\*|\basync\b/;
var blockBindingExp = /\b(let|const)\s+/;

function exports(file, options) {
  var data = [];
  return through(write, end);

  function write(buf) {
    data.push(buf);
  }

  function end() {
    this.queue(compile(data.join(""), options).code);
    this.queue(null);
  }
}

// To get a writable stream for use as a browserify transform, call
// require("regenerator")().
module.exports = exports;

// To include the runtime globally in the current node process, call
// require("regenerator").runtime().
function runtime() {
  require("./runtime");
}
exports.runtime = runtime;
runtime.path = path.join(__dirname, "runtime.js");

// To modify an AST directly, call require("regenerator").transform(ast).
exports.transform = transform;

}).call(this,"/node_modules/babel/node_modules/regenerator-babel")

},{"./lib/util":275,"./lib/visit":276,"./runtime":279,"assert":306,"ast-types":139,"fs":305,"path":314,"through":278}],278:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data == null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":315,"stream":327}],279:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    _findFinallyEntry: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") && (
              entry.finallyLoc === finallyLoc ||
              this.prev < entry.finallyLoc)) {
          return entry;
        }
      }
    },

    abrupt: function(type, arg) {
      var entry = this._findFinallyEntry();
      var record = entry ? entry.completion : {};

      record.type = type;
      record.arg = arg;

      if (entry) {
        this.next = entry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      var entry = this._findFinallyEntry(finallyLoc);
      return this.complete(entry.completion, entry.afterLoc);
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],280:[function(require,module,exports){
// Generated by `/scripts/character-class-escape-sets.js`. Do not edit.
var regenerate = require('regenerate');

exports.REGULAR = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0xFFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0xFFFF),
	'w': regenerate(0x5F)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0xFFFF)
};

exports.UNICODE = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x10FFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0x10FFFF),
	'w': regenerate(0x5F)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0x10FFFF)
};

exports.UNICODE_IGNORE_CASE = {
	'd': regenerate()
		.addRange(0x30, 0x39),
	'D': regenerate()
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x10FFFF),
	's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF)
		.addRange(0x9, 0xD)
		.addRange(0x2000, 0x200A)
		.addRange(0x2028, 0x2029),
	'S': regenerate()
		.addRange(0x0, 0x8)
		.addRange(0xE, 0x1F)
		.addRange(0x21, 0x9F)
		.addRange(0xA1, 0x167F)
		.addRange(0x1681, 0x180D)
		.addRange(0x180F, 0x1FFF)
		.addRange(0x200B, 0x2027)
		.addRange(0x202A, 0x202E)
		.addRange(0x2030, 0x205E)
		.addRange(0x2060, 0x2FFF)
		.addRange(0x3001, 0xFEFE)
		.addRange(0xFF00, 0x10FFFF),
	'w': regenerate(0x5F, 0x17F, 0x212A)
		.addRange(0x30, 0x39)
		.addRange(0x41, 0x5A)
		.addRange(0x61, 0x7A),
	'W': regenerate(0x4B, 0x53, 0x60)
		.addRange(0x0, 0x2F)
		.addRange(0x3A, 0x40)
		.addRange(0x5B, 0x5E)
		.addRange(0x7B, 0x10FFFF)
};

},{"regenerate":282}],281:[function(require,module,exports){
module.exports={
	"75": 8490,
	"83": 383,
	"107": 8490,
	"115": 383,
	"181": 924,
	"197": 8491,
	"383": 83,
	"452": 453,
	"453": 452,
	"455": 456,
	"456": 455,
	"458": 459,
	"459": 458,
	"497": 498,
	"498": 497,
	"837": 8126,
	"914": 976,
	"917": 1013,
	"920": 1012,
	"921": 8126,
	"922": 1008,
	"924": 181,
	"928": 982,
	"929": 1009,
	"931": 962,
	"934": 981,
	"937": 8486,
	"962": 931,
	"976": 914,
	"977": 1012,
	"981": 934,
	"982": 928,
	"1008": 922,
	"1009": 929,
	"1012": [
		920,
		977
	],
	"1013": 917,
	"7776": 7835,
	"7835": 7776,
	"8126": [
		837,
		921
	],
	"8486": 937,
	"8490": 75,
	"8491": 197,
	"66560": 66600,
	"66561": 66601,
	"66562": 66602,
	"66563": 66603,
	"66564": 66604,
	"66565": 66605,
	"66566": 66606,
	"66567": 66607,
	"66568": 66608,
	"66569": 66609,
	"66570": 66610,
	"66571": 66611,
	"66572": 66612,
	"66573": 66613,
	"66574": 66614,
	"66575": 66615,
	"66576": 66616,
	"66577": 66617,
	"66578": 66618,
	"66579": 66619,
	"66580": 66620,
	"66581": 66621,
	"66582": 66622,
	"66583": 66623,
	"66584": 66624,
	"66585": 66625,
	"66586": 66626,
	"66587": 66627,
	"66588": 66628,
	"66589": 66629,
	"66590": 66630,
	"66591": 66631,
	"66592": 66632,
	"66593": 66633,
	"66594": 66634,
	"66595": 66635,
	"66596": 66636,
	"66597": 66637,
	"66598": 66638,
	"66599": 66639,
	"66600": 66560,
	"66601": 66561,
	"66602": 66562,
	"66603": 66563,
	"66604": 66564,
	"66605": 66565,
	"66606": 66566,
	"66607": 66567,
	"66608": 66568,
	"66609": 66569,
	"66610": 66570,
	"66611": 66571,
	"66612": 66572,
	"66613": 66573,
	"66614": 66574,
	"66615": 66575,
	"66616": 66576,
	"66617": 66577,
	"66618": 66578,
	"66619": 66579,
	"66620": 66580,
	"66621": 66581,
	"66622": 66582,
	"66623": 66583,
	"66624": 66584,
	"66625": 66585,
	"66626": 66586,
	"66627": 66587,
	"66628": 66588,
	"66629": 66589,
	"66630": 66590,
	"66631": 66591,
	"66632": 66592,
	"66633": 66593,
	"66634": 66594,
	"66635": 66595,
	"66636": 66596,
	"66637": 66597,
	"66638": 66598,
	"66639": 66599,
	"71840": 71872,
	"71841": 71873,
	"71842": 71874,
	"71843": 71875,
	"71844": 71876,
	"71845": 71877,
	"71846": 71878,
	"71847": 71879,
	"71848": 71880,
	"71849": 71881,
	"71850": 71882,
	"71851": 71883,
	"71852": 71884,
	"71853": 71885,
	"71854": 71886,
	"71855": 71887,
	"71856": 71888,
	"71857": 71889,
	"71858": 71890,
	"71859": 71891,
	"71860": 71892,
	"71861": 71893,
	"71862": 71894,
	"71863": 71895,
	"71864": 71896,
	"71865": 71897,
	"71866": 71898,
	"71867": 71899,
	"71868": 71900,
	"71869": 71901,
	"71870": 71902,
	"71871": 71903,
	"71872": 71840,
	"71873": 71841,
	"71874": 71842,
	"71875": 71843,
	"71876": 71844,
	"71877": 71845,
	"71878": 71846,
	"71879": 71847,
	"71880": 71848,
	"71881": 71849,
	"71882": 71850,
	"71883": 71851,
	"71884": 71852,
	"71885": 71853,
	"71886": 71854,
	"71887": 71855,
	"71888": 71856,
	"71889": 71857,
	"71890": 71858,
	"71891": 71859,
	"71892": 71860,
	"71893": 71861,
	"71894": 71862,
	"71895": 71863,
	"71896": 71864,
	"71897": 71865,
	"71898": 71866,
	"71899": 71867,
	"71900": 71868,
	"71901": 71869,
	"71902": 71870,
	"71903": 71871
}

},{}],282:[function(require,module,exports){
(function (global){
/*! https://mths.be/regenerate v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`.
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var ERRORS = {
		'rangeOrder': 'A range\u2019s `stop` value must be greater than or equal ' +
			'to the `start` value.',
		'codePointRange': 'Invalid code point value. Code points range from ' +
			'U+000000 to U+10FFFF.'
	};

	// https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs
	var HIGH_SURROGATE_MIN = 0xD800;
	var HIGH_SURROGATE_MAX = 0xDBFF;
	var LOW_SURROGATE_MIN = 0xDC00;
	var LOW_SURROGATE_MAX = 0xDFFF;

	// In Regenerate output, `\0` will never be preceded by `\` because we sort
	// by code point value, so let’s keep this regular expression simple.
	var regexNull = /\\x00([^0123456789]|$)/g;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var extend = function(destination, source) {
		var key;
		for (key in source) {
			if (hasOwnProperty.call(source, key)) {
				destination[key] = source[key];
			}
		}
		return destination;
	};

	var forEach = function(array, callback) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			callback(array[index], index);
		}
	};

	var toString = object.toString;
	var isArray = function(value) {
		return toString.call(value) == '[object Array]';
	};
	var isNumber = function(value) {
		return typeof value == 'number' ||
			toString.call(value) == '[object Number]';
	};

	// This assumes that `number` is a positive integer that `toString()`s nicely
	// (which is the case for all code point values).
	var zeroes = '0000';
	var pad = function(number, totalCharacters) {
		var string = String(number);
		return string.length < totalCharacters
			? (zeroes + string).slice(-totalCharacters)
			: string;
	};

	var hex = function(number) {
		return Number(number).toString(16).toUpperCase();
	};

	var slice = [].slice;

	/*--------------------------------------------------------------------------*/

	var dataFromCodePoints = function(codePoints) {
		var index = -1;
		var length = codePoints.length;
		var max = length - 1;
		var result = [];
		var isStart = true;
		var tmp;
		var previous = 0;
		while (++index < length) {
			tmp = codePoints[index];
			if (isStart) {
				result.push(tmp);
				previous = tmp;
				isStart = false;
			} else {
				if (tmp == previous + 1) {
					if (index != max) {
						previous = tmp;
						continue;
					} else {
						isStart = true;
						result.push(tmp + 1);
					}
				} else {
					// End the previous range and start a new one.
					result.push(previous + 1, tmp);
					previous = tmp;
				}
			}
		}
		if (!isStart) {
			result.push(tmp + 1);
		}
		return result;
	};

	var dataRemove = function(data, codePoint) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			if (codePoint >= start && codePoint < end) {
				// Modify this pair.
				if (codePoint == start) {
					if (end == start + 1) {
						// Just remove `start` and `end`.
						data.splice(index, 2);
						return data;
					} else {
						// Just replace `start` with a new value.
						data[index] = codePoint + 1;
						return data;
					}
				} else if (codePoint == end - 1) {
					// Just replace `end` with a new value.
					data[index + 1] = codePoint;
					return data;
				} else {
					// Replace `[start, end]` with `[startA, endA, startB, endB]`.
					data.splice(index, 2, start, codePoint, codePoint + 1, end);
					return data;
				}
			}
			index += 2;
		}
		return data;
	};

	var dataRemoveRange = function(data, rangeStart, rangeEnd) {
		if (rangeEnd < rangeStart) {
			throw Error(ERRORS.rangeOrder);
		}
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		while (index < data.length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

			// Exit as soon as no more matching pairs can be found.
			if (start > rangeEnd) {
				return data;
			}

			// Check if this range pair is equal to, or forms a subset of, the range
			// to be removed.
			// E.g. we have `[0, 11, 40, 51]` and want to remove 0-10 → `[40, 51]`.
			// E.g. we have `[40, 51]` and want to remove 0-100 → `[]`.
			if (rangeStart <= start && rangeEnd >= end) {
				// Remove this pair.
				data.splice(index, 2);
				continue;
			}

			// Check if both `rangeStart` and `rangeEnd` are within the bounds of
			// this pair.
			// E.g. we have `[0, 11]` and want to remove 4-6 → `[0, 4, 7, 11]`.
			if (rangeStart >= start && rangeEnd < end) {
				if (rangeStart == start) {
					// Replace `[start, end]` with `[startB, endB]`.
					data[index] = rangeEnd + 1;
					data[index + 1] = end + 1;
					return data;
				}
				// Replace `[start, end]` with `[startA, endA, startB, endB]`.
				data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
				return data;
			}

			// Check if only `rangeStart` is within the bounds of this pair.
			// E.g. we have `[0, 11]` and want to remove 4-20 → `[0, 4]`.
			if (rangeStart >= start && rangeStart <= end) {
				// Replace `end` with `rangeStart`.
				data[index + 1] = rangeStart;
				// Note: we cannot `return` just yet, in case any following pairs still
				// contain matching code points.
				// E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
				// → `[0, 4, 21, 31]`.
			}

			// Check if only `rangeEnd` is within the bounds of this pair.
			// E.g. we have `[14, 31]` and want to remove 4-20 → `[21, 31]`.
			else if (rangeEnd >= start && rangeEnd <= end) {
				// Just replace `start`.
				data[index] = rangeEnd + 1;
				return data;
			}

			index += 2;
		}
		return data;
	};

	 var dataAdd = function(data, codePoint) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var lastIndex = null;
		var length = data.length;
		if (codePoint < 0x0 || codePoint > 0x10FFFF) {
			throw RangeError(ERRORS.codePointRange);
		}
		while (index < length) {
			start = data[index];
			end = data[index + 1];

			// Check if the code point is already in the set.
			if (codePoint >= start && codePoint < end) {
				return data;
			}

			if (codePoint == start - 1) {
				// Just replace `start` with a new value.
				data[index] = codePoint;
				return data;
			}

			// At this point, if `start` is `greater` than `codePoint`, insert a new
			// `[start, end]` pair before the current pair, or after the current pair
			// if there is a known `lastIndex`.
			if (start > codePoint) {
				data.splice(
					lastIndex != null ? lastIndex + 2 : 0,
					0,
					codePoint,
					codePoint + 1
				);
				return data;
			}

			if (codePoint == end) {
				// Check if adding this code point causes two separate ranges to become
				// a single range, e.g. `dataAdd([0, 4, 5, 10], 4)` → `[0, 10]`.
				if (codePoint + 1 == data[index + 2]) {
					data.splice(index, 4, start, data[index + 3]);
					return data;
				}
				// Else, just replace `end` with a new value.
				data[index + 1] = codePoint + 1;
				return data;
			}
			lastIndex = index;
			index += 2;
		}
		// The loop has finished; add the new pair to the end of the data set.
		data.push(codePoint, codePoint + 1);
		return data;
	};

	var dataAddData = function(dataA, dataB) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var data = dataA.slice();
		var length = dataB.length;
		while (index < length) {
			start = dataB[index];
			end = dataB[index + 1] - 1;
			if (start == end) {
				data = dataAdd(data, start);
			} else {
				data = dataAddRange(data, start, end);
			}
			index += 2;
		}
		return data;
	};

	var dataRemoveData = function(dataA, dataB) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var data = dataA.slice();
		var length = dataB.length;
		while (index < length) {
			start = dataB[index];
			end = dataB[index + 1] - 1;
			if (start == end) {
				data = dataRemove(data, start);
			} else {
				data = dataRemoveRange(data, start, end);
			}
			index += 2;
		}
		return data;
	};

	var dataAddRange = function(data, rangeStart, rangeEnd) {
		if (rangeEnd < rangeStart) {
			throw Error(ERRORS.rangeOrder);
		}
		if (
			rangeStart < 0x0 || rangeStart > 0x10FFFF ||
			rangeEnd < 0x0 || rangeEnd > 0x10FFFF
		) {
			throw RangeError(ERRORS.codePointRange);
		}
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var added = false;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];

			if (added) {
				// The range has already been added to the set; at this point, we just
				// need to get rid of the following ranges in case they overlap.

				// Check if this range can be combined with the previous range.
				if (start == rangeEnd + 1) {
					data.splice(index - 1, 2);
					return data;
				}

				// Exit as soon as no more possibly overlapping pairs can be found.
				if (start > rangeEnd) {
					return data;
				}

				// E.g. `[0, 11, 12, 16]` and we’ve added 5-15, so we now have
				// `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
				// `0,16` range that was previously added.
				if (start >= rangeStart && start <= rangeEnd) {
					// `start` lies within the range that was previously added.

					if (end > rangeStart && end - 1 <= rangeEnd) {
						// `end` lies within the range that was previously added as well,
						// so remove this pair.
						data.splice(index, 2);
						index -= 2;
						// Note: we cannot `return` just yet, as there may still be other
						// overlapping pairs.
					} else {
						// `start` lies within the range that was previously added, but
						// `end` doesn’t. E.g. `[0, 11, 12, 31]` and we’ve added 5-15, so
						// now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
						// Remove the previously added `end` and the current `start`.
						data.splice(index - 1, 2);
						index -= 2;
					}

					// Note: we cannot return yet.
				}

			}

			else if (start == rangeEnd + 1) {
				data[index] = rangeStart;
				return data;
			}

			// Check if a new pair must be inserted *before* the current one.
			else if (start > rangeEnd) {
				data.splice(index, 0, rangeStart, rangeEnd + 1);
				return data;
			}

			else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
				// The new range lies entirely within an existing range pair. No action
				// needed.
				return data;
			}

			else if (
				// E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.
				(rangeStart >= start && rangeStart < end) ||
				// E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.
				end == rangeStart
			) {
				// Replace `end` with the new value.
				data[index + 1] = rangeEnd + 1;
				// Make sure the next range pair doesn’t overlap, e.g. `[0, 11, 12, 14]`
				// and you add 5-15 → `[0, 16]`, i.e. remove the `12,14` part.
				added = true;
				// Note: we cannot `return` just yet.
			}

			else if (rangeStart <= start && rangeEnd + 1 >= end) {
				// The new range is a superset of the old range.
				data[index] = rangeStart;
				data[index + 1] = rangeEnd + 1;
				added = true;
			}

			index += 2;
		}
		// The loop has finished without doing anything; add the new pair to the end
		// of the data set.
		if (!added) {
			data.push(rangeStart, rangeEnd + 1);
		}
		return data;
	};

	var dataContains = function(data, codePoint) {
		var index = 0;
		var length = data.length;
		// Exit early if `codePoint` is not within `data`’s overall range.
		var start = data[index];
		var end = data[length - 1];
		if (length >= 2) {
			if (codePoint < start || codePoint > end) {
				return false;
			}
		}
		// Iterate over the data per `(start, end)` pair.
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			if (codePoint >= start && codePoint < end) {
				return true;
			}
			index += 2;
		}
		return false;
	};

	var dataIntersection = function(data, codePoints) {
		var index = 0;
		var length = codePoints.length;
		var codePoint;
		var result = [];
		while (index < length) {
			codePoint = codePoints[index];
			if (dataContains(data, codePoint)) {
				result.push(codePoint);
			}
			++index;
		}
		return dataFromCodePoints(result);
	};

	var dataIsEmpty = function(data) {
		return !data.length;
	};

	var dataIsSingleton = function(data) {
		// Check if the set only represents a single code point.
		return data.length == 2 && data[0] + 1 == data[1];
	};

	var dataToArray = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var result = [];
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1];
			while (start < end) {
				result.push(start);
				++start;
			}
			index += 2;
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	var floor = Math.floor;
	var highSurrogate = function(codePoint) {
		return parseInt(
			floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN,
			10
		);
	};

	var lowSurrogate = function(codePoint) {
		return parseInt(
			(codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN,
			10
		);
	};

	var stringFromCharCode = String.fromCharCode;
	var codePointToString = function(codePoint) {
		var string;
		// https://mathiasbynens.be/notes/javascript-escapes#single
		// Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
		// different meaning in regular expressions (word boundary), so it cannot
		// be used here.
		if (codePoint == 0x09) {
			string = '\\t';
		}
		// Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
		// else if (codePoint == 0x0B) {
		// 	string = '\\v';
		// }
		else if (codePoint == 0x0A) {
			string = '\\n';
		}
		else if (codePoint == 0x0C) {
			string = '\\f';
		}
		else if (codePoint == 0x0D) {
			string = '\\r';
		}
		else if (codePoint == 0x5C) {
			string = '\\\\';
		}
		else if (
			codePoint == 0x24 ||
			(codePoint >= 0x28 && codePoint <= 0x2B) ||
			codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F ||
			(codePoint >= 0x5B && codePoint <= 0x5E) ||
			(codePoint >= 0x7B && codePoint <= 0x7D)
		) {
			// The code point maps to an unsafe printable ASCII character;
			// backslash-escape it. Here’s the list of those symbols:
			//
			//     $()*+-.?[\]^{|}
			//
			// See #7 for more info.
			string = '\\' + stringFromCharCode(codePoint);
		}
		else if (codePoint >= 0x20 && codePoint <= 0x7E) {
			// The code point maps to one of these printable ASCII symbols
			// (including the space character):
			//
			//      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
			//     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
			//
			// These can safely be used directly.
			string = stringFromCharCode(codePoint);
		}
		else if (codePoint <= 0xFF) {
			// https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
			string = '\\x' + pad(hex(codePoint), 2);
		}
		else { // `codePoint <= 0xFFFF` holds true.
			// https://mathiasbynens.be/notes/javascript-escapes#unicode
			string = '\\u' + pad(hex(codePoint), 4);
		}

		// There’s no need to account for astral symbols / surrogate pairs here,
		// since `codePointToString` is private and only used for BMP code points.
		// But if that’s what you need, just add an `else` block with this code:
		//
		//     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
		//     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);

		return string;
	};

	var symbolToCodePoint = function(symbol) {
		var length = symbol.length;
		var first = symbol.charCodeAt(0);
		var second;
		if (
			first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX &&
			length > 1 // There is a next code unit.
		) {
			// `first` is a high surrogate, and there is a next character. Assume
			// it’s a low surrogate (else it’s invalid usage of Regenerate anyway).
			second = symbol.charCodeAt(1);
			// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
			return (first - HIGH_SURROGATE_MIN) * 0x400 +
				second - LOW_SURROGATE_MIN + 0x10000;
		}
		return first;
	};

	var createBMPCharacterClasses = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var result = '';
		var index = 0;
		var start;
		var end;
		var length = data.length;
		if (dataIsSingleton(data)) {
			return codePointToString(data[0]);
		}
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
			if (start == end) {
				result += codePointToString(start);
			} else if (start + 1 == end) {
				result += codePointToString(start) + codePointToString(end);
			} else {
				result += codePointToString(start) + '-' + codePointToString(end);
			}
			index += 2;
		}
		return '[' + result + ']';
	};

	var splitAtBMP = function(data) {
		// Iterate over the data per `(start, end)` pair.
		var loneHighSurrogates = [];
		var loneLowSurrogates = [];
		var bmp = [];
		var astral = [];
		var index = 0;
		var start;
		var end;
		var length = data.length;
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

			if (start < HIGH_SURROGATE_MIN) {

				// The range starts and ends before the high surrogate range.
				// E.g. (0, 0x10).
				if (end < HIGH_SURROGATE_MIN) {
					bmp.push(start, end + 1);
				}

				// The range starts before the high surrogate range and ends within it.
				// E.g. (0, 0xD855).
				if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
				}

				// The range starts before the high surrogate range and ends in the low
				// surrogate range. E.g. (0, 0xDCFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
				}

				// The range starts before the high surrogate range and ends after the
				// low surrogate range. E.g. (0, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					bmp.push(start, HIGH_SURROGATE_MIN);
					loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {

				// The range starts and ends in the high surrogate range.
				// E.g. (0xD855, 0xD866).
				if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
					loneHighSurrogates.push(start, end + 1);
				}

				// The range starts in the high surrogate range and ends in the low
				// surrogate range. E.g. (0xD855, 0xDCFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
				}

				// The range starts in the high surrogate range and ends after the low
				// surrogate range. E.g. (0xD855, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
					loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {

				// The range starts and ends in the low surrogate range.
				// E.g. (0xDCFF, 0xDDFF).
				if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
					loneLowSurrogates.push(start, end + 1);
				}

				// The range starts in the low surrogate range and ends after the low
				// surrogate range. E.g. (0xDCFF, 0x10FFFF).
				if (end > LOW_SURROGATE_MAX) {
					loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
					if (end <= 0xFFFF) {
						bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
					} else {
						bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
						astral.push(0xFFFF + 1, end + 1);
					}
				}

			} else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {

				// The range starts and ends after the low surrogate range.
				// E.g. (0xFFAA, 0x10FFFF).
				if (end <= 0xFFFF) {
					bmp.push(start, end + 1);
				} else {
					bmp.push(start, 0xFFFF + 1);
					astral.push(0xFFFF + 1, end + 1);
				}

			} else {

				// The range starts and ends in the astral range.
				astral.push(start, end + 1);

			}

			index += 2;
		}
		return {
			'loneHighSurrogates': loneHighSurrogates,
			'loneLowSurrogates': loneLowSurrogates,
			'bmp': bmp,
			'astral': astral
		};
	};

	var optimizeSurrogateMappings = function(surrogateMappings) {
		var result = [];
		var tmpLow = [];
		var addLow = false;
		var mapping;
		var nextMapping;
		var highSurrogates;
		var lowSurrogates;
		var nextHighSurrogates;
		var nextLowSurrogates;
		var index = -1;
		var length = surrogateMappings.length;
		while (++index < length) {
			mapping = surrogateMappings[index];
			nextMapping = surrogateMappings[index + 1];
			if (!nextMapping) {
				result.push(mapping);
				continue;
			}
			highSurrogates = mapping[0];
			lowSurrogates = mapping[1];
			nextHighSurrogates = nextMapping[0];
			nextLowSurrogates = nextMapping[1];

			// Check for identical high surrogate ranges.
			tmpLow = lowSurrogates;
			while (
				nextHighSurrogates &&
				highSurrogates[0] == nextHighSurrogates[0] &&
				highSurrogates[1] == nextHighSurrogates[1]
			) {
				// Merge with the next item.
				if (dataIsSingleton(nextLowSurrogates)) {
					tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
				} else {
					tmpLow = dataAddRange(
						tmpLow,
						nextLowSurrogates[0],
						nextLowSurrogates[1] - 1
					);
				}
				++index;
				mapping = surrogateMappings[index];
				highSurrogates = mapping[0];
				lowSurrogates = mapping[1];
				nextMapping = surrogateMappings[index + 1];
				nextHighSurrogates = nextMapping && nextMapping[0];
				nextLowSurrogates = nextMapping && nextMapping[1];
				addLow = true;
			}
			result.push([
				highSurrogates,
				addLow ? tmpLow : lowSurrogates
			]);
			addLow = false;
		}
		return optimizeByLowSurrogates(result);
	};

	var optimizeByLowSurrogates = function(surrogateMappings) {
		if (surrogateMappings.length == 1) {
			return surrogateMappings;
		}
		var index = -1;
		var innerIndex = -1;
		while (++index < surrogateMappings.length) {
			var mapping = surrogateMappings[index];
			var lowSurrogates = mapping[1];
			var lowSurrogateStart = lowSurrogates[0];
			var lowSurrogateEnd = lowSurrogates[1];
			innerIndex = index; // Note: the loop starts at the next index.
			while (++innerIndex < surrogateMappings.length) {
				var otherMapping = surrogateMappings[innerIndex];
				var otherLowSurrogates = otherMapping[1];
				var otherLowSurrogateStart = otherLowSurrogates[0];
				var otherLowSurrogateEnd = otherLowSurrogates[1];
				if (
					lowSurrogateStart == otherLowSurrogateStart &&
					lowSurrogateEnd == otherLowSurrogateEnd
				) {
					// Add the code points in the other item to this one.
					if (dataIsSingleton(otherMapping[0])) {
						mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
					} else {
						mapping[0] = dataAddRange(
							mapping[0],
							otherMapping[0][0],
							otherMapping[0][1] - 1
						);
					}
					// Remove the other, now redundant, item.
					surrogateMappings.splice(innerIndex, 1);
					--innerIndex;
				}
			}
		}
		return surrogateMappings;
	};

	var surrogateSet = function(data) {
		// Exit early if `data` is an empty set.
		if (!data.length) {
			return [];
		}

		// Iterate over the data per `(start, end)` pair.
		var index = 0;
		var start;
		var end;
		var startHigh;
		var startLow;
		var prevStartHigh = 0;
		var prevEndHigh = 0;
		var tmpLow = [];
		var endHigh;
		var endLow;
		var surrogateMappings = [];
		var length = data.length;
		var dataHigh = [];
		while (index < length) {
			start = data[index];
			end = data[index + 1] - 1;

			startHigh = highSurrogate(start);
			startLow = lowSurrogate(start);
			endHigh = highSurrogate(end);
			endLow = lowSurrogate(end);

			var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
			var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
			var complete = false;

			// Append the previous high-surrogate-to-low-surrogate mappings.
			// Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.
			if (
				startHigh == endHigh ||
				startsWithLowestLowSurrogate && endsWithHighestLowSurrogate
			) {
				surrogateMappings.push([
					[startHigh, endHigh + 1],
					[startLow, endLow + 1]
				]);
				complete = true;
			} else {
				surrogateMappings.push([
					[startHigh, startHigh + 1],
					[startLow, LOW_SURROGATE_MAX + 1]
				]);
			}

			// Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
			// `(endHigh - 1, LOW_SURROGATE_MAX)`.
			if (!complete && startHigh + 1 < endHigh) {
				if (endsWithHighestLowSurrogate) {
					// Combine step 2 and step 3.
					surrogateMappings.push([
						[startHigh + 1, endHigh + 1],
						[LOW_SURROGATE_MIN, endLow + 1]
					]);
					complete = true;
				} else {
					surrogateMappings.push([
						[startHigh + 1, endHigh],
						[LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]
					]);
				}
			}

			// Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.
			if (!complete) {
				surrogateMappings.push([
					[endHigh, endHigh + 1],
					[LOW_SURROGATE_MIN, endLow + 1]
				]);
			}

			prevStartHigh = startHigh;
			prevEndHigh = endHigh;

			index += 2;
		}

		// The format of `surrogateMappings` is as follows:
		//
		//     [ surrogateMapping1, surrogateMapping2 ]
		//
		// i.e.:
		//
		//     [
		//       [ highSurrogates1, lowSurrogates1 ],
		//       [ highSurrogates2, lowSurrogates2 ]
		//     ]
		return optimizeSurrogateMappings(surrogateMappings);
	};

	var createSurrogateCharacterClasses = function(surrogateMappings) {
		var result = [];
		forEach(surrogateMappings, function(surrogateMapping) {
			var highSurrogates = surrogateMapping[0];
			var lowSurrogates = surrogateMapping[1];
			result.push(
				createBMPCharacterClasses(highSurrogates) +
				createBMPCharacterClasses(lowSurrogates)
			);
		});
		return result.join('|');
	};

	var createCharacterClassesFromData = function(data, bmpOnly) {
		var result = [];

		var parts = splitAtBMP(data);
		var loneHighSurrogates = parts.loneHighSurrogates;
		var loneLowSurrogates = parts.loneLowSurrogates;
		var bmp = parts.bmp;
		var astral = parts.astral;
		var hasAstral = !dataIsEmpty(parts.astral);
		var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
		var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);

		var surrogateMappings = surrogateSet(astral);

		if (bmpOnly) {
			bmp = dataAddData(bmp, loneHighSurrogates);
			hasLoneHighSurrogates = false;
			bmp = dataAddData(bmp, loneLowSurrogates);
			hasLoneLowSurrogates = false;
		}

		if (!dataIsEmpty(bmp)) {
			// The data set contains BMP code points that are not high surrogates
			// needed for astral code points in the set.
			result.push(createBMPCharacterClasses(bmp));
		}
		if (surrogateMappings.length) {
			// The data set contains astral code points; append character classes
			// based on their surrogate pairs.
			result.push(createSurrogateCharacterClasses(surrogateMappings));
		}
		// https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
		if (hasLoneHighSurrogates) {
			result.push(
				createBMPCharacterClasses(loneHighSurrogates) +
				// Make sure the high surrogates aren’t part of a surrogate pair.
				'(?![\\uDC00-\\uDFFF])'
			);
		}
		if (hasLoneLowSurrogates) {
			result.push(
				// Make sure the low surrogates aren’t part of a surrogate pair.
				'(?:[^\\uD800-\\uDBFF]|^)' +
				createBMPCharacterClasses(loneLowSurrogates)
			);
		}
		return result.join('|');
	};

	/*--------------------------------------------------------------------------*/

	// `regenerate` can be used as a constructor (and new methods can be added to
	// its prototype) but also as a regular function, the latter of which is the
	// documented and most common usage. For that reason, it’s not capitalized.
	var regenerate = function(value) {
		if (arguments.length > 1) {
			value = slice.call(arguments);
		}
		if (this instanceof regenerate) {
			this.data = [];
			return value ? this.add(value) : this;
		}
		return (new regenerate).add(value);
	};

	regenerate.version = '1.2.0';

	var proto = regenerate.prototype;
	extend(proto, {
		'add': function(value) {
			var $this = this;
			if (value == null) {
				return $this;
			}
			if (value instanceof regenerate) {
				// Allow passing other Regenerate instances.
				$this.data = dataAddData($this.data, value.data);
				return $this;
			}
			if (arguments.length > 1) {
				value = slice.call(arguments);
			}
			if (isArray(value)) {
				forEach(value, function(item) {
					$this.add(item);
				});
				return $this;
			}
			$this.data = dataAdd(
				$this.data,
				isNumber(value) ? value : symbolToCodePoint(value)
			);
			return $this;
		},
		'remove': function(value) {
			var $this = this;
			if (value == null) {
				return $this;
			}
			if (value instanceof regenerate) {
				// Allow passing other Regenerate instances.
				$this.data = dataRemoveData($this.data, value.data);
				return $this;
			}
			if (arguments.length > 1) {
				value = slice.call(arguments);
			}
			if (isArray(value)) {
				forEach(value, function(item) {
					$this.remove(item);
				});
				return $this;
			}
			$this.data = dataRemove(
				$this.data,
				isNumber(value) ? value : symbolToCodePoint(value)
			);
			return $this;
		},
		'addRange': function(start, end) {
			var $this = this;
			$this.data = dataAddRange($this.data,
				isNumber(start) ? start : symbolToCodePoint(start),
				isNumber(end) ? end : symbolToCodePoint(end)
			);
			return $this;
		},
		'removeRange': function(start, end) {
			var $this = this;
			var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
			var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
			$this.data = dataRemoveRange(
				$this.data,
				startCodePoint,
				endCodePoint
			);
			return $this;
		},
		'intersection': function(argument) {
			var $this = this;
			// Allow passing other Regenerate instances.
			// TODO: Optimize this by writing and using `dataIntersectionData()`.
			var array = argument instanceof regenerate ?
				dataToArray(argument.data) :
				argument;
			$this.data = dataIntersection($this.data, array);
			return $this;
		},
		'contains': function(codePoint) {
			return dataContains(
				this.data,
				isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint)
			);
		},
		'clone': function() {
			var set = new regenerate;
			set.data = this.data.slice(0);
			return set;
		},
		'toString': function(options) {
			var result = createCharacterClassesFromData(
				this.data,
				options ? options.bmpOnly : false
			);
			// Use `\0` instead of `\x00` where possible.
			return result.replace(regexNull, '\\0$1');
		},
		'toRegExp': function(flags) {
			return RegExp(this.toString(), flags || '');
		},
		'valueOf': function() { // Note: `valueOf` is aliased as `toArray`.
			return dataToArray(this.data);
		}
	});

	proto.toArray = proto.valueOf;

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return regenerate;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = regenerate;
		} else { // in Narwhal or RingoJS v0.7.0-
			freeExports.regenerate = regenerate;
		}
	} else { // in Rhino or a web browser
		root.regenerate = regenerate;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],283:[function(require,module,exports){
(function (global){
/*!
 * RegJSGen
 * Copyright 2014 Benjamin Tan <https://d10.github.io/>
 * Available under MIT license <http://d10.mit-license.org/>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object` */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object */
  var oldRoot = root;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */

  var stringFromCharCode = String.fromCharCode;
  var floor = Math.floor;
  function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    var result = '';
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (
        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 0x10FFFF || // not a valid Unicode code point
        floor(codePoint) != codePoint // not an integer
      ) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        // BMP code point
        codeUnits.push(codePoint);
      } else {
        // Astral code point; split in surrogate halves
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
        result += stringFromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  }

  function assertType(type, expected) {
    if (expected.indexOf('|') == -1) {
      if (type == expected) {
        return;
      }

      throw Error('Invalid node type: ' + type);
    }

    expected = assertType.hasOwnProperty(expected)
      ? assertType[expected]
      : (assertType[expected] = RegExp('^(?:' + expected + ')$'));

    if (expected.test(type)) {
      return;
    }

    throw Error('Invalid node type: ' + type);
  }

  /*--------------------------------------------------------------------------*/

  function generate(node) {
    var type = node.type;

    if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {
      return generate[type](node);
    }

    throw Error('Invalid node type: ' + type);
  }

  /*--------------------------------------------------------------------------*/

  function generateAlternative(node) {
    assertType(node.type, 'alternative');

    var terms = node.body,
        length = terms ? terms.length : 0;

    if (length == 1) {
      return generateTerm(terms[0]);
    } else {
      var i = -1,
          result = '';

      while (++i < length) {
        result += generateTerm(terms[i]);
      }

      return result;
    }
  }

  function generateAnchor(node) {
    assertType(node.type, 'anchor');

    switch (node.kind) {
      case 'start':
        return '^';
      case 'end':
        return '$';
      case 'boundary':
        return '\\b';
      case 'not-boundary':
        return '\\B';
      default:
        throw Error('Invalid assertion');
    }
  }

  function generateAtom(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');

    return generate(node);
  }

  function generateCharacterClass(node) {
    assertType(node.type, 'characterClass');

    var classRanges = node.body,
        length = classRanges ? classRanges.length : 0;

    var i = -1,
        result = '[';

    if (node.negative) {
      result += '^';
    }

    while (++i < length) {
      result += generateClassAtom(classRanges[i]);
    }

    result += ']';

    return result;
  }

  function generateCharacterClassEscape(node) {
    assertType(node.type, 'characterClassEscape');

    return '\\' + node.value;
  }

  function generateCharacterClassRange(node) {
    assertType(node.type, 'characterClassRange');

    var min = node.min,
        max = node.max;

    if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
      throw Error('Invalid character class range');
    }

    return generateClassAtom(min) + '-' + generateClassAtom(max);
  }

  function generateClassAtom(node) {
    assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');

    return generate(node);
  }

  function generateDisjunction(node) {
    assertType(node.type, 'disjunction');

    var body = node.body,
        length = body ? body.length : 0;

    if (length == 0) {
      throw Error('No body');
    } else if (length == 1) {
      return generate(body[0]);
    } else {
      var i = -1,
          result = '';

      while (++i < length) {
        if (i != 0) {
          result += '|';
        }
        result += generate(body[i]);
      }

      return result;
    }
  }

  function generateDot(node) {
    assertType(node.type, 'dot');

    return '.';
  }

  function generateGroup(node) {
    assertType(node.type, 'group');

    var result = '(';

    switch (node.behavior) {
      case 'normal':
        break;
      case 'ignore':
        result += '?:';
        break;
      case 'lookahead':
        result += '?=';
        break;
      case 'negativeLookahead':
        result += '?!';
        break;
      default:
        throw Error('Invalid behaviour: ' + node.behaviour);
    }

    var body = node.body,
        length = body ? body.length : 0;

    if (length == 1) {
      result += generate(body[0]);
    } else {
      var i = -1;

      while (++i < length) {
        result += generate(body[i]);
      }
    }

    result += ')';

    return result;
  }

  function generateQuantifier(node) {
    assertType(node.type, 'quantifier');

    var quantifier = '',
        min = node.min,
        max = node.max;

    switch (max) {
      case undefined:
      case null:
        switch (min) {
          case 0:
            quantifier = '*'
            break;
          case 1:
            quantifier = '+';
            break;
          default:
            quantifier = '{' + min + ',}';
            break;
        }
        break;
      default:
        if (min == max) {
          quantifier = '{' + min + '}';
        }
        else if (min == 0 && max == 1) {
          quantifier = '?';
        } else {
          quantifier = '{' + min + ',' + max + '}';
        }
        break;
    }

    if (!node.greedy) {
      quantifier += '?';
    }

    return generateAtom(node.body[0]) + quantifier;
  }

  function generateReference(node) {
    assertType(node.type, 'reference');

    return '\\' + node.matchIndex;
  }

  function generateTerm(node) {
    assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');

    return generate(node);
  }

  function generateValue(node) {
    assertType(node.type, 'value');

    var kind = node.kind,
        codePoint = node.codePoint;

    switch (kind) {
      case 'controlLetter':
        return '\\c' + fromCodePoint(codePoint + 64);
      case 'hexadecimalEscape':
        return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);
      case 'identifier':
        return '\\' + fromCodePoint(codePoint);
      case 'null':
        return '\\' + codePoint;
      case 'octal':
        return '\\' + codePoint.toString(8);
      case 'singleEscape':
        switch (codePoint) {
          case 0x0008:
            return '\\b';
          case 0x009:
            return '\\t';
          case 0x00A:
            return '\\n';
          case 0x00B:
            return '\\v';
          case 0x00C:
            return '\\f';
          case 0x00D:
            return '\\r';
          default:
            throw Error('Invalid codepoint: ' + codePoint);
        }
      case 'symbol':
        return fromCodePoint(codePoint);
      case 'unicodeEscape':
        return '\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);
      case 'unicodeCodePointEscape':
        return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
      default:
        throw Error('Unsupported node kind: ' + kind);
    }
  }

  /*--------------------------------------------------------------------------*/

  generate.alternative = generateAlternative;
  generate.anchor = generateAnchor;
  generate.characterClass = generateCharacterClass;
  generate.characterClassEscape = generateCharacterClassEscape;
  generate.characterClassRange = generateCharacterClassRange;
  generate.disjunction = generateDisjunction;
  generate.dot = generateDot;
  generate.group = generateGroup;
  generate.quantifier = generateQuantifier;
  generate.reference = generateReference;
  generate.value = generateValue;

  /*--------------------------------------------------------------------------*/

  // export regjsgen
  // some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // define as an anonymous module so, through path mapping, it can be aliased
    define(function() {
      return {
        'generate': generate
      };
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Narwhal, Node.js, Rhino -require, or RingoJS
    freeExports.generate = generate;
  }
  // in a browser or Rhino
  else {
    root.regjsgen = {
      'generate': generate
    };
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],284:[function(require,module,exports){
// regjsparser
//
// ==================================================================
//
// See ECMA-262 Standard: 15.10.1
//
// NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
//   term "Anchor" is used.
//
// Pattern ::
//      Disjunction
//
// Disjunction ::
//      Alternative
//      Alternative | Disjunction
//
// Alternative ::
//      [empty]
//      Alternative Term
//
// Term ::
//      Anchor
//      Atom
//      Atom Quantifier
//
// Anchor ::
//      ^
//      $
//      \ b
//      \ B
//      ( ? = Disjunction )
//      ( ? ! Disjunction )
//
// Quantifier ::
//      QuantifierPrefix
//      QuantifierPrefix ?
//
// QuantifierPrefix ::
//      *
//      +
//      ?
//      { DecimalDigits }
//      { DecimalDigits , }
//      { DecimalDigits , DecimalDigits }
//
// Atom ::
//      PatternCharacter
//      .
//      \ AtomEscape
//      CharacterClass
//      ( Disjunction )
//      ( ? : Disjunction )
//
// PatternCharacter ::
//      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
//
// AtomEscape ::
//      DecimalEscape
//      CharacterEscape
//      CharacterClassEscape
//
// CharacterEscape[U] ::
//      ControlEscape
//      c ControlLetter
//      HexEscapeSequence
//      RegExpUnicodeEscapeSequence[?U] (ES6)
//      IdentityEscape[?U]
//
// ControlEscape ::
//      one of f n r t v
// ControlLetter ::
//      one of
//          a b c d e f g h i j k l m n o p q r s t u v w x y z
//          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
//
// IdentityEscape ::
//      SourceCharacter but not IdentifierPart
//      <ZWJ>
//      <ZWNJ>
//
// DecimalEscape ::
//      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
//
// CharacterClassEscape ::
//      one of d D s S w W
//
// CharacterClass ::
//      [ [lookahead ∉ {^}] ClassRanges ]
//      [ ^ ClassRanges ]
//
// ClassRanges ::
//      [empty]
//      NonemptyClassRanges
//
// NonemptyClassRanges ::
//      ClassAtom
//      ClassAtom NonemptyClassRangesNoDash
//      ClassAtom - ClassAtom ClassRanges
//
// NonemptyClassRangesNoDash ::
//      ClassAtom
//      ClassAtomNoDash NonemptyClassRangesNoDash
//      ClassAtomNoDash - ClassAtom ClassRanges
//
// ClassAtom ::
//      -
//      ClassAtomNoDash
//
// ClassAtomNoDash ::
//      SourceCharacter but not one of \ or ] or -
//      \ ClassEscape
//
// ClassEscape ::
//      DecimalEscape
//      b
//      CharacterEscape
//      CharacterClassEscape

(function() {

  function parse(str, flags) {
    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
    var pos = 0;
    var closedCaptureCounter = 0;

    function addRaw(node) {
      node.raw = str.substring(node.range[0], node.range[1]);
      return node;
    }

    function updateRawStart(node, start) {
      node.range[0] = start;
      return addRaw(node);
    }

    function createAnchor(kind, rawLength) {
      return addRaw({
        type: 'anchor',
        kind: kind,
        range: [
          pos - rawLength,
          pos
        ]
      });
    }

    function createValue(kind, codePoint, from, to) {
      return addRaw({
        type: 'value',
        kind: kind,
        codePoint: codePoint,
        range: [from, to]
      });
    }

    function createEscaped(kind, codePoint, value, fromOffset) {
      fromOffset = fromOffset || 0;
      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
    }

    function createCharacter(matches) {
      var _char = matches[0];
      var first = _char.charCodeAt(0);
      if (hasUnicodeFlag) {
        var second;
        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
          second = lookahead().charCodeAt(0);
          if (second >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            pos++;
            return createValue(
                'symbol',
                (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,
                pos - 2, pos);
          }
        }
      }
      return createValue('symbol', first, pos - 1, pos);
    }

    function createDisjunction(alternatives, from, to) {
      return addRaw({
        type: 'disjunction',
        body: alternatives,
        range: [
          from,
          to
        ]
      });
    }

    function createDot() {
      return addRaw({
        type: 'dot',
        range: [
          pos - 1,
          pos
        ]
      });
    }

    function createCharacterClassEscape(value) {
      return addRaw({
        type: 'characterClassEscape',
        value: value,
        range: [
          pos - 2,
          pos
        ]
      });
    }

    function createReference(matchIndex) {
      return addRaw({
        type: 'reference',
        matchIndex: parseInt(matchIndex, 10),
        range: [
          pos - 1 - matchIndex.length,
          pos
        ]
      });
    }

    function createGroup(behavior, disjunction, from, to) {
      return addRaw({
        type: 'group',
        behavior: behavior,
        body: disjunction,
        range: [
          from,
          to
        ]
      });
    }

    function createQuantifier(min, max, from, to) {
      if (to == null) {
        from = pos - 1;
        to = pos;
      }

      return addRaw({
        type: 'quantifier',
        min: min,
        max: max,
        greedy: true,
        body: null, // set later on,
        range: [
          from,
          to
        ]
      });
    }

    function createAlternative(terms, from, to) {
      return addRaw({
        type: 'alternative',
        body: terms,
        range: [
          from,
          to
        ]
      });
    }

    function createCharacterClass(classRanges, negative, from, to) {
      return addRaw({
        type: 'characterClass',
        body: classRanges,
        negative: negative,
        range: [
          from,
          to
        ]
      });
    }

    function createClassRange(min, max, from, to) {
      // See 15.10.2.15:
      if (min.codePoint > max.codePoint) {
        throw SyntaxError('invalid range in character class');
      }

      return addRaw({
        type: 'characterClassRange',
        min: min,
        max: max,
        range: [
          from,
          to
        ]
      });
    }

    function flattenBody(body) {
      if (body.type === 'alternative') {
        return body.body;
      } else {
        return [body];
      }
    }

    function isEmpty(obj) {
      return obj.type === 'empty';
    }

    function incr(amount) {
      amount = (amount || 1);
      var res = str.substring(pos, pos + amount);
      pos += (amount || 1);
      return res;
    }

    function skip(value) {
      if (!match(value)) {
        throw SyntaxError('character: ' + value);
      }
    }

    function match(value) {
      if (str.indexOf(value, pos) === pos) {
        return incr(value.length);
      }
    }

    function lookahead() {
      return str[pos];
    }

    function current(value) {
      return str.indexOf(value, pos) === pos;
    }

    function next(value) {
      return str[pos + 1] === value;
    }

    function matchReg(regExp) {
      var subStr = str.substring(pos);
      var res = subStr.match(regExp);
      if (res) {
        res.range = [];
        res.range[0] = pos;
        incr(res[0].length);
        res.range[1] = pos;
      }
      return res;
    }

    function parseDisjunction() {
      // Disjunction ::
      //      Alternative
      //      Alternative | Disjunction
      var res = [], from = pos;
      res.push(parseAlternative());

      while (match('|')) {
        res.push(parseAlternative());
      }

      if (res.length === 1) {
        return res[0];
      }

      return createDisjunction(res, from, pos);
    }

    function parseAlternative() {
      var res = [], from = pos;
      var term;

      // Alternative ::
      //      [empty]
      //      Alternative Term
      while (term = parseTerm()) {
        res.push(term);
      }

      if (res.length === 1) {
        return res[0];
      }

      return createAlternative(res, from, pos);
    }

    function parseTerm() {
      // Term ::
      //      Anchor
      //      Atom
      //      Atom Quantifier

      if (pos >= str.length || current('|') || current(')')) {
        return null; /* Means: The term is empty */
      }

      var anchor = parseAnchor();

      if (anchor) {
        return anchor;
      }

      var atom = parseAtom();
      if (!atom) {
        throw SyntaxError('Expected atom')
      }
      var quantifier = parseQuantifier() || false;
      if (quantifier) {
        quantifier.body = flattenBody(atom);
        // The quantifier contains the atom. Therefore, the beginning of the
        // quantifier range is given by the beginning of the atom.
        updateRawStart(quantifier, atom.range[0]);
        return quantifier;
      }
      return atom;
    }

    function parseGroup(matchA, typeA, matchB, typeB) {
      var type = null, from = pos;

      if (match(matchA)) {
        type = typeA;
      } else if (match(matchB)) {
        type = typeB;
      } else {
        return false;
      }

      var body = parseDisjunction();
      if (!body) {
        throw SyntaxError('Expected disjunction');
      }
      skip(')');
      var group = createGroup(type, flattenBody(body), from, pos);

      if (type == 'normal') {
        // Keep track of the number of closed groups. This is required for
        // parseDecimalEscape().
        closedCaptureCounter++;
      }
      return group;
    }

    function parseAnchor() {
      // Anchor ::
      //      ^
      //      $
      //      \ b
      //      \ B
      //      ( ? = Disjunction )
      //      ( ? ! Disjunction )
      var res, from = pos;

      if (match('^')) {
        return createAnchor('start', 1 /* rawLength */);
      } else if (match('$')) {
        return createAnchor('end', 1 /* rawLength */);
      } else if (match('\\b')) {
        return createAnchor('boundary', 2 /* rawLength */);
      } else if (match('\\B')) {
        return createAnchor('not-boundary', 2 /* rawLength */);
      } else {
        return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
      }
    }

    function parseQuantifier() {
      // Quantifier ::
      //      QuantifierPrefix
      //      QuantifierPrefix ?
      //
      // QuantifierPrefix ::
      //      *
      //      +
      //      ?
      //      { DecimalDigits }
      //      { DecimalDigits , }
      //      { DecimalDigits , DecimalDigits }

      var res;
      var quantifier;
      var min, max;

      if (match('*')) {
        quantifier = createQuantifier(0);
      }
      else if (match('+')) {
        quantifier = createQuantifier(1);
      }
      else if (match('?')) {
        quantifier = createQuantifier(0, 1);
      }
      else if (res = matchReg(/^\{([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
      }
      else if (res = matchReg(/^\{([0-9]+),\}/)) {
        min = parseInt(res[1], 10);
        quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
      }
      else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
        min = parseInt(res[1], 10);
        max = parseInt(res[2], 10);
        if (min > max) {
          throw SyntaxError('numbers out of order in {} quantifier');
        }
        quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
      }

      if (quantifier) {
        if (match('?')) {
          quantifier.greedy = false;
          quantifier.range[1] += 1;
        }
      }

      return quantifier;
    }

    function parseAtom() {
      // Atom ::
      //      PatternCharacter
      //      .
      //      \ AtomEscape
      //      CharacterClass
      //      ( Disjunction )
      //      ( ? : Disjunction )

      var res;

      // jviereck: allow ']', '}' here as well to be compatible with browser's
      //   implementations: ']'.match(/]/);
      // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
      if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
        //      PatternCharacter
        return createCharacter(res);
      }
      else if (match('.')) {
        //      .
        return createDot();
      }
      else if (match('\\')) {
        //      \ AtomEscape
        res = parseAtomEscape();
        if (!res) {
          throw SyntaxError('atomEscape');
        }
        return res;
      }
      else if (res = parseCharacterClass()) {
        return res;
      }
      else {
        //      ( Disjunction )
        //      ( ? : Disjunction )
        return parseGroup('(?:', 'ignore', '(', 'normal');
      }
    }

    function parseUnicodeSurrogatePairEscape(firstEscape) {
      if (hasUnicodeFlag) {
        var first, second;
        if (firstEscape.kind == 'unicodeEscape' &&
          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&
          current('\\') && next('u') ) {
          var prevPos = pos;
          pos++;
          var secondEscape = parseClassEscape();
          if (secondEscape.kind == 'unicodeEscape' &&
            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
            // Unicode surrogate pair
            firstEscape.range[1] = secondEscape.range[1];
            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            firstEscape.type = 'value';
            firstEscape.kind = 'unicodeCodePointEscape';
            addRaw(firstEscape);
          }
          else {
            pos = prevPos;
          }
        }
      }
      return firstEscape;
    }

    function parseClassEscape() {
      return parseAtomEscape(true);
    }

    function parseAtomEscape(insideCharacterClass) {
      // AtomEscape ::
      //      DecimalEscape
      //      CharacterEscape
      //      CharacterClassEscape

      var res;

      res = parseDecimalEscape();
      if (res) {
        return res;
      }

      // For ClassEscape
      if (insideCharacterClass) {
        if (match('b')) {
          // 15.10.2.19
          // The production ClassEscape :: b evaluates by returning the
          // CharSet containing the one character <BS> (Unicode value 0008).
          return createEscaped('singleEscape', 0x0008, '\\b');
        } else if (match('B')) {
          throw SyntaxError('\\B not possible inside of CharacterClass');
        }
      }

      res = parseCharacterEscape();

      return res;
    }


    function parseDecimalEscape() {
      // DecimalEscape ::
      //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
      //      CharacterClassEscape :: one of d D s S w W

      var res, match;

      if (res = matchReg(/^(?!0)\d+/)) {
        match = res[0];
        var refIdx = parseInt(res[0], 10);
        if (refIdx <= closedCaptureCounter) {
          // If the number is smaller than the normal-groups found so
          // far, then it is a reference...
          return createReference(res[0]);
        } else {
          // ... otherwise it needs to be interpreted as a octal (if the
          // number is in an octal format). If it is NOT octal format,
          // then the slash is ignored and the number is matched later
          // as normal characters.

          // Reset the position again, as maybe only parts of the previous
          // matched numbers are actual octal numbers. E.g. in '019' only
          // the '01' should be matched.
          incr(-res[0].length);
          if (res = matchReg(/^[0-7]{1,3}/)) {
            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
          } else {
            // If we end up here, we have a case like /\91/. Then the
            // first slash is to be ignored and the 9 & 1 to be treated
            // like ordinary characters. Create a character for the
            // first number only here - other number-characters
            // (if available) will be matched later.
            res = createCharacter(matchReg(/^[89]/));
            return updateRawStart(res, res.range[0] - 1);
          }
        }
      }
      // Only allow octal numbers in the following. All matched numbers start
      // with a zero (if the do not, the previous if-branch is executed).
      // If the number is not octal format and starts with zero (e.g. `091`)
      // then only the zeros `0` is treated here and the `91` are ordinary
      // characters.
      // Example:
      //   /\091/.exec('\091')[0].length === 3
      else if (res = matchReg(/^[0-7]{1,3}/)) {
        match = res[0];
        if (/^0{1,3}$/.test(match)) {
          // If they are all zeros, then only take the first one.
          return createEscaped('null', 0x0000, '0', match.length + 1);
        } else {
          return createEscaped('octal', parseInt(match, 8), match, 1);
        }
      } else if (res = matchReg(/^[dDsSwW]/)) {
        return createCharacterClassEscape(res[0]);
      }
      return false;
    }

    function parseCharacterEscape() {
      // CharacterEscape ::
      //      ControlEscape
      //      c ControlLetter
      //      HexEscapeSequence
      //      UnicodeEscapeSequence
      //      IdentityEscape

      var res;
      if (res = matchReg(/^[fnrtv]/)) {
        // ControlEscape
        var codePoint = 0;
        switch (res[0]) {
          case 't': codePoint = 0x009; break;
          case 'n': codePoint = 0x00A; break;
          case 'v': codePoint = 0x00B; break;
          case 'f': codePoint = 0x00C; break;
          case 'r': codePoint = 0x00D; break;
        }
        return createEscaped('singleEscape', codePoint, '\\' + res[0]);
      } else if (res = matchReg(/^c([a-zA-Z])/)) {
        // c ControlLetter
        return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
      } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
        // HexEscapeSequence
        return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
      } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
        // UnicodeEscapeSequence
        return parseUnicodeSurrogatePairEscape(
          createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2)
        );
      } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]{1,})\}/))) {
        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
      } else {
        // IdentityEscape
        return parseIdentityEscape();
      }
    }

    // Taken from the Esprima parser.
    function isIdentifierPart(ch) {
      // Generated by `tools/generate-identifier-regex.js`.
      var NonAsciiIdentifierPart = new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]');

      return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
        (ch >= 65 && ch <= 90) ||         // A..Z
        (ch >= 97 && ch <= 122) ||        // a..z
        (ch >= 48 && ch <= 57) ||         // 0..9
        (ch === 92) ||                    // \ (backslash)
        ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    function parseIdentityEscape() {
      // IdentityEscape ::
      //      SourceCharacter but not IdentifierPart
      //      <ZWJ>
      //      <ZWNJ>

      var ZWJ = '\u200C';
      var ZWNJ = '\u200D';

      var res;
      var tmp;

      if (!isIdentifierPart(lookahead())) {
        tmp = incr();
        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
      }

      if (match(ZWJ)) {
        // <ZWJ>
        return createEscaped('identifier', 0x200C, ZWJ);
      } else if (match(ZWNJ)) {
        // <ZWNJ>
        return createEscaped('identifier', 0x200D, ZWNJ);
      }

      return null;
    }

    function parseCharacterClass() {
      // CharacterClass ::
      //      [ [lookahead ∉ {^}] ClassRanges ]
      //      [ ^ ClassRanges ]

      var res, from = pos;
      if (res = matchReg(/^\[\^/)) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, true, from, pos);
      } else if (match('[')) {
        res = parseClassRanges();
        skip(']');
        return createCharacterClass(res, false, from, pos);
      }

      return null;
    }

    function parseClassRanges() {
      // ClassRanges ::
      //      [empty]
      //      NonemptyClassRanges

      var res;
      if (current(']')) {
        // Empty array means nothing insinde of the ClassRange.
        return [];
      } else {
        res = parseNonemptyClassRanges();
        if (!res) {
          throw SyntaxError('nonEmptyClassRanges');
        }
        return res;
      }
    }

    function parseHelperClassRanges(atom) {
      var from, to, res;
      if (current('-') && !next(']')) {
        // ClassAtom - ClassAtom ClassRanges
        skip('-');

        res = parseClassAtom();
        if (!res) {
          throw SyntaxError('classAtom');
        }
        to = pos;
        var classRanges = parseClassRanges();
        if (!classRanges) {
          throw SyntaxError('classRanges');
        }
        from = atom.range[0];
        if (classRanges.type === 'empty') {
          return [createClassRange(atom, res, from, to)];
        }
        return [createClassRange(atom, res, from, to)].concat(classRanges);
      }

      res = parseNonemptyClassRangesNoDash();
      if (!res) {
        throw SyntaxError('nonEmptyClassRangesNoDash');
      }

      return [atom].concat(res);
    }

    function parseNonemptyClassRanges() {
      // NonemptyClassRanges ::
      //      ClassAtom
      //      ClassAtom NonemptyClassRangesNoDash
      //      ClassAtom - ClassAtom ClassRanges

      var atom = parseClassAtom();
      if (!atom) {
        throw SyntaxError('classAtom');
      }

      if (current(']')) {
        // ClassAtom
        return [atom];
      }

      // ClassAtom NonemptyClassRangesNoDash
      // ClassAtom - ClassAtom ClassRanges
      return parseHelperClassRanges(atom);
    }

    function parseNonemptyClassRangesNoDash() {
      // NonemptyClassRangesNoDash ::
      //      ClassAtom
      //      ClassAtomNoDash NonemptyClassRangesNoDash
      //      ClassAtomNoDash - ClassAtom ClassRanges

      var res = parseClassAtom();
      if (!res) {
        throw SyntaxError('classAtom');
      }
      if (current(']')) {
        //      ClassAtom
        return res;
      }

      // ClassAtomNoDash NonemptyClassRangesNoDash
      // ClassAtomNoDash - ClassAtom ClassRanges
      return parseHelperClassRanges(res);
    }

    function parseClassAtom() {
      // ClassAtom ::
      //      -
      //      ClassAtomNoDash
      if (match('-')) {
        return createCharacter('-');
      } else {
        return parseClassAtomNoDash();
      }
    }

    function parseClassAtomNoDash() {
      // ClassAtomNoDash ::
      //      SourceCharacter but not one of \ or ] or -
      //      \ ClassEscape

      var res;
      if (res = matchReg(/^[^\\\]-]/)) {
        return createCharacter(res[0]);
      } else if (match('\\')) {
        res = parseClassEscape();
        if (!res) {
          throw SyntaxError('classEscape');
        }

        return parseUnicodeSurrogatePairEscape(res);
      }
    }

    // Convert the input to a string and treat the empty string special.
    str = String(str);
    if (str === '') {
      str = '(?:)';
    }

    var result = parseDisjunction();

    if (result.range[1] !== str.length) {
      throw SyntaxError('Could not parse entire input - got stuck: ' + str);
    }

    return result;
  };

  var regjsparser = {
    parse: parse
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = regjsparser;
  } else {
    window.regjsparser = regjsparser;
  }

}());

},{}],285:[function(require,module,exports){
var generate = require('regjsgen').generate;
var parse = require('regjsparser').parse;
var regenerate = require('regenerate');
var iuMappings = require('./data/iu-mappings.json');
var ESCAPE_SETS = require('./data/character-class-escape-sets.js');

function getCharacterClassEscapeSet(character) {
	if (unicode) {
		if (ignoreCase) {
			return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];
		}
		return ESCAPE_SETS.UNICODE[character];
	}
	return ESCAPE_SETS.REGULAR[character];
}

var object = {};
var hasOwnProperty = object.hasOwnProperty;
function has(object, property) {
	return hasOwnProperty.call(object, property);
}

// Prepare a Regenerate set containing all code points, used for negative
// character classes (if any).
var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
// Without the `u` flag, the range stops at 0xFFFF.
// https://mths.be/es6#sec-pattern-semantics
var BMP_SET = regenerate().addRange(0x0, 0xFFFF);

// Prepare a Regenerate set containing all code points that are supposed to be
// matched by `/./u`. https://mths.be/es6#sec-atom
var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
	.remove(
		// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
		0x000A, // Line Feed <LF>
		0x000D, // Carriage Return <CR>
		0x2028, // Line Separator <LS>
		0x2029  // Paragraph Separator <PS>
	);
// Prepare a Regenerate set containing all code points that are supposed to be
// matched by `/./` (only BMP code points).
var DOT_SET = DOT_SET_UNICODE.clone()
	.intersection(BMP_SET);

// Add a range of code points + any case-folded code points in that range to a
// set.
regenerate.prototype.iuAddRange = function(min, max) {
	var $this = this;
	do {
		var folded = caseFold(min);
		if (folded) {
			$this.add(folded);
		}
	} while (++min <= max);
	return $this;
};

function assign(target, source) {
	for (var key in source) {
		// Note: `hasOwnProperty` is not needed here.
		target[key] = source[key];
	}
}

function update(item, pattern) {
	// TODO: Test if memoizing `pattern` here is worth the effort.
	if (!pattern) {
		return;
	}
	var tree = parse(pattern, '');
	switch (tree.type) {
		case 'characterClass':
		case 'group':
		case 'value':
			// No wrapping needed.
			break;
		default:
			// Wrap the pattern in a non-capturing group.
			tree = wrap(tree, pattern);
	}
	assign(item, tree);
}

function wrap(tree, pattern) {
	// Wrap the pattern in a non-capturing group.
	return {
		'type': 'group',
		'behavior': 'ignore',
		'body': [tree],
		'raw': '(?:' + pattern + ')'
	};
}

function caseFold(codePoint) {
	return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;
}

var ignoreCase = false;
var unicode = false;
function processCharacterClass(characterClassItem) {
	var set = regenerate();
	var body = characterClassItem.body.forEach(function(item) {
		switch (item.type) {
			case 'value':
				set.add(item.codePoint);
				if (ignoreCase && unicode) {
					var folded = caseFold(item.codePoint);
					if (folded) {
						set.add(folded);
					}
				}
				break;
			case 'characterClassRange':
				var min = item.min.codePoint;
				var max = item.max.codePoint;
				set.addRange(min, max);
				if (ignoreCase && unicode) {
					set.iuAddRange(min, max);
				}
				break;
			case 'characterClassEscape':
				set.add(getCharacterClassEscapeSet(item.value));
				break;
			// The `default` clause is only here as a safeguard; it should never be
			// reached. Code coverage tools should ignore it.
			/* istanbul ignore next */
			default:
				throw Error('Unknown term type: ' + item.type);
		}
	});
	if (characterClassItem.negative) {
		set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);
	}
	update(characterClassItem, set.toString());
	return characterClassItem;
}

function processTerm(item) {
	switch (item.type) {
		case 'dot':
			update(
				item,
				(unicode ? DOT_SET_UNICODE : DOT_SET).toString()
			);
			break;
		case 'characterClass':
			item = processCharacterClass(item);
			break;
		case 'characterClassEscape':
			update(
				item,
				getCharacterClassEscapeSet(item.value).toString()
			);
			break;
		case 'alternative':
		case 'disjunction':
		case 'group':
		case 'quantifier':
			item.body = item.body.map(processTerm);
			break;
		case 'value':
			var codePoint = item.codePoint;
			var set = regenerate(codePoint);
			if (ignoreCase && unicode) {
				var folded = caseFold(codePoint);
				if (folded) {
					set.add(folded);
				}
			}
			update(item, set.toString());
			break;
		case 'anchor':
		case 'empty':
		case 'group':
		case 'reference':
			// Nothing to do here.
			break;
		// The `default` clause is only here as a safeguard; it should never be
		// reached. Code coverage tools should ignore it.
		/* istanbul ignore next */
		default:
			throw Error('Unknown term type: ' + item.type);
	}
	return item;
};

module.exports = function(pattern, flags) {
	var tree = parse(pattern, flags);
	ignoreCase = flags ? flags.indexOf('i') > -1 : false;
	unicode = flags ? flags.indexOf('u') > -1 : false;
	assign(tree, processTerm(tree));
	return generate(tree);
};

},{"./data/character-class-escape-sets.js":280,"./data/iu-mappings.json":281,"regenerate":282,"regjsgen":283,"regjsparser":284}],286:[function(require,module,exports){
'use strict';
var isFinite = require('is-finite');

module.exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string as the first argument');
	}

	if (n < 0 || !isFinite(n)) {
		throw new TypeError('Expected a finite positive number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while (n = n >> 1);

	return ret;
};

},{"is-finite":287}],287:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],288:[function(require,module,exports){
'use strict';
module.exports = /^#!.*/;

},{}],289:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	var isExtendedLengthPath = /^\\\\\?\\/.test(str);
	var hasNonAscii = /[^\x00-\x80]+/.test(str);

	if (isExtendedLengthPath || hasNonAscii) {
		return str;
	}

	return str.replace(/\\/g, '/');
};

},{}],290:[function(require,module,exports){
(function (Buffer){
'use strict';
module.exports = function (val) {
	var base64 = new Buffer(JSON.stringify(val)).toString('base64');
	return '//# sourceMappingURL=data:application/json;base64,' + base64;
};

}).call(this,require("buffer").Buffer)

},{"buffer":307}],291:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":297,"./source-map/source-map-generator":298,"./source-map/source-node":299}],292:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":300,"amdefine":301}],293:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":294,"amdefine":301}],294:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":301}],295:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":301}],296:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":300,"amdefine":301}],297:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":292,"./base64-vlq":293,"./binary-search":295,"./util":300,"amdefine":301}],298:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":292,"./base64-vlq":293,"./mapping-list":296,"./util":300,"amdefine":301}],299:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":298,"./util":300,"amdefine":301}],300:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":301}],301:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/babel/node_modules/source-map/node_modules/amdefine/amdefine.js")

},{"_process":315,"path":314}],302:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return str.replace(/[\s\uFEFF\xA0]+$/g, '');
};

},{}],303:[function(require,module,exports){
module.exports={
  "name": "babel",
  "description": "Turn ES6 code into readable vanilla ES5 with source maps",
  "version": "4.3.0",
  "author": {
    "name": "Sebastian McKenzie",
    "email": "sebmck@gmail.com"
  },
  "homepage": "https://babeljs.io/",
  "repository": {
    "type": "git",
    "url": "https://github.com/babel/babel"
  },
  "preferGlobal": true,
  "main": "lib/babel/api/node.js",
  "browser": {
    "./lib/babel/api/register/node.js": "./lib/babel/api/register/browser.js"
  },
  "bin": {
    "6to5": "./bin/deprecated/6to5",
    "6to5-minify": "./bin/deprecated/6to5-minify",
    "6to5-node": "./bin/deprecated/6to5-node",
    "6to5-runtime": "./bin/deprecated/6to5-runtime",
    "babel": "./bin/babel/index.js",
    "babel-minify": "./bin/babel-minify",
    "babel-node": "./bin/babel-node",
    "babel-external-helpers": "./bin/babel-external-helpers"
  },
  "keywords": [
    "harmony",
    "classes",
    "modules",
    "let",
    "const",
    "var",
    "es6",
    "transpile",
    "transpiler",
    "6to5",
    "babel"
  ],
  "scripts": {
    "bench": "make bench",
    "test": "make test"
  },
  "dependencies": {
    "acorn-babel": "0.11.1-33",
    "ast-types": "~0.6.1",
    "chalk": "^0.5.1",
    "chokidar": "^0.12.6",
    "commander": "^2.6.0",
    "core-js": "^0.5.4",
    "debug": "^2.1.1",
    "detect-indent": "^3.0.0",
    "estraverse": "^1.9.1",
    "esutils": "^1.1.6",
    "fs-readdir-recursive": "^0.1.0",
    "globals": "^6.2.0",
    "is-integer": "^1.0.4",
    "js-tokenizer": "^1.3.3",
    "leven": "^1.0.1",
    "lodash": "^3.2.0",
    "output-file-sync": "^1.1.0",
    "path-is-absolute": "^1.0.0",
    "private": "^0.1.6",
    "regenerator-babel": "0.8.10-2",
    "regexpu": "^1.1.1",
    "repeating": "^1.1.2",
    "shebang-regex": "^1.0.0",
    "slash": "^1.0.0",
    "source-map": "^0.1.43",
    "source-map-support": "^0.2.9",
    "source-map-to-comment": "^1.0.0",
    "trim-right": "^1.0.0"
  },
  "devDependencies": {
    "browserify": "^8.1.3",
    "chai": "^2.0.0",
    "esvalid": "^1.1.0",
    "istanbul": "^0.3.5",
    "jscs": "^1.11.3",
    "jshint": "^2.6.0",
    "jshint-stylish": "^1.0.0",
    "matcha": "^0.6.0",
    "mocha": "^2.1.0",
    "rimraf": "^2.2.8",
    "uglify-js": "^2.4.16"
  },
  "gitHead": "bb19649af8612a662a11aaeb361a2bc1c7a284fa",
  "bugs": {
    "url": "https://github.com/babel/babel/issues"
  },
  "_id": "babel@4.3.0",
  "_shasum": "6eecac2b24cf2a0308df74fcffbff00939530c06",
  "_from": "babel@>=4.3.0 <5.0.0",
  "_npmVersion": "2.1.18",
  "_nodeVersion": "1.0.2",
  "_npmUser": {
    "name": "sebmck",
    "email": "sebmck@gmail.com"
  },
  "maintainers": [
    {
      "name": "sebmck",
      "email": "sebmck@gmail.com"
    }
  ],
  "dist": {
    "shasum": "6eecac2b24cf2a0308df74fcffbff00939530c06",
    "tarball": "http://registry.npmjs.org/babel/-/babel-4.3.0.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/babel/-/babel-4.3.0.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],304:[function(require,module,exports){
module.exports={"abstract-expression-call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceGet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-delete":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceDelete","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-get":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceGet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"abstract-expression-set":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"PROPERTY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"referenceSet","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"apply-constructor":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"create","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"object","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"||","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-comprehension-container":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ArrayExpression","start":null,"end":null,"loc":null,"range":null,"elements":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-from":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"array-push":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"push","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STATEMENT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"async-to-generator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"fn","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"gen","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"fn","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Promise","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"reject","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"next","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callThrow","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"throw","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"FunctionDeclaration","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arg","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"TryStatement","start":null,"end":null,"loc":null,"range":null,"block":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"gen","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arg","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"handler":{"type":"CatchClause","start":null,"end":null,"loc":null,"range":null,"param":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"error","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"guard":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"reject","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"error","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"guardedHandlers":[],"finalizer":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"info","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Promise","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"resolve","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"then","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callThrow","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"callNext","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"bind":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Function","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"bind","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CONTEXT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-call-check":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instance","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"instanceof","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Cannot call a class as a function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-super-constructor-call-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"class-super-constructor-call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SUPER_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"corejs-is-iterator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CORE_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"$for","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isIterable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"corejs-iterator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CORE_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"$for","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getIterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"default-parameter":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VARIABLE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENT_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"DEFAULT_VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENT_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"let","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"defaults":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyNames","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defaults","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"define-property":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"enumerable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-assign":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-default-assign":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"module","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VALUE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-module-declaration-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"exports-module-declaration":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"__esModule","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"extends":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"assign","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"||","right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":1,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForInStatement","start":null,"end":null,"loc":null,"range":null,"left":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"source","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"key","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"for-of-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":null,"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"IS_ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":">=","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LOOP_OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"INDEX","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"for-of":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ITERATOR_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"OBJECT","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STEP_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"STEP_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ITERATOR_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"get":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getPrototypeOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"value","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"in","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"get","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"has-own":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"inherits":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Super expression must either be null or a function, not ","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"+","right":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"create","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"enumerable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":false,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"configurable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"subClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__proto__","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"superClass","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"interop-require-wildcard":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"default","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"interop-require":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"default","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"let-scoping-return":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"RETURN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"object","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"RETURN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"v","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"named-func":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"FunctionDeclaration","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"GET_OUTER_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"object-destructuring-empty":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Cannot destructure undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"object-without-properties":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForInStatement","start":null,"end":null,"loc":null,"range":null,"left":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"keys","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"indexOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":">=","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ContinueStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"hasOwnProperty","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ContinueStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"target","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property-method-assignment-wrapper-generator":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":true,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"YieldExpression","start":null,"end":null,"loc":null,"range":null,"delegate":true,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property-method-assignment-wrapper":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arguments","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"toString","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"WRAPPER_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"prototype-identifier":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"CLASS_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"prototype-properties":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"staticProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"child","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"instanceProps","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"require-assign-key":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"VARIABLE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"require","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"require":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"require","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"rest":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY_LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"START","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"LEN","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARRAY_KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"KEY","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"self-contained-helpers-head":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"helpers","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"default","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"__esModule","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"self-global":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"global","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"self","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"global","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"set":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getOwnPropertyDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"getPrototypeOf","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":null,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"parent","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"property","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"value","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"operator":"in","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"writable","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"desc","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"set","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undefined","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setter","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"call","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"receiver","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"slice":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"slice","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"sliced-to-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"in","right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"ArrayExpression","start":null,"end":null,"loc":null,"range":null,"elements":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_iterator","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"next","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"done","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"push","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_step","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BreakStatement","start":null,"end":null,"loc":null,"range":null,"label":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"TypeError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"Invalid attempt to destructure non-iterable instance","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"system":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"System","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"register","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_NAME","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"MODULE_DEPENDENCIES","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"EXPORT_IDENTIFIER","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"setters","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"SETTERS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"execute","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"EXECUTE","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tagged-template-literal-loose":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tagged-template-literal":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"freeze","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"defineProperties","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"strings","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[{"type":"Property","start":null,"end":null,"loc":null,"range":null,"method":false,"shorthand":false,"computed":false,"key":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"value","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"value":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Object","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"freeze","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"raw","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"kind":"init","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tail-call-body":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"LabeledStatement","start":null,"end":null,"loc":null,"range":null,"body":{"type":"WhileStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"body":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"BLOCK","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"label":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"FUNCTION_ID","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"tail-call":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"FunctionDeclaration","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Tail","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"ThisExpression","start":null,"end":null,"loc":null,"range":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Tail","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"prototype","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_isTailDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isRunning","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":false,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Tail","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"!","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isRunning","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isRunning","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"DoWhileStatement","start":null,"end":null,"loc":null,"range":null,"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"func","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"apply","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"context","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"args","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"instanceof","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Tail","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"||","right":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"_isTailDescriptor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isRunning","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":false,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"result","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"arguments":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"temporal-assert-defined":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"val","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"name","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undef","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"val","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"undef","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ThrowStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"NewExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"ReferenceError","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"name","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"+","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":" is not defined - temporal dead zone","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":true,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"temporal-undefined":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"ObjectExpression","start":null,"end":null,"loc":null,"range":null,"properties":[],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test-exports":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"exports","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test-module":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"module","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"!==","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"undefined","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"to-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"alternate":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"to-consumable-array":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"isArray","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ForStatement","start":null,"end":null,"loc":null,"range":null,"init":{"type":"VariableDeclaration","start":null,"end":null,"loc":null,"range":null,"declarations":[{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":0,"raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"VariableDeclarator","start":null,"end":null,"loc":null,"range":null,"id":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"init":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"kind":"var","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"test":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"<","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"length","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"update":{"type":"UpdateExpression","start":null,"end":null,"loc":null,"range":null,"operator":"++","prefix":false,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"body":{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"AssignmentExpression","start":null,"end":null,"loc":null,"range":null,"operator":"=","left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"i","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":true,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr2","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Array","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"from","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"arr","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"typeof":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ReturnStatement","start":null,"end":null,"loc":null,"range":null,"argument":{"type":"ConditionalExpression","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"constructor","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"Symbol","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"symbol","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"alternate":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"obj","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"umd-runner-body":{"type":"Program","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"FunctionExpression","start":null,"end":null,"loc":null,"range":null,"id":null,"generator":false,"expression":false,"params":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"body":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"LogicalExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"BinaryExpression","start":null,"end":null,"loc":null,"range":null,"left":{"type":"UnaryExpression","start":null,"end":null,"loc":null,"range":null,"operator":"typeof","prefix":true,"argument":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"===","right":{"type":"Literal","start":null,"end":null,"loc":null,"range":null,"value":"function","raw":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"operator":"&&","right":{"type":"MemberExpression","start":null,"end":null,"loc":null,"range":null,"object":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"property":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"amd","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"computed":false,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"define","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"AMD_ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":{"type":"IfStatement","start":null,"end":null,"loc":null,"range":null,"test":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"COMMON_TEST","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"consequent":{"type":"BlockStatement","start":null,"end":null,"loc":null,"range":null,"body":[{"type":"ExpressionStatement","start":null,"end":null,"loc":null,"range":null,"expression":{"type":"CallExpression","start":null,"end":null,"loc":null,"range":null,"callee":{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"factory","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"arguments":[{"type":"Identifier","start":null,"end":null,"loc":null,"range":null,"name":"COMMON_ARGUMENTS","_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"alternate":null,"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_scopeInfo":null,"_declarations":null,"extendedRange":null,"tokens":null,"raw":null},"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}],"_declarations":null,"extendedRange":null,"_scopeInfo":null,"tokens":null,"raw":null}}
},{}],305:[function(require,module,exports){

},{}],306:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":331}],307:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  if (length < 0)
    length = 0
  else
    length >>>= 0 // Coerce to uint32.

  var self = this
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    /*eslint-disable consistent-this */
    self = Buffer._augment(new Uint8Array(length))
    /*eslint-enable consistent-this */
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        self[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        self[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize)
    self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding, noZero) {
  if (!(this instanceof SlowBuffer))
    return new SlowBuffer(subject, encoding, noZero)

  var buf = new Buffer(subject, encoding, noZero)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length)
    throw new RangeError('attempt to write outside buffer bounds')

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length)
    newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul

  return val
}

Buffer.prototype.readUIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100))
    val += this[offset + --byteLength] * mul

  return val
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100))
    val += this[offset + --i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var self = this // source

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || self.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0)
    throw new RangeError('targetStart out of bounds')
  if (start < 0 || start >= self.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":308,"ieee754":309,"is-array":310}],308:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],309:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],310:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],311:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],312:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],313:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],314:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":315}],315:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],316:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":317}],317:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":319,"./_stream_writable":321,"_process":315,"core-util-is":322,"inherits":312}],318:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":320,"core-util-is":322,"inherits":312}],319:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"_process":315,"buffer":307,"core-util-is":322,"events":311,"inherits":312,"isarray":313,"stream":327,"string_decoder/":328}],320:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":317,"core-util-is":322,"inherits":312}],321:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":317,"_process":315,"buffer":307,"core-util-is":322,"inherits":312,"stream":327}],322:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":307}],323:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":318}],324:[function(require,module,exports){
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":317,"./lib/_stream_passthrough.js":318,"./lib/_stream_readable.js":319,"./lib/_stream_transform.js":320,"./lib/_stream_writable.js":321,"stream":327}],325:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":320}],326:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":321}],327:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":311,"inherits":312,"readable-stream/duplex.js":316,"readable-stream/passthrough.js":323,"readable-stream/readable.js":324,"readable-stream/transform.js":325,"readable-stream/writable.js":326}],328:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":307}],329:[function(require,module,exports){
exports.isatty = function () { return false; };

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.WriteStream = WriteStream;

},{}],330:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],331:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":330,"_process":315,"inherits":312}],332:[function(require,module,exports){
/**
 * Adapted to Babel by Darío Javier Cravero <dario@uxtemple.com>
 *
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
/* eslint-env browser */
/* eslint-disable no-eval */

'use strict';

var buffer = require('buffer');
var transform = require('babel').transform;

var headEl;
var dummyAnchor;
var inlineScriptCount = 0;

// The source-map library relies on Object.defineProperty, but IE8 doesn't
// support it fully even with es5-sham. Indeed, es5-sham's defineProperty
// throws when Object.prototype.__defineGetter__ is missing, so we skip building
// the source map in that case.
var supportsAccessors = Object.prototype.hasOwnProperty('__defineGetter__');

/**
 * Run provided code through jstransform.
 *
 * @param {string} source Original source code
 * @param {object?} options Options to pass to jstransform
 * @return {object} object as returned from jstransform
 */
function transformBabel(source, options) {
  options = options || {sourceMap: true, experimental: true};

  return transform(source, options);
}

/**
 * Eval provided source after transforming it.
 *
 * @param {string} source Original source code
 * @param {object?} options Options to pass to jstransform
 */
function exec(source, options) {
  return eval(transformBabel(source, options).code);
}

/**
 * This method returns a nicely formated line of code pointing to the exact
 * location of the error `e`. The line is limited in size so big lines of code
 * are also shown in a readable way.
 *
 * Example:
 * ... x', overflow:'scroll'}} id={} onScroll={this.scroll} class=" ...
 * ^
 *
 * @param {string} code The full string of code
 * @param {Error} e The error being thrown
 * @return {string} formatted message
 * @internal
 */
function createSourceCodeErrorMessage(code, e) {
  var sourceLines = code.split('\n');
  // e.lineNumber is non-standard so we can't depend on its availability. If
  // we're in a browser where it isn't supported, don't even bother trying to
  // format anything. We may also hit a case where the line number is reported
  // incorrectly and is outside the bounds of the actual code. Handle that too.
  if (!e.lineNumber || e.lineNumber > sourceLines.length) {
    return '';
  }
  var erroneousLine = sourceLines[e.lineNumber - 1];

  // Removes any leading indenting spaces and gets the number of
  // chars indenting the `erroneousLine`
  var indentation = 0;
  erroneousLine = erroneousLine.replace(/^\s+/, function(leadingSpaces) {
    indentation = leadingSpaces.length;
    return '';
  });

  // Defines the number of characters that are going to show
  // before and after the erroneous code
  var LIMIT = 30;
  var errorColumn = e.column - indentation;

  if (errorColumn > LIMIT) {
    erroneousLine = '... ' + erroneousLine.slice(errorColumn - LIMIT);
    errorColumn = 4 + LIMIT;
  }
  if (erroneousLine.length - errorColumn > LIMIT) {
    erroneousLine = erroneousLine.slice(0, errorColumn + LIMIT) + ' ...';
  }
  var message = '\n\n' + erroneousLine + '\n';
  message += new Array(errorColumn - 1).join(' ') + '^';
  return message;
}

/**
 * Actually transform the code.
 *
 * @param {string} code
 * @param {string?} url
 * @param {object?} options
 * @return {string} The transformed code.
 * @internal
 */
function transformCode(code, url, options) {
  try {
    var transformed = transformBabel(code, options);
  } catch(e) {
    e.message += '\n    at ';
    if (url) {
      if ('fileName' in e) {
        // We set `fileName` if it's supported by this error object and
        // a `url` was provided.
        // The error will correctly point to `url` in Firefox.
        e.fileName = url;
      }
      e.message += url + ':' + e.lineNumber + ':' + e.columnNumber;
    } else {
      e.message += location.href;
    }
    e.message += createSourceCodeErrorMessage(code, e);
    throw e;
  }

  if (!transformed.sourceMap) {
    return transformed.code;
  }

  var map = transformed.sourceMap.toJSON();
  var source;
  if (url == null) {
    source = "Inline JSX script";
    inlineScriptCount++;
    if (inlineScriptCount > 1) {
      source += ' (' + inlineScriptCount + ')';
    }
  } else if (dummyAnchor) {
    // Firefox has problems when the sourcemap source is a proper URL with a
    // protocol and hostname, so use the pathname. We could use just the
    // filename, but hopefully using the full path will prevent potential
    // issues where the same filename exists in multiple directories.
    dummyAnchor.href = url;
    source = dummyAnchor.pathname.substr(1);
  }
  map.sources = [source];
  map.sourcesContent = [code];

  return (
    transformed.code +
    '\n//# sourceMappingURL=data:application/json;base64,' +
    buffer.Buffer(JSON.stringify(map)).toString('base64')
  );
}


/**
 * Appends a script element at the end of the <head> with the content of code,
 * after transforming it.
 *
 * @param {string} code The original source code
 * @param {string?} url Where the code came from. null if inline
 * @param {object?} options Options to pass to jstransform
 * @internal
 */
function run(code, url, options) {
  var scriptEl = document.createElement('script');
  scriptEl.text = transformCode(code, url, options);
  headEl.appendChild(scriptEl);
}

/**
 * Load script from the provided url and pass the content to the callback.
 *
 * @param {string} url The location of the script src
 * @param {function} callback Function to call with the content of url
 * @internal
 */
function load(url, successCallback, errorCallback) {
  var xhr;
  xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP')
                             : new XMLHttpRequest();

  // async, however scripts will be executed in the order they are in the
  // DOM to mirror normal script loading.
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) {
    xhr.overrideMimeType('text/plain');
  }
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 0 || xhr.status === 200) {
        successCallback(xhr.responseText);
      } else {
        errorCallback();
        throw new Error("Could not load " + url);
      }
    }
  };
  return xhr.send(null);
}

/**
 * Loop over provided script tags and get the content, via innerHTML if an
 * inline script, or by using XHR. Transforms are applied if needed. The scripts
 * are executed in the order they are found on the page.
 *
 * @param {array} scripts The <script> elements to load and run.
 * @internal
 */
function loadScripts(scripts) {
  var result = [];
  var count = scripts.length;

  function check() {
    var script, i;

    for (i = 0; i < count; i++) {
      script = result[i];

      if (script.loaded && !script.executed) {
        script.executed = true;
        run(script.content, script.url, script.options);
      } else if (!script.loaded && !script.error && !script.async) {
        break;
      }
    }
  }

  scripts.forEach(function(script, i) {
    var options = {
      sourceMap: true
    };
    if (/;harmony=true(;|$)/.test(script.type)) {
      options.harmony = true;
    }
    if (/;stripTypes=true(;|$)/.test(script.type)) {
      options.stripTypes = true;
    }

    // script.async is always true for non-javascript script tags
    var async = script.hasAttribute('async');

    if (script.src) {
      result[i] = {
        async: async,
        error: false,
        executed: false,
        content: null,
        loaded: false,
        url: script.src,
        options: options
      };

      load(script.src, function(content) {
        result[i].loaded = true;
        result[i].content = content;
        check();
      }, function() {
        result[i].error = true;
        check();
      });
    } else {
      result[i] = {
        async: async,
        error: false,
        executed: false,
        content: script.innerHTML,
        loaded: true,
        url: null,
        options: options
      };
    }
  });

  check();
}

/**
 * Find and run all script tags with type="text/jsx".
 *
 * @internal
 */
function runScripts() {
  var scripts = document.getElementsByTagName('script');

  // Array.prototype.slice cannot be used on NodeList on IE8
  var scriptsToLoad = [];
  for (var i = 0; i < scripts.length; i++) {
    if (/^text\/(babel|es6|es7|jsx)(;|$)/.test(scripts.item(i).type)) {
      scriptsToLoad.push(scripts.item(i));
    }
  }

  if (scriptsToLoad.length < 1) {
    return;
  }

  console.warn(
    'You are using babel\'s in-browser ES6/7 & JSX transformer. Be sure to precompile ' +
    'your ES6/7 & JSX for production - ' +
    'babeljs.io/docs/using-babel/' +
    'http://facebook.github.io/react/docs/tooling-integration.html#jsx'
  );

  loadScripts(scriptsToLoad);
}

// Listen for load event if we're in a browser and then kick off finding and
// running of scripts.
if (typeof window !== "undefined" && window !== null) {
  headEl = document.getElementsByTagName('head')[0];
  dummyAnchor = document.createElement('a');

  if (window.addEventListener) {
    window.addEventListener('DOMContentLoaded', runScripts, false);
  } else {
    window.attachEvent('onload', runScripts);
  }
}

module.exports = {
  transform: transformBabel,
  exec: exec
};

},{"babel":1,"buffer":307}]},{},[332])(332)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2FwaS9ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9hcGkvcmVnaXN0ZXIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvYnVpbGQtZXh0ZXJuYWwtaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvYnVpbGQtaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2dlbmVyYXRpb24vZ2VuZXJhdG9ycy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9nZW5lcmF0b3JzL2NvbXByZWhlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvZXhwcmVzc2lvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2dlbmVyYXRpb24vZ2VuZXJhdG9ycy9mbG93LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvanN4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9nZW5lcmF0b3JzL21vZHVsZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2dlbmVyYXRpb24vZ2VuZXJhdG9ycy9wbGF5Z3JvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvc3RhdGVtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9nZW5lcmF0b3JzL3RlbXBsYXRlLWxpdGVyYWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL2dlbmVyYXRvcnMvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2dlbmVyYXRpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2dlbmVyYXRpb24vbm9kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9ub2RlL3BhcmVudGhlc2VzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL25vZGUvd2hpdGVzcGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9wb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvZ2VuZXJhdGlvbi9zb3VyY2UtbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9nZW5lcmF0aW9uL3doaXRlc3BhY2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL2hlbHBlcnMvY29kZS1mcmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvaGVscGVycy9ub3JtYWxpemUtYXN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9oZWxwZXJzL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvaGVscGVycy9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvaGVscGVycy90by1mYXN0LXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC9wYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2ZpbGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvYnVpbGQtYmluYXJ5LWFzc2lnbm1lbnQtb3BlcmF0b3ItdHJhbnNmb3JtZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvYnVpbGQtY29tcHJlaGVuc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vaGVscGVycy9idWlsZC1jb25kaXRpb25hbC1hc3NpZ25tZW50LW9wZXJhdG9yLXRyYW5zZm9ybWVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9oZWxwZXJzL2J1aWxkLXJlYWN0LXRyYW5zZm9ybWVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9oZWxwZXJzL2RlZmluZS1tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvZXhwbG9kZS1hc3NpZ25hYmxlLWV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvbmFtZS1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvcmVhY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2hlbHBlcnMvcmVtYXAtYXN5bmMtdG8tZ2VuZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9oZWxwZXJzL3JlcGxhY2Utc3VwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9oZWxwZXJzL3VzZS1zdHJpY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9tb2R1bGVzL19kZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9tb2R1bGVzL19zdHJpY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL21vZHVsZXMvYW1kLXN0cmljdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vbW9kdWxlcy9hbWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL21vZHVsZXMvY29tbW9uLXN0cmljdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vbW9kdWxlcy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL21vZHVsZXMvaWdub3JlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9tb2R1bGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9tb2R1bGVzL3N5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vbW9kdWxlcy91bWQtc3RyaWN0Iiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi9tb2R1bGVzL3VtZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXItcGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9kZXByZWNhdGVkLmpzb24iLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczMvbWVtYmVyLWV4cHJlc3Npb24tbGl0ZXJhbHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczMvcHJvcGVydHktbGl0ZXJhbHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczUvcHJvcGVydGllcy5tdXRhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi9hcnJvdy1mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczYvYmxvY2stc2NvcGluZy10ZHouanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczYvYmxvY2stc2NvcGluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi9jbGFzc2VzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM2L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi9kZXN0cnVjdHVyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM2L2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi9tb2R1bGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM2L29iamVjdC1zdXBlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi9wYXJhbWV0ZXJzLmRlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczYvcGFyYW1ldGVycy5yZXN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM2L3Byb3BlcnRpZXMuY29tcHV0ZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczYvcHJvcGVydGllcy5zaG9ydGhhbmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczYvc3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM2L3RhaWwtY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi90ZW1wbGF0ZS1saXRlcmFscy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2VzNi91bmljb2RlLXJlZ2V4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvZXM3L2Fic3RyYWN0LXJlZmVyZW5jZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczcvY29tcHJlaGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczcvZXhwb25lbnRpYXRpb24tb3BlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9lczcvb2JqZWN0LXJlc3Qtc3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9pbnRlcm5hbC9hbGlhcy1mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9pbnRlcm5hbC9ibG9jay1ob2lzdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL2ludGVybmFsL2NsZWFudXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9pbnRlcm5hbC9kZWNsYXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9pbnRlcm5hbC9tb2R1bGUtZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvaW50ZXJuYWwvbW9kdWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL21pbmlmaWNhdGlvbi9kZWFkLWNvZGUtZWxpbWluYXRpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9taW5pZmljYXRpb24vcmVtb3ZlLWNvbnNvbGUtY2FsbHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9taW5pZmljYXRpb24vcmVtb3ZlLWRlYnVnZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvbWluaWZpY2F0aW9uL3JlbmFtZS1sb2NhbC12YXJpYWJsZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9vdGhlci9hc3luYy10by1nZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9vdGhlci9ibHVlYmlyZC1jb3JvdXRpbmVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvb3RoZXIvZmxvdy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL290aGVyL3JlYWN0LWNvbXBhdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL290aGVyL3JlYWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvb3RoZXIvcmVnZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9vdGhlci9zZWxmLWNvbnRhaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL290aGVyL3VzZS1zdHJpY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9wbGF5Z3JvdW5kL21hbGxldC1vcGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL3BsYXlncm91bmQvbWVtb2l6YXRpb24tb3BlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9wbGF5Z3JvdW5kL21ldGhvZC1iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvcGxheWdyb3VuZC9vYmplY3QtZ2V0dGVyLW1lbW9pemF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvc3BlYy9ibG9jay1zY29wZWQtZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvc3BlYy9mdW5jdGlvbi1uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvc3BlYy9wcm90by10by1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9zcGVjL3R5cGVvZi1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy9zcGVjL3VuZGVmaW5lZC10by12b2lkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmFuc2Zvcm1hdGlvbi90cmFuc2Zvcm1lcnMvdmFsaWRhdGlvbi9uby1mb3ItaW4tb2YtYXNzaWdubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHJhbnNmb3JtYXRpb24vdHJhbnNmb3JtZXJzL3ZhbGlkYXRpb24vcmVhY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy92YWxpZGF0aW9uL3NldHRlcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYW5zZm9ybWF0aW9uL3RyYW5zZm9ybWVycy92YWxpZGF0aW9uL3VuZGVjbGFyZWQtdmFyaWFibGUtY2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYXZlcnNhbC9jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmF2ZXJzYWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3RyYXZlcnNhbC9wYXRoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90cmF2ZXJzYWwvc2NvcGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3R5cGVzL2FsaWFzLWtleXMuanNvbiIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdHlwZXMvYnVpbGRlci1rZXlzLmpzb24iLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3R5cGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL2xpYi9iYWJlbC90eXBlcy92aXNpdG9yLWtleXMuanNvbiIsIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYWNvcm4tYmFiZWwvYWNvcm5fY3NwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9hc3QtdHlwZXMvZGVmL2NvcmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2FzdC10eXBlcy9kZWYvZTR4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9hc3QtdHlwZXMvZGVmL2VzNi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYXN0LXR5cGVzL2RlZi9lczcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2FzdC10eXBlcy9kZWYvZmItaGFybW9ueS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYXN0LXR5cGVzL2RlZi9tb3ppbGxhLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9hc3QtdHlwZXMvbGliL2VxdWl2LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9hc3QtdHlwZXMvbGliL25vZGUtcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYXN0LXR5cGVzL2xpYi9wYXRoLXZpc2l0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2FzdC10eXBlcy9saWIvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYXN0LXR5cGVzL2xpYi9zY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvYXN0LXR5cGVzL2xpYi9zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2FzdC10eXBlcy9saWIvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2FzdC10eXBlcy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jaGFsay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jaGFsay9ub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9oYXMtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL2hhcy1hbnNpL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jaGFsay9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2RlYnVnL25vZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2RlYnVnL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvZGV0ZWN0LWluZGVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9lc3RyYXZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi9hc3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2NvZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2tleXdvcmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9nbG9iYWxzL2dsb2JhbHMuanNvbiIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvZ2xvYmFscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvaXMtaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvaXMtaW50ZWdlci9ub2RlX21vZHVsZXMvaXMtZmluaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9pcy1pbnRlZ2VyL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2pzLXRva2VuaXplci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbGV2ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9hcnJheS9jb21wYWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXJyYXkvZmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2FycmF5L2xhc3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9hcnJheS9wdWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXJyYXkvdW5pcS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbGxlY3Rpb24vY29udGFpbnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL2VhY2guanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL2dyb3VwQnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL2luY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb2xsZWN0aW9uL3JlZHVjZVJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9zb21lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29sbGVjdGlvbi9zb3J0QnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9TZXRDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5Q29weS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYXJyYXlSZWR1Y2VSaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Fzc2lnbkRlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VDYWxsYmFjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VDb21wYXJlQXNjZW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUNvcHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VFYWNoUmlnaHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9ySW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlRm9yT3duLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZvck93blJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUZvclJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VNZXJnZURlZXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlUmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvYmFzZVNldERhdGEuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlU29tZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VTb3J0QnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iYXNlVW5pcS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2Jhc2VWYWx1ZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9iaW5kQ2FsbGJhY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9idWZmZXJDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NhY2hlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NhY2hlUHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2NvbXBhcmVBc2NlbmRpbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVBZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvY3JlYXRlQXNzaWduZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9jcmVhdGVDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2luZGV4T2ZOYU4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaXNCaW5kYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvaXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvbWV0YU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2ludGVybmFsL3NoaW1Jc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvc2hpbUtleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcm5hbC9zb3J0ZWRVbmlxLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvaW50ZXJuYWwvdG9PYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9jbG9uZURlZXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc0Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzRW1wdHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9sYW5nL2lzUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL2xhbmcvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFuZy90b1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL29iamVjdC9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL29iamVjdC9leHRlbmQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3QvaGFzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9vYmplY3Qva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvb2JqZWN0L3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL3N0cmluZy9lc2NhcGVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdXBwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9sb2Rhc2gvdXRpbGl0eS9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvbG9kYXNoL3V0aWxpdHkvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3ByaXZhdGUvcHJpdmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItYmFiZWwvbGliL2VtaXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLWJhYmVsL2xpYi9ob2lzdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItYmFiZWwvbGliL2xlYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLWJhYmVsL2xpYi9tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1iYWJlbC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItYmFiZWwvbGliL3Zpc2l0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1iYWJlbC9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1iYWJlbC9ub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItYmFiZWwvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZXhwdS9kYXRhL2NoYXJhY3Rlci1jbGFzcy1lc2NhcGUtc2V0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZXhwdS9kYXRhL2l1LW1hcHBpbmdzLmpzb24iLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2V4cHUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdGUvcmVnZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZXhwdS9ub2RlX21vZHVsZXMvcmVnanNnZW4vcmVnanNnZW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2V4cHUvbm9kZV9tb2R1bGVzL3JlZ2pzcGFyc2VyL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZXhwdS9yZXdyaXRlLXBhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlcGVhdGluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc2hlYmFuZy1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc2xhc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtdG8tY29tbWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9hcnJheS1zZXQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmluYXJ5LXNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9tYXBwaW5nLWxpc3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2Utbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL25vZGVfbW9kdWxlcy9hbWRlZmluZS9hbWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvdHJpbS1yaWdodC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvYmFiZWwvdGVtcGxhdGVzLmpzb24iLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3R0eS1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwic3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDampCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNudEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4cUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdG9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFHQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9pc0Z1bmN0aW9uXCIpO1xudmFyIHRyYW5zZm9ybSAgPSByZXF1aXJlKFwiLi4vdHJhbnNmb3JtYXRpb25cIik7XG52YXIgdXRpbCAgICAgICA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGZzICAgICAgICAgPSByZXF1aXJlKFwiZnNcIik7XG5cbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wYWNrYWdlXCIpLnZlcnNpb247XG5cbmV4cG9ydHMuYnVpbGRFeHRlcm5hbEhlbHBlcnMgPSByZXF1aXJlKFwiLi4vYnVpbGQtZXh0ZXJuYWwtaGVscGVyc1wiKTtcblxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxuZXhwb3J0cy5yZWdpc3RlciA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZWdpc3RlciA9IHJlcXVpcmUoXCIuL3JlZ2lzdGVyL25vZGVcIik7XG4gIGlmIChvcHRzICE9IG51bGwpIHJlZ2lzdGVyKG9wdHMpO1xuICByZXR1cm4gcmVnaXN0ZXI7XG59O1xuXG5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24gKCkge1xuICByZXF1aXJlKFwiLi4vcG9seWZpbGxcIik7XG59O1xuXG5leHBvcnRzLmNhbkNvbXBpbGUgPSB1dGlsLmNhbkNvbXBpbGU7XG5cbi8vIGRvIG5vdCB1c2UgdGhpcyAtIHRoaXMgaXMgZm9yIHVzZSBieSBvZmZpY2lhbCBtYWludGFpbmVkIGJhYmVsIHBsdWdpbnNcbmV4cG9ydHMuX3V0aWwgPSB1dGlsO1xuXG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuZXhwb3J0cy50cmFuc2Zvcm1GaWxlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoaXNGdW5jdGlvbihvcHRzKSkge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBvcHRzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG5cbiAgZnMucmVhZEZpbGUoZmlsZW5hbWUsIGZ1bmN0aW9uIChlcnIsIGNvZGUpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdHJhbnNmb3JtKGNvZGUsIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRyYW5zZm9ybUZpbGVTeW5jID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gIHJldHVybiB0cmFuc2Zvcm0oZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lKSwgb3B0cyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJlcXVpcmVkIHRvIHNhZmVseSB1c2UgYmFiZWwvcmVnaXN0ZXIgd2l0aGluIGEgYnJvd3NlcmlmeSBjb2RlYmFzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5yZXF1aXJlKFwiLi4vLi4vcG9seWZpbGxcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGJ1aWxkSGVscGVycyA9IHJlcXVpcmUoXCIuL2J1aWxkLWhlbHBlcnNcIik7XG52YXIgZ2VuZXJhdG9yICAgID0gcmVxdWlyZShcIi4vZ2VuZXJhdGlvblwiKTtcbnZhciB1dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWVzcGFjZSA9IHQuaWRlbnRpZmllcihcImJhYmVsSGVscGVyc1wiKTtcblxuICB2YXIgYm9keSAgICAgID0gW107XG4gIHZhciBjb250YWluZXIgPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBbdC5pZGVudGlmaWVyKFwiZ2xvYmFsXCIpXSwgdC5ibG9ja1N0YXRlbWVudChib2R5KSk7XG4gIHZhciB0cmVlICAgICAgPSB0LnByb2dyYW0oW3QuZXhwcmVzc2lvblN0YXRlbWVudCh0LmNhbGxFeHByZXNzaW9uKGNvbnRhaW5lciwgW3V0aWwudGVtcGxhdGUoXCJzZWxmLWdsb2JhbFwiKV0pKV0pO1xuXG4gIGJvZHkucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcImdsb2JhbFwiKSwgbmFtZXNwYWNlKSwgdC5vYmplY3RFeHByZXNzaW9uKFtdKSlcbiAgICApXG4gIF0pKTtcblxuICBidWlsZEhlbHBlcnMoYm9keSwgbmFtZXNwYWNlKTtcblxuICByZXR1cm4gZ2VuZXJhdG9yKHRyZWUpLmNvZGU7XG59O1xuIiwidmFyIEZpbGUgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1hdGlvbi9maWxlXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGVhY2ggPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciB0ICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJvZHksIG5hbWVzcGFjZSkge1xuICBlYWNoKEZpbGUuaGVscGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIga2V5ID0gdC5pZGVudGlmaWVyKHQudG9JZGVudGlmaWVyKG5hbWUpKTtcbiAgICBib2R5LnB1c2godC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdC5tZW1iZXJFeHByZXNzaW9uKG5hbWVzcGFjZSwga2V5KSwgdXRpbC50ZW1wbGF0ZShuYW1lKSlcbiAgICApKTtcbiAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgcmVwZWF0aW5nID0gcmVxdWlyZShcInJlcGVhdGluZ1wiKTtcbnZhciB0cmltUmlnaHQgPSByZXF1aXJlKFwidHJpbS1yaWdodFwiKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNCb29sZWFuXCIpO1xudmFyIGluY2x1ZGVzICA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9pbmNsdWRlc1wiKTtcbnZhciBpc051bWJlciAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNOdW1iZXJcIik7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihwb3NpdGlvbiwgZm9ybWF0KSB7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5faW5kZW50ICA9IGZvcm1hdC5pbmRlbnQuYmFzZTtcbiAgdGhpcy5mb3JtYXQgICA9IGZvcm1hdDtcbiAgdGhpcy5idWYgICAgICA9IFwiXCI7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJpbVJpZ2h0KHRoaXMuYnVmKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuZ2V0SW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5mb3JtYXQuY29tcGFjdCB8fCB0aGlzLmZvcm1hdC5jb25jaXNlKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcGVhdGluZyh0aGlzLmZvcm1hdC5pbmRlbnQuc3R5bGUsIHRoaXMuX2luZGVudCk7XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0SW5kZW50KCkubGVuZ3RoO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luZGVudCsrO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5kZWRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luZGVudC0tO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChcIjtcIik7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVuc3VyZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmlzTGFzdChcIjtcIikpIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJpZ2h0QnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubmV3bGluZSh0cnVlKTtcbiAgdGhpcy5wdXNoKFwifVwiKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUua2V5d29yZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHRoaXMucHVzaChuYW1lKTtcbiAgdGhpcy5zcGFjZSgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZm9ybWF0LmNvbXBhY3QpIHJldHVybjtcblxuICBpZiAodGhpcy5idWYgJiYgIXRoaXMuaXNMYXN0KFtcIiBcIiwgXCJcXG5cIl0pKSB7XG4gICAgdGhpcy5wdXNoKFwiIFwiKTtcbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZW1vdmVMYXN0ID0gZnVuY3Rpb24gKGNoYSkge1xuICBpZiAoIXRoaXMuaXNMYXN0KGNoYSkpIHJldHVybjtcblxuICB0aGlzLmJ1ZiA9IHRoaXMuYnVmLnN1YnN0cigwLCB0aGlzLmJ1Zi5sZW5ndGggLSAxKTtcbiAgdGhpcy5wb3NpdGlvbi51bnNoaWZ0KGNoYSk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLm5ld2xpbmUgPSBmdW5jdGlvbiAoaSwgcmVtb3ZlTGFzdCkge1xuICBpZiAodGhpcy5mb3JtYXQuY29tcGFjdCB8fCB0aGlzLmZvcm1hdC5jb25jaXNlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlbW92ZUxhc3QgPSByZW1vdmVMYXN0IHx8IGZhbHNlO1xuXG4gIGlmIChpc051bWJlcihpKSkge1xuICAgIGlmICh0aGlzLmVuZHNXaXRoKFwie1xcblwiKSkgaS0tO1xuICAgIGlmICh0aGlzLmVuZHNXaXRoKHJlcGVhdGluZyhcIlxcblwiLCBpID4gMCA/IGkgOiAwKSkpIHJldHVybjtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuX25ld2xpbmUocmVtb3ZlTGFzdCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW4oaSkpIHtcbiAgICByZW1vdmVMYXN0ID0gaTtcbiAgfVxuXG4gIHRoaXMuX25ld2xpbmUocmVtb3ZlTGFzdCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLl9uZXdsaW5lID0gZnVuY3Rpb24gKHJlbW92ZUxhc3QpIHtcbiAgaWYgKHJlbW92ZUxhc3QgJiYgdGhpcy5pc0xhc3QoXCJcXG5cIikpIHRoaXMucmVtb3ZlTGFzdChcIlxcblwiKTtcblxuICB0aGlzLnJlbW92ZUxhc3QoXCIgXCIpO1xuXG4gIC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGlmIGxhc3QgY2hhcmFjdGVyIHdhcyBhIG5ld2xpbmVcbiAgdGhpcy5fcmVtb3ZlU3BhY2VzQWZ0ZXJMYXN0TmV3bGluZSgpO1xuICB0aGlzLl9wdXNoKFwiXFxuXCIpO1xufTtcblxuLyoqXG4gKiBJZiBidWZmZXIgZW5kcyB3aXRoIGEgbmV3bGluZSBhbmQgc29tZSBzcGFjZXMgYWZ0ZXIgaXQsIHRyaW0gdGhvc2Ugc3BhY2VzLlxuICovXG5CdWZmZXIucHJvdG90eXBlLl9yZW1vdmVTcGFjZXNBZnRlckxhc3ROZXdsaW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGFzdE5ld2xpbmVJbmRleCA9IHRoaXMuYnVmLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZiAobGFzdE5ld2xpbmVJbmRleCA9PT0gLTEpXG4gICAgcmV0dXJuO1xuXG4gIHZhciBpbmRleCA9IHRoaXMuYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpbmRleCA+IGxhc3ROZXdsaW5lSW5kZXgpIHtcbiAgICBpZiAodGhpcy5idWZbaW5kZXhdICE9PSBcIiBcIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaW5kZXgtLTtcbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gbGFzdE5ld2xpbmVJbmRleCkge1xuICAgIHRoaXMuYnVmID0gdGhpcy5idWYuc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChzdHIsIG5vSW5kZW50KSB7XG4gIGlmICh0aGlzLl9pbmRlbnQgJiYgIW5vSW5kZW50ICYmIHN0ciAhPT0gXCJcXG5cIikge1xuICAgIC8vIHdlIGhhdmUgYW4gaW5kZW50IGxldmVsIGFuZCB3ZSBhcmVuJ3QgcHVzaGluZyBhIG5ld2xpbmVcbiAgICB2YXIgaW5kZW50ID0gdGhpcy5nZXRJbmRlbnQoKTtcblxuICAgIC8vIHJlcGxhY2UgYWxsIG5ld2xpbmVzIHdpdGggbmV3bGluZXMgd2l0aCB0aGUgaW5kZW50YXRpb25cbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxuL2csIFwiXFxuXCIgKyBpbmRlbnQpO1xuXG4gICAgLy8gd2UndmUgZ290IGEgbmV3bGluZSBiZWZvcmUgdXMgc28gcHJlcGVuZCBvbiB0aGUgaW5kZW50YXRpb25cbiAgICBpZiAodGhpcy5pc0xhc3QoXCJcXG5cIikpIHN0ciA9IGluZGVudCArIHN0cjtcbiAgfVxuXG4gIHRoaXMuX3B1c2goc3RyKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHRoaXMucG9zaXRpb24ucHVzaChzdHIpO1xuICB0aGlzLmJ1ZiArPSBzdHI7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgZCA9IHRoaXMuYnVmLmxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gIHJldHVybiBkID49IDAgJiYgdGhpcy5idWYubGFzdEluZGV4T2Yoc3RyKSA9PT0gZDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaXNMYXN0ID0gZnVuY3Rpb24gKGNoYSwgc2hvdWxkVHJpbVJpZ2h0KSB7XG4gIHZhciBidWYgPSB0aGlzLmJ1ZjtcbiAgaWYgKHNob3VsZFRyaW1SaWdodCkgYnVmID0gdHJpbVJpZ2h0KGJ1Zik7XG4gIHZhciBsYXN0ID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGEpKSB7XG4gICAgcmV0dXJuIGluY2x1ZGVzKGNoYSwgbGFzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNoYSA9PT0gbGFzdDtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLkZpbGUgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgcHJpbnQobm9kZS5wcm9ncmFtKTtcbn07XG5cbmV4cG9ydHMuUHJvZ3JhbSA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBwcmludC5zZXF1ZW5jZShub2RlLmJvZHkpO1xufTtcblxuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBpZiAobm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMucHVzaChcInt9XCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHVzaChcIntcIik7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgcHJpbnQuc2VxdWVuY2Uobm9kZS5ib2R5LCB7IGluZGVudDogdHJ1ZSB9KTtcbiAgICB0aGlzLnJlbW92ZUxhc3QoXCJcXG5cIik7XG4gICAgdGhpcy5yaWdodEJyYWNlKCk7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPVxuZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMucHVzaChcImNsYXNzXCIpO1xuXG4gIGlmIChub2RlLmlkKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHByaW50KG5vZGUuaWQpO1xuICB9XG5cbiAgaWYgKG5vZGUuc3VwZXJDbGFzcykge1xuICAgIHRoaXMucHVzaChcIiBleHRlbmRzIFwiKTtcbiAgICBwcmludChub2RlLnN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgdGhpcy5zcGFjZSgpO1xuICBwcmludChub2RlLmJvZHkpO1xufTtcblxuZXhwb3J0cy5DbGFzc0JvZHkgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgaWYgKG5vZGUuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnB1c2goXCJ7fVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnB1c2goXCJ7XCIpO1xuICAgIHRoaXMubmV3bGluZSgpO1xuXG4gICAgdGhpcy5pbmRlbnQoKTtcbiAgICBwcmludC5zZXF1ZW5jZShub2RlLmJvZHkpO1xuICAgIHRoaXMuZGVkZW50KCk7XG5cbiAgICB0aGlzLnJpZ2h0QnJhY2UoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHRoaXMucHVzaChcInN0YXRpYyBcIik7XG4gIH1cblxuICB0aGlzLl9tZXRob2Qobm9kZSwgcHJpbnQpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLkNvbXByZWhlbnNpb25CbG9jayA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLmtleXdvcmQoXCJmb3JcIik7XG4gIHRoaXMucHVzaChcIihcIik7XG4gIHByaW50KG5vZGUubGVmdCk7XG4gIHRoaXMucHVzaChcIiBvZiBcIik7XG4gIHByaW50KG5vZGUucmlnaHQpO1xuICB0aGlzLnB1c2goXCIpXCIpO1xufTtcblxuZXhwb3J0cy5Db21wcmVoZW5zaW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2gobm9kZS5nZW5lcmF0b3IgPyBcIihcIiA6IFwiW1wiKTtcblxuICBwcmludC5qb2luKG5vZGUuYmxvY2tzLCB7IHNlcGFyYXRvcjogXCIgXCIgfSk7XG4gIHRoaXMuc3BhY2UoKTtcblxuICBpZiAobm9kZS5maWx0ZXIpIHtcbiAgICB0aGlzLmtleXdvcmQoXCJpZlwiKTtcbiAgICB0aGlzLnB1c2goXCIoXCIpO1xuICAgIHByaW50KG5vZGUuZmlsdGVyKTtcbiAgICB0aGlzLnB1c2goXCIpXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuXG4gIHByaW50KG5vZGUuYm9keSk7XG5cbiAgdGhpcy5wdXNoKG5vZGUuZ2VuZXJhdG9yID8gXCIpXCIgOiBcIl1cIik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKFwiaXMtaW50ZWdlclwiKTtcbnZhciBpc051bWJlciAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNOdW1iZXJcIik7XG52YXIgdCAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB2YXIgaGFzU3BhY2UgPSAvW2Etel0kLy50ZXN0KG5vZGUub3BlcmF0b3IpO1xuICB2YXIgYXJnID0gbm9kZS5hcmd1bWVudDtcblxuICBpZiAodC5pc1VwZGF0ZUV4cHJlc3Npb24oYXJnKSB8fCB0LmlzVW5hcnlFeHByZXNzaW9uKGFyZykpIHtcbiAgICBoYXNTcGFjZSA9IHRydWU7XG4gIH1cblxuICBpZiAodC5pc1VuYXJ5RXhwcmVzc2lvbihhcmcpICYmIGFyZy5vcGVyYXRvciA9PT0gXCIhXCIpIHtcbiAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5wdXNoKG5vZGUub3BlcmF0b3IpO1xuICBpZiAoaGFzU3BhY2UpIHRoaXMucHVzaChcIiBcIik7XG4gIHByaW50KG5vZGUuYXJndW1lbnQpO1xufTtcblxuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIGlmIChub2RlLnByZWZpeCkge1xuICAgIHRoaXMucHVzaChub2RlLm9wZXJhdG9yKTtcbiAgICBwcmludChub2RlLmFyZ3VtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBwcmludChub2RlLmFyZ3VtZW50KTtcbiAgICB0aGlzLnB1c2gobm9kZS5vcGVyYXRvcik7XG4gIH1cbn07XG5cbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wdXNoKFwiP1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBwcmludChub2RlLmNvbnNlcXVlbnQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHVzaChcIjpcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgcHJpbnQobm9kZS5hbHRlcm5hdGUpO1xufTtcblxuZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMucHVzaChcIm5ldyBcIik7XG4gIHByaW50KG5vZGUuY2FsbGVlKTtcbiAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCB8fCB0aGlzLmZvcm1hdC5wYXJlbnRoZXNlcykge1xuICAgIHRoaXMucHVzaChcIihcIik7XG4gICAgcHJpbnQubGlzdChub2RlLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wdXNoKFwiKVwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgcHJpbnQubGlzdChub2RlLmV4cHJlc3Npb25zKTtcbn07XG5cbmV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChcInRoaXNcIik7XG59O1xuXG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHByaW50KG5vZGUuY2FsbGVlKTtcblxuICB0aGlzLnB1c2goXCIoXCIpO1xuXG4gIHZhciBzZXBhcmF0b3IgPSBcIixcIjtcblxuICBpZiAobm9kZS5fcHJldHR5Q2FsbCkge1xuICAgIHNlcGFyYXRvciArPSBcIlxcblwiO1xuICAgIHRoaXMubmV3bGluZSgpO1xuICAgIHRoaXMuaW5kZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgc2VwYXJhdG9yICs9IFwiIFwiO1xuICB9XG5cbiAgcHJpbnQubGlzdChub2RlLmFyZ3VtZW50cywgeyBzZXBhcmF0b3I6IHNlcGFyYXRvciB9KTtcblxuICBpZiAobm9kZS5fcHJldHR5Q2FsbCkge1xuICAgIHRoaXMubmV3bGluZSgpO1xuICAgIHRoaXMuZGVkZW50KCk7XG4gIH1cblxuICB0aGlzLnB1c2goXCIpXCIpO1xufTtcblxudmFyIGJ1aWxkWWllbGRBd2FpdCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgICB0aGlzLnB1c2goa2V5d29yZCk7XG5cbiAgICBpZiAobm9kZS5kZWxlZ2F0ZSB8fCBub2RlLmFsbCkge1xuICAgICAgdGhpcy5wdXNoKFwiKlwiKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgcHJpbnQobm9kZS5hcmd1bWVudCk7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBidWlsZFlpZWxkQXdhaXQoXCJ5aWVsZFwiKTtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gYnVpbGRZaWVsZEF3YWl0KFwiYXdhaXRcIik7XG5cbmV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgcHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn07XG5cbmV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID1cbmV4cG9ydHMuQXNzaWdubWVudFBhdHRlcm4gPVxuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICAvLyB0b2RvOiBhZGQgY2FzZXMgd2hlcmUgdGhlIHNwYWNlcyBjYW4gYmUgZHJvcHBlZCB3aGVuIGluIGNvbXBhY3QgbW9kZVxuICBwcmludChub2RlLmxlZnQpO1xuICB0aGlzLnB1c2goXCIgXCIpO1xuICB0aGlzLnB1c2gobm9kZS5vcGVyYXRvcik7XG4gIHRoaXMucHVzaChcIiBcIik7XG4gIHByaW50KG5vZGUucmlnaHQpO1xufTtcblxudmFyIFNDSUVOVElGSUNfTk9UQVRJT04gPSAvZS9pO1xuXG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdmFyIG9iaiA9IG5vZGUub2JqZWN0O1xuICBwcmludChvYmopO1xuXG4gIGlmICghbm9kZS5jb21wdXRlZCAmJiB0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlLnByb3BlcnR5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHb3QgYSBNZW1iZXJFeHByZXNzaW9uIGZvciBNZW1iZXJFeHByZXNzaW9uIHByb3BlcnR5XCIpO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZDtcbiAgaWYgKHQuaXNMaXRlcmFsKG5vZGUucHJvcGVydHkpICYmIGlzTnVtYmVyKG5vZGUucHJvcGVydHkudmFsdWUpKSB7XG4gICAgY29tcHV0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgdGhpcy5wdXNoKFwiW1wiKTtcbiAgICBwcmludChub2RlLnByb3BlcnR5KTtcbiAgICB0aGlzLnB1c2goXCJdXCIpO1xuICB9IGVsc2Uge1xuICAgIC8vIDUuLnRvRml4ZWQoMik7XG4gICAgaWYgKHQuaXNMaXRlcmFsKG9iaikgJiYgaXNJbnRlZ2VyKG9iai52YWx1ZSkgJiYgIVNDSUVOVElGSUNfTk9UQVRJT04udGVzdChvYmoudmFsdWUudG9TdHJpbmcoKSkpIHtcbiAgICAgIHRoaXMucHVzaChcIi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKFwiLlwiKTtcbiAgICBwcmludChub2RlLnByb3BlcnR5KTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLkFueVR5cGVBbm5vdGF0aW9uID1cbmV4cG9ydHMuQXJyYXlUeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLkJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLkNsYXNzUHJvcGVydHkgPVxuZXhwb3J0cy5EZWNsYXJlQ2xhc3MgPVxuZXhwb3J0cy5EZWNsYXJlRnVuY3Rpb24gPVxuZXhwb3J0cy5EZWNsYXJlTW9kdWxlID1cbmV4cG9ydHMuRGVjbGFyZVZhcmlhYmxlID1cbmV4cG9ydHMuRnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLkZ1bmN0aW9uVHlwZVBhcmFtID1cbmV4cG9ydHMuR2VuZXJpY1R5cGVBbm5vdGF0aW9uID1cbmV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9XG5leHBvcnRzLkludGVyZmFjZURlY2xhcmF0aW9uID1cbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPVxuZXhwb3J0cy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uID1cbmV4cG9ydHMuTnVtYmVyVHlwZUFubm90YXRpb24gPVxuZXhwb3J0cy5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPVxuZXhwb3J0cy5TdHJpbmdUeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLlR1cGxlVHlwZUFubm90YXRpb24gPVxuZXhwb3J0cy5UeXBlb2ZUeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLlR5cGVBbGlhcyA9XG5leHBvcnRzLlR5cGVBbm5vdGF0aW9uID1cbmV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID1cbmV4cG9ydHMuVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPVxuZXhwb3J0cy5PYmplY3RUeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLk9iamVjdFR5cGVDYWxsUHJvcGVydHkgPVxuZXhwb3J0cy5PYmplY3RUeXBlSW5kZXhlciA9XG5leHBvcnRzLk9iamVjdFR5cGVQcm9wZXJ0eSA9XG5leHBvcnRzLlF1YWxpZmllZFR5cGVJZGVudGlmaWVyID1cbmV4cG9ydHMuVW5pb25UeXBlQW5ub3RhdGlvbiA9XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9XG5leHBvcnRzLlZvaWRUeXBlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdG9kbzogaW1wbGVtZW50IHRoZXNlIG9uY2Ugd2UgaGF2ZSBhIGAtLWtlZXAtdHlwZXNgIG9wdGlvblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCAgICA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcbnZhciBlYWNoID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2VhY2hcIik7XG5cbmV4cG9ydHMuSlNYQXR0cmlidXRlID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHByaW50KG5vZGUubmFtZSk7XG4gIGlmIChub2RlLnZhbHVlKSB7XG4gICAgdGhpcy5wdXNoKFwiPVwiKTtcbiAgICBwcmludChub2RlLnZhbHVlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5wdXNoKG5vZGUubmFtZSk7XG59O1xuXG5leHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHByaW50KG5vZGUubmFtZXNwYWNlKTtcbiAgdGhpcy5wdXNoKFwiOlwiKTtcbiAgcHJpbnQobm9kZS5uYW1lKTtcbn07XG5cbmV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBwcmludChub2RlLm9iamVjdCk7XG4gIHRoaXMucHVzaChcIi5cIik7XG4gIHByaW50KG5vZGUucHJvcGVydHkpO1xufTtcblxuZXhwb3J0cy5KU1hTcHJlYWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5wdXNoKFwiey4uLlwiKTtcbiAgcHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIHRoaXMucHVzaChcIn1cIik7XG59O1xuXG5leHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5wdXNoKFwie1wiKTtcbiAgcHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5wdXNoKFwifVwiKTtcbn07XG5cbmV4cG9ydHMuSlNYRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIG9wZW4gPSBub2RlLm9wZW5pbmdFbGVtZW50O1xuICBwcmludChvcGVuKTtcbiAgaWYgKG9wZW4uc2VsZkNsb3NpbmcpIHJldHVybjtcblxuICB0aGlzLmluZGVudCgpO1xuICBlYWNoKG5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmICh0LmlzTGl0ZXJhbChjaGlsZCkpIHtcbiAgICAgIHNlbGYucHVzaChjaGlsZC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KGNoaWxkKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmRlZGVudCgpO1xuXG4gIHByaW50KG5vZGUuY2xvc2luZ0VsZW1lbnQpO1xufTtcblxuZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2goXCI8XCIpO1xuICBwcmludChub2RlLm5hbWUpO1xuICBpZiAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnB1c2goXCIgXCIpO1xuICAgIHByaW50LmpvaW4obm9kZS5hdHRyaWJ1dGVzLCB7IHNlcGFyYXRvcjogXCIgXCIgfSk7XG4gIH1cbiAgdGhpcy5wdXNoKG5vZGUuc2VsZkNsb3NpbmcgPyBcIiAvPlwiIDogXCI+XCIpO1xufTtcblxuZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2goXCI8L1wiKTtcbiAgcHJpbnQobm9kZS5uYW1lKTtcbiAgdGhpcy5wdXNoKFwiPlwiKTtcbn07XG5cbmV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge307XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuX3BhcmFtcyA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2goXCIoXCIpO1xuICBwcmludC5saXN0KG5vZGUucGFyYW1zKTtcbiAgdGhpcy5wdXNoKFwiKVwiKTtcbn07XG5cbmV4cG9ydHMuX21ldGhvZCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB2YXIga2luZCAgPSBub2RlLmtpbmQ7XG4gIHZhciBrZXkgICA9IG5vZGUua2V5O1xuXG4gIGlmICgha2luZCB8fCBraW5kID09PSBcImluaXRcIikge1xuICAgIGlmICh2YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgIHRoaXMucHVzaChcIipcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMucHVzaChraW5kICsgXCIgXCIpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmFzeW5jKSB0aGlzLnB1c2goXCJhc3luYyBcIik7XG5cbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnB1c2goXCJbXCIpO1xuICAgIHByaW50KGtleSk7XG4gICAgdGhpcy5wdXNoKFwiXVwiKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludChrZXkpO1xuICB9XG5cbiAgdGhpcy5fcGFyYW1zKHZhbHVlLCBwcmludCk7XG4gIHRoaXMucHVzaChcIiBcIik7XG4gIHByaW50KHZhbHVlLmJvZHkpO1xufTtcblxuZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID1cbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIGlmIChub2RlLmFzeW5jKSB0aGlzLnB1c2goXCJhc3luYyBcIik7XG4gIHRoaXMucHVzaChcImZ1bmN0aW9uXCIpO1xuICBpZiAobm9kZS5nZW5lcmF0b3IpIHRoaXMucHVzaChcIipcIik7XG5cbiAgaWYgKG5vZGUuaWQpIHtcbiAgICB0aGlzLnB1c2goXCIgXCIpO1xuICAgIHByaW50KG5vZGUuaWQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuXG4gIHRoaXMuX3BhcmFtcyhub2RlLCBwcmludCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgcHJpbnQobm9kZS5ib2R5KTtcbn07XG5cbmV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgaWYgKG5vZGUuYXN5bmMpIHRoaXMucHVzaChcImFzeW5jIFwiKTtcblxuICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmIHQuaXNJZGVudGlmaWVyKG5vZGUucGFyYW1zWzBdKSkge1xuICAgIHByaW50KG5vZGUucGFyYW1zWzBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9wYXJhbXMobm9kZSwgcHJpbnQpO1xuICB9XG5cbiAgdGhpcy5wdXNoKFwiID0+IFwiKTtcbiAgcHJpbnQobm9kZS5ib2R5KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG52YXIgZWFjaCA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9lYWNoXCIpO1xuXG5leHBvcnRzLkltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBpZiAodC5pc1NwZWNpZmllckRlZmF1bHQobm9kZSkpIHtcbiAgICBwcmludCh0LmdldFNwZWNpZmllck5hbWUobm9kZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBvcnRzLkV4cG9ydFNwZWNpZmllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG5leHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBwcmludChub2RlLmlkKTtcbiAgaWYgKG5vZGUubmFtZSkge1xuICAgIHRoaXMucHVzaChcIiBhcyBcIik7XG4gICAgcHJpbnQobm9kZS5uYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0cy5FeHBvcnRCYXRjaFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wdXNoKFwiKlwiKTtcbn07XG5cbmV4cG9ydHMuRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5wdXNoKFwiZXhwb3J0IFwiKTtcblxuICB2YXIgc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycztcblxuICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgdGhpcy5wdXNoKFwiZGVmYXVsdCBcIik7XG4gIH1cblxuICBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgIHByaW50KG5vZGUuZGVjbGFyYXRpb24pO1xuICAgIGlmICh0LmlzU3RhdGVtZW50KG5vZGUuZGVjbGFyYXRpb24pKSByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoID09PSAxICYmIHQuaXNFeHBvcnRCYXRjaFNwZWNpZmllcihzcGVjaWZpZXJzWzBdKSkge1xuICAgICAgcHJpbnQoc3BlY2lmaWVyc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChcIntcIik7XG4gICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgICBwcmludC5qb2luKHNwZWNpZmllcnMsIHsgc2VwYXJhdG9yOiBcIiwgXCIgfSk7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICB0aGlzLnB1c2goXCIgZnJvbSBcIik7XG4gICAgICBwcmludChub2RlLnNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lbnN1cmVTZW1pY29sb24oKTtcbn07XG5cbmV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucHVzaChcImltcG9ydCBcIik7XG5cbiAgdmFyIHNwZWNmaWVycyA9IG5vZGUuc3BlY2lmaWVycztcbiAgaWYgKHNwZWNmaWVycyAmJiBzcGVjZmllcnMubGVuZ3RoKSB7XG4gICAgdmFyIGZvdW5kSW1wb3J0U3BlY2lmaWVyID0gZmFsc2U7XG5cbiAgICBlYWNoKG5vZGUuc3BlY2lmaWVycywgZnVuY3Rpb24gKHNwZWMsIGkpIHtcbiAgICAgIGlmICgraSA+IDApIHtcbiAgICAgICAgc2VsZi5wdXNoKFwiLCBcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0RlZmF1bHQgPSB0LmlzU3BlY2lmaWVyRGVmYXVsdChzcGVjKTtcblxuICAgICAgaWYgKCFpc0RlZmF1bHQgJiYgc3BlYy50eXBlICE9PSBcIkltcG9ydEJhdGNoU3BlY2lmaWVyXCIgJiYgIWZvdW5kSW1wb3J0U3BlY2lmaWVyKSB7XG4gICAgICAgIGZvdW5kSW1wb3J0U3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5wdXNoKFwieyBcIik7XG4gICAgICB9XG5cbiAgICAgIHByaW50KHNwZWMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGZvdW5kSW1wb3J0U3BlY2lmaWVyKSB7XG4gICAgICB0aGlzLnB1c2goXCIgfVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2goXCIgZnJvbSBcIik7XG4gIH1cblxuICBwcmludChub2RlLnNvdXJjZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5leHBvcnRzLkltcG9ydEJhdGNoU3BlY2lmaWVyID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMucHVzaChcIiogYXMgXCIpO1xuICBwcmludChub2RlLm5hbWUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZWFjaCA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9lYWNoXCIpO1xuXG5lYWNoKFtcIkJpbmRNZW1iZXJFeHByZXNzaW9uXCIsIFwiQmluZEZ1bmN0aW9uRXhwcmVzc2lvblwiXSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgZXhwb3J0c1t0eXBlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJUcnlpbmcgdG8gcmVuZGVyIG5vbi1zdGFuZGFyZCBwbGF5Z3JvdW5kIG5vZGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSk7XG4gIH07XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVwZWF0aW5nID0gcmVxdWlyZShcInJlcGVhdGluZ1wiKTtcbnZhciB0ICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLmtleXdvcmQoXCJ3aXRoXCIpO1xuICB0aGlzLnB1c2goXCIoXCIpO1xuICBwcmludChub2RlLm9iamVjdCk7XG4gIHRoaXMucHVzaChcIilcIik7XG4gIHByaW50LmJsb2NrKG5vZGUuYm9keSk7XG59O1xuXG5leHBvcnRzLklmU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMua2V5d29yZChcImlmXCIpO1xuICB0aGlzLnB1c2goXCIoXCIpO1xuICBwcmludChub2RlLnRlc3QpO1xuICB0aGlzLnB1c2goXCIpXCIpO1xuICB0aGlzLnNwYWNlKCk7XG5cbiAgcHJpbnQuaW5kZW50T25Db21tZW50cyhub2RlLmNvbnNlcXVlbnQpO1xuXG4gIGlmIChub2RlLmFsdGVybmF0ZSkge1xuICAgIGlmICh0aGlzLmlzTGFzdChcIn1cIikpIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLmtleXdvcmQoXCJlbHNlXCIpO1xuXG4gICAgaWYgKHRoaXMuZm9ybWF0LmZvcm1hdCAmJiAhdC5pc0Jsb2NrU3RhdGVtZW50KG5vZGUuYWx0ZXJuYXRlKSkge1xuICAgICAgdGhpcy5wdXNoKFwiIFwiKTtcbiAgICB9XG5cbiAgICBwcmludC5pbmRlbnRPbkNvbW1lbnRzKG5vZGUuYWx0ZXJuYXRlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5rZXl3b3JkKFwiZm9yXCIpO1xuICB0aGlzLnB1c2goXCIoXCIpO1xuXG4gIHByaW50KG5vZGUuaW5pdCk7XG4gIHRoaXMucHVzaChcIjtcIik7XG5cbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMucHVzaChcIiBcIik7XG4gICAgcHJpbnQobm9kZS50ZXN0KTtcbiAgfVxuICB0aGlzLnB1c2goXCI7XCIpO1xuXG4gIGlmIChub2RlLnVwZGF0ZSkge1xuICAgIHRoaXMucHVzaChcIiBcIik7XG4gICAgcHJpbnQobm9kZS51cGRhdGUpO1xuICB9XG5cbiAgdGhpcy5wdXNoKFwiKVwiKTtcbiAgcHJpbnQuYmxvY2sobm9kZS5ib2R5KTtcbn07XG5cbmV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5rZXl3b3JkKFwid2hpbGVcIik7XG4gIHRoaXMucHVzaChcIihcIik7XG4gIHByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMucHVzaChcIilcIik7XG4gIHByaW50LmJsb2NrKG5vZGUuYm9keSk7XG59O1xuXG52YXIgYnVpbGRGb3JYU3RhdGVtZW50ID0gZnVuY3Rpb24gKG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgICB0aGlzLmtleXdvcmQoXCJmb3JcIik7XG4gICAgdGhpcy5wdXNoKFwiKFwiKTtcbiAgICBwcmludChub2RlLmxlZnQpO1xuICAgIHRoaXMucHVzaChcIiBcIiArIG9wICsgXCIgXCIpO1xuICAgIHByaW50KG5vZGUucmlnaHQpO1xuICAgIHRoaXMucHVzaChcIilcIik7XG4gICAgcHJpbnQuYmxvY2sobm9kZS5ib2R5KTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBidWlsZEZvclhTdGF0ZW1lbnQoXCJpblwiKTtcbmV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBidWlsZEZvclhTdGF0ZW1lbnQoXCJvZlwiKTtcblxuZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMua2V5d29yZChcImRvXCIpO1xuICBwcmludChub2RlLmJvZHkpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMua2V5d29yZChcIndoaWxlXCIpO1xuICB0aGlzLnB1c2goXCIoXCIpO1xuICBwcmludChub2RlLnRlc3QpO1xuICB0aGlzLnB1c2goXCIpO1wiKTtcbn07XG5cbnZhciBidWlsZExhYmVsU3RhdGVtZW50ID0gZnVuY3Rpb24gKHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgICB0aGlzLnB1c2gocHJlZml4KTtcblxuICAgIHZhciBsYWJlbCA9IG5vZGVba2V5IHx8IFwibGFiZWxcIl07XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLnB1c2goXCIgXCIpO1xuICAgICAgcHJpbnQobGFiZWwpO1xuICAgIH1cblxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH07XG59O1xuXG5leHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gYnVpbGRMYWJlbFN0YXRlbWVudChcImNvbnRpbnVlXCIpO1xuZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgICA9IGJ1aWxkTGFiZWxTdGF0ZW1lbnQoXCJyZXR1cm5cIiwgXCJhcmd1bWVudFwiKTtcbmV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgICAgPSBidWlsZExhYmVsU3RhdGVtZW50KFwiYnJlYWtcIik7XG5cbmV4cG9ydHMuTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBwcmludChub2RlLmxhYmVsKTtcbiAgdGhpcy5wdXNoKFwiOiBcIik7XG4gIHByaW50KG5vZGUuYm9keSk7XG59O1xuXG5leHBvcnRzLlRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLmtleXdvcmQoXCJ0cnlcIik7XG4gIHByaW50KG5vZGUuYmxvY2spO1xuICB0aGlzLnNwYWNlKCk7XG5cbiAgLy8gRXNwcmltYSBidWcgcHV0cyB0aGUgY2F0Y2ggY2xhdXNlIGluIGEgYGhhbmRsZXJzYCBhcnJheS5cbiAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZXNwcmltYS9pc3N1ZXMvZGV0YWlsP2lkPTQzM1xuICAvLyBXZSBydW4gaW50byB0aGlzIGZyb20gcmVnZW5lcmF0b3IgZ2VuZXJhdGVkIGFzdC5cbiAgaWYgKG5vZGUuaGFuZGxlcnMpIHtcbiAgICBwcmludChub2RlLmhhbmRsZXJzWzBdKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludChub2RlLmhhbmRsZXIpO1xuICB9XG5cbiAgaWYgKG5vZGUuZmluYWxpemVyKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHVzaChcImZpbmFsbHkgXCIpO1xuICAgIHByaW50KG5vZGUuZmluYWxpemVyKTtcbiAgfVxufTtcblxuZXhwb3J0cy5DYXRjaENsYXVzZSA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLmtleXdvcmQoXCJjYXRjaFwiKTtcbiAgdGhpcy5wdXNoKFwiKFwiKTtcbiAgcHJpbnQobm9kZS5wYXJhbSk7XG4gIHRoaXMucHVzaChcIikgXCIpO1xuICBwcmludChub2RlLmJvZHkpO1xufTtcblxuZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2goXCJ0aHJvdyBcIik7XG4gIHByaW50KG5vZGUuYXJndW1lbnQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufTtcblxuZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5rZXl3b3JkKFwic3dpdGNoXCIpO1xuICB0aGlzLnB1c2goXCIoXCIpO1xuICBwcmludChub2RlLmRpc2NyaW1pbmFudCk7XG4gIHRoaXMucHVzaChcIilcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wdXNoKFwie1wiKTtcbiAgcHJpbnQuc2VxdWVuY2Uobm9kZS5jYXNlcywgeyBpbmRlbnQ6IHRydWUgfSk7XG4gIHRoaXMucHVzaChcIn1cIik7XG59O1xuXG5leHBvcnRzLlN3aXRjaENhc2UgPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMucHVzaChcImNhc2UgXCIpO1xuICAgIHByaW50KG5vZGUudGVzdCk7XG4gICAgdGhpcy5wdXNoKFwiOlwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnB1c2goXCJkZWZhdWx0OlwiKTtcbiAgfVxuXG4gIHRoaXMubmV3bGluZSgpO1xuICBwcmludC5zZXF1ZW5jZShub2RlLmNvbnNlcXVlbnQsIHsgaW5kZW50OiB0cnVlIH0pO1xufTtcblxuZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wdXNoKFwiZGVidWdnZXI7XCIpO1xufTtcblxuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHByaW50LCBwYXJlbnQpIHtcbiAgdGhpcy5wdXNoKG5vZGUua2luZCArIFwiIFwiKTtcblxuICB2YXIgaGFzSW5pdHMgPSBmYWxzZTtcbiAgLy8gZG9uJ3QgYWRkIHdoaXRlc3BhY2UgdG8gbG9vcCBoZWFkc1xuICBpZiAoIXQuaXNGb3IocGFyZW50KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uc1tpXS5pbml0KSB7XG4gICAgICAgIC8vIGhhcyBhbiBpbml0IHNvIGxldCdzIHNwbGl0IGl0IHVwIG92ZXIgbXVsdGlwbGUgbGluZXNcbiAgICAgICAgaGFzSW5pdHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzZXAgPSBcIixcIjtcbiAgaWYgKGhhc0luaXRzKSB7XG4gICAgc2VwICs9IFwiXFxuXCIgKyByZXBlYXRpbmcoXCIgXCIsIG5vZGUua2luZC5sZW5ndGggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBzZXAgKz0gXCIgXCI7XG4gIH1cblxuICBwcmludC5saXN0KG5vZGUuZGVjbGFyYXRpb25zLCB7IHNlcGFyYXRvcjogc2VwIH0pO1xuXG4gIGlmICghdC5pc0ZvcihwYXJlbnQpKSB7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxufTtcblxuZXhwb3J0cy5Qcml2YXRlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgdGhpcy5wdXNoKFwicHJpdmF0ZSBcIik7XG4gIHByaW50LmpvaW4obm9kZS5kZWNsYXJhdGlvbnMsIHsgc2VwYXJhdG9yOiBcIiwgXCIgfSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICBpZiAobm9kZS5pbml0KSB7XG4gICAgcHJpbnQobm9kZS5pZCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHVzaChcIj1cIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHByaW50KG5vZGUuaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnQobm9kZS5pZCk7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVhY2ggPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcblxuZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgcHJpbnQobm9kZS50YWcpO1xuICBwcmludChub2RlLnF1YXNpKTtcbn07XG5cbmV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5fcHVzaChub2RlLnZhbHVlLnJhdyk7XG59O1xuXG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB0aGlzLnB1c2goXCJgXCIpO1xuXG4gIHZhciBxdWFzaXMgPSBub2RlLnF1YXNpcztcbiAgdmFyIHNlbGYgICA9IHRoaXM7XG4gIHZhciBsZW4gICAgPSBxdWFzaXMubGVuZ3RoO1xuXG4gIGVhY2gocXVhc2lzLCBmdW5jdGlvbiAocXVhc2ksIGkpIHtcbiAgICBwcmludChxdWFzaSk7XG5cbiAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgIHNlbGYucHVzaChcIiR7IFwiKTtcbiAgICAgIHByaW50KG5vZGUuZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgc2VsZi5wdXNoKFwiIH1cIik7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLl9wdXNoKFwiYFwiKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVhY2ggPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcblxuZXhwb3J0cy5JZGVudGlmaWVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5wdXNoKG5vZGUubmFtZSk7XG59O1xuXG5leHBvcnRzLlJlc3RFbGVtZW50ID1cbmV4cG9ydHMuU3ByZWFkRWxlbWVudCA9XG5leHBvcnRzLlNwcmVhZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHRoaXMucHVzaChcIi4uLlwiKTtcbiAgcHJpbnQobm9kZS5hcmd1bWVudCk7XG59O1xuXG5leHBvcnRzLlZpcnR1YWxQcm9wZXJ0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcHJpbnQpIHtcbiAgcHJpbnQobm9kZS5vYmplY3QpO1xuICB0aGlzLnB1c2goXCI6OlwiKTtcbiAgcHJpbnQobm9kZS5wcm9wZXJ0eSk7XG59O1xuXG5leHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPVxuZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIHZhciBwcm9wcyA9IG5vZGUucHJvcGVydGllcztcblxuICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgdGhpcy5wdXNoKFwie1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG5cbiAgICBwcmludC5saXN0KHByb3BzLCB7IGluZGVudDogdHJ1ZSB9KTtcblxuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnB1c2goXCJ9XCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHVzaChcInt9XCIpO1xuICB9XG59O1xuXG5leHBvcnRzLlByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHByaW50KSB7XG4gIGlmIChub2RlLm1ldGhvZCB8fCBub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKSB7XG4gICAgdGhpcy5fbWV0aG9kKG5vZGUsIHByaW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgdGhpcy5wdXNoKFwiW1wiKTtcbiAgICAgIHByaW50KG5vZGUua2V5KTtcbiAgICAgIHRoaXMucHVzaChcIl1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KG5vZGUua2V5KTtcbiAgICAgIGlmIChub2RlLnNob3J0aGFuZCkgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHVzaChcIjpcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHByaW50KG5vZGUudmFsdWUpO1xuICB9XG59O1xuXG5leHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9XG5leHBvcnRzLkFycmF5UGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBwcmludCkge1xuICB2YXIgZWxlbXMgPSBub2RlLmVsZW1lbnRzO1xuICB2YXIgc2VsZiAgPSB0aGlzO1xuICB2YXIgbGVuICAgPSBlbGVtcy5sZW5ndGg7XG5cbiAgdGhpcy5wdXNoKFwiW1wiKTtcblxuICBlYWNoKGVsZW1zLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgIGlmICghZWxlbSkge1xuICAgICAgLy8gSWYgdGhlIGFycmF5IGV4cHJlc3Npb24gZW5kcyB3aXRoIGEgaG9sZSwgdGhhdCBob2xlXG4gICAgICAvLyB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGludGVycHJldGVyLCBidXQgaWYgaXQgZW5kcyB3aXRoXG4gICAgICAvLyB0d28gKG9yIG1vcmUpIGhvbGVzLCB3ZSBuZWVkIHRvIHdyaXRlIG91dCB0d28gKG9yIG1vcmUpXG4gICAgICAvLyBjb21tYXMgc28gdGhhdCB0aGUgcmVzdWx0aW5nIGNvZGUgaXMgaW50ZXJwcmV0ZWQgd2l0aFxuICAgICAgLy8gYm90aCAoYWxsKSBvZiB0aGUgaG9sZXMuXG4gICAgICBzZWxmLnB1c2goXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA+IDAgJiYgIXNlbGYuZm9ybWF0LmNvbXBhY3QpIHNlbGYucHVzaChcIiBcIik7XG4gICAgICBwcmludChlbGVtKTtcbiAgICAgIGlmIChpIDwgbGVuIC0gMSkgc2VsZi5wdXNoKFwiLFwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMucHVzaChcIl1cIik7XG59O1xuXG5leHBvcnRzLkxpdGVyYWwgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgdmFsICA9IG5vZGUudmFsdWU7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cbiAgICAvLyBlc2NhcGUgaWxsZWdhbCBqcyBidXQgdmFsaWQganNvbiB1bmljb2RlIGNoYXJhY3RlcnNcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvW1xcdTAwMEFcXHUwMDBEXFx1MjAyOFxcdTIwMjldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gXCJcXFxcdVwiICsgKFwiMDAwMFwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wdXNoKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHRoaXMucHVzaCh2YWwgKyBcIlwiKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHRoaXMucHVzaCh2YWwgPyBcInRydWVcIiA6IFwiZmFsc2VcIik7XG4gIH0gZWxzZSBpZiAobm9kZS5yZWdleCkge1xuICAgIHRoaXMucHVzaChcIi9cIiArIG5vZGUucmVnZXgucGF0dGVybiArIFwiL1wiICsgbm9kZS5yZWdleC5mbGFncyk7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdGhpcy5wdXNoKFwibnVsbFwiKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhc3QsIG9wdHMsIGNvZGUpIHtcbiAgdmFyIGdlbiA9IG5ldyBDb2RlR2VuZXJhdG9yKGFzdCwgb3B0cywgY29kZSk7XG4gIHJldHVybiBnZW4uZ2VuZXJhdGUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvZGVHZW5lcmF0b3IgPSBDb2RlR2VuZXJhdG9yO1xuXG52YXIgZGV0ZWN0SW5kZW50ID0gcmVxdWlyZShcImRldGVjdC1pbmRlbnRcIik7XG52YXIgV2hpdGVzcGFjZSAgID0gcmVxdWlyZShcIi4vd2hpdGVzcGFjZVwiKTtcbnZhciByZXBlYXRpbmcgICAgPSByZXF1aXJlKFwicmVwZWF0aW5nXCIpO1xudmFyIFNvdXJjZU1hcCAgICA9IHJlcXVpcmUoXCIuL3NvdXJjZS1tYXBcIik7XG52YXIgUG9zaXRpb24gICAgID0gcmVxdWlyZShcIi4vcG9zaXRpb25cIik7XG52YXIgQnVmZmVyICAgICAgID0gcmVxdWlyZShcIi4vYnVmZmVyXCIpO1xudmFyIGV4dGVuZCAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvb2JqZWN0L2V4dGVuZFwiKTtcbnZhciBtZXJnZSAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC9tZXJnZVwiKTtcbnZhciBlYWNoICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciBuICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xudmFyIHQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gQ29kZUdlbmVyYXRvcihhc3QsIG9wdHMsIGNvZGUpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdGhpcy5jb21tZW50cyA9IGFzdC5jb21tZW50cyB8fCBbXTtcbiAgdGhpcy50b2tlbnMgICA9IGFzdC50b2tlbnMgfHwgW107XG4gIHRoaXMuZm9ybWF0ICAgPSBDb2RlR2VuZXJhdG9yLm5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cyk7XG4gIHRoaXMub3B0cyAgICAgPSBvcHRzO1xuICB0aGlzLmFzdCAgICAgID0gYXN0O1xuXG4gIHRoaXMud2hpdGVzcGFjZSA9IG5ldyBXaGl0ZXNwYWNlKHRoaXMudG9rZW5zLCB0aGlzLmNvbW1lbnRzKTtcbiAgdGhpcy5wb3NpdGlvbiAgID0gbmV3IFBvc2l0aW9uO1xuICB0aGlzLm1hcCAgICAgICAgPSBuZXcgU291cmNlTWFwKHRoaXMucG9zaXRpb24sIG9wdHMsIGNvZGUpO1xuICB0aGlzLmJ1ZmZlciAgICAgPSBuZXcgQnVmZmVyKHRoaXMucG9zaXRpb24sIHRoaXMuZm9ybWF0KTtcbn1cblxuZWFjaChCdWZmZXIucHJvdG90eXBlLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLmJ1ZmZlciwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5Db2RlR2VuZXJhdG9yLm5vcm1hbGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiAoY29kZSwgb3B0cykge1xuICB2YXIgc3R5bGUgPSBcIiAgXCI7XG4gIGlmIChjb2RlKSB7XG4gICAgdmFyIGluZGVudCA9IGRldGVjdEluZGVudChjb2RlKS5pbmRlbnQ7XG4gICAgaWYgKGluZGVudCAmJiBpbmRlbnQgIT09IFwiIFwiKSBzdHlsZSA9IGluZGVudDtcbiAgfVxuXG4gIHJldHVybiBtZXJnZSh7XG4gICAgcGFyZW50aGVzZXM6IHRydWUsXG4gICAgY29tbWVudHM6IG9wdHMuY29tbWVudHMgPT0gbnVsbCB8fCBvcHRzLmNvbW1lbnRzLFxuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIGNvbmNpc2U6IGZhbHNlLFxuICAgIGluZGVudDoge1xuICAgICAgYWRqdXN0TXVsdGlsaW5lQ29tbWVudDogdHJ1ZSxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIGJhc2U6IDBcbiAgICB9XG4gIH0sIG9wdHMuZm9ybWF0IHx8IHt9KTtcbn07XG5cbkNvZGVHZW5lcmF0b3IuZ2VuZXJhdG9ycyA9IHtcbiAgdGVtcGxhdGVMaXRlcmFsczogcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy90ZW1wbGF0ZS1saXRlcmFsc1wiKSxcbiAgY29tcHJlaGVuc2lvbnM6ICAgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9jb21wcmVoZW5zaW9uc1wiKSxcbiAgZXhwcmVzc2lvbnM6ICAgICAgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9leHByZXNzaW9uc1wiKSxcbiAgc3RhdGVtZW50czogICAgICAgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9zdGF0ZW1lbnRzXCIpLFxuICBwbGF5Z3JvdW5kOiAgICAgICByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL3BsYXlncm91bmRcIiksXG4gIGNsYXNzZXM6ICAgICAgICAgIHJlcXVpcmUoXCIuL2dlbmVyYXRvcnMvY2xhc3Nlc1wiKSxcbiAgbWV0aG9kczogICAgICAgICAgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9tZXRob2RzXCIpLFxuICBtb2R1bGVzOiAgICAgICAgICByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL21vZHVsZXNcIiksXG4gIHR5cGVzOiAgICAgICAgICAgIHJlcXVpcmUoXCIuL2dlbmVyYXRvcnMvdHlwZXNcIiksXG4gIGZsb3c6ICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2dlbmVyYXRvcnMvZmxvd1wiKSxcbiAgYmFzZTogICAgICAgICAgICAgcmVxdWlyZShcIi4vZ2VuZXJhdG9ycy9iYXNlXCIpLFxuICBqc3g6ICAgICAgICAgICAgICByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL2pzeFwiKVxufTtcblxuZWFjaChDb2RlR2VuZXJhdG9yLmdlbmVyYXRvcnMsIGZ1bmN0aW9uIChnZW5lcmF0b3IpIHtcbiAgZXh0ZW5kKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBnZW5lcmF0b3IpO1xufSk7XG5cbkNvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXN0ID0gdGhpcy5hc3Q7XG5cbiAgdGhpcy5wcmludChhc3QpO1xuXG4gIHZhciBjb21tZW50cyA9IFtdO1xuICBlYWNoKGFzdC5jb21tZW50cywgZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICBpZiAoIWNvbW1lbnQuX2Rpc3BsYXllZCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgfSk7XG4gIHRoaXMuX3ByaW50Q29tbWVudHMoY29tbWVudHMpO1xuXG4gIHJldHVybiB7XG4gICAgbWFwOiAgdGhpcy5tYXAuZ2V0KCksXG4gICAgY29kZTogdGhpcy5idWZmZXIuZ2V0KClcbiAgfTtcbn07XG5cbkNvZGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUHJpbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgcHJpbnQgPSBmdW5jdGlvbiAobm9kZSwgb3B0cykge1xuICAgIHJldHVybiBzZWxmLnByaW50KG5vZGUsIHBhcmVudCwgb3B0cyk7XG4gIH07XG5cbiAgcHJpbnQuc2VxdWVuY2UgPSBmdW5jdGlvbiAobm9kZXMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBvcHRzLnN0YXRlbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIHNlbGYucHJpbnRKb2luKHByaW50LCBub2Rlcywgb3B0cyk7XG4gIH07XG5cbiAgcHJpbnQuam9pbiA9IGZ1bmN0aW9uIChub2Rlcywgb3B0cykge1xuICAgIHJldHVybiBzZWxmLnByaW50Sm9pbihwcmludCwgbm9kZXMsIG9wdHMpO1xuICB9O1xuXG4gIHByaW50Lmxpc3QgPSBmdW5jdGlvbiAoaXRlbXMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBzZXAgPSBvcHRzLnNlcGFyYXRvciB8fCBcIiwgXCI7XG4gICAgaWYgKHNlbGYuZm9ybWF0LmNvbXBhY3QpIHNlcCA9IFwiLFwiO1xuICAgIG9wdHMuc2VwYXJhdG9yID0gc2VwO1xuXG4gICAgcHJpbnQuam9pbihpdGVtcywgb3B0cyk7XG4gIH07XG5cbiAgcHJpbnQuYmxvY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBzZWxmLnByaW50QmxvY2socHJpbnQsIG5vZGUpO1xuICB9O1xuXG4gIHByaW50LmluZGVudE9uQ29tbWVudHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBzZWxmLnByaW50QW5kSW5kZW50T25Db21tZW50cyhwcmludCwgbm9kZSk7XG4gIH07XG5cbiAgcmV0dXJuIHByaW50O1xufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIFwiXCI7XG5cbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX2NvbXBhY3QpIHtcbiAgICBub2RlLl9jb21wYWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBvbGRDb25jaXNlID0gdGhpcy5mb3JtYXQuY29uY2lzZTtcbiAgaWYgKG5vZGUuX2NvbXBhY3QpIHtcbiAgICB0aGlzLmZvcm1hdC5jb25jaXNlID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgbmV3bGluZSA9IGZ1bmN0aW9uIChsZWFkaW5nKSB7XG4gICAgaWYgKCFvcHRzLnN0YXRlbWVudCAmJiAhbi5pc1VzZXJXaGl0ZXNwYWNhYmxlKG5vZGUsIHBhcmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSAwO1xuXG4gICAgaWYgKG5vZGUuc3RhcnQgIT0gbnVsbCAmJiAhbm9kZS5faWdub3JlVXNlcldoaXRlc3BhY2UpIHtcbiAgICAgIC8vIHVzZXIgbm9kZVxuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgbGluZXMgPSBzZWxmLndoaXRlc3BhY2UuZ2V0TmV3bGluZXNCZWZvcmUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcyA9IHNlbGYud2hpdGVzcGFjZS5nZXROZXdsaW5lc0FmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZW5lcmF0ZWQgbm9kZVxuICAgICAgaWYgKCFsZWFkaW5nKSBsaW5lcysrOyAvLyBhbHdheXMgaW5jbHVkZSBhdCBsZWFzdCBhIHNpbmdsZSBsaW5lIGFmdGVyXG5cbiAgICAgIHZhciBuZWVkcyA9IG4ubmVlZHNXaGl0ZXNwYWNlQWZ0ZXI7XG4gICAgICBpZiAobGVhZGluZykgbmVlZHMgPSBuLm5lZWRzV2hpdGVzcGFjZUJlZm9yZTtcbiAgICAgIGxpbmVzICs9IG5lZWRzKG5vZGUsIHBhcmVudCk7XG5cbiAgICAgIC8vIGdlbmVyYXRlZCBub2RlcyBjYW4ndCBhZGQgc3RhcnRpbmcgZmlsZSB3aGl0ZXNwYWNlXG4gICAgICBpZiAoIXNlbGYuYnVmZmVyLmdldCgpKSBsaW5lcyA9IDA7XG4gICAgfVxuXG4gICAgc2VsZi5uZXdsaW5lKGxpbmVzKTtcbiAgfTtcblxuICBpZiAodGhpc1tub2RlLnR5cGVdKSB7XG4gICAgdmFyIG5lZWRzTm9MaW5lVGVybVBhcmVucyA9IG4ubmVlZHNQYXJlbnNOb0xpbmVUZXJtaW5hdG9yKG5vZGUsIHBhcmVudCk7XG4gICAgdmFyIG5lZWRzUGFyZW5zICAgICAgICAgICA9IG5lZWRzTm9MaW5lVGVybVBhcmVucyB8fCBuLm5lZWRzUGFyZW5zKG5vZGUsIHBhcmVudCk7XG5cbiAgICBpZiAobmVlZHNQYXJlbnMpIHRoaXMucHVzaChcIihcIik7XG4gICAgaWYgKG5lZWRzTm9MaW5lVGVybVBhcmVucykgdGhpcy5pbmRlbnQoKTtcblxuICAgIHRoaXMucHJpbnRMZWFkaW5nQ29tbWVudHMobm9kZSwgcGFyZW50KTtcblxuICAgIG5ld2xpbmUodHJ1ZSk7XG5cbiAgICBpZiAob3B0cy5iZWZvcmUpIG9wdHMuYmVmb3JlKCk7XG4gICAgdGhpcy5tYXAubWFyayhub2RlLCBcInN0YXJ0XCIpO1xuXG4gICAgdGhpc1tub2RlLnR5cGVdKG5vZGUsIHRoaXMuYnVpbGRQcmludChub2RlKSwgcGFyZW50KTtcblxuICAgIGlmIChuZWVkc05vTGluZVRlcm1QYXJlbnMpIHtcbiAgICAgIHRoaXMubmV3bGluZSgpO1xuICAgICAgdGhpcy5kZWRlbnQoKTtcbiAgICB9XG4gICAgaWYgKG5lZWRzUGFyZW5zKSB0aGlzLnB1c2goXCIpXCIpO1xuXG4gICAgdGhpcy5tYXAubWFyayhub2RlLCBcImVuZFwiKTtcbiAgICBpZiAob3B0cy5hZnRlcikgb3B0cy5hZnRlcigpO1xuXG4gICAgbmV3bGluZShmYWxzZSk7XG5cbiAgICB0aGlzLnByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInVua25vd24gbm9kZSBvZiB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkobm9kZS50eXBlKSArIFwiIHdpdGggY29uc3RydWN0b3IgXCIgKyBKU09OLnN0cmluZ2lmeShub2RlICYmIG5vZGUuY29uc3RydWN0b3IubmFtZSkpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQuY29uY2lzZSA9IG9sZENvbmNpc2U7XG59O1xuXG5Db2RlR2VuZXJhdG9yLnByb3RvdHlwZS5wcmludEpvaW4gPSBmdW5jdGlvbiAocHJpbnQsIG5vZGVzLCBvcHRzKSB7XG4gIGlmICghbm9kZXMgfHwgIW5vZGVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxlbiAgPSBub2Rlcy5sZW5ndGg7XG5cbiAgaWYgKG9wdHMuaW5kZW50KSBzZWxmLmluZGVudCgpO1xuXG4gIGVhY2gobm9kZXMsIGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgcHJpbnQobm9kZSwge1xuICAgICAgc3RhdGVtZW50OiBvcHRzLnN0YXRlbWVudCxcbiAgICAgIGFmdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRzLml0ZXJhdG9yKSB7XG4gICAgICAgICAgb3B0cy5pdGVyYXRvcihub2RlLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLnNlcGFyYXRvciAmJiBpIDwgbGVuIC0gMSkge1xuICAgICAgICAgIHNlbGYucHVzaChvcHRzLnNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuaW5kZW50KSBzZWxmLmRlZGVudCgpO1xufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUucHJpbnRBbmRJbmRlbnRPbkNvbW1lbnRzID0gZnVuY3Rpb24gKHByaW50LCBub2RlKSB7XG4gIHZhciBpbmRlbnQgPSAhIW5vZGUubGVhZGluZ0NvbW1lbnRzO1xuICBpZiAoaW5kZW50KSB0aGlzLmluZGVudCgpO1xuICBwcmludChub2RlKTtcbiAgaWYgKGluZGVudCkgdGhpcy5kZWRlbnQoKTtcbn07XG5cbkNvZGVHZW5lcmF0b3IucHJvdG90eXBlLnByaW50QmxvY2sgPSBmdW5jdGlvbiAocHJpbnQsIG5vZGUpIHtcbiAgaWYgKHQuaXNFbXB0eVN0YXRlbWVudChub2RlKSkge1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wdXNoKFwiIFwiKTtcbiAgICBwcmludChub2RlKTtcbiAgfVxufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgdmFyIHZhbCA9IGNvbW1lbnQudmFsdWU7XG4gIGlmIChjb21tZW50LnR5cGUgPT09IFwiTGluZVwiKSB7XG4gICAgdmFsID0gXCIvL1wiICsgdmFsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IFwiLypcIiArIHZhbCArIFwiKi9cIjtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUucHJpbnRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLl9wcmludENvbW1lbnRzKHRoaXMuZ2V0Q29tbWVudHMoXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIG5vZGUsIHBhcmVudCkpO1xufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUucHJpbnRMZWFkaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIHRoaXMuX3ByaW50Q29tbWVudHModGhpcy5nZXRDb21tZW50cyhcImxlYWRpbmdDb21tZW50c1wiLCBub2RlLCBwYXJlbnQpKTtcbn07XG5cbkNvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdldENvbW1lbnRzID0gZnVuY3Rpb24gKGtleSwgbm9kZSwgcGFyZW50KSB7XG4gIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNvbW1lbnRzID0gW107XG4gIHZhciBub2RlcyAgICA9IFtub2RlXTtcbiAgdmFyIHNlbGYgICAgID0gdGhpcztcblxuICBpZiAodC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUuYXJndW1lbnQpO1xuICB9XG5cbiAgZWFjaChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChzZWxmLl9nZXRDb21tZW50cyhrZXksIG5vZGUpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbW1lbnRzO1xufTtcblxuQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuX2dldENvbW1lbnRzID0gZnVuY3Rpb24gKGtleSwgbm9kZSkge1xuICByZXR1cm4gKG5vZGUgJiYgbm9kZVtrZXldKSB8fCBbXTtcbn07XG5cbkNvZGVHZW5lcmF0b3IucHJvdG90eXBlLl9wcmludENvbW1lbnRzID0gZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gIGlmICh0aGlzLmZvcm1hdC5jb21wYWN0KSByZXR1cm47XG4gIGlmICghdGhpcy5mb3JtYXQuY29tbWVudHMpIHJldHVybjtcbiAgaWYgKCFjb21tZW50cyB8fCAhY29tbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGVhY2goY29tbWVudHMsIGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgdmFyIHNraXAgPSBmYWxzZTtcblxuICAgIC8vIGZpbmQgdGhlIG9yaWdpbmFsIGNvbW1lbnQgaW4gdGhlIGFzdCBhbmQgc2V0IGl0IGFzIGRpc3BsYXllZFxuICAgIGVhY2goc2VsZi5hc3QuY29tbWVudHMsIGZ1bmN0aW9uIChvcmlnQ29tbWVudCkge1xuICAgICAgaWYgKG9yaWdDb21tZW50LnN0YXJ0ID09PSBjb21tZW50LnN0YXJ0KSB7XG4gICAgICAgIC8vIGNvbW1lbnQgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXRcbiAgICAgICAgaWYgKG9yaWdDb21tZW50Ll9kaXNwbGF5ZWQpIHNraXAgPSB0cnVlO1xuXG4gICAgICAgIG9yaWdDb21tZW50Ll9kaXNwbGF5ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2tpcCkgcmV0dXJuO1xuXG4gICAgLy8gd2hpdGVzcGFjZSBiZWZvcmVcbiAgICBzZWxmLm5ld2xpbmUoc2VsZi53aGl0ZXNwYWNlLmdldE5ld2xpbmVzQmVmb3JlKGNvbW1lbnQpKTtcblxuICAgIHZhciBjb2x1bW4gPSBzZWxmLnBvc2l0aW9uLmNvbHVtbjtcbiAgICB2YXIgdmFsICAgID0gc2VsZi5nZW5lcmF0ZUNvbW1lbnQoY29tbWVudCk7XG5cbiAgICBpZiAoY29sdW1uICYmICFzZWxmLmlzTGFzdChbXCJcXG5cIiwgXCIgXCIsIFwiW1wiLCBcIntcIl0pKSB7XG4gICAgICBzZWxmLl9wdXNoKFwiIFwiKTtcbiAgICAgIGNvbHVtbisrO1xuICAgIH1cblxuICAgIC8vXG5cbiAgICBpZiAoY29tbWVudC50eXBlID09PSBcIkJsb2NrXCIgJiYgc2VsZi5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBjb21tZW50LmxvYy5zdGFydC5jb2x1bW47XG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBuZXdsaW5lUmVnZXggPSBuZXcgUmVnRXhwKFwiXFxcXG5cXFxcc3sxLFwiICsgb2Zmc2V0ICsgXCJ9XCIsIFwiZ1wiKTtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UobmV3bGluZVJlZ2V4LCBcIlxcblwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudCA9IE1hdGgubWF4KHNlbGYuaW5kZW50U2l6ZSgpLCBjb2x1bW4pO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcbi9nLCBcIlxcblwiICsgcmVwZWF0aW5nKFwiIFwiLCBpbmRlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAoY29sdW1uID09PSAwKSB7XG4gICAgICB2YWwgPSBzZWxmLmdldEluZGVudCgpICsgdmFsO1xuICAgIH1cblxuICAgIC8vXG5cbiAgICBzZWxmLl9wdXNoKHZhbCk7XG5cbiAgICAvLyB3aGl0ZXNwYWNlIGFmdGVyXG4gICAgc2VsZi5uZXdsaW5lKHNlbGYud2hpdGVzcGFjZS5nZXROZXdsaW5lc0FmdGVyKGNvbW1lbnQpKTtcbiAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxudmFyIHdoaXRlc3BhY2UgPSByZXF1aXJlKFwiLi93aGl0ZXNwYWNlXCIpO1xudmFyIHBhcmVucyAgICAgPSByZXF1aXJlKFwiLi9wYXJlbnRoZXNlc1wiKTtcbnZhciB0ICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xudmFyIGVhY2ggICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciBzb21lICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL3NvbWVcIik7XG5cbnZhciBmaW5kID0gZnVuY3Rpb24gKG9iaiwgbm9kZSwgcGFyZW50KSB7XG4gIGlmICghb2JqKSByZXR1cm47XG4gIHZhciByZXN1bHQ7XG5cbiAgdmFyIHR5cGVzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG5cbiAgICBpZiAodC5pcyh0eXBlLCBub2RlKSkge1xuICAgICAgdmFyIGZuID0gb2JqW3R5cGVdO1xuICAgICAgcmVzdWx0ID0gZm4obm9kZSwgcGFyZW50KTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIE5vZGUobm9kZSwgcGFyZW50KSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLm5vZGUgICA9IG5vZGU7XG59XG5cbk5vZGUuaXNVc2VyV2hpdGVzcGFjYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LmlzVXNlcldoaXRlc3BhY2FibGUobm9kZSk7XG59O1xuXG5Ob2RlLm5lZWRzV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHR5cGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gMDtcblxuICBpZiAodC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gZmluZCh3aGl0ZXNwYWNlW3R5cGVdLm5vZGVzLCBub2RlLCBwYXJlbnQpO1xuICBpZiAobGluZXMpIHJldHVybiBsaW5lcztcblxuICBlYWNoKGZpbmQod2hpdGVzcGFjZVt0eXBlXS5saXN0LCBub2RlLCBwYXJlbnQpLCBmdW5jdGlvbiAoZXhwcikge1xuICAgIGxpbmVzID0gTm9kZS5uZWVkc1doaXRlc3BhY2UoZXhwciwgbm9kZSwgdHlwZSk7XG4gICAgaWYgKGxpbmVzKSByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gbGluZXMgfHwgMDtcbn07XG5cbk5vZGUubmVlZHNXaGl0ZXNwYWNlQmVmb3JlID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gTm9kZS5uZWVkc1doaXRlc3BhY2Uobm9kZSwgcGFyZW50LCBcImJlZm9yZVwiKTtcbn07XG5cbk5vZGUubmVlZHNXaGl0ZXNwYWNlQWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiBOb2RlLm5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIFwiYWZ0ZXJcIik7XG59O1xuXG5Ob2RlLm5lZWRzUGFyZW5zID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0LmlzTmV3RXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICBpZiAodC5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBoYXNDYWxsID0gc29tZShub2RlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdC5pc0NhbGxFeHByZXNzaW9uKHZhbCk7XG4gICAgfSk7XG4gICAgaWYgKGhhc0NhbGwpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZpbmQocGFyZW5zLCBub2RlLCBwYXJlbnQpO1xufTtcblxuTm9kZS5uZWVkc1BhcmVuc05vTGluZVRlcm1pbmF0b3IgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIGlmICghcGFyZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gbm8gY29tbWVudHNcbiAgaWYgKCFub2RlLmxlYWRpbmdDb21tZW50cyB8fCAhbm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHQuaXNZaWVsZEV4cHJlc3Npb24ocGFyZW50KSB8fCB0LmlzQXdhaXRFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0LmlzQ29udGludWVTdGF0ZW1lbnQocGFyZW50KSB8fCB0LmlzQnJlYWtTdGF0ZW1lbnQocGFyZW50KSB8fFxuICAgICAgdC5pc1JldHVyblN0YXRlbWVudChwYXJlbnQpIHx8IHQuaXNUaHJvd1N0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5lYWNoKE5vZGUsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gIE5vZGUucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQXZvaWQgbGVha2luZyBhcmd1bWVudHMgdG8gcHJldmVudCBkZW9wdGltaXphdGlvblxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggKyAyKTtcblxuICAgIGFyZ3NbMF0gPSB0aGlzLm5vZGU7XG4gICAgYXJnc1sxXSA9IHRoaXMucGFyZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2kgKyAyXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZVtrZXldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG52YXIgZWFjaCA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9lYWNoXCIpO1xuXG52YXIgUFJFQ0VERU5DRSA9IHt9O1xuXG5lYWNoKFtcbiAgW1wifHxcIl0sXG4gIFtcIiYmXCJdLFxuICBbXCJ8XCJdLFxuICBbXCJeXCJdLFxuICBbXCImXCJdLFxuICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gIFtcIitcIiwgXCItXCJdLFxuICBbXCIqXCIsIFwiL1wiLCBcIiVcIl0sXG4gIFtcIioqXCJdXG5dLCBmdW5jdGlvbiAodGllciwgaSkge1xuICBlYWNoKHRpZXIsIGZ1bmN0aW9uIChvcCkge1xuICAgIFBSRUNFREVOQ0Vbb3BdID0gaTtcbiAgfSk7XG59KTtcblxuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAodC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlKSB7XG4gICAgLy8gKGZvbysrKS50ZXN0KClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAodC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQocGFyZW50KSkge1xuICAgIC8vICh7IGZvbzogXCJiYXJcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGUpIHtcbiAgICAvLyAoeyBmb286IFwiYmFyXCIgfSkuZm9vXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLkJpbmFyeSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCh0LmlzQ2FsbEV4cHJlc3Npb24ocGFyZW50KSB8fCB0LmlzTmV3RXhwcmVzc2lvbihwYXJlbnQpKSAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodC5pc1VuYXJ5TGlrZShwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodC5pc0JpbmFyeShwYXJlbnQpKSB7XG4gICAgdmFyIHBhcmVudE9wICA9IHBhcmVudC5vcGVyYXRvcjtcbiAgICB2YXIgcGFyZW50UG9zID0gUFJFQ0VERU5DRVtwYXJlbnRPcF07XG5cbiAgICB2YXIgbm9kZU9wID0gbm9kZS5vcGVyYXRvcjtcbiAgICB2YXIgbm9kZVBvcyA9IFBSRUNFREVOQ0Vbbm9kZU9wXTtcblxuICAgIGlmIChwYXJlbnRQb3MgPiBub2RlUG9zKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50UG9zID09PSBub2RlUG9zICYmIHBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIGlmIChub2RlLm9wZXJhdG9yID09PSBcImluXCIpIHtcbiAgICAvLyB2YXIgaSA9ICgxIGluIFtdKTtcbiAgICBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRvcihwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmb3IgKCgxIGluIFtdKTs7KTtcbiAgICBpZiAodC5pc0ZvcihwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAodC5pc0ZvclN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgLy8gQWx0aG91Z2ggcGFyZW50aGVzZXMgd291bGRuJ3QgaHVydCBhcm91bmQgc2VxdWVuY2VcbiAgICAvLyBleHByZXNzaW9ucyBpbiB0aGUgaGVhZCBvZiBmb3IgbG9vcHMsIHRyYWRpdGlvbmFsIHN0eWxlXG4gICAgLy8gZGljdGF0ZXMgdGhhdCBlLmcuIGkrKywgaisrIHNob3VsZCBub3QgYmUgd3JhcHBlZCB3aXRoXG4gICAgLy8gcGFyZW50aGVzZXMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KHBhcmVudCkgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPdGhlcndpc2UgZXJyIG9uIHRoZSBzaWRlIG9mIG92ZXJwYXJlbnRoZXNpemF0aW9uLCBhZGRpbmdcbiAgLy8gZXhwbGljaXQgZXhjZXB0aW9ucyBhYm92ZSBpZiB0aGlzIHByb3ZlcyBvdmVyemVhbG91cy5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHQuaXNCaW5hcnkocGFyZW50KSB8fFxuICAgICAgICAgdC5pc1VuYXJ5TGlrZShwYXJlbnQpIHx8XG4gICAgICAgICB0LmlzQ2FsbEV4cHJlc3Npb24ocGFyZW50KSB8fFxuICAgICAgICAgdC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSB8fFxuICAgICAgICAgdC5pc05ld0V4cHJlc3Npb24ocGFyZW50KSB8fFxuICAgICAgICAgdC5pc0NvbmRpdGlvbmFsRXhwcmVzc2lvbihwYXJlbnQpIHx8XG4gICAgICAgICB0LmlzWWllbGRFeHByZXNzaW9uKHBhcmVudCk7XG59O1xuXG5leHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KHBhcmVudCk7XG59O1xuXG5leHBvcnRzLlVuYXJ5TGlrZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHQuaXNNZW1iZXJFeHByZXNzaW9uKHBhcmVudCkgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbn07XG5cbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAvLyBmdW5jdGlvbiAoKSB7fTtcbiAgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KHBhcmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIChmdW5jdGlvbiB0ZXN0KCkge30pLm5hbWU7XG4gIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIChmdW5jdGlvbiAoKSB7fSkoKTtcbiAgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9XG5leHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHQuaXNVbmFyeUxpa2UocGFyZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHQuaXNCaW5hcnkocGFyZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQpIHx8IHQuaXNOZXdFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50LmNhbGxlZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHQuaXNDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKHBhcmVudCkgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG52YXIgZWFjaCAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciBtYXAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9tYXBcIik7XG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNOdW1iZXJcIik7XG5cbmV4cG9ydHMuYmVmb3JlID0ge1xuICBub2Rlczoge1xuICAgIFByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnByb3BlcnRpZXNbMF0gPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFNwcmVhZFByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5iZWZvcmUubm9kZXMuUHJvcGVydHkobm9kZSwgcGFyZW50KTtcbiAgICB9LFxuXG4gICAgU3dpdGNoQ2FzZTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5jYXNlc1swXSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAodC5pc0Z1bmN0aW9uKG5vZGUuY2FsbGVlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuYWZ0ZXIgPSB7XG4gIG5vZGVzOiB7XG4gICAgTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gdC5pc0Z1bmN0aW9uKG5vZGUubGVmdCkgfHwgdC5pc0Z1bmN0aW9uKG5vZGUucmlnaHQpO1xuICAgIH0sXG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0LmlzRnVuY3Rpb24obm9kZS5yaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxpc3Q6IHtcbiAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG1hcChub2RlLmRlY2xhcmF0aW9ucywgXCJpbml0XCIpO1xuICAgIH0sXG5cbiAgICBBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5lbGVtZW50cztcbiAgICB9LFxuXG4gICAgT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnByb3BlcnRpZXM7XG4gICAgfVxuICB9XG59O1xuXG5lYWNoKHtcbiAgRnVuY3Rpb246IDEsXG4gIENsYXNzOiAxLFxuICBGb3I6IDEsXG4gIEFycmF5RXhwcmVzc2lvbjogeyBhZnRlcjogMSB9LFxuICBPYmplY3RFeHByZXNzaW9uOiB7IGFmdGVyOiAxIH0sXG4gIFN3aXRjaFN0YXRlbWVudDogMSxcbiAgSWZTdGF0ZW1lbnQ6IHsgYmVmb3JlOiAxIH0sXG4gIENhbGxFeHByZXNzaW9uOiB7IGFmdGVyOiAxIH0sXG4gIExpdGVyYWw6IHsgYWZ0ZXI6IDEgfVxufSwgZnVuY3Rpb24gKGFtb3VudHMsIHR5cGUpIHtcbiAgaWYgKGlzTnVtYmVyKGFtb3VudHMpKSB7XG4gICAgYW1vdW50cyA9IHsgYWZ0ZXI6IGFtb3VudHMsIGJlZm9yZTogYW1vdW50cyB9O1xuICB9XG5cbiAgZWFjaChbdHlwZV0uY29uY2F0KHQuRkxJUFBFRF9BTElBU19LRVlTW3R5cGVdIHx8IFtdKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBlYWNoKGFtb3VudHMsIGZ1bmN0aW9uIChhbW91bnQsIGtleSkge1xuICAgICAgZXhwb3J0c1trZXldLm5vZGVzW3R5cGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5saW5lID0gMTtcbiAgdGhpcy5jb2x1bW4gPSAwO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLmxpbmUrKztcbiAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICB9XG4gIH1cbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHN0cikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IFwiXFxuXCIpIHtcbiAgICAgIHRoaXMubGluZS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbHVtbi0tO1xuICAgIH1cbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdXJjZU1hcDtcblxudmFyIHNvdXJjZU1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpO1xudmFyIHQgICAgICAgICA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gU291cmNlTWFwKHBvc2l0aW9uLCBvcHRzLCBjb2RlKSB7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5vcHRzICAgICA9IG9wdHM7XG5cbiAgaWYgKG9wdHMuc291cmNlTWFwKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgc291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBvcHRzLnNvdXJjZU1hcE5hbWUsXG4gICAgICBzb3VyY2VSb290OiBvcHRzLnNvdXJjZVJvb3RcbiAgICB9KTtcblxuICAgIHRoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQob3B0cy5zb3VyY2VGaWxlTmFtZSwgY29kZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tYXAgPSBudWxsO1xuICB9XG59XG5cblNvdXJjZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gIGlmIChtYXApIHtcbiAgICByZXR1cm4gbWFwLnRvSlNPTigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXA7XG4gIH1cbn07XG5cblNvdXJjZU1hcC5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uIChub2RlLCB0eXBlKSB7XG4gIHZhciBsb2MgPSBub2RlLmxvYztcbiAgaWYgKCFsb2MpIHJldHVybjsgLy8gbm8gbG9jYXRpb24gaW5mb1xuXG4gIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgaWYgKCFtYXApIHJldHVybjsgLy8gbm8gc291cmNlIG1hcFxuXG4gIGlmICh0LmlzUHJvZ3JhbShub2RlKSB8fCB0LmlzRmlsZShub2RlKSkgcmV0dXJuOyAvLyBpbGxlZ2FsIG1hcHBpbmcgbm9kZXNcblxuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgbGluZTogcG9zaXRpb24ubGluZSxcbiAgICBjb2x1bW46IHBvc2l0aW9uLmNvbHVtblxuICB9O1xuXG4gIHZhciBvcmlnaW5hbCA9IGxvY1t0eXBlXTtcblxuICBtYXAuYWRkTWFwcGluZyh7XG4gICAgc291cmNlOiB0aGlzLm9wdHMuc291cmNlRmlsZU5hbWUsXG4gICAgZ2VuZXJhdGVkOiBnZW5lcmF0ZWQsXG4gICAgb3JpZ2luYWw6IG9yaWdpbmFsXG4gIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdoaXRlc3BhY2U7XG5cbnZhciBzb3J0QnkgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vc29ydEJ5XCIpO1xuXG4vKipcbiAqIFJldHVybnMgYGlgdGggbnVtYmVyIGZyb20gYGJhc2VgLCBjb250aW51aW5nIGZyb20gMCB3aGVuIGBtYXhgIGlzIHJlYWNoZWQuXG4gKiBVc2VmdWwgZm9yIHNoaWZ0aW5nIGBmb3JgIGxvb3AgYnkgYSBmaXhlZCBudW1iZXIgYnV0IGdvaW5nIG92ZXIgYWxsIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpIEN1cnJlbnQgaW5kZXggaW4gdGhlIGxvb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSBiYXNlIFN0YXJ0IGluZGV4IGZvciB3aGljaCB0byByZXR1cm4gMFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBBcnJheSBsZW5ndGhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNoaWZ0ZWRJbmRleFxuICovXG5mdW5jdGlvbiBnZXRMb29rdXBJbmRleChpLCBiYXNlLCBtYXgpIHtcbiAgaSArPSBiYXNlO1xuXG4gIGlmIChpID49IG1heClcbiAgICBpIC09IG1heDtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gV2hpdGVzcGFjZSh0b2tlbnMsIGNvbW1lbnRzKSB7XG4gIHRoaXMudG9rZW5zID0gc29ydEJ5KHRva2Vucy5jb25jYXQoY29tbWVudHMpLCBcInN0YXJ0XCIpO1xuICB0aGlzLnVzZWQgICA9IHt9O1xuXG4gIC8vIFByb2ZpbGluZyB0aGlzIGNvZGUgc2hvd3MgdGhhdCB3aGlsZSBnZW5lcmF0b3IgcGFzc2VzIG92ZXIgaXQsIGluZGV4ZXNcbiAgLy8gcmV0dXJuZWQgYnkgYGdldE5ld2xpbmVzQmVmb3JlYCBhbmQgYGdldE5ld2xpbmVzQWZ0ZXJgIGFyZSBhbHdheXMgaW5jcmVhc2luZy5cblxuICAvLyBXZSB1c2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgZm9yIGFuIG9wdGltaXphdGlvbjogaW5zdGVhZCBvZiBhbHdheXNcbiAgLy8gc3RhcnRpbmcgdG8gbG9vayBmcm9tIGB0aGlzLnRva2Vuc1swXWAsIHdlIHdpbGwgc3RhcnQgYGZvcmAgbG9vcHMgZnJvbSB0aGVcbiAgLy8gcHJldmlvdXMgc3VjY2Vzc2Z1bCBtYXRjaC4gV2Ugd2lsbCBlbnVtZXJhdGUgYWxsIHRva2Vuc+KAlGJ1dCB0aGUgY29tbW9uXG4gIC8vIGNhc2Ugd2lsbCBiZSBtdWNoIGZhc3Rlci5cblxuICB0aGlzLl9sYXN0Rm91bmRJbmRleCA9IDA7XG59XG5cbldoaXRlc3BhY2UucHJvdG90eXBlLmdldE5ld2xpbmVzQmVmb3JlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHN0YXJ0VG9rZW47XG4gIHZhciBlbmRUb2tlbjtcbiAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICB2YXIgdG9rZW47XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAvLyBvcHRpbWl6ZSBmb3IgZm9yd2FyZCB0cmF2ZXJzYWwgYnkgc2hpZnRpbmcgZm9yIGxvb3AgaW5kZXhcbiAgICB2YXIgaSA9IGdldExvb2t1cEluZGV4KGosIHRoaXMuX2xhc3RGb3VuZEluZGV4LCB0aGlzLnRva2Vucy5sZW5ndGgpO1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgdG9rZW4gdGhpcyBub2RlIHN0YXJ0cyB3aXRoXG4gICAgaWYgKG5vZGUuc3RhcnQgPT09IHRva2VuLnN0YXJ0KSB7XG4gICAgICBzdGFydFRva2VuID0gdG9rZW5zW2kgLSAxXTtcbiAgICAgIGVuZFRva2VuID0gdG9rZW47XG5cbiAgICAgIHRoaXMuX2xhc3RGb3VuZEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldE5ld2xpbmVzQmV0d2VlbihzdGFydFRva2VuLCBlbmRUb2tlbik7XG59O1xuXG5XaGl0ZXNwYWNlLnByb3RvdHlwZS5nZXROZXdsaW5lc0FmdGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHN0YXJ0VG9rZW47XG4gIHZhciBlbmRUb2tlbjtcbiAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICB2YXIgdG9rZW47XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAvLyBvcHRpbWl6ZSBmb3IgZm9yd2FyZCB0cmF2ZXJzYWwgYnkgc2hpZnRpbmcgZm9yIGxvb3AgaW5kZXhcbiAgICB2YXIgaSA9IGdldExvb2t1cEluZGV4KGosIHRoaXMuX2xhc3RGb3VuZEluZGV4LCB0aGlzLnRva2Vucy5sZW5ndGgpO1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgdG9rZW4gdGhpcyBub2RlIGVuZHMgd2l0aFxuICAgIGlmIChub2RlLmVuZCA9PT0gdG9rZW4uZW5kKSB7XG4gICAgICBzdGFydFRva2VuID0gdG9rZW47XG4gICAgICBlbmRUb2tlbiA9IHRva2Vuc1tpICsgMV07XG5cbiAgICAgIHRoaXMuX2xhc3RGb3VuZEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmRUb2tlbiAmJiBlbmRUb2tlbi50eXBlLnR5cGUgPT09IFwiZW9mXCIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGluZXMgPSB0aGlzLmdldE5ld2xpbmVzQmV0d2VlbihzdGFydFRva2VuLCBlbmRUb2tlbik7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJMaW5lXCIgJiYgIWxpbmVzKSB7XG4gICAgICAvLyBsaW5lIGNvbW1lbnRcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICB9XG59O1xuXG5XaGl0ZXNwYWNlLnByb3RvdHlwZS5nZXROZXdsaW5lc0JldHdlZW4gPSBmdW5jdGlvbiAoc3RhcnRUb2tlbiwgZW5kVG9rZW4pIHtcbiAgaWYgKCFlbmRUb2tlbiB8fCAhZW5kVG9rZW4ubG9jKSByZXR1cm4gMDtcblxuICB2YXIgc3RhcnQgPSBzdGFydFRva2VuID8gc3RhcnRUb2tlbi5sb2MuZW5kLmxpbmUgOiAxO1xuICB2YXIgZW5kICAgPSBlbmRUb2tlbi5sb2Muc3RhcnQubGluZTtcbiAgdmFyIGxpbmVzID0gMDtcblxuICBmb3IgKHZhciBsaW5lID0gc3RhcnQ7IGxpbmUgPCBlbmQ7IGxpbmUrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy51c2VkW2xpbmVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnVzZWRbbGluZV0gPSB0cnVlO1xuICAgICAgbGluZXMrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59O1xuIiwiLy8gc3ludGF4IGhpZ2hsaWdodGluZyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvYW5zaS1oaWdobGlnaHQgYnkgdGhlIGZhbnRhc3RpYyBEb21pbmljIFRhcnJcblxudmFyIHJlcGVhdGluZyA9IHJlcXVpcmUoXCJyZXBlYXRpbmdcIik7XG52YXIgdG9rZW5pemUgID0gcmVxdWlyZShcImpzLXRva2VuaXplclwiKTtcbnZhciBjaGFsayAgICAgPSByZXF1aXJlKFwiY2hhbGtcIik7XG5cbnZhciBkZWZzID0ge1xuICBzdHJpbmcxOiAgXCJyZWRcIixcbiAgc3RyaW5nMjogIFwicmVkXCIsXG4gIHB1bmN0OiAgICBbXCJ3aGl0ZVwiLCBcImJvbGRcIl0sXG4gIGN1cmx5OiAgICBcImdyZWVuXCIsXG4gIHBhcmVuczogICBbXCJibHVlXCIsIFwiYm9sZFwiXSxcbiAgc3F1YXJlOiAgIFtcInllbGxvd1wiXSxcbiAgbmFtZTogICAgIFwid2hpdGVcIixcbiAga2V5d29yZDogIFtcImN5YW5cIl0sXG4gIG51bWJlcjogICBcIm1hZ2VudGFcIixcbiAgcmVnZXhwOiAgIFwibWFnZW50YVwiLFxuICBjb21tZW50MTogXCJncmV5XCIsXG4gIGNvbW1lbnQyOiBcImdyZXlcIlxufTtcblxudmFyIGhpZ2hsaWdodCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHZhciBjb2xvcml6ZSA9IGZ1bmN0aW9uIChzdHIsIGNvbCkge1xuICAgIGlmICghY29sKSByZXR1cm4gc3RyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sKSkge1xuICAgICAgY29sLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICBzdHIgPSBjaGFsa1tjb2xdKHN0cik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY2hhbGtbY29sXShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiB0b2tlbml6ZSh0ZXh0LCB0cnVlKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciB0eXBlID0gdG9rZW5pemUudHlwZShzdHIpO1xuICAgIHJldHVybiBjb2xvcml6ZShzdHIsIGRlZnNbdHlwZV0pO1xuICB9KS5qb2luKFwiXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGluZXMsIGxpbmVOdW1iZXIsIGNvbE51bWJlcikge1xuICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuXG4gIGlmIChjaGFsay5zdXBwb3J0c0NvbG9yKSB7XG4gICAgbGluZXMgPSBoaWdobGlnaHQobGluZXMpO1xuICB9XG5cbiAgbGluZXMgPSBsaW5lcy5zcGxpdCgvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKTtcblxuICB2YXIgc3RhcnQgPSBNYXRoLm1heChsaW5lTnVtYmVyIC0gMywgMCk7XG4gIHZhciBlbmQgICA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgbGluZU51bWJlciArIDMpO1xuICB2YXIgd2lkdGggPSAoZW5kICsgXCJcIikubGVuZ3RoO1xuXG4gIGlmICghbGluZU51bWJlciAmJiAhY29sTnVtYmVyKSB7XG4gICAgc3RhcnQgPSAwO1xuICAgIGVuZCA9IGxpbmVzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBcIlxcblwiICsgbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgdmFyIGN1cnIgPSBpICsgc3RhcnQgKyAxO1xuXG4gICAgdmFyIGd1dHRlciA9IGN1cnIgPT09IGxpbmVOdW1iZXIgPyBcIj4gXCIgOiBcIiAgXCI7XG5cbiAgICB2YXIgc2VwID0gY3VyciArIHJlcGVhdGluZyhcIiBcIiwgd2lkdGggKyAxKTtcbiAgICBndXR0ZXIgKz0gc2VwICsgXCJ8IFwiO1xuXG4gICAgdmFyIHN0ciA9IGd1dHRlciArIGxpbmU7XG5cbiAgICBpZiAoY29sTnVtYmVyICYmIGN1cnIgPT09IGxpbmVOdW1iZXIpIHtcbiAgICAgIHN0ciArPSBcIlxcblwiO1xuICAgICAgc3RyICs9IHJlcGVhdGluZyhcIiBcIiwgZ3V0dGVyLmxlbmd0aCAtIDIpO1xuICAgICAgc3RyICs9IFwifFwiICsgcmVwZWF0aW5nKFwiIFwiLCBjb2xOdW1iZXIpICsgXCJeXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfSkuam9pbihcIlxcblwiKTtcbn07XG4iLCJ2YXIgdCA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXN0LCBjb21tZW50cywgdG9rZW5zKSB7XG4gIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IFwiUHJvZ3JhbVwiKSB7XG4gICAgcmV0dXJuIHQuZmlsZShhc3QsIGNvbW1lbnRzIHx8IFtdLCB0b2tlbnMgfHwgW10pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIGFzdD9cIik7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcbiIsInZhciBub3JtYWxpemVBc3QgPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtYXN0XCIpO1xudmFyIGVzdHJhdmVyc2UgICA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpO1xudmFyIGNvZGVGcmFtZSAgICA9IHJlcXVpcmUoXCIuL2NvZGUtZnJhbWVcIik7XG52YXIgYWNvcm4gICAgICAgID0gcmVxdWlyZShcImFjb3JuLWJhYmVsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzLCBjb2RlLCBjYWxsYmFjaykge1xuICB0cnkge1xuICAgIHZhciBjb21tZW50cyA9IFtdO1xuICAgIHZhciB0b2tlbnMgICA9IFtdO1xuXG4gICAgdmFyIGFzdCA9IGFjb3JuLnBhcnNlKGNvZGUsIHtcbiAgICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogb3B0cy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUsXG4gICAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogICFvcHRzLl9hbmFsLFxuICAgICAgZWNtYVZlcnNpb246ICAgICAgICAgICAgICAgICBvcHRzLmV4cGVyaW1lbnRhbCA/IDcgOiA2LFxuICAgICAgcGxheWdyb3VuZDogICAgICAgICAgICAgICAgICBvcHRzLnBsYXlncm91bmQsXG4gICAgICBzdHJpY3RNb2RlOiAgICAgICAgICAgICAgICAgIG9wdHMuc3RyaWN0TW9kZSxcbiAgICAgIG9uQ29tbWVudDogICAgICAgICAgICAgICAgICAgY29tbWVudHMsXG4gICAgICBsb2NhdGlvbnM6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICBvblRva2VuOiAgICAgICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgIHJhbmdlczogICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgIH0pO1xuXG4gICAgZXN0cmF2ZXJzZS5hdHRhY2hDb21tZW50cyhhc3QsIGNvbW1lbnRzLCB0b2tlbnMpO1xuXG4gICAgYXN0ID0gbm9ybWFsaXplQXN0KGFzdCwgY29tbWVudHMsIHRva2Vucyk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCFlcnIuX2JhYmVsKSB7XG4gICAgICBlcnIuX2JhYmVsID0gdHJ1ZTtcbiAgICAgIHZhciBtZXNzYWdlID0gb3B0cy5maWxlbmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlO1xuXG4gICAgICB2YXIgbG9jID0gZXJyLmxvYztcbiAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gY29kZUZyYW1lKGNvZGUsIGxvYy5saW5lLCBsb2MuY29sdW1uICsgMSk7XG4gICAgICAgIG1lc3NhZ2UgKz0gZnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIuc3RhY2spIGVyci5zdGFjayA9IGVyci5zdGFjay5yZXBsYWNlKGVyci5tZXNzYWdlLCBtZXNzYWdlKTtcbiAgICAgIGVyci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBBIHRyaWNrIGZyb20gQmx1ZWJpcmQgdG8gZm9yY2UgVjggdG8gdXNlIGZhc3QgcHJvcGVydGllcyBmb3IgYW4gb2JqZWN0LlxuICogUmVhZCBtb3JlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0OTg3ODk2L1xuICpcbiAqIFVzZSAlSGFzRmFzdFByb3BlcnRpZXMob2JqKSBhbmQgLS1hbGxvdy1uYXRpdmVzLXN5bnRheCB0byBjaGVjayB3aGV0aGVyXG4gKiBhIHBhcnRpY3VsYXIgb2JqZWN0IGFscmVhZHkgaGFzIGZhc3QgcHJvcGVydGllcy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXMob2JqKSB7XG4gIC8qanNoaW50IC1XMDI3Ki9cbiAgZnVuY3Rpb24gZigpIHt9XG4gIGYucHJvdG90eXBlID0gb2JqO1xuICByZXR1cm4gZjtcbiAgZXZhbChvYmopO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5cbmV4cG9ydHMubWVzc2FnZXMgPSB7XG4gIHRhaWxDYWxsUmVhc3NpZ25tZW50RGVvcHQ6IFwiRnVuY3Rpb24gcmVmZXJlbmNlIGhhcyBiZWVuIHJlYXNzaWduZWQgc28gaXQncyBwcm9iYWJseSBiZSBkZXJlZmVyZW5jZWQgc28gd2UgY2FuJ3Qgb3B0aW1pc2UgdGhpcyB3aXRoIGNvbmZpZGVuY2VcIixcbiAgSlNYTmFtZXNwYWNlZFRhZ3M6IFwiTmFtZXNwYWNlIHRhZ3MgYXJlIG5vdCBzdXBwb3J0ZWQuIFJlYWN0SlNYIGlzIG5vdCBYTUwuXCIsXG4gIGNsYXNzZXNJbGxlZ2FsQmFyZVN1cGVyOiBcIklsbGVnYWwgdXNlIG9mIGJhcmUgc3VwZXJcIixcbiAgY2xhc3Nlc0lsbGVnYWxTdXBlckNhbGw6IFwiRGlyZWN0IHN1cGVyIGNhbGwgaXMgaWxsZWdhbCBpbiBub24tY29uc3RydWN0b3IsIHVzZSBzdXBlci4kMSgpIGluc3RlYWRcIixcbiAgY2xhc3Nlc0lsbGVnYWxDb25zdHJ1Y3RvcktpbmQ6IFwiSWxsZWdhbCBraW5kIGZvciBjb25zdHJ1Y3RvciBtZXRob2RcIixcbiAgc2NvcGVEdXBsaWNhdGVEZWNsYXJhdGlvbjogXCJEdXBsaWNhdGUgZGVjbGFyYXRpb24gJDFcIixcbiAgdW5kZWNsYXJlZFZhcmlhYmxlOiBcIlJlZmVyZW5jZSB0byB1bmRlY2xhcmVkIHZhcmlhYmxlICQxXCIsXG4gIHVuZGVjbGFyZWRWYXJpYWJsZVN1Z2dlc3Rpb246IFwiUmVmZXJlbmNlIHRvIHVuZGVjbGFyZWQgdmFyaWFibGUgJDEgLSBkaWQgeW91IG1lYW4gJDI/XCIsXG4gIHNldHRlcnNJbnZhbGlkUGFyYW1MZW5ndGg6IFwiU2V0dGVycyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcGFyYW1ldGVyXCIsXG4gIG5vQXNzaWdubWVudHNJbkZvckhlYWQ6IFwiTm8gYXNzaWdubWVudHMgYWxsb3dlZCBpbiBmb3ItaW4vb2YgaGVhZFwiLFxuICBleHBlY3RlZE1lbWJlckV4cHJlc3Npb25PcklkZW50aWZpZXI6IFwiRXhwZWN0ZWQgdHlwZSBNZW1lYmVyRXhwcmVzc2lvbiBvciBJZGVudGlmaWVyXCIsXG4gIGludmFsaWRQYXJlbnRGb3JUaGlzTm9kZTogXCJXZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgdGhpcyBub2RlIHdpdGhpbiB0aGUgY3VycmVudCBwYXJlbnQgLSBwbGVhc2Ugb3BlbiBhbiBpc3N1ZVwiLFxuICByZWFkT25seTogXCIkMSBpcyByZWFkLW9ubHlcIixcbiAgbW9kdWxlc0lsbGVnYWxFeHBvcnROYW1lOiBcIklsbGVnYWwgZXhwb3J0ICQxXCIsXG4gIHVua25vd25Gb3JIZWFkOiBcIlVua25vd24gbm9kZSB0eXBlICQxIGluIEZvclN0YXRlbWVudFwiLFxuICBkaWRZb3VNZWFuOiBcIkRpZCB5b3UgbWVhbiAkMT9cIixcbiAgZXZhbEluU3RyaWN0TW9kZTogXCJldmFsIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCJcbn07XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgbXNnID0gZXhwb3J0cy5tZXNzYWdlc1trZXldO1xuICBpZiAoIW1zZykgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVW5rbm93biBtZXNzYWdlIGBcIiArIGtleSArIFwiYFwiKTtcblxuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB9XG4gIGFyZ3MgPSBleHBvcnRzLnBhcnNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gbXNnLnJlcGxhY2UoL1xcJChcXGQrKS9nLCBmdW5jdGlvbiAoc3RyLCBpKSB7XG4gICAgcmV0dXJuIGFyZ3NbLS1pXTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnBhcnNlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC5pbnNwZWN0KSB7XG4gICAgICByZXR1cm4gdmFsLmluc3BlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCkgfHwgdmFsICsgXCJcIjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC9leHRlbmRcIik7XG52YXIgdCAgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbi8vIGVzdHJhdmVyc2VcblxudmFyIGVzdHJhdmVyc2UgPSByZXF1aXJlKFwiZXN0cmF2ZXJzZVwiKTtcbmV4dGVuZChlc3RyYXZlcnNlLlZpc2l0b3JLZXlzLCB0LlZJU0lUT1JfS0VZUyk7XG5cbi8vIHJlZ2VuZXJhdG9yLWJhYmVsL2FzdC10eXBlc1xuXG52YXIgdHlwZXMgPSByZXF1aXJlKFwiYXN0LXR5cGVzXCIpO1xudmFyIGRlZiAgID0gdHlwZXMuVHlwZS5kZWY7XG52YXIgb3IgICAgPSB0eXBlcy5UeXBlLm9yO1xuXG5kZWYoXCJGaWxlXCIpXG4gIC5iYXNlcyhcIk5vZGVcIilcbiAgLmJ1aWxkKFwicHJvZ3JhbVwiKVxuICAuZmllbGQoXCJwcm9ncmFtXCIsIGRlZihcIlByb2dyYW1cIikpO1xuXG5kZWYoXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAuYmFzZXMoXCJQYXR0ZXJuXCIpXG4gIC5idWlsZChcImxlZnRcIiwgXCJyaWdodFwiKVxuICAuZmllbGQoXCJsZWZ0XCIsIGRlZihcIlBhdHRlcm5cIikpXG4gIC5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuXG4vLyBBY29ybiAtIFNhbWUgYXMgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIGJ1dCBgaWRgIGlzIGBuYW1lYFxuZGVmKFwiSW1wb3J0QmF0Y2hTcGVjaWZpZXJcIilcbiAgLmJhc2VzKFwiU3BlY2lmaWVyXCIpXG4gIC5idWlsZChcIm5hbWVcIilcbiAgLmZpZWxkKFwibmFtZVwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcblxuZGVmKFwiUmVzdEVsZW1lbnRcIilcbiAgLmJhc2VzKFwiUGF0dGVyblwiKVxuICAuYnVpbGQoXCJhcmd1bWVudFwiKVxuICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJleHByZXNzaW9uXCIpKTtcblxuLy8gQWJzdHJhY3QgcmVmZXJlbmNlc1xuZGVmKFwiVmlydHVhbFByb3BlcnR5RXhwcmVzc2lvblwiKVxuICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gIC5idWlsZChcIm9iamVjdFwiLCBcInByb3BlcnR5XCIpXG4gIC5maWVsZChcIm9iamVjdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAuZmllbGQoXCJwcm9wZXJ0eVwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSk7XG5cbmRlZihcIlByaXZhdGVEZWNsYXJhdGlvblwiKVxuICAuYmFzZXMoXCJEZWNsYXJhdGlvblwiKVxuICAuYnVpbGQoXCJkZWNsYXJhdGlvbnNcIilcbiAgLmZpZWxkKFwiZGVjbGFyYXRpb25zXCIsIFtkZWYoXCJJZGVudGlmaWVyXCIpXSk7XG5cbi8vIFBsYXlncm91bmRcbmRlZihcIkJpbmRNZW1iZXJFeHByZXNzaW9uXCIpXG4gIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgLmJ1aWxkKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIiwgXCJhcmd1bWVudHNcIilcbiAgLmZpZWxkKFwib2JqZWN0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpXG4gIC5maWVsZChcInByb3BlcnR5XCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKVxuICAuZmllbGQoXCJhcmd1bWVudHNcIiwgW2RlZihcIkV4cHJlc3Npb25cIildKTtcblxuZGVmKFwiQmluZEZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gIC5idWlsZChcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiKVxuICAuZmllbGQoXCJjYWxsZWVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgLmZpZWxkKFwiYXJndW1lbnRzXCIsIFtkZWYoXCJFeHByZXNzaW9uXCIpXSk7XG5cbnR5cGVzLmZpbmFsaXplKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1iYWJlbC9ydW50aW1lXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsZTtcblxudmFyIHNvdXJjZU1hcFRvQ29tbWVudCA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwLXRvLWNvbW1lbnRcIik7XG52YXIgc2hlYmFuZ1JlZ2V4ICAgICAgID0gcmVxdWlyZShcInNoZWJhbmctcmVnZXhcIik7XG52YXIgaXNGdW5jdGlvbiAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9sYW5nL2lzRnVuY3Rpb25cIik7XG52YXIgdHJhbnNmb3JtICAgICAgICAgID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG52YXIgZ2VuZXJhdGUgICAgICAgICAgID0gcmVxdWlyZShcIi4uL2dlbmVyYXRpb25cIik7XG52YXIgZGVmYXVsdHMgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvZGVmYXVsdHNcIik7XG52YXIgaW5jbHVkZXMgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2luY2x1ZGVzXCIpO1xudmFyIGFzc2lnbiAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvb2JqZWN0L2Fzc2lnblwiKTtcbnZhciBwYXJzZSAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vaGVscGVycy9wYXJzZVwiKTtcbnZhciBTY29wZSAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdHJhdmVyc2FsL3Njb3BlXCIpO1xudmFyIHNsYXNoICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJzbGFzaFwiKTtcbnZhciB1dGlsICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBwYXRoICAgICAgICAgICAgICAgPSByZXF1aXJlKFwicGF0aFwiKTtcbnZhciBlYWNoICAgICAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciB0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIEZpbGUob3B0cykge1xuICB0aGlzLmR5bmFtaWNJbXBvcnRlZE5vRGVmYXVsdCA9IFtdO1xuICB0aGlzLmR5bmFtaWNJbXBvcnRJZHMgICAgICAgICA9IHt9O1xuICB0aGlzLmR5bmFtaWNJbXBvcnRlZCAgICAgICAgICA9IFtdO1xuICB0aGlzLmR5bmFtaWNJbXBvcnRzICAgICAgICAgICA9IFtdO1xuXG4gIHRoaXMuZHluYW1pY0RhdGEgICAgICA9IHt9O1xuICB0aGlzLmRhdGEgICAgICAgICAgICAgPSB7fTtcblxuICB0aGlzLmxhc3RTdGF0ZW1lbnRzICAgPSBbXTtcbiAgdGhpcy5vcHRzICAgICAgICAgICAgID0gdGhpcy5ub3JtYWxpemVPcHRpb25zKG9wdHMpO1xuICB0aGlzLmFzdCAgICAgICAgICAgICAgPSB7fTtcblxuICB0aGlzLmJ1aWxkVHJhbnNmb3JtZXJzKCk7XG59XG5cbkZpbGUuaGVscGVycyA9IFtcbiAgXCJpbmhlcml0c1wiLFxuICBcImRlZmF1bHRzXCIsXG4gIFwicHJvdG90eXBlLXByb3BlcnRpZXNcIixcbiAgXCJhcHBseS1jb25zdHJ1Y3RvclwiLFxuICBcInRhZ2dlZC10ZW1wbGF0ZS1saXRlcmFsXCIsXG4gIFwidGFnZ2VkLXRlbXBsYXRlLWxpdGVyYWwtbG9vc2VcIixcbiAgXCJpbnRlcm9wLXJlcXVpcmVcIixcbiAgXCJ0by1hcnJheVwiLFxuICBcInRvLWNvbnN1bWFibGUtYXJyYXlcIixcbiAgXCJzbGljZWQtdG8tYXJyYXlcIixcbiAgXCJvYmplY3Qtd2l0aG91dC1wcm9wZXJ0aWVzXCIsXG4gIFwiaGFzLW93blwiLFxuICBcInNsaWNlXCIsXG4gIFwiYmluZFwiLFxuICBcImRlZmluZS1wcm9wZXJ0eVwiLFxuICBcImFzeW5jLXRvLWdlbmVyYXRvclwiLFxuICBcImludGVyb3AtcmVxdWlyZS13aWxkY2FyZFwiLFxuICBcInR5cGVvZlwiLFxuICBcImV4dGVuZHNcIixcbiAgXCJnZXRcIixcbiAgXCJzZXRcIixcbiAgXCJjbGFzcy1jYWxsLWNoZWNrXCIsXG4gIFwib2JqZWN0LWRlc3RydWN0dXJpbmctZW1wdHlcIixcbiAgXCJ0ZW1wb3JhbC11bmRlZmluZWRcIixcbiAgXCJ0ZW1wb3JhbC1hc3NlcnQtZGVmaW5lZFwiLFxuICBcInRhaWwtY2FsbFwiLFxuICBcInNlbGYtZ2xvYmFsXCJcbl07XG5cbkZpbGUudmFsaWRPcHRpb25zID0gW1xuICBcImZpbGVuYW1lXCIsXG4gIFwiZmlsZW5hbWVSZWxhdGl2ZVwiLFxuICBcImJsYWNrbGlzdFwiLFxuICBcIndoaXRlbGlzdFwiLFxuICBcImxvb3NlXCIsXG4gIFwib3B0aW9uYWxcIixcbiAgXCJtb2R1bGVzXCIsXG4gIFwic291cmNlTWFwXCIsXG4gIFwic291cmNlTWFwTmFtZVwiLFxuICBcInNvdXJjZUZpbGVOYW1lXCIsXG4gIFwic291cmNlUm9vdFwiLFxuICBcIm1vZHVsZVJvb3RcIixcbiAgXCJtb2R1bGVJZHNcIixcbiAgXCJjb21tZW50c1wiLFxuICBcInJlYWN0Q29tcGF0XCIsXG4gIFwia2VlcE1vZHVsZUlkRXh0ZW5zaW9uc1wiLFxuICBcImNvZGVcIixcbiAgXCJhc3RcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJwbGF5Z3JvdW5kXCIsXG4gIFwiZXhwZXJpbWVudGFsXCIsXG4gIFwicmVzb2x2ZU1vZHVsZVNvdXJjZVwiLFxuICBcImV4dGVybmFsSGVscGVyc1wiLFxuICBcImF1eGlsaWFyeUNvbW1lbnRcIixcblxuICAvLyB0aGVzZSBhcmUgdXNlZCBieSBwbHVnaW5zXG4gIFwiaWdub3JlXCIsXG4gIFwib25seVwiLFxuICBcImV4dGVuc2lvbnNcIixcbiAgXCJhY2NlcHRcIlxuXTtcblxuRmlsZS5wcm90b3R5cGUubm9ybWFsaXplT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBhc3NpZ24oe30sIG9wdHMpO1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgaWYgKGtleVswXSAhPT0gXCJfXCIgJiYgRmlsZS52YWxpZE9wdGlvbnMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVW5rbm93biBvcHRpb246IFwiICsga2V5KTtcbiAgICB9XG4gIH1cblxuICBkZWZhdWx0cyhvcHRzLCB7XG4gICAga2VlcE1vZHVsZUlkRXh0ZW5zaW9uczogZmFsc2UsXG4gICAgcmVzb2x2ZU1vZHVsZVNvdXJjZTogICAgbnVsbCxcbiAgICBleHRlcm5hbEhlbHBlcnM6ICAgICAgICBmYWxzZSxcbiAgICBhdXhpbGFyeUNvbW1lbnQ6ICAgICAgICBcIlwiLFxuICAgIGV4cGVyaW1lbnRhbDogICAgICAgICAgIGZhbHNlLFxuICAgIHJlYWN0Q29tcGF0OiAgICAgICAgICAgIGZhbHNlLFxuICAgIHBsYXlncm91bmQ6ICAgICAgICAgICAgIGZhbHNlLFxuICAgIHdoaXRlc3BhY2U6ICAgICAgICAgICAgIHRydWUsXG4gICAgbW9kdWxlSWRzOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgYmxhY2tsaXN0OiAgICAgICAgICAgICAgW10sXG4gICAgd2hpdGVsaXN0OiAgICAgICAgICAgICAgW10sXG4gICAgc291cmNlTWFwOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgb3B0aW9uYWw6ICAgICAgICAgICAgICAgW10sXG4gICAgY29tbWVudHM6ICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICBmaWxlbmFtZTogICAgICAgICAgICAgICBcInVua25vd25cIixcbiAgICBtb2R1bGVzOiAgICAgICAgICAgICAgICBcImNvbW1vblwiLFxuICAgIGxvb3NlOiAgICAgICAgICAgICAgICAgIFtdLFxuICAgIGNvZGU6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgYXN0OiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICB9KTtcblxuICAvLyBub3JtYWxpemUgd2luZG93cyBwYXRoIHNlcGFyYXRvcnMgdG8gdW5peFxuICBvcHRzLmZpbGVuYW1lID0gc2xhc2gob3B0cy5maWxlbmFtZSk7XG4gIGlmIChvcHRzLnNvdXJjZVJvb3QpIHtcbiAgICBvcHRzLnNvdXJjZVJvb3QgPSBzbGFzaChvcHRzLnNvdXJjZVJvb3QpO1xuICB9XG5cbiAgb3B0cy5iYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUob3B0cy5maWxlbmFtZSwgcGF0aC5leHRuYW1lKG9wdHMuZmlsZW5hbWUpKTtcblxuICBvcHRzLmJsYWNrbGlzdCA9IHV0aWwuYXJyYXlpZnkob3B0cy5ibGFja2xpc3QpO1xuICBvcHRzLndoaXRlbGlzdCA9IHV0aWwuYXJyYXlpZnkob3B0cy53aGl0ZWxpc3QpO1xuICBvcHRzLm9wdGlvbmFsICA9IHV0aWwuYXJyYXlpZnkob3B0cy5vcHRpb25hbCk7XG4gIG9wdHMubG9vc2UgICAgID0gdXRpbC5hcnJheWlmeShvcHRzLmxvb3NlKTtcblxuICBpZiAoaW5jbHVkZXMob3B0cy5sb29zZSwgXCJhbGxcIikgfHwgaW5jbHVkZXMob3B0cy5sb29zZSwgdHJ1ZSkpIHtcbiAgICBvcHRzLmxvb3NlID0gT2JqZWN0LmtleXModHJhbnNmb3JtLnRyYW5zZm9ybWVycyk7XG4gIH1cblxuICBkZWZhdWx0cyhvcHRzLCB7XG4gICAgbW9kdWxlUm9vdDogb3B0cy5zb3VyY2VSb290XG4gIH0pO1xuXG4gIGRlZmF1bHRzKG9wdHMsIHtcbiAgICBzb3VyY2VSb290OiBvcHRzLm1vZHVsZVJvb3RcbiAgfSk7XG5cbiAgZGVmYXVsdHMob3B0cywge1xuICAgIGZpbGVuYW1lUmVsYXRpdmU6IG9wdHMuZmlsZW5hbWVcbiAgfSk7XG5cbiAgZGVmYXVsdHMob3B0cywge1xuICAgIHNvdXJjZUZpbGVOYW1lOiBvcHRzLmZpbGVuYW1lUmVsYXRpdmUsXG4gICAgc291cmNlTWFwTmFtZTogIG9wdHMuZmlsZW5hbWVSZWxhdGl2ZVxuICB9KTtcblxuICBpZiAob3B0cy5wbGF5Z3JvdW5kKSB7XG4gICAgb3B0cy5leHBlcmltZW50YWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdHMuZXh0ZXJuYWxIZWxwZXJzKSB7XG4gICAgdGhpcy5zZXQoXCJydW50aW1lSWRlbnRpZmllclwiLCB0LmlkZW50aWZpZXIoXCJiYWJlbEhlbHBlcnNcIikpO1xuICB9XG5cbiAgb3B0cy5ibGFja2xpc3QgPSB0cmFuc2Zvcm0uX2Vuc3VyZVRyYW5zZm9ybWVyTmFtZXMoXCJibGFja2xpc3RcIiwgb3B0cy5ibGFja2xpc3QpO1xuICBvcHRzLndoaXRlbGlzdCA9IHRyYW5zZm9ybS5fZW5zdXJlVHJhbnNmb3JtZXJOYW1lcyhcIndoaXRlbGlzdFwiLCBvcHRzLndoaXRlbGlzdCk7XG4gIG9wdHMub3B0aW9uYWwgID0gdHJhbnNmb3JtLl9lbnN1cmVUcmFuc2Zvcm1lck5hbWVzKFwib3B0aW9uYWxcIiwgb3B0cy5vcHRpb25hbCk7XG4gIG9wdHMubG9vc2UgICAgID0gdHJhbnNmb3JtLl9lbnN1cmVUcmFuc2Zvcm1lck5hbWVzKFwibG9vc2VcIiwgb3B0cy5sb29zZSk7XG5cbiAgaWYgKG9wdHMucmVhY3RDb21wYXQpIHtcbiAgICBvcHRzLm9wdGlvbmFsLnB1c2goXCJyZWFjdENvbXBhdFwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiVGhlIHJlYWN0Q29tcGF0IG9wdGlvbiBoYXMgYmVlbiBtb3ZlZCBpbnRvIHRoZSBvcHRpb25hbCB0cmFuc2Zvcm1lciBcIiArXG4gICAgICAgICAgICAgICAgICBcImByZWFjdENvbXBhdGAgLSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aWxsIGJlIHJlbW92ZWQgaW4gdjQuMC4wXCIpO1xuICB9XG5cbiAgdmFyIGVuc3VyZUVuYWJsZWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHRyYW5zZm9ybS50cmFuc2Zvcm1lck5hbWVzcGFjZXNba2V5XTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImVzN1wiKSBvcHRzLmV4cGVyaW1lbnRhbCA9IHRydWU7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJwbGF5Z3JvdW5kXCIpIG9wdHMucGxheWdyb3VuZCA9IHRydWU7XG4gIH07XG5cbiAgZWFjaChvcHRzLndoaXRlbGlzdCwgZW5zdXJlRW5hYmxlZCk7XG4gIGVhY2gob3B0cy5vcHRpb25hbCwgZW5zdXJlRW5hYmxlZCk7XG5cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG5GaWxlLnByb3RvdHlwZS5pc0xvb3NlID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gaW5jbHVkZXModGhpcy5vcHRzLmxvb3NlLCBrZXkpO1xufTtcblxuRmlsZS5wcm90b3R5cGUuYnVpbGRUcmFuc2Zvcm1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaWxlID0gdGhpcztcblxuICB2YXIgdHJhbnNmb3JtZXJzID0ge307XG5cbiAgdmFyIHNlY29uZGFyeVN0YWNrID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIGVhY2godHJhbnNmb3JtLnRyYW5zZm9ybWVycywgZnVuY3Rpb24gKHRyYW5zZm9ybWVyLCBrZXkpIHtcbiAgICB2YXIgcGFzcyA9IHRyYW5zZm9ybWVyc1trZXldID0gdHJhbnNmb3JtZXIuYnVpbGRQYXNzKGZpbGUpO1xuXG4gICAgaWYgKHBhc3MuY2FuUnVuKGZpbGUpKSB7XG4gICAgICBzdGFjay5wdXNoKHBhc3MpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtZXIuc2Vjb25kUGFzcykge1xuICAgICAgICBzZWNvbmRhcnlTdGFjay5wdXNoKHBhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtZXIubWFuaXB1bGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgdHJhbnNmb3JtZXIubWFuaXB1bGF0ZU9wdGlvbnMoZmlsZS5vcHRzLCBmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMudHJhbnNmb3JtZXJTdGFjayA9IHN0YWNrLmNvbmNhdChzZWNvbmRhcnlTdGFjayk7XG4gIHRoaXMudHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzO1xufTtcblxuRmlsZS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gIHZhciBwYXJ0cyA9IHRoaXMub3B0cy5maWxlbmFtZTtcbiAgaWYgKG1zZykgcGFydHMgKz0gXCI6IFwiICsgbXNnO1xuICB1dGlsLmRlYnVnKHBhcnRzKTtcbn07XG5cbkZpbGUucHJvdG90eXBlLmdldE1vZHVsZUZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBNb2R1bGVGb3JtYXR0ZXIgPSBpc0Z1bmN0aW9uKHR5cGUpID8gdHlwZSA6IHRyYW5zZm9ybS5tb2R1bGVGb3JtYXR0ZXJzW3R5cGVdO1xuXG4gIGlmICghTW9kdWxlRm9ybWF0dGVyKSB7XG4gICAgdmFyIGxvYyA9IHV0aWwucmVzb2x2ZSh0eXBlKTtcbiAgICBpZiAobG9jKSBNb2R1bGVGb3JtYXR0ZXIgPSByZXF1aXJlKGxvYyk7XG4gIH1cblxuICBpZiAoIU1vZHVsZUZvcm1hdHRlcikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIlVua25vd24gbW9kdWxlIGZvcm1hdHRlciB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBNb2R1bGVGb3JtYXR0ZXIodGhpcyk7XG59O1xuXG5GaWxlLnByb3RvdHlwZS5wYXJzZVNoZWJhbmcgPSBmdW5jdGlvbiAoY29kZSkge1xuICB2YXIgc2hlYmFuZ01hdGNoID0gc2hlYmFuZ1JlZ2V4LmV4ZWMoY29kZSk7XG5cbiAgaWYgKHNoZWJhbmdNYXRjaCkge1xuICAgIHRoaXMuc2hlYmFuZyA9IHNoZWJhbmdNYXRjaFswXTtcblxuICAgIC8vIHJlbW92ZSBzaGViYW5nXG4gICAgY29kZSA9IGNvZGUucmVwbGFjZShzaGViYW5nUmVnZXgsIFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvZGU7XG59O1xuXG5GaWxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtrZXldID0gdmFsO1xufTtcblxuRmlsZS5wcm90b3R5cGUuc2V0RHluYW1pYyA9IGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gIHRoaXMuZHluYW1pY0RhdGFba2V5XSA9IGZuO1xufTtcblxuRmlsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuZGF0YVtrZXldO1xuICBpZiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBkeW5hbWljID0gdGhpcy5keW5hbWljRGF0YVtrZXldO1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCBkeW5hbWljKCkpO1xuICAgIH1cbiAgfVxufTtcblxuRmlsZS5wcm90b3R5cGUuYWRkSW1wb3J0ID0gZnVuY3Rpb24gKHNvdXJjZSwgbmFtZSwgbm9EZWZhdWx0KSB7XG4gIG5hbWUgPSBuYW1lIHx8IHNvdXJjZTtcbiAgdmFyIGlkID0gdGhpcy5keW5hbWljSW1wb3J0SWRzW25hbWVdO1xuXG4gIGlmICghaWQpIHtcbiAgICBpZCA9IHRoaXMuZHluYW1pY0ltcG9ydElkc1tuYW1lXSA9IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKG5hbWUpO1xuXG4gICAgdmFyIHNwZWNpZmllcnMgPSBbdC5pbXBvcnRTcGVjaWZpZXIodC5pZGVudGlmaWVyKFwiZGVmYXVsdFwiKSwgaWQpXTtcbiAgICB2YXIgZGVjbGFyID0gdC5pbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCB0LmxpdGVyYWwoc291cmNlKSk7XG4gICAgZGVjbGFyLl9ibG9ja0hvaXN0ID0gMztcblxuICAgIHRoaXMuZHluYW1pY0ltcG9ydGVkLnB1c2goZGVjbGFyKTtcbiAgICBpZiAobm9EZWZhdWx0KSB0aGlzLmR5bmFtaWNJbXBvcnRlZE5vRGVmYXVsdC5wdXNoKGRlY2xhcik7XG5cbiAgICB0aGlzLm1vZHVsZUZvcm1hdHRlci5pbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyc1swXSwgZGVjbGFyLCB0aGlzLmR5bmFtaWNJbXBvcnRzKTtcbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbkZpbGUucHJvdG90eXBlLmlzQ29uc2VxdWVuY2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpICYmIHRoaXMubGFzdFN0YXRlbWVudHMuaW5kZXhPZihub2RlKSA+PSAwO1xufTtcblxuRmlsZS5wcm90b3R5cGUuYXR0YWNoQXV4aWxpYXJ5Q29tbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjb21tZW50ID0gdGhpcy5vcHRzLmF1eGlsaWFyeUNvbW1lbnQ7XG4gIGlmIChjb21tZW50KSB7XG4gICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBub2RlLmxlYWRpbmdDb21tZW50cyB8fCBbXTtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiTGluZVwiLFxuICAgICAgdmFsdWU6IFwiIFwiICsgY29tbWVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuRmlsZS5wcm90b3R5cGUuYWRkSGVscGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFpbmNsdWRlcyhGaWxlLmhlbHBlcnMsIG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVW5rbm93biBoZWxwZXIgXCIgKyBuYW1lKTtcbiAgfVxuXG4gIHZhciBwcm9ncmFtID0gdGhpcy5hc3QucHJvZ3JhbTtcblxuICB2YXIgZGVjbGFyID0gcHJvZ3JhbS5fZGVjbGFyYXRpb25zICYmIHByb2dyYW0uX2RlY2xhcmF0aW9uc1tuYW1lXTtcbiAgaWYgKGRlY2xhcikgcmV0dXJuIGRlY2xhci5pZDtcblxuICB2YXIgcnVudGltZSA9IHRoaXMuZ2V0KFwicnVudGltZUlkZW50aWZpZXJcIik7XG4gIGlmIChydW50aW1lKSB7XG4gICAgbmFtZSA9IHQuaWRlbnRpZmllcih0LnRvSWRlbnRpZmllcihuYW1lKSk7XG4gICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihydW50aW1lLCBuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVmID0gdXRpbC50ZW1wbGF0ZShuYW1lKTtcbiAgICByZWYuX2NvbXBhY3QgPSB0cnVlO1xuICAgIHZhciB1aWQgPSB0aGlzLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihuYW1lKTtcbiAgICB0aGlzLnNjb3BlLnB1c2goe1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgaWQ6IHVpZCxcbiAgICAgIGluaXQ6IHJlZlxuICAgIH0pO1xuICAgIHJldHVybiB1aWQ7XG4gIH1cbn07XG5cbkZpbGUucHJvdG90eXBlLmxvZ0Rlb3B0ID0gZnVuY3Rpb24gKCkge1xuICAvLyB0b2RvLCAobm9kZSwgbXNnKVxufTtcblxuRmlsZS5wcm90b3R5cGUuZXJyb3JXaXRoTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBtc2csIEVycm9yKSB7XG4gIEVycm9yID0gRXJyb3IgfHwgU3ludGF4RXJyb3I7XG5cbiAgdmFyIGxvYyA9IG5vZGUubG9jLnN0YXJ0O1xuICB2YXIgZXJyID0gbmV3IEVycm9yKFwiTGluZSBcIiArIGxvYy5saW5lICsgXCI6IFwiICsgbXNnKTtcbiAgZXJyLmxvYyA9IGxvYztcbiAgcmV0dXJuIGVycjtcbn07XG5cbkZpbGUucHJvdG90eXBlLmFkZENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICBjb2RlID0gKGNvZGUgfHwgXCJcIikgKyBcIlwiO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICByZXR1cm4gdGhpcy5wYXJzZVNoZWJhbmcoY29kZSk7XG59O1xuXG5GaWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBjb2RlID0gdGhpcy5hZGRDb2RlKGNvZGUpO1xuXG4gIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuXG4gIG9wdHMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlID0gdGhpcy5pc0xvb3NlKFwiZXM2Lm1vZHVsZXNcIik7XG4gIG9wdHMuc3RyaWN0TW9kZSA9IHRoaXMudHJhbnNmb3JtZXJzLnVzZVN0cmljdC5jYW5SdW4oKTtcblxuICByZXR1cm4gcGFyc2Uob3B0cywgY29kZSwgZnVuY3Rpb24gKHRyZWUpIHtcbiAgICBzZWxmLnRyYW5zZm9ybSh0cmVlKTtcbiAgICByZXR1cm4gc2VsZi5nZW5lcmF0ZSgpO1xuICB9KTtcbn07XG5cbkZpbGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgdGhpcy5kZWJ1ZygpO1xuXG4gIHRoaXMuYXN0ID0gYXN0O1xuICB0aGlzLmxhc3RTdGF0ZW1lbnRzID0gdC5nZXRMYXN0U3RhdGVtZW50cyhhc3QucHJvZ3JhbSk7XG4gIHRoaXMuc2NvcGUgPSBuZXcgU2NvcGUoYXN0LnByb2dyYW0sIGFzdCwgbnVsbCwgdGhpcyk7XG5cbiAgdmFyIG1vZEZvcm1hdHRlciA9IHRoaXMubW9kdWxlRm9ybWF0dGVyID0gdGhpcy5nZXRNb2R1bGVGb3JtYXR0ZXIodGhpcy5vcHRzLm1vZHVsZXMpO1xuICBpZiAobW9kRm9ybWF0dGVyLmluaXQgJiYgdGhpcy50cmFuc2Zvcm1lcnNbXCJlczYubW9kdWxlc1wiXS5jYW5SdW4oKSkge1xuICAgIG1vZEZvcm1hdHRlci5pbml0KCk7XG4gIH1cblxuICB0aGlzLmNoZWNrTm9kZShhc3QpO1xuXG4gIHRoaXMuY2FsbChcInByZVwiKTtcblxuICBlYWNoKHRoaXMudHJhbnNmb3JtZXJTdGFjaywgZnVuY3Rpb24gKHBhc3MpIHtcbiAgICBwYXNzLnRyYW5zZm9ybSgpO1xuICB9KTtcblxuICB0aGlzLmNhbGwoXCJwb3N0XCIpO1xufTtcblxuRmlsZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy50cmFuc2Zvcm1lclN0YWNrO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybWVyID0gc3RhY2tbaV0udHJhbnNmb3JtZXI7XG4gICAgaWYgKHRyYW5zZm9ybWVyW2tleV0pIHtcbiAgICAgIHRyYW5zZm9ybWVyW2tleV0odGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgY2hlY2tUcmFuc2Zvcm1lclZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBjaGVja05vZGUoc3RhdGUuc3RhY2ssIG5vZGUsIHNjb3BlKTtcbiAgfVxufTtcblxudmFyIGNoZWNrTm9kZSA9IGZ1bmN0aW9uIChzdGFjaywgbm9kZSwgc2NvcGUpIHtcbiAgZWFjaChzdGFjaywgZnVuY3Rpb24gKHBhc3MpIHtcbiAgICBpZiAocGFzcy5zaG91bGRSdW4pIHJldHVybjtcbiAgICBwYXNzLmNoZWNrTm9kZShub2RlLCBzY29wZSk7XG4gIH0pO1xufTtcblxuRmlsZS5wcm90b3R5cGUuY2hlY2tOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHNjb3BlKSB7XG4gIHZhciBzdGFjayA9IHRoaXMudHJhbnNmb3JtZXJTdGFjaztcbiAgc2NvcGUgPSBzY29wZSB8fCB0aGlzLnNjb3BlO1xuXG4gIGNoZWNrTm9kZShzdGFjaywgbm9kZSwgc2NvcGUpO1xuXG4gIHNjb3BlLnRyYXZlcnNlKG5vZGUsIGNoZWNrVHJhbnNmb3JtZXJWaXNpdG9yLCB7XG4gICAgc3RhY2s6IHN0YWNrXG4gIH0pO1xufTtcblxuRmlsZS5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICB2YXIgYXN0ICA9IHRoaXMuYXN0O1xuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBtYXA6IG51bGwsXG4gICAgYXN0OiBudWxsXG4gIH07XG5cbiAgaWYgKG9wdHMuYXN0KSByZXN1bHQuYXN0ID0gYXN0O1xuICBpZiAoIW9wdHMuY29kZSkgcmV0dXJuIHJlc3VsdDtcblxuICB2YXIgX3Jlc3VsdCA9IGdlbmVyYXRlKGFzdCwgb3B0cywgdGhpcy5jb2RlKTtcbiAgcmVzdWx0LmNvZGUgPSBfcmVzdWx0LmNvZGU7XG4gIHJlc3VsdC5tYXAgID0gX3Jlc3VsdC5tYXA7XG5cbiAgaWYgKHRoaXMuc2hlYmFuZykge1xuICAgIC8vIGFkZCBiYWNrIHNoZWJhbmdcbiAgICByZXN1bHQuY29kZSA9IHRoaXMuc2hlYmFuZyArIFwiXFxuXCIgKyByZXN1bHQuY29kZTtcbiAgfVxuXG4gIGlmIChvcHRzLnNvdXJjZU1hcCA9PT0gXCJpbmxpbmVcIikge1xuICAgIHJlc3VsdC5jb2RlICs9IFwiXFxuXCIgKyBzb3VyY2VNYXBUb0NvbW1lbnQocmVzdWx0Lm1hcCk7XG4gICAgcmVzdWx0Lm1hcCA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXhwbG9kZSA9IHJlcXVpcmUoXCIuL2V4cGxvZGUtYXNzaWduYWJsZS1leHByZXNzaW9uXCIpO1xudmFyIHQgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4cG9ydHMsIG9wdHMpIHtcbiAgdmFyIGlzQXNzaWdubWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IG9wdHMub3BlcmF0b3IgKyBcIj1cIjtcbiAgfTtcblxuICB2YXIgYnVpbGRBc3NpZ25tZW50ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGxlZnQsIHJpZ2h0KTtcbiAgfTtcblxuICBleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICAgIC8vIGhpdCB0aGUgYEFzc2lnbm1lbnRFeHByZXNzaW9uYCBvbmUgYmVsb3dcbiAgICBpZiAoZmlsZS5pc0NvbnNlcXVlbmNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkgcmV0dXJuO1xuXG4gICAgdmFyIGV4cHIgPSBub2RlLmV4cHJlc3Npb247XG4gICAgaWYgKCFpc0Fzc2lnbm1lbnQoZXhwcikpIHJldHVybjtcblxuICAgIHZhciBub2RlcyAgICA9IFtdO1xuICAgIHZhciBleHBsb2RlZCA9IGV4cGxvZGUoZXhwci5sZWZ0LCBub2RlcywgZmlsZSwgc2NvcGUsIHRydWUpO1xuXG4gICAgbm9kZXMucHVzaCh0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICBidWlsZEFzc2lnbm1lbnQoZXhwbG9kZWQucmVmLCBvcHRzLmJ1aWxkKGV4cGxvZGVkLnVpZCwgZXhwci5yaWdodCkpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG5cbiAgZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gICAgaWYgKCFpc0Fzc2lnbm1lbnQobm9kZSkpIHJldHVybjtcblxuICAgIHZhciBub2RlcyAgICA9IFtdO1xuICAgIHZhciBleHBsb2RlZCA9IGV4cGxvZGUobm9kZS5sZWZ0LCBub2RlcywgZmlsZSwgc2NvcGUpO1xuICAgIG5vZGVzLnB1c2goYnVpbGRBc3NpZ25tZW50KGV4cGxvZGVkLnJlZiwgb3B0cy5idWlsZChleHBsb2RlZC51aWQsIG5vZGUucmlnaHQpKSk7XG5cbiAgICByZXR1cm4gdC50b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpO1xuICB9O1xuXG4gIGV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IG9wdHMub3BlcmF0b3IpIHJldHVybjtcbiAgICByZXR1cm4gb3B0cy5idWlsZChub2RlLmxlZnQsIG5vZGUucmlnaHQpO1xuICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZChub2RlLCBidWlsZEJvZHkpIHtcbiAgdmFyIHNlbGYgPSBub2RlLmJsb2Nrcy5zaGlmdCgpO1xuICBpZiAoIXNlbGYpIHJldHVybjtcblxuICB2YXIgY2hpbGQgPSBidWlsZChub2RlLCBidWlsZEJvZHkpO1xuICBpZiAoIWNoaWxkKSB7XG4gICAgLy8gbGFzdCBpdGVtXG4gICAgY2hpbGQgPSBidWlsZEJvZHkoKTtcblxuICAgIC8vIGFkZCBhIGZpbHRlciBhcyB0aGlzIGlzIG91ciBmaW5hbCBzdG9wXG4gICAgaWYgKG5vZGUuZmlsdGVyKSB7XG4gICAgICBjaGlsZCA9IHQuaWZTdGF0ZW1lbnQobm9kZS5maWx0ZXIsIHQuYmxvY2tTdGF0ZW1lbnQoW2NoaWxkXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0LmZvck9mU3RhdGVtZW50KFxuICAgIHQudmFyaWFibGVEZWNsYXJhdGlvbihcImxldFwiLCBbdC52YXJpYWJsZURlY2xhcmF0b3Ioc2VsZi5sZWZ0KV0pLFxuICAgIHNlbGYucmlnaHQsXG4gICAgdC5ibG9ja1N0YXRlbWVudChbY2hpbGRdKVxuICApO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXhwbG9kZSA9IHJlcXVpcmUoXCIuL2V4cGxvZGUtYXNzaWduYWJsZS1leHByZXNzaW9uXCIpO1xudmFyIHQgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4cG9ydHMsIG9wdHMpIHtcbiAgdmFyIGJ1aWxkQXNzaWdubWVudCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBsZWZ0LCByaWdodCk7XG4gIH07XG5cbiAgZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgICAvLyBoaXQgdGhlIGBBc3NpZ25tZW50RXhwcmVzc2lvbmAgb25lIGJlbG93XG4gICAgaWYgKGZpbGUuaXNDb25zZXF1ZW5jZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHJldHVybjtcblxuICAgIHZhciBleHByID0gbm9kZS5leHByZXNzaW9uO1xuICAgIGlmICghb3B0cy5pcyhleHByLCBmaWxlKSkgcmV0dXJuO1xuXG4gICAgdmFyIG5vZGVzID0gW107XG5cbiAgICB2YXIgZXhwbG9kZWQgPSBleHBsb2RlKGV4cHIubGVmdCwgbm9kZXMsIGZpbGUsIHNjb3BlKTtcblxuICAgIG5vZGVzLnB1c2godC5pZlN0YXRlbWVudChcbiAgICAgIG9wdHMuYnVpbGQoZXhwbG9kZWQudWlkLCBmaWxlKSxcbiAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChidWlsZEFzc2lnbm1lbnQoZXhwbG9kZWQucmVmLCBleHByLnJpZ2h0KSlcbiAgICApKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfTtcblxuICBleHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgICBpZiAoIW9wdHMuaXMobm9kZSwgZmlsZSkpIHJldHVybjtcblxuICAgIHZhciBub2RlcyAgICA9IFtdO1xuICAgIHZhciBleHBsb2RlZCA9IGV4cGxvZGUobm9kZS5sZWZ0LCBub2RlcywgZmlsZSwgc2NvcGUpO1xuXG4gICAgbm9kZXMucHVzaCh0LmxvZ2ljYWxFeHByZXNzaW9uKFxuICAgICAgXCImJlwiLFxuICAgICAgb3B0cy5idWlsZChleHBsb2RlZC51aWQsIGZpbGUpLFxuICAgICAgYnVpbGRBc3NpZ25tZW50KGV4cGxvZGVkLnJlZiwgbm9kZS5yaWdodClcbiAgICApKTtcblxuICAgIC8vIHRvZG86IGR1cGxpY2F0ZSBleHByZXNzaW9uIG5vZGVcbiAgICBub2Rlcy5wdXNoKGV4cGxvZGVkLnJlZik7XG5cbiAgICByZXR1cm4gdC50b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpO1xuICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBCYXNlZCB1cG9uIHRoZSBleGNlbGxlbnQganN4LXRyYW5zcGlsZXIgYnkgSW5ndmFyIFN0ZXBhbnlhbiAoUlJldmVyc2VyKVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1JSZXZlcnNlci9qc3gtdHJhbnNwaWxlclxuXG4vLyBqc3hcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZShcImxvZGFzaC9sYW5nL2lzU3RyaW5nXCIpO1xudmFyIG1lc3NhZ2VzID0gcmVxdWlyZShcIi4uLy4uL21lc3NhZ2VzXCIpO1xudmFyIGVzdXRpbHMgID0gcmVxdWlyZShcImVzdXRpbHNcIik7XG52YXIgcmVhY3QgICAgPSByZXF1aXJlKFwiLi9yZWFjdFwiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhwb3J0cywgb3B0cykge1xuICBleHBvcnRzLmNoZWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAodC5pc0pTWChub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHJlYWN0LmlzQ3JlYXRlQ2xhc3Mobm9kZSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLkpTWElkZW50aWZpZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJ0aGlzXCIgJiYgdC5pc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KSkge1xuICAgICAgcmV0dXJuIHQudGhpc0V4cHJlc3Npb24oKTtcbiAgICB9IGVsc2UgaWYgKGVzdXRpbHMua2V5d29yZC5pc0lkZW50aWZpZXJOYW1lKG5vZGUubmFtZSkpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiSWRlbnRpZmllclwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdC5saXRlcmFsKG5vZGUubmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuSlNYTmFtZXNwYWNlZE5hbWUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICAgIHRocm93IGZpbGUuZXJyb3JXaXRoTm9kZShub2RlLCBtZXNzYWdlcy5nZXQoXCJKU1hOYW1lc3BhY2VkVGFnc1wiKSk7XG4gIH07XG5cbiAgZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0ge1xuICAgIGV4aXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLmNvbXB1dGVkID0gdC5pc0xpdGVyYWwobm9kZS5wcm9wZXJ0eSk7XG4gICAgICBub2RlLnR5cGUgPSBcIk1lbWJlckV4cHJlc3Npb25cIjtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9O1xuXG4gIGV4cG9ydHMuSlNYQXR0cmlidXRlID0ge1xuICAgIGV4aXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlIHx8IHQubGl0ZXJhbCh0cnVlKTtcblxuICAgICAgaWYgKHQuaXNMaXRlcmFsKHZhbHVlKSAmJiBpc1N0cmluZyh2YWx1ZS52YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUudmFsdWUgPSB2YWx1ZS52YWx1ZS5yZXBsYWNlKC9cXG5cXHMrL2csIFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQuaW5oZXJpdHModC5wcm9wZXJ0eShcImluaXRcIiwgbm9kZS5uYW1lLCB2YWx1ZSksIG5vZGUpO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IHtcbiAgICBleGl0OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICAgICAgdmFyIHRhZ0V4cHIgPSBub2RlLm5hbWU7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICB2YXIgdGFnTmFtZTtcbiAgICAgIGlmICh0LmlzSWRlbnRpZmllcih0YWdFeHByKSkge1xuICAgICAgICB0YWdOYW1lID0gdGFnRXhwci5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0LmlzTGl0ZXJhbCh0YWdFeHByKSkge1xuICAgICAgICB0YWdOYW1lID0gdGFnRXhwci52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB0YWdFeHByOiB0YWdFeHByLFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhcmdzOiAgICBhcmdzXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0cy5wcmUpIHtcbiAgICAgICAgb3B0cy5wcmUoc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlicyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIGlmIChhdHRyaWJzLmxlbmd0aCkge1xuICAgICAgICBhdHRyaWJzID0gYnVpbGRKU1hPcGVuaW5nRWxlbWVudEF0dHJpYnV0ZXMoYXR0cmlicywgZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJzID0gdC5saXRlcmFsKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBhcmdzLnB1c2goYXR0cmlicyk7XG5cbiAgICAgIGlmIChvcHRzLnBvc3QpIHtcbiAgICAgICAgb3B0cy5wb3N0KHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlLmNhbGwgfHwgdC5jYWxsRXhwcmVzc2lvbihzdGF0ZS5jYWxsZWUsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhlIGxvZ2ljIGZvciB0aGlzIGlzIHF1aXRlIHRlcnNlLiBJdCdzIGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgKiBzdXBwb3J0IHNwcmVhZCBlbGVtZW50cy4gV2UgbG9vcCBvdmVyIGFsbCBhdHRyaWJ1dGVzLFxuICAgKiBicmVha2luZyBvbiBzcHJlYWRzLCB3ZSB0aGVuIHB1c2ggYSBuZXcgb2JqZWN0IGNvbnRhaW5nXG4gICAqIGFsbCBwcmlvciBhdHRyaWJ1dGVzIHRvIGFuIGFycmF5IGZvciBsYXRlciBwcm9jZXNzaW5nLlxuICAgKi9cblxuICB2YXIgYnVpbGRKU1hPcGVuaW5nRWxlbWVudEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlicywgZmlsZSkge1xuICAgIHZhciBfcHJvcHMgPSBbXTtcbiAgICB2YXIgb2JqcyA9IFtdO1xuXG4gICAgdmFyIHB1c2hQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3Byb3BzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICBvYmpzLnB1c2godC5vYmplY3RFeHByZXNzaW9uKF9wcm9wcykpO1xuICAgICAgX3Byb3BzID0gW107XG4gICAgfTtcblxuICAgIHdoaWxlIChhdHRyaWJzLmxlbmd0aCkge1xuICAgICAgdmFyIHByb3AgPSBhdHRyaWJzLnNoaWZ0KCk7XG4gICAgICBpZiAodC5pc0pTWFNwcmVhZEF0dHJpYnV0ZShwcm9wKSkge1xuICAgICAgICBwdXNoUHJvcHMoKTtcbiAgICAgICAgb2Jqcy5wdXNoKHByb3AuYXJndW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Byb3BzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaFByb3BzKCk7XG5cbiAgICBpZiAob2Jqcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIG9ubHkgb25lIG9iamVjdFxuICAgICAgYXR0cmlicyA9IG9ianNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvb2tzIGxpa2Ugd2UgaGF2ZSBtdWx0aXBsZSBvYmplY3RzXG4gICAgICBpZiAoIXQuaXNPYmplY3RFeHByZXNzaW9uKG9ianNbMF0pKSB7XG4gICAgICAgIG9ianMudW5zaGlmdCh0Lm9iamVjdEV4cHJlc3Npb24oW10pKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3ByZWFkIGl0XG4gICAgICBhdHRyaWJzID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgZmlsZS5hZGRIZWxwZXIoXCJleHRlbmRzXCIpLFxuICAgICAgICBvYmpzXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJzO1xuICB9O1xuXG4gIGV4cG9ydHMuSlNYRWxlbWVudCA9IHtcbiAgICBleGl0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGNhbGxFeHByID0gbm9kZS5vcGVuaW5nRWxlbWVudDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKHQuaXNMaXRlcmFsKGNoaWxkKSAmJiB0eXBlb2YgY2hpbGQudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQoY2hpbGQsIGNhbGxFeHByLmFyZ3VtZW50cyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodC5pc0pTWEVtcHR5RXhwcmVzc2lvbihjaGlsZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxFeHByLmFyZ3VtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2FsbEV4cHIuYXJndW1lbnRzID0gZmxhdHRlbihjYWxsRXhwci5hcmd1bWVudHMpO1xuXG4gICAgICBpZiAoY2FsbEV4cHIuYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGNhbGxFeHByLl9wcmV0dHlDYWxsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQuaW5oZXJpdHMoY2FsbEV4cHIsIG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdC5pc0xpdGVyYWwobm9kZSkgJiYgaXNTdHJpbmcobm9kZS52YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBmbGF0dGVuZWQgPSBbXTtcbiAgICB2YXIgbGFzdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICBpZiAoaXNTdHJpbmdMaXRlcmFsKGFyZykgJiYgaXNTdHJpbmdMaXRlcmFsKGxhc3QpKSB7XG4gICAgICAgIGxhc3QudmFsdWUgKz0gYXJnLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdCA9IGFyZztcbiAgICAgICAgZmxhdHRlbmVkLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9O1xuXG4gIHZhciBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIGFyZ3MpIHtcbiAgICB2YXIgbGluZXMgPSBjaGlsZC52YWx1ZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcblxuICAgIHZhciBsYXN0Tm9uRW1wdHlMaW5lID0gMDtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpbmVzW2ldLm1hdGNoKC9bXiBcXHRdLykpIHtcbiAgICAgICAgbGFzdE5vbkVtcHR5TGluZSA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICB2YXIgaXNGaXJzdExpbmUgPSBpID09PSAwO1xuICAgICAgdmFyIGlzTGFzdExpbmUgPSBpID09PSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlzTGFzdE5vbkVtcHR5TGluZSA9IGkgPT09IGxhc3ROb25FbXB0eUxpbmU7XG5cbiAgICAgIC8vIHJlcGxhY2UgcmVuZGVyZWQgd2hpdGVzcGFjZSB0YWJzIHdpdGggc3BhY2VzXG4gICAgICB2YXIgdHJpbW1lZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBcIiBcIik7XG5cbiAgICAgIC8vIHRyaW0gd2hpdGVzcGFjZSB0b3VjaGluZyBhIG5ld2xpbmVcbiAgICAgIGlmICghaXNGaXJzdExpbmUpIHtcbiAgICAgICAgdHJpbW1lZExpbmUgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9eWyBdKy8sIFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyB0cmltIHdoaXRlc3BhY2UgdG91Y2hpbmcgYW4gZW5kbGluZVxuICAgICAgaWYgKCFpc0xhc3RMaW5lKSB7XG4gICAgICAgIHRyaW1tZWRMaW5lID0gdHJpbW1lZExpbmUucmVwbGFjZSgvWyBdKyQvLCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaW1tZWRMaW5lKSB7XG4gICAgICAgIGlmICghaXNMYXN0Tm9uRW1wdHlMaW5lKSB7XG4gICAgICAgICAgdHJpbW1lZExpbmUgKz0gXCIgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnB1c2godC5saXRlcmFsKHRyaW1tZWRMaW5lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGRpc3BsYXkgbmFtZXNcblxuICB2YXIgYWRkRGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoaWQsIGNhbGwpIHtcbiAgICB2YXIgcHJvcHMgPSBjYWxsLmFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzO1xuICAgIHZhciBzYWZlID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAodC5pc0lkZW50aWZpZXIocHJvcC5rZXksIHsgbmFtZTogXCJkaXNwbGF5TmFtZVwiIH0pKSB7XG4gICAgICAgIHNhZmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNhZmUpIHtcbiAgICAgIHByb3BzLnVuc2hpZnQodC5wcm9wZXJ0eShcImluaXRcIiwgdC5pZGVudGlmaWVyKFwiZGlzcGxheU5hbWVcIiksIHQubGl0ZXJhbChpZCkpKTtcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5FeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gICAgaWYgKG5vZGUuZGVmYXVsdCAmJiByZWFjdC5pc0NyZWF0ZUNsYXNzKG5vZGUuZGVjbGFyYXRpb24pKSB7XG4gICAgICBhZGREaXNwbGF5TmFtZShmaWxlLm9wdHMuYmFzZW5hbWUsIG5vZGUuZGVjbGFyYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID1cbiAgZXhwb3J0cy5Qcm9wZXJ0eSA9XG4gIGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgbGVmdCwgcmlnaHQ7XG5cbiAgICBpZiAodC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICBsZWZ0ID0gbm9kZS5sZWZ0O1xuICAgICAgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAodC5pc1Byb3BlcnR5KG5vZGUpKSB7XG4gICAgICBsZWZ0ID0gbm9kZS5rZXk7XG4gICAgICByaWdodCA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdG9yKG5vZGUpKSB7XG4gICAgICBsZWZ0ID0gbm9kZS5pZDtcbiAgICAgIHJpZ2h0ID0gbm9kZS5pbml0O1xuICAgIH1cblxuICAgIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihsZWZ0KSkge1xuICAgICAgbGVmdCA9IGxlZnQucHJvcGVydHk7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKGxlZnQpICYmIHJlYWN0LmlzQ3JlYXRlQ2xhc3MocmlnaHQpKSB7XG4gICAgICBhZGREaXNwbGF5TmFtZShsZWZ0Lm5hbWUsIHJpZ2h0KTtcbiAgICB9XG4gIH07XG59O1xuIiwidmFyIGNsb25lRGVlcCA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9jbG9uZURlZXBcIik7XG52YXIgdHJhdmVyc2UgID0gcmVxdWlyZShcIi4uLy4uL3RyYXZlcnNhbFwiKTtcbnZhciBjbG9uZSAgICAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvY2xvbmVcIik7XG52YXIgZWFjaCAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2VhY2hcIik7XG52YXIgaGFzICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvaGFzXCIpO1xudmFyIHQgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5wdXNoID0gZnVuY3Rpb24gKG11dGF0b3JNYXAsIGtleSwga2luZCwgY29tcHV0ZWQsIHZhbHVlKSB7XG4gIHZhciBhbGlhcztcblxuICBpZiAodC5pc0lkZW50aWZpZXIoa2V5KSkge1xuICAgIGFsaWFzID0ga2V5Lm5hbWU7XG4gICAgaWYgKGNvbXB1dGVkKSBhbGlhcyA9IFwiY29tcHV0ZWQ6XCIgKyBhbGlhcztcbiAgfSBlbHNlIGlmICh0LmlzTGl0ZXJhbChrZXkpKSB7XG4gICAgYWxpYXMgPSBTdHJpbmcoa2V5LnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBhbGlhcyA9IEpTT04uc3RyaW5naWZ5KHRyYXZlcnNlLnJlbW92ZVByb3BlcnRpZXMoY2xvbmVEZWVwKGtleSkpKTtcbiAgfVxuXG4gIHZhciBtYXA7XG4gIGlmIChoYXMobXV0YXRvck1hcCwgYWxpYXMpKSB7XG4gICAgbWFwID0gbXV0YXRvck1hcFthbGlhc107XG4gIH0gZWxzZSB7XG4gICAgbWFwID0ge307XG4gIH1cbiAgbXV0YXRvck1hcFthbGlhc10gPSBtYXA7XG5cbiAgbWFwLl9rZXkgPSBrZXk7XG4gIGlmIChjb21wdXRlZCkge1xuICAgIG1hcC5fY29tcHV0ZWQgPSB0cnVlO1xuICB9XG5cbiAgbWFwW2tpbmRdID0gdmFsdWU7XG59O1xuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKG11dGF0b3JNYXApIHtcbiAgdmFyIG9iakV4cHIgPSB0Lm9iamVjdEV4cHJlc3Npb24oW10pO1xuXG4gIGVhY2gobXV0YXRvck1hcCwgZnVuY3Rpb24gKG1hcCkge1xuICAgIHZhciBtYXBOb2RlID0gdC5vYmplY3RFeHByZXNzaW9uKFtdKTtcblxuICAgIHZhciBwcm9wTm9kZSA9IHQucHJvcGVydHkoXCJpbml0XCIsIG1hcC5fa2V5LCBtYXBOb2RlLCBtYXAuX2NvbXB1dGVkKTtcblxuICAgIGlmICghbWFwLmdldCAmJiAhbWFwLnNldCkge1xuICAgICAgbWFwLndyaXRhYmxlID0gdC5saXRlcmFsKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChtYXAuZW51bWVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlbGV0ZSBtYXAuZW51bWVyYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmVudW1lcmFibGUgPSB0LmxpdGVyYWwodHJ1ZSk7XG4gICAgfVxuXG4gICAgbWFwLmNvbmZpZ3VyYWJsZSA9IHQubGl0ZXJhbCh0cnVlKTtcblxuICAgIGVhY2gobWFwLCBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICBpZiAoa2V5WzBdID09PSBcIl9cIikgcmV0dXJuO1xuXG4gICAgICBub2RlID0gY2xvbmUobm9kZSk7XG4gICAgICB2YXIgaW5oZXJpdE5vZGUgPSBub2RlO1xuICAgICAgaWYgKHQuaXNNZXRob2REZWZpbml0aW9uKG5vZGUpKSBub2RlID0gbm9kZS52YWx1ZTtcblxuICAgICAgdmFyIHByb3AgPSB0LnByb3BlcnR5KFwiaW5pdFwiLCB0LmlkZW50aWZpZXIoa2V5KSwgbm9kZSk7XG4gICAgICB0LmluaGVyaXRzQ29tbWVudHMocHJvcCwgaW5oZXJpdE5vZGUpO1xuICAgICAgdC5yZW1vdmVDb21tZW50cyhpbmhlcml0Tm9kZSk7XG4gICAgICBtYXBOb2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9KTtcblxuICAgIG9iakV4cHIucHJvcGVydGllcy5wdXNoKHByb3BOb2RlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iakV4cHI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuXG52YXIgZ2V0T2JqUmVmID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVzLCBmaWxlLCBzY29wZSkge1xuICB2YXIgcmVmO1xuICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICBpZiAoc2NvcGUuaGFzQmluZGluZyhub2RlLm5hbWUpKSB7XG4gICAgICAvLyB0aGlzIHZhcmlhYmxlIGlzIGRlY2xhcmVkIGluIHNjb3BlIHNvIHdlIGNhbiBiZSAxMDAlIHN1cmVcbiAgICAgIC8vIHRoYXQgZXZhbHVhdGluZyBpdCBtdWx0aXBsZSB0aW1lcyB3b250IHRyaWdnZXIgYSBnZXR0ZXJcbiAgICAgIC8vIG9yIHNvbWV0aGluZyBlbHNlXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY291bGQgcG9zc2libHkgdHJpZ2dlciBhIGdldHRlciBzbyB3ZSBuZWVkIHRvIG9ubHkgZXZhbHVhdGVcbiAgICAgIC8vIGl0IG9uY2VcbiAgICAgIHJlZiA9IG5vZGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmVmID0gbm9kZS5vYmplY3Q7XG5cbiAgICBpZiAodC5pc0lkZW50aWZpZXIocmVmKSAmJiBzY29wZS5oYXNHbG9iYWwocmVmLm5hbWUpKSB7XG4gICAgICAvLyB0aGUgb2JqZWN0IHJlZmVyZW5jZSB0aGF0IHdlIG5lZWQgdG8gc2F2ZSBpcyBsb2NhbGx5IGRlY2xhcmVkXG4gICAgICAvLyBzbyBhcyBwZXIgdGhlIHByZXZpb3VzIGNvbW1lbnQgd2UgY2FuIGJlIDEwMCUgc3VyZSBldmFsdWF0aW5nXG4gICAgICAvLyBpdCBtdWx0aXBsZSB0aW1lcyB3aWxsIGJlIHNhZmVcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldlIGNhbid0IGV4cGxvZGUgdGhpcyBub2RlIHR5cGUgXCIgKyBub2RlLnR5cGUpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKHJlZik7XG4gIG5vZGVzLnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0ZW1wLCByZWYpXG4gIF0pKTtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG52YXIgZ2V0UHJvcFJlZiA9IGZ1bmN0aW9uIChub2RlLCBub2RlcywgZmlsZSwgc2NvcGUpIHtcbiAgdmFyIHByb3AgPSBub2RlLnByb3BlcnR5O1xuICB2YXIga2V5ID0gdC50b0NvbXB1dGVkS2V5KG5vZGUsIHByb3ApO1xuICBpZiAodC5pc0xpdGVyYWwoa2V5KSkgcmV0dXJuIGtleTtcblxuICB2YXIgdGVtcCA9IHNjb3BlLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUocHJvcCk7XG4gIG5vZGVzLnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0ZW1wLCBwcm9wKVxuICBdKSk7XG4gIHJldHVybiB0ZW1wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZSwgbm9kZXMsIGZpbGUsIHNjb3BlLCBhbGxvd2VkU2luZ2xlSWRlbnQpIHtcbiAgdmFyIG9iajtcbiAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpICYmIGFsbG93ZWRTaW5nbGVJZGVudCkge1xuICAgIG9iaiA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgb2JqID0gZ2V0T2JqUmVmKG5vZGUsIG5vZGVzLCBmaWxlLCBzY29wZSk7XG4gIH1cblxuICB2YXIgcmVmLCB1aWQ7XG5cbiAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgcmVmID0gbm9kZTtcbiAgICB1aWQgPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByb3AgPSBnZXRQcm9wUmVmKG5vZGUsIG5vZGVzLCBmaWxlLCBzY29wZSk7XG4gICAgdmFyIGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZCB8fCB0LmlzTGl0ZXJhbChwcm9wKTtcbiAgICB1aWQgPSByZWYgPSB0Lm1lbWJlckV4cHJlc3Npb24ob2JqLCBwcm9wLCBjb21wdXRlZCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVpZDogdWlkLFxuICAgIHJlZjogcmVmXG4gIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdCAgICA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxudmFyIHZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICAvLyBjaGVjayBpZiB0aGlzIG5vZGUgaXMgYW4gaWRlbnRpZmllciB0aGF0IG1hdGNoZXMgdGhlIHNhbWUgYXMgb3VyIGZ1bmN0aW9uIGlkXG4gICAgaWYgKCF0LmlzSWRlbnRpZmllcihub2RlLCB7IG5hbWU6IHN0YXRlLmlkIH0pKSByZXR1cm47XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIG5vZGUgaXMgdGhlIG9uZSByZWZlcmVuY2VkXG4gICAgaWYgKCF0LmlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQpKSByZXR1cm47XG5cbiAgICAvLyBjaGVjayB0aGF0IHdlIGRvbid0IGhhdmUgYSBsb2NhbCB2YXJpYWJsZSBkZWNsYXJlZCBhcyB0aGF0IHJlbW92ZXMgdGhlIG5lZWRcbiAgICAvLyBmb3IgdGhlIHdyYXBwZXJcbiAgICB2YXIgbG9jYWxEZWNsYXIgPSBzY29wZS5nZXRCaW5kaW5nSWRlbnRpZmllcihzdGF0ZS5pZCk7XG4gICAgaWYgKGxvY2FsRGVjbGFyICE9PSBzdGF0ZS5vdXRlckRlY2xhcikgcmV0dXJuO1xuXG4gICAgc3RhdGUuc2VsZlJlZmVyZW5jZSA9IHRydWU7XG4gICAgdGhpcy5zdG9wKCk7XG4gIH1cbn07XG5cbmV4cG9ydHMucHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgZmlsZSwgc2NvcGUpIHtcbiAgdmFyIGtleSA9IHQudG9Db21wdXRlZEtleShub2RlLCBub2RlLmtleSk7XG4gIGlmICghdC5pc0xpdGVyYWwoa2V5KSkgcmV0dXJuIG5vZGU7IC8vIHdlIGNhbid0IHNldCBhIGZ1bmN0aW9uIGlkIHdpdGggdGhpc1xuXG4gIHZhciBpZCA9IHQudG9JZGVudGlmaWVyKGtleS52YWx1ZSk7XG4gIGtleSA9IHQuaWRlbnRpZmllcihpZCk7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGlkOiBpZCxcbiAgICBzZWxmUmVmZXJlbmNlOiBmYWxzZSxcbiAgICBvdXRlckRlY2xhcjogc2NvcGUuZ2V0QmluZGluZ0lkZW50aWZpZXIoaWQpLFxuICB9O1xuXG4gIHNjb3BlLnRyYXZlcnNlKG5vZGUsIHZpc2l0b3IsIHN0YXRlKTtcblxuICB2YXIgbWV0aG9kID0gbm9kZS52YWx1ZTtcblxuICBpZiAoc3RhdGUuc2VsZlJlZmVyZW5jZSkge1xuICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSBcInByb3BlcnR5LW1ldGhvZC1hc3NpZ25tZW50LXdyYXBwZXJcIjtcbiAgICBpZiAobWV0aG9kLmdlbmVyYXRvcikgdGVtcGxhdGVOYW1lICs9IFwiLWdlbmVyYXRvclwiO1xuICAgIG5vZGUudmFsdWUgPSB1dGlsLnRlbXBsYXRlKHRlbXBsYXRlTmFtZSwge1xuICAgICAgRlVOQ1RJT046IG1ldGhvZCxcbiAgICAgIEZVTkNUSU9OX0lEOiBrZXksXG4gICAgICBGVU5DVElPTl9LRVk6IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihpZCksXG4gICAgICBXUkFQUEVSX0tFWTogc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKGlkICsgXCJXcmFwcGVyXCIpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kLmlkID0ga2V5O1xuICB9XG59O1xuIiwidmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbnZhciBpc0NyZWF0ZUNsYXNzQ2FsbEV4cHJlc3Npb24gPSB0LmJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiUmVhY3QuY3JlYXRlQ2xhc3NcIik7XG5cbmV4cG9ydHMuaXNDcmVhdGVDbGFzcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZSB8fCAhdC5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gbm90IFJlYWN0LmNyZWF0ZUNsYXNzIGNhbGwgbWVtYmVyIG9iamVjdFxuICBpZiAoIWlzQ3JlYXRlQ2xhc3NDYWxsRXhwcmVzc2lvbihub2RlLmNhbGxlZSkpIHJldHVybiBmYWxzZTtcblxuICAvLyBubyBjYWxsIGFyZ3VtZW50c1xuICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAvLyBmaXJzdCBub2RlIGFyZyBpcyBub3QgYW4gb2JqZWN0XG4gIHZhciBmaXJzdCA9IGFyZ3NbMF07XG4gIGlmICghdC5pc09iamVjdEV4cHJlc3Npb24oZmlyc3QpKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmlzUmVhY3RDb21wb25lbnQgPSB0LmJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiUmVhY3QuQ29tcG9uZW50XCIpO1xuXG5leHBvcnRzLmlzQ29tcGF0VGFnID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHRhZ05hbWUgJiYgL15bYS16XXxcXC0vLnRlc3QodGFnTmFtZSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuXG52YXIgdmlzaXRvciA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkgdGhpcy5za2lwKCk7XG5cbiAgICBpZiAodC5pc0F3YWl0RXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgbm9kZS50eXBlID0gXCJZaWVsZEV4cHJlc3Npb25cIjtcblxuICAgICAgaWYgKG5vZGUuYWxsKSB7XG4gICAgICAgIC8vIGF3YWl0KiBmb287IC0+IHlpZWxkIFByb21pc2UuYWxsKGZvbyk7XG4gICAgICAgIG5vZGUuYWxsID0gZmFsc2U7XG4gICAgICAgIG5vZGUuYXJndW1lbnQgPSB0LmNhbGxFeHByZXNzaW9uKHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoXCJQcm9taXNlXCIpLCB0LmlkZW50aWZpZXIoXCJhbGxcIikpLCBbbm9kZS5hcmd1bWVudF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZSwgY2FsbElkLCBzY29wZSkge1xuICBub2RlLmFzeW5jID0gZmFsc2U7XG4gIG5vZGUuZ2VuZXJhdG9yID0gdHJ1ZTtcblxuICBzY29wZS50cmF2ZXJzZShub2RlLCB2aXNpdG9yKTtcblxuICB2YXIgY2FsbCA9IHQuY2FsbEV4cHJlc3Npb24oY2FsbElkLCBbbm9kZV0pO1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICBkZWxldGUgbm9kZS5pZDtcblxuICBpZiAodC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICB2YXIgZGVjbGFyID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKFwibGV0XCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGlkLCBjYWxsKVxuICAgIF0pO1xuICAgIGRlY2xhci5fYmxvY2tIb2lzdCA9IHRydWU7XG4gICAgcmV0dXJuIGRlY2xhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGxhY2VTdXBlcnM7XG5cbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoXCIuLi8uLi9tZXNzYWdlc1wiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpbkNsYXNzXVxuICovXG5cbmZ1bmN0aW9uIFJlcGxhY2VTdXBlcnMob3B0cywgaW5DbGFzcykge1xuICB0aGlzLnRvcExldmVsVGhpc1JlZmVyZW5jZSA9IG9wdHMudG9wTGV2ZWxUaGlzUmVmZXJlbmNlO1xuICB0aGlzLm1ldGhvZE5vZGUgICAgICAgICAgICA9IG9wdHMubWV0aG9kTm9kZTtcbiAgdGhpcy5jbGFzc05hbWUgICAgICAgICAgICAgPSBvcHRzLmNsYXNzTmFtZTtcbiAgdGhpcy5zdXBlck5hbWUgICAgICAgICAgICAgPSBvcHRzLnN1cGVyTmFtZTtcbiAgdGhpcy5pc1N0YXRpYyAgICAgICAgICAgICAgPSBvcHRzLmlzU3RhdGljO1xuICB0aGlzLmhhc1N1cGVyICAgICAgICAgICAgICA9IGZhbHNlO1xuICB0aGlzLmluQ2xhc3MgICAgICAgICAgICAgICA9IGluQ2xhc3M7XG4gIHRoaXMuaXNMb29zZSAgICAgICAgICAgICAgID0gb3B0cy5pc0xvb3NlO1xuICB0aGlzLnNjb3BlICAgICAgICAgICAgICAgICA9IG9wdHMuc2NvcGU7XG4gIHRoaXMuZmlsZSAgICAgICAgICAgICAgICAgID0gb3B0cy5maWxlO1xufVxuXG4vKipcbiAqIFNldHMgYSBzdXBlciBjbGFzcyB2YWx1ZSBvZiB0aGUgbmFtZWQgcHJvcGVydHkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgIF9zZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENMQVNTLnByb3RvdHlwZSksIFwiTUVUSE9EXCIsIFwiVkFMVUVcIiwgdGhpcylcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHByb3BlcnR5XG4gKiBAcGFyYW0ge05vZGV9IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ29tcHV0ZWRcbiAqIEBwYXJhbSB7Tm9kZX0gdGhpc0V4cHJlc3Npb25cbiAqXG4gKiBAcmV0dXJucyB7Tm9kZX1cbiAqL1xuXG5SZXBsYWNlU3VwZXJzLnByb3RvdHlwZS5zZXRTdXBlclByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSwgaXNDb21wdXRlZCwgdGhpc0V4cHJlc3Npb24pIHtcbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgdGhpcy5maWxlLmFkZEhlbHBlcihcInNldFwiKSxcbiAgICBbXG4gICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKFwiT2JqZWN0XCIpLCB0LmlkZW50aWZpZXIoXCJnZXRQcm90b3R5cGVPZlwiKSksXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLmlzU3RhdGljID8gdGhpcy5jbGFzc05hbWUgOiB0Lm1lbWJlckV4cHJlc3Npb24odGhpcy5jbGFzc05hbWUsIHQuaWRlbnRpZmllcihcInByb3RvdHlwZVwiKSlcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIGlzQ29tcHV0ZWQgPyBwcm9wZXJ0eSA6IHQubGl0ZXJhbChwcm9wZXJ0eS5uYW1lKSxcbiAgICAgIHZhbHVlLFxuICAgICAgdGhpc0V4cHJlc3Npb25cbiAgICBdXG4gICk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBub2RlIHJlcHJlc2VudGluZyB0aGUgc3VwZXIgY2xhc3MgdmFsdWUgb2YgdGhlIG5hbWVkIHByb3BlcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDTEFTUy5wcm90b3R5cGUpLCBcIk1FVEhPRFwiLCB0aGlzKVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gcHJvcGVydHlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDb21wdXRlZFxuICogQHBhcmFtIHtOb2RlfSB0aGlzRXhwcmVzc2lvblxuICpcbiAqIEByZXR1cm5zIHtOb2RlfVxuICovXG5cblJlcGxhY2VTdXBlcnMucHJvdG90eXBlLmdldFN1cGVyUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHksIGlzQ29tcHV0ZWQsIHRoaXNFeHByZXNzaW9uKSB7XG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgIHRoaXMuZmlsZS5hZGRIZWxwZXIoXCJnZXRcIiksXG4gICAgW1xuICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcIk9iamVjdFwiKSwgdC5pZGVudGlmaWVyKFwiZ2V0UHJvdG90eXBlT2ZcIikpLFxuICAgICAgICBbXG4gICAgICAgICAgdGhpcy5pc1N0YXRpYyA/IHRoaXMuY2xhc3NOYW1lIDogdC5tZW1iZXJFeHByZXNzaW9uKHRoaXMuY2xhc3NOYW1lLCB0LmlkZW50aWZpZXIoXCJwcm90b3R5cGVcIikpXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgICBpc0NvbXB1dGVkID8gcHJvcGVydHkgOiB0LmxpdGVyYWwocHJvcGVydHkubmFtZSksXG4gICAgICB0aGlzRXhwcmVzc2lvblxuICAgIF1cbiAgKTtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqL1xuXG5SZXBsYWNlU3VwZXJzLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRyYXZlcnNlTGV2ZWwodGhpcy5tZXRob2ROb2RlLnZhbHVlLCB0cnVlKTtcbn07XG5cbnZhciB2aXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgdmFyIHRvcExldmVsID0gc3RhdGUudG9wTGV2ZWw7XG4gICAgdmFyIHNlbGYgPSBzdGF0ZS5zZWxmO1xuXG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSAmJiAhdC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIGNhbGwgdHJhdmVyc2VMZXZlbCBhZ2FpbiBzbyB3ZSdyZSBjb250ZXh0IGF3YXJlXG4gICAgICBzZWxmLnRyYXZlcnNlTGV2ZWwobm9kZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xuICAgIH1cblxuICAgIGlmICh0LmlzUHJvcGVydHkobm9kZSwgeyBtZXRob2Q6IHRydWUgfSkgfHwgdC5pc01ldGhvZERlZmluaXRpb24obm9kZSkpIHtcbiAgICAgIC8vIGJyZWFrIG9uIG9iamVjdCBtZXRob2RzXG4gICAgICByZXR1cm4gdGhpcy5za2lwKCk7XG4gICAgfVxuXG4gICAgdmFyIGdldFRoaXNSZWZlcmVuY2UgPSB0b3BMZXZlbCA/XG4gICAgICAvLyB0b3AgbGV2ZWwgc28gYHRoaXNgIGlzIHRoZSBpbnN0YW5jZVxuICAgICAgdC50aGlzRXhwcmVzc2lvbiA6XG4gICAgICAvLyBub3QgaW4gdGhlIHRvcCBsZXZlbCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHJlZmVyZW5jZVxuICAgICAgc2VsZi5nZXRUaGlzUmVmZXJlbmNlLmJpbmQoc2VsZik7XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBzZWxmLnNwZWNIYW5kbGU7XG4gICAgaWYgKHNlbGYuaXNMb29zZSkgY2FsbGJhY2sgPSBzZWxmLmxvb3NlSGFuZGxlO1xuICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNlbGYsIGdldFRoaXNSZWZlcmVuY2UsIG5vZGUsIHBhcmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtCb29sZWFufSB0b3BMZXZlbFxuICovXG5cblJlcGxhY2VTdXBlcnMucHJvdG90eXBlLnRyYXZlcnNlTGV2ZWwgPSBmdW5jdGlvbiAobm9kZSwgdG9wTGV2ZWwpIHtcbiAgdmFyIHN0YXRlID0geyBzZWxmOiB0aGlzLCB0b3BMZXZlbDogdG9wTGV2ZWwgfTtcbiAgdGhpcy5zY29wZS50cmF2ZXJzZShub2RlLCB2aXNpdG9yLCBzdGF0ZSk7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKi9cblxuUmVwbGFjZVN1cGVycy5wcm90b3R5cGUuZ2V0VGhpc1JlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudG9wTGV2ZWxUaGlzUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wTGV2ZWxUaGlzUmVmZXJlbmNlO1xuICB9IGVsc2Uge1xuICAgIHZhciByZWYgPSB0aGlzLnRvcExldmVsVGhpc1JlZmVyZW5jZSA9IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwidGhpc1wiKTtcbiAgICB0aGlzLm1ldGhvZE5vZGUudmFsdWUuYm9keS5ib2R5LnVuc2hpZnQodC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKHRoaXMudG9wTGV2ZWxUaGlzUmVmZXJlbmNlLCB0LnRoaXNFeHByZXNzaW9uKCkpXG4gICAgXSkpO1xuICAgIHJldHVybiByZWY7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cblJlcGxhY2VTdXBlcnMucHJvdG90eXBlLmdldExvb3NlU3VwZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uIChpZCwgcGFyZW50KSB7XG4gIHZhciBtZXRob2ROb2RlID0gdGhpcy5tZXRob2ROb2RlO1xuICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5vZGUua2V5O1xuICB2YXIgc3VwZXJOYW1lICA9IHRoaXMuc3VwZXJOYW1lIHx8IHQuaWRlbnRpZmllcihcIkZ1bmN0aW9uXCIpO1xuXG4gIGlmIChwYXJlbnQucHJvcGVydHkgPT09IGlkKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQsIHsgY2FsbGVlOiBpZCB9KSkge1xuICAgIC8vIHN1cGVyKCk7IC0+IENsYXNzTmFtZS5wcm90b3R5cGUuTWV0aG9kTmFtZS5jYWxsKHRoaXMpO1xuICAgIHBhcmVudC5hcmd1bWVudHMudW5zaGlmdCh0LnRoaXNFeHByZXNzaW9uKCkpO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAvLyBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoKTsgfVxuICAgICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihzdXBlck5hbWUsIHQuaWRlbnRpZmllcihcImNhbGxcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHN1cGVyTmFtZTtcblxuICAgICAgLy8gZm9vKCkgeyBzdXBlcigpOyB9XG4gICAgICBpZiAoIW1ldGhvZE5vZGUuc3RhdGljKSB7XG4gICAgICAgIGlkID0gdC5tZW1iZXJFeHByZXNzaW9uKGlkLCB0LmlkZW50aWZpZXIoXCJwcm90b3R5cGVcIikpO1xuICAgICAgfVxuXG4gICAgICBpZCA9IHQubWVtYmVyRXhwcmVzc2lvbihpZCwgbWV0aG9kTmFtZSwgbWV0aG9kTm9kZS5jb21wdXRlZCk7XG4gICAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKGlkLCB0LmlkZW50aWZpZXIoXCJjYWxsXCIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiAhbWV0aG9kTm9kZS5zdGF0aWMpIHtcbiAgICAvLyBzdXBlci50ZXN0IC0+IENsYXNzTmFtZS5wcm90b3R5cGUudGVzdFxuICAgIHJldHVybiB0Lm1lbWJlckV4cHJlc3Npb24oc3VwZXJOYW1lLCB0LmlkZW50aWZpZXIoXCJwcm90b3R5cGVcIikpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdXBlck5hbWU7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRUaGlzUmVmZXJlbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICovXG5cblJlcGxhY2VTdXBlcnMucHJvdG90eXBlLmxvb3NlSGFuZGxlID0gZnVuY3Rpb24gKGdldFRoaXNSZWZlcmVuY2UsIG5vZGUsIHBhcmVudCkge1xuICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSwgeyBuYW1lOiBcInN1cGVyXCIgfSkpIHtcbiAgICB0aGlzLmhhc1N1cGVyID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5nZXRMb29zZVN1cGVyUHJvcGVydHkobm9kZSwgcGFyZW50KTtcbiAgfSBlbHNlIGlmICh0LmlzQ2FsbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgaWYgKCF0LmlzTWVtYmVyRXhwcmVzc2lvbihjYWxsZWUpKSByZXR1cm47XG4gICAgaWYgKGNhbGxlZS5vYmplY3QubmFtZSAhPT0gXCJzdXBlclwiKSByZXR1cm47XG5cbiAgICAvLyBzdXBlci50ZXN0KCk7IC0+IENsYXNzTmFtZS5wcm90b3R5cGUuTWV0aG9kTmFtZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaGFzU3VwZXIgPSB0cnVlO1xuICAgIHQuYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uKGNhbGxlZSwgdC5pZGVudGlmaWVyKFwiY2FsbFwiKSk7XG4gICAgbm9kZS5hcmd1bWVudHMudW5zaGlmdChnZXRUaGlzUmVmZXJlbmNlKCkpO1xuICB9XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0VGhpc1JlZmVyZW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqL1xuXG5SZXBsYWNlU3VwZXJzLnByb3RvdHlwZS5zcGVjSGFuZGxlID0gZnVuY3Rpb24gKGdldFRoaXNSZWZlcmVuY2UsIG5vZGUsIHBhcmVudCkge1xuICB2YXIgbWV0aG9kTm9kZSA9IHRoaXMubWV0aG9kTm9kZTtcbiAgdmFyIHByb3BlcnR5O1xuICB2YXIgY29tcHV0ZWQ7XG4gIHZhciBhcmdzO1xuICB2YXIgdGhpc1JlZmVyZW5jZTtcblxuICBpZiAoaXNJbGxlZ2FsQmFyZVN1cGVyKG5vZGUsIHBhcmVudCkpIHtcbiAgICB0aHJvdyB0aGlzLmZpbGUuZXJyb3JXaXRoTm9kZShub2RlLCBtZXNzYWdlcy5nZXQoXCJjbGFzc2VzSWxsZWdhbEJhcmVTdXBlclwiKSk7XG4gIH1cblxuICBpZiAodC5pc0NhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuICAgIGlmIChpc1N1cGVyKGNhbGxlZSwgbm9kZSkpIHtcbiAgICAgIC8vIHN1cGVyKCk7IC0+IF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzTmFtZSksIFwiTWV0aG9kTmFtZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgcHJvcGVydHkgPSBtZXRob2ROb2RlLmtleTtcbiAgICAgIGNvbXB1dGVkID0gbWV0aG9kTm9kZS5jb21wdXRlZDtcbiAgICAgIGFyZ3MgPSBub2RlLmFyZ3VtZW50cztcblxuICAgICAgLy8gYmFyZSBgc3VwZXJgIGNhbGwgaXMgaWxsZWdhbCBpbnNpZGUgbm9uLWNvbnN0cnVjdG9yc1xuICAgICAgLy8gIC0gaHR0cHM6Ly9lc2Rpc2N1c3Mub3JnL3RvcGljL3N1cGVyLWNhbGwtaW4tbWV0aG9kc1xuICAgICAgLy8gIC0gaHR0cHM6Ly90d2l0dGVyLmNvbS93eWNhdHMvc3RhdHVzLzU0NDU1MzE4NDM5NjgzNjg2NFxuICAgICAgaWYgKG1ldGhvZE5vZGUua2V5Lm5hbWUgIT09IFwiY29uc3RydWN0b3JcIiB8fCAhdGhpcy5pbkNsYXNzKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbWV0aG9kTm9kZS5rZXkubmFtZSB8fCBcIk1FVEhPRF9OQU1FXCI7XG4gICAgICAgIHRocm93IHRoaXMuZmlsZS5lcnJvcldpdGhOb2RlKG5vZGUsIG1lc3NhZ2VzLmdldChcImNsYXNzZXNJbGxlZ2FsU3VwZXJDYWxsXCIsIG1ldGhvZE5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKGNhbGxlZSkgJiYgaXNTdXBlcihjYWxsZWUub2JqZWN0LCBjYWxsZWUpKSB7XG4gICAgICAvLyBzdXBlci50ZXN0KCk7IC0+IF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzTmFtZS5wcm90b3R5cGUpLCBcInRlc3RcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHByb3BlcnR5ID0gY2FsbGVlLnByb3BlcnR5O1xuICAgICAgY29tcHV0ZWQgPSBjYWxsZWUuY29tcHV0ZWQ7XG4gICAgICBhcmdzID0gbm9kZS5hcmd1bWVudHM7XG4gICAgfVxuICB9IGVsc2UgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpICYmIGlzU3VwZXIobm9kZS5vYmplY3QsIG5vZGUpKSB7XG4gICAgLy8gc3VwZXIubmFtZTsgLT4gX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xhc3NOYW1lLnByb3RvdHlwZSksIFwibmFtZVwiLCB0aGlzKTtcbiAgICBwcm9wZXJ0eSA9IG5vZGUucHJvcGVydHk7XG4gICAgY29tcHV0ZWQgPSBub2RlLmNvbXB1dGVkO1xuICB9IGVsc2UgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSAmJiBpc1N1cGVyKG5vZGUubGVmdC5vYmplY3QsIG5vZGUubGVmdCkgJiYgbWV0aG9kTm9kZS5raW5kID09PSBcInNldFwiKSB7XG4gICAgLy8gc3VwZXIubmFtZSA9IFwidmFsXCI7IC0+IF9zZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzTmFtZS5wcm90b3R5cGUpLCBcIm5hbWVcIiwgdGhpcyk7XG4gICAgdGhpcy5oYXNTdXBlciA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc2V0U3VwZXJQcm9wZXJ0eShub2RlLmxlZnQucHJvcGVydHksIG5vZGUucmlnaHQsIG5vZGUubGVmdC5jb21wdXRlZCwgZ2V0VGhpc1JlZmVyZW5jZSgpKTtcbiAgfVxuXG4gIGlmICghcHJvcGVydHkpIHJldHVybjtcblxuICB0aGlzLmhhc1N1cGVyID0gdHJ1ZTtcblxuICB0aGlzUmVmZXJlbmNlID0gZ2V0VGhpc1JlZmVyZW5jZSgpO1xuICB2YXIgc3VwZXJQcm9wZXJ0eSA9IHRoaXMuZ2V0U3VwZXJQcm9wZXJ0eShwcm9wZXJ0eSwgY29tcHV0ZWQsIHRoaXNSZWZlcmVuY2UpO1xuICBpZiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0LmlzU3ByZWFkRWxlbWVudChhcmdzWzBdKSkge1xuICAgICAgLy8gc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oc3VwZXJQcm9wZXJ0eSwgdC5pZGVudGlmaWVyKFwiYXBwbHlcIikpLFxuICAgICAgICBbdGhpc1JlZmVyZW5jZSwgYXJnc1swXS5hcmd1bWVudF1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oc3VwZXJQcm9wZXJ0eSwgdC5pZGVudGlmaWVyKFwiY2FsbFwiKSksXG4gICAgICAgIFt0aGlzUmVmZXJlbmNlXS5jb25jYXQoYXJncylcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdXBlclByb3BlcnR5O1xuICB9XG59O1xuXG52YXIgaXNJbGxlZ2FsQmFyZVN1cGVyID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIWlzU3VwZXIobm9kZSwgcGFyZW50KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50LCB7IGNvbXB1dGVkOiBmYWxzZSB9KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodC5pc0NhbGxFeHByZXNzaW9uKHBhcmVudCwgeyBjYWxsZWU6IG5vZGUgfSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNTdXBlciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHQuaXNJZGVudGlmaWVyKG5vZGUsIHsgbmFtZTogXCJzdXBlclwiIH0pICYmIHQuaXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmhhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBmaXJzdCA9IG5vZGUuYm9keVswXTtcbiAgcmV0dXJuIHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KGZpcnN0KSAmJiB0LmlzTGl0ZXJhbChmaXJzdC5leHByZXNzaW9uLCB7IHZhbHVlOiBcInVzZSBzdHJpY3RcIiB9KTtcbn07XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICB2YXIgdXNlU3RyaWN0Tm9kZTtcbiAgaWYgKGV4cG9ydHMuaGFzKG5vZGUpKSB7XG4gICAgdXNlU3RyaWN0Tm9kZSA9IG5vZGUuYm9keS5zaGlmdCgpO1xuICB9XG5cbiAgY2FsbGJhY2soKTtcblxuICBpZiAodXNlU3RyaWN0Tm9kZSkge1xuICAgIG5vZGUuYm9keS51bnNoaWZ0KHVzZVN0cmljdE5vZGUpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuXG52YXIgbm9ybWFsaXplQXN0ID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9ybWFsaXplLWFzdFwiKTtcbnZhciBUcmFuc2Zvcm1lciAgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1lclwiKTtcbnZhciBvYmplY3QgICAgICAgPSByZXF1aXJlKFwiLi4vaGVscGVycy9vYmplY3RcIik7XG52YXIgRmlsZSAgICAgICAgID0gcmVxdWlyZShcIi4vZmlsZVwiKTtcbnZhciBlYWNoICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtKGNvZGUsIG9wdHMpIHtcbiAgdmFyIGZpbGUgPSBuZXcgRmlsZShvcHRzKTtcbiAgcmV0dXJuIGZpbGUucGFyc2UoY29kZSk7XG59XG5cbnRyYW5zZm9ybS5mcm9tQXN0ID0gZnVuY3Rpb24gKGFzdCwgY29kZSwgb3B0cykge1xuICBhc3QgPSBub3JtYWxpemVBc3QoYXN0KTtcblxuICB2YXIgZmlsZSA9IG5ldyBGaWxlKG9wdHMpO1xuICBmaWxlLmFkZENvZGUoY29kZSk7XG4gIGZpbGUudHJhbnNmb3JtKGFzdCk7XG4gIHJldHVybiBmaWxlLmdlbmVyYXRlKCk7XG59O1xuXG50cmFuc2Zvcm0uX2Vuc3VyZVRyYW5zZm9ybWVyTmFtZXMgPSBmdW5jdGlvbiAodHlwZSwgcmF3S2V5cykge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByYXdLZXlzW2ldO1xuXG4gICAgdmFyIGRlcHJlY2F0ZWRLZXkgPSB0cmFuc2Zvcm0uZGVwcmVjYXRlZFRyYW5zZm9ybWVyTWFwW2tleV07XG4gICAgaWYgKGRlcHJlY2F0ZWRLZXkpIHtcbiAgICAgIC8vIGRlcHJlY2F0ZWQga2V5LCByZW1hcCBpdCB0byB0aGUgbmV3IG9uZVxuICAgICAgY29uc29sZS5lcnJvcihcIlRoZSB0cmFuc2Zvcm1lciBcIiArIGtleSArIFwiIGhhcyBiZWVuIHJlbmFtZWQgdG8gXCIgKyBkZXByZWNhdGVkS2V5KTtcbiAgICAgIHJhd0tleXMucHVzaChkZXByZWNhdGVkS2V5KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm1lcnNba2V5XSkge1xuICAgICAgLy8gdmFsaWQga2V5XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS5uYW1lc3BhY2VzW2tleV0pIHtcbiAgICAgIC8vIG5hbWVzcGFjZSwgYXBwZW5kIGFsbCB0cmFuc2Zvcm1lcnMgd2l0aGluIHRoaXMgbmFtZXNwYWNlXG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQodHJhbnNmb3JtLm5hbWVzcGFjZXNba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludmFsaWQga2V5XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJVbmtub3duIHRyYW5zZm9ybWVyIFwiICsga2V5ICsgXCIgc3BlY2lmaWVkIGluIFwiICsgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuXG50cmFuc2Zvcm0udHJhbnNmb3JtZXJOYW1lc3BhY2VzID0gb2JqZWN0KCk7XG50cmFuc2Zvcm0udHJhbnNmb3JtZXJzICAgICAgICAgID0gb2JqZWN0KCk7XG50cmFuc2Zvcm0ubmFtZXNwYWNlcyAgICAgICAgICAgID0gb2JqZWN0KCk7XG5cbnRyYW5zZm9ybS5kZXByZWNhdGVkVHJhbnNmb3JtZXJNYXAgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1lcnMvZGVwcmVjYXRlZFwiKTtcbnRyYW5zZm9ybS5tb2R1bGVGb3JtYXR0ZXJzID0gcmVxdWlyZShcIi4vbW9kdWxlc1wiKTtcblxudmFyIHJhd1RyYW5zZm9ybWVycyA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWVyc1wiKTtcblxuZWFjaChyYXdUcmFuc2Zvcm1lcnMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1lciwga2V5KSB7XG4gIHZhciBuYW1lc3BhY2UgPSBrZXkuc3BsaXQoXCIuXCIpWzBdO1xuXG4gIHRyYW5zZm9ybS5uYW1lc3BhY2VzW25hbWVzcGFjZV0gPSB0cmFuc2Zvcm0ubmFtZXNwYWNlc1tuYW1lc3BhY2VdIHx8IFtdO1xuICB0cmFuc2Zvcm0ubmFtZXNwYWNlc1tuYW1lc3BhY2VdLnB1c2goa2V5KTtcbiAgdHJhbnNmb3JtLnRyYW5zZm9ybWVyTmFtZXNwYWNlc1trZXldID0gbmFtZXNwYWNlO1xuXG4gIHRyYW5zZm9ybS50cmFuc2Zvcm1lcnNba2V5XSA9IG5ldyBUcmFuc2Zvcm1lcihrZXksIHRyYW5zZm9ybWVyKTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEZvcm1hdHRlcjtcblxudmFyIG1lc3NhZ2VzID0gcmVxdWlyZShcIi4uLy4uL21lc3NhZ2VzXCIpO1xudmFyIGV4dGVuZCAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvZXh0ZW5kXCIpO1xudmFyIG9iamVjdCAgID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvb2JqZWN0XCIpO1xudmFyIHV0aWwgICAgID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdCAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIERlZmF1bHRGb3JtYXR0ZXIoZmlsZSkge1xuICB0aGlzLnNjb3BlID0gZmlsZS5zY29wZTtcbiAgdGhpcy5maWxlICA9IGZpbGU7XG4gIHRoaXMuaWRzICAgPSBvYmplY3QoKTtcblxuICB0aGlzLmhhc05vbkRlZmF1bHRFeHBvcnRzID0gZmFsc2U7XG5cbiAgdGhpcy5oYXNMb2NhbEV4cG9ydHMgPSBmYWxzZTtcbiAgdGhpcy5oYXNMb2NhbEltcG9ydHMgPSBmYWxzZTtcblxuICB0aGlzLmxvY2FsSW1wb3J0T2NjdXJlbmNlcyA9IG9iamVjdCgpO1xuICB0aGlzLmxvY2FsRXhwb3J0cyA9IG9iamVjdCgpO1xuICB0aGlzLmxvY2FsSW1wb3J0cyA9IG9iamVjdCgpO1xuXG4gIHRoaXMuZ2V0TG9jYWxFeHBvcnRzKCk7XG4gIHRoaXMuZ2V0TG9jYWxJbXBvcnRzKCk7XG5cbiAgdGhpcy5yZW1hcEFzc2lnbm1lbnRzKCk7XG59XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmRvRGVmYXVsdEV4cG9ydEludGVyb3AgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS5kZWZhdWx0ICYmICF0aGlzLm5vSW50ZXJvcFJlcXVpcmVFeHBvcnQgJiYgIXRoaXMuaGFzTm9uRGVmYXVsdEV4cG9ydHM7XG59O1xuXG5EZWZhdWx0Rm9ybWF0dGVyLnByb3RvdHlwZS5idW1wSW1wb3J0T2NjdXJlbmNlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBzb3VyY2UgPSBub2RlLnNvdXJjZS52YWx1ZTtcbiAgdmFyIG9jY3VycyA9IHRoaXMubG9jYWxJbXBvcnRPY2N1cmVuY2VzO1xuICBvY2N1cnNbc291cmNlXSA9IG9jY3Vyc1tzb3VyY2VdIHx8IDA7XG4gIG9jY3Vyc1tzb3VyY2VdICs9IG5vZGUuc3BlY2lmaWVycy5sZW5ndGg7XG59O1xuXG52YXIgZXhwb3J0c1Zpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZm9ybWF0dGVyKSB7XG4gICAgdmFyIGRlY2xhciA9IG5vZGUgJiYgbm9kZS5kZWNsYXJhdGlvbjtcbiAgICBpZiAodC5pc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICBmb3JtYXR0ZXIuaGFzTG9jYWxJbXBvcnRzID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlY2xhciAmJiB0LmlzU3RhdGVtZW50KGRlY2xhcikpIHtcbiAgICAgICAgZXh0ZW5kKGZvcm1hdHRlci5sb2NhbEV4cG9ydHMsIHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKGRlY2xhcikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5vZGUuZGVmYXVsdCkge1xuICAgICAgICBmb3JtYXR0ZXIuaGFzTm9uRGVmYXVsdEV4cG9ydHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgICAgZm9ybWF0dGVyLmJ1bXBJbXBvcnRPY2N1cmVuY2VzKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TG9jYWxFeHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZpbGUuc2NvcGUudHJhdmVyc2UodGhpcy5maWxlLmFzdCwgZXhwb3J0c1Zpc2l0b3IsIHRoaXMpO1xufTtcblxudmFyIGltcG9ydHNWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZvcm1hdHRlcikge1xuICAgIGlmICh0LmlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIGZvcm1hdHRlci5oYXNMb2NhbEltcG9ydHMgPSB0cnVlO1xuICAgICAgZXh0ZW5kKGZvcm1hdHRlci5sb2NhbEltcG9ydHMsIHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUpKTtcbiAgICAgIGZvcm1hdHRlci5idW1wSW1wb3J0T2NjdXJlbmNlcyhub2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmdldExvY2FsSW1wb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5maWxlLnNjb3BlLnRyYXZlcnNlKHRoaXMuZmlsZS5hc3QsIGltcG9ydHNWaXNpdG9yLCB0aGlzKTtcbn07XG5cbnZhciByZW1hcFZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKHQuaXNVcGRhdGVFeHByZXNzaW9uKG5vZGUpICYmIGZvcm1hdHRlci5pc0xvY2FsUmVmZXJlbmNlKG5vZGUuYXJndW1lbnQsIHNjb3BlKSkge1xuICAgICAgdGhpcy5za2lwKCk7XG5cbiAgICAgIC8vIGV4cGFuZCB0byBsb25nIGZpbGUgYXNzaWdubWVudCBleHByZXNzaW9uXG4gICAgICB2YXIgYXNzaWduID0gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihub2RlLm9wZXJhdG9yWzBdICsgXCI9XCIsIG5vZGUuYXJndW1lbnQsIHQubGl0ZXJhbCgxKSk7XG5cbiAgICAgIC8vIHJlbWFwIHRoaXMgYXNzaWdubWVudCBleHByZXNzaW9uXG4gICAgICB2YXIgcmVtYXBwZWQgPSBmb3JtYXR0ZXIucmVtYXBFeHBvcnRBc3NpZ25tZW50KGFzc2lnbik7XG5cbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIHRoZSByZXN1bHRcbiAgICAgIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChwYXJlbnQpIHx8IG5vZGUucHJlZml4KSB7XG4gICAgICAgIHJldHVybiByZW1hcHBlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICBub2Rlcy5wdXNoKHJlbWFwcGVkKTtcblxuICAgICAgdmFyIG9wZXJhdG9yO1xuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiLS1cIikge1xuICAgICAgICBvcGVyYXRvciA9IFwiK1wiO1xuICAgICAgfSBlbHNlIHsgLy8gXCIrK1wiXG4gICAgICAgIG9wZXJhdG9yID0gXCItXCI7XG4gICAgICB9XG4gICAgICBub2Rlcy5wdXNoKHQuYmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbm9kZS5hcmd1bWVudCwgdC5saXRlcmFsKDEpKSk7XG5cbiAgICAgIHJldHVybiB0LnNlcXVlbmNlRXhwcmVzc2lvbihub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSAmJiBmb3JtYXR0ZXIuaXNMb2NhbFJlZmVyZW5jZShub2RlLmxlZnQsIHNjb3BlKSkge1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLnJlbWFwRXhwb3J0QXNzaWdubWVudChub2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLnJlbWFwQXNzaWdubWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmhhc0xvY2FsSW1wb3J0cykge1xuICAgIHRoaXMuZmlsZS5zY29wZS50cmF2ZXJzZSh0aGlzLmZpbGUuYXN0LCByZW1hcFZpc2l0b3IsIHRoaXMpO1xuICB9XG59O1xuXG5EZWZhdWx0Rm9ybWF0dGVyLnByb3RvdHlwZS5pc0xvY2FsUmVmZXJlbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGxvY2FsSW1wb3J0cyA9IHRoaXMubG9jYWxJbXBvcnRzO1xuICByZXR1cm4gdC5pc0lkZW50aWZpZXIobm9kZSkgJiYgbG9jYWxJbXBvcnRzW25vZGUubmFtZV0gJiYgbG9jYWxJbXBvcnRzW25vZGUubmFtZV0gIT09IG5vZGU7XG59O1xuXG5EZWZhdWx0Rm9ybWF0dGVyLnByb3RvdHlwZS5yZW1hcEV4cG9ydEFzc2lnbm1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICBcIj1cIixcbiAgICBub2RlLmxlZnQsXG4gICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIG5vZGUub3BlcmF0b3IsXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKFwiZXhwb3J0c1wiKSwgbm9kZS5sZWZ0KSxcbiAgICAgIG5vZGUucmlnaHRcbiAgICApXG4gICk7XG59O1xuXG5EZWZhdWx0Rm9ybWF0dGVyLnByb3RvdHlwZS5pc0xvY2FsUmVmZXJlbmNlID0gZnVuY3Rpb24gKG5vZGUsIHNjb3BlKSB7XG4gIHZhciBsb2NhbEV4cG9ydHMgPSB0aGlzLmxvY2FsRXhwb3J0cztcbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIHJldHVybiB0LmlzSWRlbnRpZmllcihub2RlKSAmJiBsb2NhbEV4cG9ydHNbbmFtZV0gJiYgbG9jYWxFeHBvcnRzW25hbWVdID09PSBzY29wZS5nZXRCaW5kaW5nSWRlbnRpZmllcihuYW1lKTtcbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmdldE1vZHVsZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0gdGhpcy5maWxlLm9wdHM7XG4gIHZhciBmaWxlbmFtZVJlbGF0aXZlID0gb3B0cy5maWxlbmFtZVJlbGF0aXZlO1xuICB2YXIgbW9kdWxlTmFtZSA9IFwiXCI7XG5cbiAgaWYgKG9wdHMubW9kdWxlUm9vdCkge1xuICAgIG1vZHVsZU5hbWUgPSBvcHRzLm1vZHVsZVJvb3QgKyBcIi9cIjtcbiAgfVxuXG4gIGlmICghb3B0cy5maWxlbmFtZVJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIG1vZHVsZU5hbWUgKyBvcHRzLmZpbGVuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgfVxuXG4gIGlmIChvcHRzLnNvdXJjZVJvb3QpIHtcbiAgICAvLyByZW1vdmUgc291cmNlUm9vdCBmcm9tIGZpbGVuYW1lXG4gICAgdmFyIHNvdXJjZVJvb3RSZWdFeCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBvcHRzLnNvdXJjZVJvb3QgKyBcIlxcLz9cIik7XG4gICAgZmlsZW5hbWVSZWxhdGl2ZSA9IGZpbGVuYW1lUmVsYXRpdmUucmVwbGFjZShzb3VyY2VSb290UmVnRXgsIFwiXCIpO1xuICB9XG5cbiAgaWYgKCFvcHRzLmtlZXBNb2R1bGVJZEV4dGVuc2lvbnMpIHtcbiAgICAvLyByZW1vdmUgZXh0ZW5zaW9uXG4gICAgZmlsZW5hbWVSZWxhdGl2ZSA9IGZpbGVuYW1lUmVsYXRpdmUucmVwbGFjZSgvXFwuKFxcdyo/KSQvLCBcIlwiKTtcbiAgfVxuXG4gIG1vZHVsZU5hbWUgKz0gZmlsZW5hbWVSZWxhdGl2ZTtcblxuICAvLyBub3JtYWxpemUgcGF0aCBzZXBhcmF0b3JzXG4gIG1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuXG4gIHJldHVybiBtb2R1bGVOYW1lO1xufTtcblxuRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuX3B1c2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAocmVmLCBub2Rlcykge1xuICBpZiAodC5pc0NsYXNzKHJlZikgfHwgdC5pc0Z1bmN0aW9uKHJlZikpIHtcbiAgICBpZiAocmVmLmlkKSB7XG4gICAgICBub2Rlcy5wdXNoKHQudG9TdGF0ZW1lbnQocmVmKSk7XG4gICAgICByZWYgPSByZWYuaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZjtcbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLl9ob2lzdEV4cG9ydCA9IGZ1bmN0aW9uIChkZWNsYXIsIGFzc2lnbiwgcHJpb3JpdHkpIHtcbiAgaWYgKHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcikpIHtcbiAgICBhc3NpZ24uX2Jsb2NrSG9pc3QgPSBwcmlvcml0eSB8fCAyO1xuICB9XG5cbiAgcmV0dXJuIGFzc2lnbjtcbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmdldEV4dGVybmFsUmVmZXJlbmNlID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVzKSB7XG4gIHZhciBpZHMgPSB0aGlzLmlkcztcbiAgdmFyIGlkID0gbm9kZS5zb3VyY2UudmFsdWU7XG5cbiAgaWYgKGlkc1tpZF0pIHtcbiAgICByZXR1cm4gaWRzW2lkXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5pZHNbaWRdID0gdGhpcy5fZ2V0RXh0ZXJuYWxSZWZlcmVuY2Uobm9kZSwgbm9kZXMpO1xuICB9XG59O1xuXG5EZWZhdWx0Rm9ybWF0dGVyLnByb3RvdHlwZS5jaGVja0V4cG9ydElkZW50aWZpZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSwgeyBuYW1lOiBcIl9fZXNNb2R1bGVcIiB9KSkge1xuICAgIHRocm93IHRoaXMuZmlsZS5lcnJvcldpdGhOb2RlKG5vZGUsIG1lc3NhZ2VzLmdldChcIm1vZHVsZXNJbGxlZ2FsRXhwb3J0TmFtZVwiLCBub2RlLm5hbWUpKTtcbiAgfVxufTtcblxuRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuZXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKHNwZWNpZmllciwgbm9kZSwgbm9kZXMpIHtcbiAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZ2V0RXh0ZXJuYWxSZWZlcmVuY2Uobm9kZSwgbm9kZXMpO1xuXG4gICAgaWYgKHQuaXNFeHBvcnRCYXRjaFNwZWNpZmllcihzcGVjaWZpZXIpKSB7XG4gICAgICAvLyBleHBvcnQgKiBmcm9tIFwiZm9vXCI7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuYnVpbGRFeHBvcnRzV2lsZGNhcmQocmVmLCBub2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0LmlzU3BlY2lmaWVyRGVmYXVsdChzcGVjaWZpZXIpICYmICF0aGlzLm5vSW50ZXJvcFJlcXVpcmVFeHBvcnQpIHtcbiAgICAgICAgLy8gaW1wb3J0aW5nIGEgZGVmYXVsdCBzbyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBpdFxuICAgICAgICByZWYgPSB0LmNhbGxFeHByZXNzaW9uKHRoaXMuZmlsZS5hZGRIZWxwZXIoXCJpbnRlcm9wLXJlcXVpcmVcIiksIFtyZWZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZiA9IHQubWVtYmVyRXhwcmVzc2lvbihyZWYsIHQuZ2V0U3BlY2lmaWVySWQoc3BlY2lmaWVyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cG9ydCB7IGZvbyB9IGZyb20gXCJ0ZXN0XCI7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuYnVpbGRFeHBvcnRzQXNzaWdubWVudChcbiAgICAgICAgdC5nZXRTcGVjaWZpZXJOYW1lKHNwZWNpZmllciksXG4gICAgICAgIHJlZixcbiAgICAgICAgbm9kZVxuICAgICAgKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGV4cG9ydCB7IGZvbyB9O1xuICAgIG5vZGVzLnB1c2godGhpcy5idWlsZEV4cG9ydHNBc3NpZ25tZW50KHQuZ2V0U3BlY2lmaWVyTmFtZShzcGVjaWZpZXIpLCBzcGVjaWZpZXIuaWQsIG5vZGUpKTtcbiAgfVxufTtcblxuRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuYnVpbGRFeHBvcnRzV2lsZGNhcmQgPSBmdW5jdGlvbiAob2JqZWN0SWRlbnRpZmllcikge1xuICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KHQuY2FsbEV4cHJlc3Npb24odGhpcy5maWxlLmFkZEhlbHBlcihcImRlZmF1bHRzXCIpLCBbXG4gICAgdC5pZGVudGlmaWVyKFwiZXhwb3J0c1wiKSxcbiAgICB0LmNhbGxFeHByZXNzaW9uKHRoaXMuZmlsZS5hZGRIZWxwZXIoXCJpbnRlcm9wLXJlcXVpcmUtd2lsZGNhcmRcIiksIFtvYmplY3RJZGVudGlmaWVyXSlcbiAgXSkpO1xufTtcblxuRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuYnVpbGRFeHBvcnRzQXNzaWdubWVudCA9IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICB0aGlzLmNoZWNrRXhwb3J0SWRlbnRpZmllcihpZCk7XG4gIHJldHVybiB1dGlsLnRlbXBsYXRlKFwiZXhwb3J0cy1hc3NpZ25cIiwge1xuICAgIFZBTFVFOiBpbml0LFxuICAgIEtFWTogICBpZFxuICB9LCB0cnVlKTtcbn07XG5cbkRlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVzKSB7XG4gIHZhciBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uO1xuXG4gIHZhciBpZCA9IGRlY2xhci5pZDtcblxuICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgaWQgPSB0LmlkZW50aWZpZXIoXCJkZWZhdWx0XCIpO1xuICB9XG5cbiAgdmFyIGFzc2lnbjtcblxuICBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjbGFyLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlY2wgPSBkZWNsYXIuZGVjbGFyYXRpb25zW2ldO1xuXG4gICAgICBkZWNsLmluaXQgPSB0aGlzLmJ1aWxkRXhwb3J0c0Fzc2lnbm1lbnQoZGVjbC5pZCwgZGVjbC5pbml0LCBub2RlKS5leHByZXNzaW9uO1xuXG4gICAgICB2YXIgbmV3RGVjbGFyID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhci5raW5kLCBbZGVjbF0pO1xuICAgICAgaWYgKGkgPT09IDApIHQuaW5oZXJpdHMobmV3RGVjbGFyLCBkZWNsYXIpO1xuICAgICAgbm9kZXMucHVzaChuZXdEZWNsYXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVmID0gZGVjbGFyO1xuXG4gICAgaWYgKHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcikgfHwgdC5pc0NsYXNzRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgcmVmID0gZGVjbGFyLmlkO1xuICAgICAgbm9kZXMucHVzaChkZWNsYXIpO1xuICAgIH1cblxuICAgIGFzc2lnbiA9IHRoaXMuYnVpbGRFeHBvcnRzQXNzaWdubWVudChpZCwgcmVmLCBub2RlKTtcblxuICAgIG5vZGVzLnB1c2goYXNzaWduKTtcblxuICAgIHRoaXMuX2hvaXN0RXhwb3J0KGRlY2xhciwgYXNzaWduKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9JbnRlcm9wUmVxdWlyZUltcG9ydCA9IHRydWU7XG4gICAgdGhpcy5ub0ludGVyb3BSZXF1aXJlRXhwb3J0ID0gdHJ1ZTtcbiAgICBQYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB1dGlsLmluaGVyaXRzKENvbnN0cnVjdG9yLCBQYXJlbnQpO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9fc3RyaWN0XCIpKHJlcXVpcmUoXCIuL2FtZFwiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBBTURGb3JtYXR0ZXI7XG5cbnZhciBEZWZhdWx0Rm9ybWF0dGVyID0gcmVxdWlyZShcIi4vX2RlZmF1bHRcIik7XG52YXIgQ29tbW9uRm9ybWF0dGVyICA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBpbmNsdWRlcyAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2luY2x1ZGVzXCIpO1xudmFyIHZhbHVlcyAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC92YWx1ZXNcIik7XG52YXIgdXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIEFNREZvcm1hdHRlcigpIHtcbiAgQ29tbW9uRm9ybWF0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQU1ERm9ybWF0dGVyLCBEZWZhdWx0Rm9ybWF0dGVyKTtcblxuQU1ERm9ybWF0dGVyLnByb3RvdHlwZS5pbml0ID0gQ29tbW9uRm9ybWF0dGVyLnByb3RvdHlwZS5pbml0O1xuXG5BTURGb3JtYXR0ZXIucHJvdG90eXBlLmJ1aWxkRGVwZW5kZW5jeUxpdGVyYWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZXMgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmlkcykge1xuICAgIG5hbWVzLnB1c2godC5saXRlcmFsKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFdyYXAgdGhlIGVudGlyZSBib2R5IGluIGEgYGRlZmluZWAgd3JhcHBlci5cbiAqL1xuXG5BTURGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gIHZhciBib2R5ID0gcHJvZ3JhbS5ib2R5O1xuXG4gIC8vIGJ1aWxkIGFuIGFycmF5IG9mIG1vZHVsZSBuYW1lc1xuXG4gIHZhciBuYW1lcyA9IFt0LmxpdGVyYWwoXCJleHBvcnRzXCIpXTtcbiAgaWYgKHRoaXMucGFzc01vZHVsZUFyZykgbmFtZXMucHVzaCh0LmxpdGVyYWwoXCJtb2R1bGVcIikpO1xuICBuYW1lcyA9IG5hbWVzLmNvbmNhdCh0aGlzLmJ1aWxkRGVwZW5kZW5jeUxpdGVyYWxzKCkpO1xuICBuYW1lcyA9IHQuYXJyYXlFeHByZXNzaW9uKG5hbWVzKTtcblxuICAvLyBidWlsZCB1cCBkZWZpbmUgY29udGFpbmVyXG5cbiAgdmFyIHBhcmFtcyA9IHZhbHVlcyh0aGlzLmlkcyk7XG4gIGlmICh0aGlzLnBhc3NNb2R1bGVBcmcpIHBhcmFtcy51bnNoaWZ0KHQuaWRlbnRpZmllcihcIm1vZHVsZVwiKSk7XG4gIHBhcmFtcy51bnNoaWZ0KHQuaWRlbnRpZmllcihcImV4cG9ydHNcIikpO1xuXG4gIHZhciBjb250YWluZXIgPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMsIHQuYmxvY2tTdGF0ZW1lbnQoYm9keSkpO1xuXG4gIHZhciBkZWZpbmVBcmdzID0gW25hbWVzLCBjb250YWluZXJdO1xuICB2YXIgbW9kdWxlTmFtZSA9IHRoaXMuZ2V0TW9kdWxlTmFtZSgpO1xuICBpZiAobW9kdWxlTmFtZSkgZGVmaW5lQXJncy51bnNoaWZ0KHQubGl0ZXJhbChtb2R1bGVOYW1lKSk7XG5cbiAgdmFyIGNhbGwgPSB0LmNhbGxFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcImRlZmluZVwiKSwgZGVmaW5lQXJncyk7XG5cbiAgcHJvZ3JhbS5ib2R5ID0gW3QuZXhwcmVzc2lvblN0YXRlbWVudChjYWxsKV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQU1EIG1vZHVsZSBuYW1lIHRoYXQgd2UnbGwgcHJlcGVuZCB0byB0aGUgd3JhcHBlclxuICogdG8gZGVmaW5lIHRoaXMgbW9kdWxlXG4gKi9cblxuQU1ERm9ybWF0dGVyLnByb3RvdHlwZS5nZXRNb2R1bGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5maWxlLm9wdHMubW9kdWxlSWRzKSB7XG4gICAgcmV0dXJuIERlZmF1bHRGb3JtYXR0ZXIucHJvdG90eXBlLmdldE1vZHVsZU5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuQU1ERm9ybWF0dGVyLnByb3RvdHlwZS5fZ2V0RXh0ZXJuYWxSZWZlcmVuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIobm9kZS5zb3VyY2UudmFsdWUpO1xufTtcblxuQU1ERm9ybWF0dGVyLnByb3RvdHlwZS5pbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMuZ2V0RXh0ZXJuYWxSZWZlcmVuY2Uobm9kZSk7XG59O1xuXG5BTURGb3JtYXR0ZXIucHJvdG90eXBlLmltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uIChzcGVjaWZpZXIsIG5vZGUsIG5vZGVzKSB7XG4gIHZhciBrZXkgPSB0LmdldFNwZWNpZmllck5hbWUoc3BlY2lmaWVyKTtcbiAgdmFyIHJlZiA9IHRoaXMuZ2V0RXh0ZXJuYWxSZWZlcmVuY2Uobm9kZSk7XG5cbiAgaWYgKGluY2x1ZGVzKHRoaXMuZmlsZS5keW5hbWljSW1wb3J0ZWROb0RlZmF1bHQsIG5vZGUpKSB7XG4gICAgLy8gUHJldmVudCB1bm5lY2Vzc2FyeSByZW5hbWluZyBvZiBkeW5hbWljIGltcG9ydHMuXG4gICAgdGhpcy5pZHNbbm9kZS5zb3VyY2UudmFsdWVdID0gcmVmO1xuICB9IGVsc2UgaWYgKHQuaXNJbXBvcnRCYXRjaFNwZWNpZmllcihzcGVjaWZpZXIpKSB7XG4gICAgLy8gaW1wb3J0ICogYXMgYmFyIGZyb20gXCJmb29cIjtcbiAgfSBlbHNlIGlmICghaW5jbHVkZXModGhpcy5maWxlLmR5bmFtaWNJbXBvcnRlZCwgbm9kZSkgJiYgdC5pc1NwZWNpZmllckRlZmF1bHQoc3BlY2lmaWVyKSAmJiAhdGhpcy5ub0ludGVyb3BSZXF1aXJlSW1wb3J0KSB7XG4gICAgLy8gaW1wb3J0IGZvbyBmcm9tIFwiZm9vXCI7XG4gICAgcmVmID0gdC5jYWxsRXhwcmVzc2lvbih0aGlzLmZpbGUuYWRkSGVscGVyKFwiaW50ZXJvcC1yZXF1aXJlXCIpLCBbcmVmXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW1wb3J0IHtmb299IGZyb20gXCJmb29cIjtcbiAgICByZWYgPSB0Lm1lbWJlckV4cHJlc3Npb24ocmVmLCB0LmdldFNwZWNpZmllcklkKHNwZWNpZmllciksIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGVzLnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihrZXksIHJlZilcbiAgXSkpO1xufTtcblxuQU1ERm9ybWF0dGVyLnByb3RvdHlwZS5leHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmRvRGVmYXVsdEV4cG9ydEludGVyb3Aobm9kZSkpIHtcbiAgICB0aGlzLnBhc3NNb2R1bGVBcmcgPSB0cnVlO1xuICB9XG5cbiAgQ29tbW9uRm9ybWF0dGVyLnByb3RvdHlwZS5leHBvcnREZWNsYXJhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL19zdHJpY3RcIikocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1vbkpTRm9ybWF0dGVyO1xuXG52YXIgRGVmYXVsdEZvcm1hdHRlciA9IHJlcXVpcmUoXCIuL19kZWZhdWx0XCIpO1xudmFyIGluY2x1ZGVzICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vaW5jbHVkZXNcIik7XG52YXIgdXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG5cbmZ1bmN0aW9uIENvbW1vbkpTRm9ybWF0dGVyKCkge1xuICBEZWZhdWx0Rm9ybWF0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQ29tbW9uSlNGb3JtYXR0ZXIsIERlZmF1bHRGb3JtYXR0ZXIpO1xuXG5Db21tb25KU0Zvcm1hdHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZpbGUgID0gdGhpcy5maWxlO1xuICB2YXIgc2NvcGUgPSBmaWxlLnNjb3BlO1xuXG4gIHNjb3BlLnJlbmFtZShcIm1vZHVsZVwiKTtcblxuICBpZiAoIXRoaXMubm9JbnRlcm9wUmVxdWlyZUltcG9ydCAmJiB0aGlzLmhhc05vbkRlZmF1bHRFeHBvcnRzKSB7XG4gICAgdmFyIHRlbXBsYXRlTmFtZSA9IFwiZXhwb3J0cy1tb2R1bGUtZGVjbGFyYXRpb25cIjtcbiAgICBpZiAodGhpcy5maWxlLmlzTG9vc2UoXCJlczYubW9kdWxlc1wiKSkgdGVtcGxhdGVOYW1lICs9IFwiLWxvb3NlXCI7XG4gICAgZmlsZS5hc3QucHJvZ3JhbS5ib2R5LnB1c2godXRpbC50ZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUsIHRydWUpKTtcbiAgfVxufTtcblxuQ29tbW9uSlNGb3JtYXR0ZXIucHJvdG90eXBlLmltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uIChzcGVjaWZpZXIsIG5vZGUsIG5vZGVzKSB7XG4gIHZhciB2YXJpYWJsZU5hbWUgPSB0LmdldFNwZWNpZmllck5hbWUoc3BlY2lmaWVyKTtcblxuICB2YXIgcmVmID0gdGhpcy5nZXRFeHRlcm5hbFJlZmVyZW5jZShub2RlLCBub2Rlcyk7XG5cbiAgLy8gaW1wb3J0IGZvbyBmcm9tIFwiZm9vXCI7XG4gIGlmICh0LmlzU3BlY2lmaWVyRGVmYXVsdChzcGVjaWZpZXIpKSB7XG4gICAgaWYgKCFpbmNsdWRlcyh0aGlzLmZpbGUuZHluYW1pY0ltcG9ydGVkTm9EZWZhdWx0LCBub2RlKSkge1xuICAgICAgaWYgKHRoaXMubm9JbnRlcm9wUmVxdWlyZUltcG9ydCB8fCBpbmNsdWRlcyh0aGlzLmZpbGUuZHluYW1pY0ltcG9ydGVkLCBub2RlKSkge1xuICAgICAgICByZWYgPSB0Lm1lbWJlckV4cHJlc3Npb24ocmVmLCB0LmlkZW50aWZpZXIoXCJkZWZhdWx0XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZiA9IHQuY2FsbEV4cHJlc3Npb24odGhpcy5maWxlLmFkZEhlbHBlcihcImludGVyb3AtcmVxdWlyZVwiKSwgW3JlZl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBub2Rlcy5wdXNoKHQudmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbdC52YXJpYWJsZURlY2xhcmF0b3IodmFyaWFibGVOYW1lLCByZWYpXSkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gXCJJbXBvcnRCYXRjaFNwZWNpZmllclwiKSB7XG5cbiAgICAgIGlmICghdGhpcy5ub0ludGVyb3BSZXF1aXJlSW1wb3J0KSB7XG4gICAgICAgIHJlZiA9IHQuY2FsbEV4cHJlc3Npb24odGhpcy5maWxlLmFkZEhlbHBlcihcImludGVyb3AtcmVxdWlyZS13aWxkY2FyZFwiKSwgW3JlZl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBpbXBvcnQgKiBhcyBiYXIgZnJvbSBcImZvb1wiO1xuICAgICAgbm9kZXMucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih2YXJpYWJsZU5hbWUsIHJlZilcbiAgICAgIF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW1wb3J0IHsgZm9vIH0gZnJvbSBcImZvb1wiO1xuICAgICAgbm9kZXMucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgICB2YXJpYWJsZU5hbWUsXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHJlZiwgdC5nZXRTcGVjaWZpZXJJZChzcGVjaWZpZXIpKVxuICAgICAgICApXG4gICAgICBdKSk7XG4gICAgfVxuICB9XG59O1xuXG5Db21tb25KU0Zvcm1hdHRlci5wcm90b3R5cGUuaW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgbm9kZXMpIHtcbiAgLy8gaW1wb3J0IFwiZm9vXCI7XG4gIG5vZGVzLnB1c2godXRpbC50ZW1wbGF0ZShcInJlcXVpcmVcIiwge1xuICAgIE1PRFVMRV9OQU1FOiBub2RlLnNvdXJjZVxuICB9LCB0cnVlKSk7XG59O1xuXG5Db21tb25KU0Zvcm1hdHRlci5wcm90b3R5cGUuZXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgbm9kZXMpIHtcbiAgaWYgKHRoaXMuZG9EZWZhdWx0RXhwb3J0SW50ZXJvcChub2RlKSkge1xuICAgIHZhciBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgIHZhciBhc3NpZ24gPSB1dGlsLnRlbXBsYXRlKFwiZXhwb3J0cy1kZWZhdWx0LWFzc2lnblwiLCB7XG4gICAgICBWQUxVRTogdGhpcy5fcHVzaFN0YXRlbWVudChkZWNsYXIsIG5vZGVzKVxuICAgIH0sIHRydWUpO1xuXG4gICAgaWYgKHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2xhcikpIHtcbiAgICAgIC8vIHdlIGNhbiBob2lzdCB0aGlzIGFzc2lnbm1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgZmlsZVxuICAgICAgYXNzaWduLl9ibG9ja0hvaXN0ID0gMztcbiAgICB9XG5cbiAgICBub2Rlcy5wdXNoKGFzc2lnbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgRGVmYXVsdEZvcm1hdHRlci5wcm90b3R5cGUuZXhwb3J0RGVjbGFyYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkNvbW1vbkpTRm9ybWF0dGVyLnByb3RvdHlwZS5fZ2V0RXh0ZXJuYWxSZWZlcmVuY2UgPSBmdW5jdGlvbiAobm9kZSwgbm9kZXMpIHtcbiAgdmFyIHNvdXJjZSA9IG5vZGUuc291cmNlLnZhbHVlO1xuICB2YXIgY2FsbCA9IHQuY2FsbEV4cHJlc3Npb24odC5pZGVudGlmaWVyKFwicmVxdWlyZVwiKSwgW25vZGUuc291cmNlXSk7XG5cbiAgaWYgKHRoaXMubG9jYWxJbXBvcnRPY2N1cmVuY2VzW3NvdXJjZV0gPiAxKSB7XG4gICAgdmFyIHVpZCA9IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKHNvdXJjZSk7XG4gICAgbm9kZXMucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IodWlkLCBjYWxsKVxuICAgIF0pKTtcbiAgICByZXR1cm4gdWlkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWdub3JlRm9ybWF0dGVyO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gSWdub3JlRm9ybWF0dGVyKCkge1xuXG59XG5cbklnbm9yZUZvcm1hdHRlci5wcm90b3R5cGUuZXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgbm9kZXMpIHtcbiAgdmFyIGRlY2xhciA9IHQudG9TdGF0ZW1lbnQobm9kZS5kZWNsYXJhdGlvbiwgdHJ1ZSk7XG4gIGlmIChkZWNsYXIpIG5vZGVzLnB1c2godC5pbmhlcml0cyhkZWNsYXIsIG5vZGUpKTtcbn07XG5cbklnbm9yZUZvcm1hdHRlci5wcm90b3R5cGUuaW1wb3J0RGVjbGFyYXRpb24gPVxuSWdub3JlRm9ybWF0dGVyLnByb3RvdHlwZS5pbXBvcnRTcGVjaWZpZXIgPVxuSWdub3JlRm9ybWF0dGVyLnByb3RvdHlwZS5leHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tbW9uU3RyaWN0OiByZXF1aXJlKFwiLi9jb21tb24tc3RyaWN0XCIpLFxuICBhbWRTdHJpY3Q6ICAgIHJlcXVpcmUoXCIuL2FtZC1zdHJpY3RcIiksXG4gIHVtZFN0cmljdDogICAgcmVxdWlyZShcIi4vdW1kLXN0cmljdFwiKSxcbiAgY29tbW9uOiAgICAgICByZXF1aXJlKFwiLi9jb21tb25cIiksXG4gIHN5c3RlbTogICAgICAgcmVxdWlyZShcIi4vc3lzdGVtXCIpLFxuICBpZ25vcmU6ICAgICAgIHJlcXVpcmUoXCIuL2lnbm9yZVwiKSxcbiAgYW1kOiAgICAgICAgICByZXF1aXJlKFwiLi9hbWRcIiksXG4gIHVtZDogICAgICAgICAgcmVxdWlyZShcIi4vdW1kXCIpXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtRm9ybWF0dGVyO1xuXG52YXIgRGVmYXVsdEZvcm1hdHRlciA9IHJlcXVpcmUoXCIuL19kZWZhdWx0XCIpO1xudmFyIEFNREZvcm1hdHRlciAgICAgPSByZXF1aXJlKFwiLi9hbWRcIik7XG52YXIgdXNlU3RyaWN0ICAgICAgICA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3VzZS1zdHJpY3RcIik7XG52YXIgdXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG52YXIgbGFzdCAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvYXJyYXkvbGFzdFwiKTtcbnZhciBlYWNoICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2VhY2hcIik7XG52YXIgbWFwICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9tYXBcIik7XG5cbmZ1bmN0aW9uIFN5c3RlbUZvcm1hdHRlcihmaWxlKSB7XG4gIHRoaXMuZXhwb3J0SWRlbnRpZmllciA9IGZpbGUuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiZXhwb3J0XCIpO1xuICB0aGlzLm5vSW50ZXJvcFJlcXVpcmVFeHBvcnQgPSB0cnVlO1xuICB0aGlzLm5vSW50ZXJvcFJlcXVpcmVJbXBvcnQgPSB0cnVlO1xuXG4gIERlZmF1bHRGb3JtYXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudXRpbC5pbmhlcml0cyhTeXN0ZW1Gb3JtYXR0ZXIsIEFNREZvcm1hdHRlcik7XG5cblN5c3RlbUZvcm1hdHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5TeXN0ZW1Gb3JtYXR0ZXIucHJvdG90eXBlLl9hZGRJbXBvcnRTb3VyY2UgPSBmdW5jdGlvbiAobm9kZSwgZXhwb3J0Tm9kZSkge1xuICBub2RlLl9pbXBvcnRTb3VyY2UgPSBleHBvcnROb2RlLnNvdXJjZSAmJiBleHBvcnROb2RlLnNvdXJjZS52YWx1ZTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5TeXN0ZW1Gb3JtYXR0ZXIucHJvdG90eXBlLmJ1aWxkRXhwb3J0c1dpbGRjYXJkID0gZnVuY3Rpb24gKG9iamVjdElkZW50aWZpZXIsIG5vZGUpIHtcbiAgdmFyIGxlZnRJZGVudGlmaWVyID0gdGhpcy5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJrZXlcIik7XG4gIHZhciB2YWxJZGVudGlmaWVyICA9IHQubWVtYmVyRXhwcmVzc2lvbihvYmplY3RJZGVudGlmaWVyLCBsZWZ0SWRlbnRpZmllciwgdHJ1ZSk7XG5cbiAgdmFyIGxlZnQgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGxlZnRJZGVudGlmaWVyKVxuICBdKTtcblxuICB2YXIgcmlnaHQgPSBvYmplY3RJZGVudGlmaWVyO1xuXG4gIHZhciBibG9jayA9IHQuYmxvY2tTdGF0ZW1lbnQoW1xuICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLmJ1aWxkRXhwb3J0Q2FsbChsZWZ0SWRlbnRpZmllciwgdmFsSWRlbnRpZmllcikpXG4gIF0pO1xuXG4gIHJldHVybiB0aGlzLl9hZGRJbXBvcnRTb3VyY2UodC5mb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYmxvY2spLCBub2RlKTtcbn07XG5cblN5c3RlbUZvcm1hdHRlci5wcm90b3R5cGUuYnVpbGRFeHBvcnRzQXNzaWdubWVudCA9IGZ1bmN0aW9uIChpZCwgaW5pdCwgbm9kZSkge1xuICB2YXIgY2FsbCA9IHRoaXMuYnVpbGRFeHBvcnRDYWxsKHQubGl0ZXJhbChpZC5uYW1lKSwgaW5pdCwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLl9hZGRJbXBvcnRTb3VyY2UoY2FsbCwgbm9kZSk7XG59O1xuXG5TeXN0ZW1Gb3JtYXR0ZXIucHJvdG90eXBlLnJlbWFwRXhwb3J0QXNzaWdubWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0aGlzLmJ1aWxkRXhwb3J0Q2FsbCh0LmxpdGVyYWwobm9kZS5sZWZ0Lm5hbWUpLCBub2RlKTtcbn07XG5cblN5c3RlbUZvcm1hdHRlci5wcm90b3R5cGUuYnVpbGRFeHBvcnRDYWxsID0gZnVuY3Rpb24gKGlkLCBpbml0LCBpc1N0YXRlbWVudCkge1xuICB2YXIgY2FsbCA9IHQuY2FsbEV4cHJlc3Npb24odGhpcy5leHBvcnRJZGVudGlmaWVyLCBbaWQsIGluaXRdKTtcbiAgaWYgKGlzU3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHQuZXhwcmVzc2lvblN0YXRlbWVudChjYWxsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxufTtcblxuU3lzdGVtRm9ybWF0dGVyLnByb3RvdHlwZS5pbXBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoc3BlY2lmaWVyLCBub2RlLCBub2Rlcykge1xuICBBTURGb3JtYXR0ZXIucHJvdG90eXBlLmltcG9ydFNwZWNpZmllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9hZGRJbXBvcnRTb3VyY2UobGFzdChub2RlcyksIG5vZGUpO1xufTtcblxudmFyIHJ1bm5lclNldHRlcnNWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUuX2ltcG9ydFNvdXJjZSA9PT0gc3RhdGUuc291cmNlKSB7XG4gICAgICBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgICAgZWFjaChub2RlLmRlY2xhcmF0aW9ucywgZnVuY3Rpb24gKGRlY2xhcikge1xuICAgICAgICAgIHN0YXRlLmhvaXN0RGVjbGFyYXRvcnMucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXIuaWQpKTtcbiAgICAgICAgICBzdGF0ZS5ub2Rlcy5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGRlY2xhci5pZCwgZGVjbGFyLmluaXQpXG4gICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn07XG5cblN5c3RlbUZvcm1hdHRlci5wcm90b3R5cGUuYnVpbGRSdW5uZXJTZXR0ZXJzID0gZnVuY3Rpb24gKGJsb2NrLCBob2lzdERlY2xhcmF0b3JzKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuZmlsZS5zY29wZTtcblxuICByZXR1cm4gdC5hcnJheUV4cHJlc3Npb24obWFwKHRoaXMuaWRzLCBmdW5jdGlvbiAodWlkLCBzb3VyY2UpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBzb3VyY2U6ICAgICAgICAgICBzb3VyY2UsXG4gICAgICBub2RlczogICAgICAgICAgICBbXSxcbiAgICAgIGhvaXN0RGVjbGFyYXRvcnM6IGhvaXN0RGVjbGFyYXRvcnNcbiAgICB9O1xuXG4gICAgc2NvcGUudHJhdmVyc2UoYmxvY2ssIHJ1bm5lclNldHRlcnNWaXNpdG9yLCBzdGF0ZSk7XG5cbiAgICByZXR1cm4gdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW3VpZF0sIHQuYmxvY2tTdGF0ZW1lbnQoc3RhdGUubm9kZXMpKTtcbiAgfSkpO1xufTtcblxudmFyIGhvaXN0VmFyaWFibGVzVmlzaXRvciA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBob2lzdERlY2xhcmF0b3JzKSB7XG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgICAgLy8gbm90aGluZyBpbnNpZGUgaXMgYWNjZXNzaWJsZVxuICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xuICAgIH1cblxuICAgIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIiAmJiAhdC5pc1Byb2dyYW0ocGFyZW50KSkgeyAvLyBsZXQsIGNvbnN0XG4gICAgICAgIC8vIGNhbid0IGJlIGFjY2Vzc2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGJsb2NrIGhvaXN0ZWQgbm9kZXMgYXMgdGhlc2UgY2FuIGJlIGxlZnQgaW5cbiAgICAgIGlmIChub2RlLl9ibG9ja0hvaXN0KSByZXR1cm47XG5cbiAgICAgIHZhciBub2RlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgaG9pc3REZWNsYXJhdG9ycy5wdXNoKHQudmFyaWFibGVEZWNsYXJhdG9yKGRlY2xhci5pZCkpO1xuICAgICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgICAvLyBubyBpbml0aWFsaXplciBzbyB3ZSBjYW4ganVzdCBob2lzdCBpdCBhcy1pc1xuICAgICAgICAgIHZhciBhc3NpZ24gPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpO1xuICAgICAgICAgIG5vZGVzLnB1c2goYXNzaWduKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgKHZhciBpIGluIHRlc3QpXG4gICAgICAvLyBmb3IgKHZhciBpID0gMDs7KVxuICAgICAgaWYgKHQuaXNGb3IocGFyZW50KSkge1xuICAgICAgICBpZiAocGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5kZWNsYXJhdGlvbnNbMF0uaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50LmluaXQgPT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdC50b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gIH1cbn07XG5cbnZhciBob2lzdEZ1bmN0aW9uc1Zpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgaGFuZGxlckJvZHkpIHtcbiAgICBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSB0aGlzLnNraXAoKTtcblxuICAgIGlmICh0LmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSB8fCBub2RlLl9ibG9ja0hvaXN0KSB7XG4gICAgICBoYW5kbGVyQm9keS5wdXNoKG5vZGUpO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn07XG5cblN5c3RlbUZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgdmFyIGhvaXN0RGVjbGFyYXRvcnMgPSBbXTtcbiAgdmFyIG1vZHVsZU5hbWUgPSB0aGlzLmdldE1vZHVsZU5hbWUoKTtcbiAgdmFyIG1vZHVsZU5hbWVMaXRlcmFsID0gdC5saXRlcmFsKG1vZHVsZU5hbWUpO1xuXG4gIHZhciBibG9jayA9IHQuYmxvY2tTdGF0ZW1lbnQocHJvZ3JhbS5ib2R5KTtcblxuICB2YXIgcnVubmVyID0gdXRpbC50ZW1wbGF0ZShcInN5c3RlbVwiLCB7XG4gICAgTU9EVUxFX05BTUU6IG1vZHVsZU5hbWVMaXRlcmFsLFxuICAgIE1PRFVMRV9ERVBFTkRFTkNJRVM6IHQuYXJyYXlFeHByZXNzaW9uKHRoaXMuYnVpbGREZXBlbmRlbmN5TGl0ZXJhbHMoKSksXG4gICAgRVhQT1JUX0lERU5USUZJRVI6IHRoaXMuZXhwb3J0SWRlbnRpZmllcixcbiAgICBTRVRURVJTOiB0aGlzLmJ1aWxkUnVubmVyU2V0dGVycyhibG9jaywgaG9pc3REZWNsYXJhdG9ycyksXG4gICAgRVhFQ1VURTogdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW10sIGJsb2NrKVxuICB9LCB0cnVlKTtcblxuICB2YXIgaGFuZGxlckJvZHkgPSBydW5uZXIuZXhwcmVzc2lvbi5hcmd1bWVudHNbMl0uYm9keS5ib2R5O1xuICBpZiAoIW1vZHVsZU5hbWUpIHJ1bm5lci5leHByZXNzaW9uLmFyZ3VtZW50cy5zaGlmdCgpO1xuXG4gIHZhciByZXR1cm5TdGF0ZW1lbnQgPSBoYW5kbGVyQm9keS5wb3AoKTtcblxuICAvLyBob2lzdCB1cCBhbGwgdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gIHRoaXMuZmlsZS5zY29wZS50cmF2ZXJzZShibG9jaywgaG9pc3RWYXJpYWJsZXNWaXNpdG9yLCBob2lzdERlY2xhcmF0b3JzKTtcblxuICBpZiAoaG9pc3REZWNsYXJhdG9ycy5sZW5ndGgpIHtcbiAgICB2YXIgaG9pc3REZWNsYXIgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgaG9pc3REZWNsYXJhdG9ycyk7XG4gICAgaG9pc3REZWNsYXIuX2Jsb2NrSG9pc3QgPSB0cnVlO1xuICAgIGhhbmRsZXJCb2R5LnVuc2hpZnQoaG9pc3REZWNsYXIpO1xuICB9XG5cbiAgLy8gaG9pc3QgdXAgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG4gIHRoaXMuZmlsZS5zY29wZS50cmF2ZXJzZShibG9jaywgaG9pc3RGdW5jdGlvbnNWaXNpdG9yLCBoYW5kbGVyQm9keSk7XG5cbiAgaGFuZGxlckJvZHkucHVzaChyZXR1cm5TdGF0ZW1lbnQpO1xuXG4gIGlmICh1c2VTdHJpY3QuaGFzKGJsb2NrKSkge1xuICAgIGhhbmRsZXJCb2R5LnVuc2hpZnQoYmxvY2suYm9keS5zaGlmdCgpKTtcbiAgfVxuXG4gIHByb2dyYW0uYm9keSA9IFtydW5uZXJdO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL19zdHJpY3RcIikocmVxdWlyZShcIi4vdW1kXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVNREZvcm1hdHRlcjtcblxudmFyIEFNREZvcm1hdHRlciA9IHJlcXVpcmUoXCIuL2FtZFwiKTtcbnZhciB1dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB0ICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdHlwZXNcIik7XG52YXIgdmFsdWVzICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvdmFsdWVzXCIpO1xuXG5mdW5jdGlvbiBVTURGb3JtYXR0ZXIoKSB7XG4gIEFNREZvcm1hdHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG51dGlsLmluaGVyaXRzKFVNREZvcm1hdHRlciwgQU1ERm9ybWF0dGVyKTtcblxuVU1ERm9ybWF0dGVyLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICB2YXIgYm9keSA9IHByb2dyYW0uYm9keTtcblxuICAvLyBidWlsZCBhbiBhcnJheSBvZiBtb2R1bGUgbmFtZXNcblxuICB2YXIgbmFtZXMgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmlkcykge1xuICAgIG5hbWVzLnB1c2godC5saXRlcmFsKG5hbWUpKTtcbiAgfVxuXG4gIC8vIGZhY3RvcnlcblxuICB2YXIgaWRzICA9IHZhbHVlcyh0aGlzLmlkcyk7XG4gIHZhciBhcmdzID0gW3QuaWRlbnRpZmllcihcImV4cG9ydHNcIildO1xuICBpZiAodGhpcy5wYXNzTW9kdWxlQXJnKSBhcmdzLnB1c2godC5pZGVudGlmaWVyKFwibW9kdWxlXCIpKTtcbiAgYXJncyA9IGFyZ3MuY29uY2F0KGlkcyk7XG5cbiAgdmFyIGZhY3RvcnkgPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBhcmdzLCB0LmJsb2NrU3RhdGVtZW50KGJvZHkpKTtcblxuICAvLyBhbWRcblxuICB2YXIgZGVmaW5lQXJncyA9IFt0LmxpdGVyYWwoXCJleHBvcnRzXCIpXTtcbiAgaWYgKHRoaXMucGFzc01vZHVsZUFyZykgZGVmaW5lQXJncy5wdXNoKHQubGl0ZXJhbChcIm1vZHVsZVwiKSk7XG4gIGRlZmluZUFyZ3MgPSBkZWZpbmVBcmdzLmNvbmNhdChuYW1lcyk7XG4gIGRlZmluZUFyZ3MgPSBbdC5hcnJheUV4cHJlc3Npb24oZGVmaW5lQXJncyldO1xuXG4gIC8vIGNvbW1vblxuXG4gIHZhciB0ZXN0RXhwb3J0cyA9IHV0aWwudGVtcGxhdGUoXCJ0ZXN0LWV4cG9ydHNcIik7XG4gIHZhciB0ZXN0TW9kdWxlICA9IHV0aWwudGVtcGxhdGUoXCJ0ZXN0LW1vZHVsZVwiKTtcbiAgdmFyIGNvbW1vblRlc3RzID0gdGhpcy5wYXNzTW9kdWxlQXJnID8gdC5sb2dpY2FsRXhwcmVzc2lvbihcIiYmXCIsIHRlc3RFeHBvcnRzLCB0ZXN0TW9kdWxlKSA6IHRlc3RFeHBvcnRzO1xuXG4gIHZhciBjb21tb25BcmdzID0gW3QuaWRlbnRpZmllcihcImV4cG9ydHNcIildO1xuICBpZiAodGhpcy5wYXNzTW9kdWxlQXJnKSBjb21tb25BcmdzLnB1c2godC5pZGVudGlmaWVyKFwibW9kdWxlXCIpKTtcbiAgY29tbW9uQXJncyA9IGNvbW1vbkFyZ3MuY29uY2F0KG5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcInJlcXVpcmVcIiksIFtuYW1lXSk7XG4gIH0pKTtcblxuICAvLyBnbG9iYWxzXG5cbiAgLy92YXIgdW1kQXJncyA9IFtdO1xuXG4gIC8vXG5cbiAgdmFyIG1vZHVsZU5hbWUgPSB0aGlzLmdldE1vZHVsZU5hbWUoKTtcbiAgaWYgKG1vZHVsZU5hbWUpIGRlZmluZUFyZ3MudW5zaGlmdCh0LmxpdGVyYWwobW9kdWxlTmFtZSkpO1xuXG4gIHZhciBydW5uZXIgPSB1dGlsLnRlbXBsYXRlKFwidW1kLXJ1bm5lci1ib2R5XCIsIHtcbiAgICBBTURfQVJHVU1FTlRTOiBkZWZpbmVBcmdzLFxuICAgIENPTU1PTl9URVNUOiBjb21tb25UZXN0cyxcbiAgICBDT01NT05fQVJHVU1FTlRTOiBjb21tb25BcmdzXG4gIH0pO1xuXG4gIC8vXG5cbiAgdmFyIGNhbGwgPSB0LmNhbGxFeHByZXNzaW9uKHJ1bm5lciwgW2ZhY3RvcnldKTtcbiAgcHJvZ3JhbS5ib2R5ID0gW3QuZXhwcmVzc2lvblN0YXRlbWVudChjYWxsKV07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1lclBhc3M7XG5cbnZhciBpbmNsdWRlcyA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9pbmNsdWRlc1wiKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0cmF2ZXJzaW5nIG92ZXIgdGhlIHByb3ZpZGVkIGBGaWxlYHNcbiAqIEFTVCBhbmQgcnVubmluZyBpdCdzIHBhcmVudCB0cmFuc2Zvcm1lcnMgaGFuZGxlcnMgb3ZlciBpdC5cbiAqL1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1lclBhc3MoZmlsZSwgdHJhbnNmb3JtZXIpIHtcbiAgdGhpcy50cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xuICB0aGlzLnNob3VsZFJ1biAgID0gIXRyYW5zZm9ybWVyLmNoZWNrO1xuICB0aGlzLmhhbmRsZXJzICAgID0gdHJhbnNmb3JtZXIuaGFuZGxlcnM7XG4gIHRoaXMuZmlsZSAgICAgICAgPSBmaWxlO1xufVxuXG5UcmFuc2Zvcm1lclBhc3MucHJvdG90eXBlLmNhblJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zZm9ybWVyID0gdGhpcy50cmFuc2Zvcm1lcjtcblxuICB2YXIgb3B0cyA9IHRoaXMuZmlsZS5vcHRzO1xuICB2YXIga2V5ICA9IHRyYW5zZm9ybWVyLmtleTtcblxuICAvLyBpbnRlcm5hbFxuICBpZiAoa2V5WzBdID09PSBcIl9cIikgcmV0dXJuIHRydWU7XG5cbiAgLy8gYmxhY2tsaXN0XG4gIHZhciBibGFja2xpc3QgPSBvcHRzLmJsYWNrbGlzdDtcbiAgaWYgKGJsYWNrbGlzdC5sZW5ndGggJiYgaW5jbHVkZXMoYmxhY2tsaXN0LCBrZXkpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gd2hpdGVsaXN0XG4gIHZhciB3aGl0ZWxpc3QgPSBvcHRzLndoaXRlbGlzdDtcbiAgaWYgKHdoaXRlbGlzdC5sZW5ndGgpIHJldHVybiBpbmNsdWRlcyh3aGl0ZWxpc3QsIGtleSk7XG5cbiAgLy8gb3B0aW9uYWxcbiAgaWYgKHRyYW5zZm9ybWVyLm9wdGlvbmFsICYmICFpbmNsdWRlcyhvcHRzLm9wdGlvbmFsLCBrZXkpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gZXhwZXJpbWVudGFsXG4gIGlmICh0cmFuc2Zvcm1lci5leHBlcmltZW50YWwgJiYgIW9wdHMuZXhwZXJpbWVudGFsKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gcGxheWdyb3VuZFxuICBpZiAodHJhbnNmb3JtZXIucGxheWdyb3VuZCAmJiAhb3B0cy5wbGF5Z3JvdW5kKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5UcmFuc2Zvcm1lclBhc3MucHJvdG90eXBlLmNoZWNrTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjaGVjayA9IHRoaXMudHJhbnNmb3JtZXIuY2hlY2s7XG4gIGlmIChjaGVjaykge1xuICAgIHJldHVybiB0aGlzLnNob3VsZFJ1biA9IGNoZWNrKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm1lclBhc3MucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnNob3VsZFJ1bikgcmV0dXJuO1xuXG4gIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gIGZpbGUuZGVidWcoXCJSdW5uaW5nIHRyYW5zZm9ybWVyIFwiICsgdGhpcy50cmFuc2Zvcm1lci5rZXkpO1xuXG4gIGZpbGUuc2NvcGUudHJhdmVyc2UoZmlsZS5hc3QsIHRoaXMuaGFuZGxlcnMsIGZpbGUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybWVyO1xuXG52YXIgVHJhbnNmb3JtZXJQYXNzID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtZXItcGFzc1wiKTtcbnZhciBpc0Z1bmN0aW9uICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNGdW5jdGlvblwiKTtcbnZhciB0cmF2ZXJzZSAgICAgICAgPSByZXF1aXJlKFwiLi4vdHJhdmVyc2FsXCIpO1xudmFyIGlzT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9pc09iamVjdFwiKTtcbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC9hc3NpZ25cIik7XG52YXIgZWFjaCAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2VhY2hcIik7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY2xhc3MgcmVzcG9uc2libGUgZm9yIG5vcm1hbGlzaW5nIGEgdHJhbnNmb3JtZXJzIGhhbmRsZXJzXG4gKiBhcyB3ZWxsIGFzIGNvbnN0cnVjdGluZyBhIGBUcmFuc2Zvcm1lclBhc3NgIHRoYXQgaXMgcmVwc29uc2libGUgZm9yXG4gKiBhY3R1YWxseSBydW5uaW5nIHRoZSB0cmFuc2Zvcm1lciBvdmVyIHRoZSBwcm92aWRlZCBgRmlsZWAuXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNmb3JtZXIoa2V5LCB0cmFuc2Zvcm1lciwgb3B0cykge1xuICB0cmFuc2Zvcm1lciA9IGFzc2lnbih7fSwgdHJhbnNmb3JtZXIpO1xuXG4gIHZhciB0YWtlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB0cmFuc2Zvcm1lcltrZXldO1xuICAgIGRlbGV0ZSB0cmFuc2Zvcm1lcltrZXldO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgdGhpcy5tYW5pcHVsYXRlT3B0aW9ucyA9IHRha2UoXCJtYW5pcHVsYXRlT3B0aW9uc1wiKTtcbiAgdGhpcy5jaGVjayAgICAgICAgICAgICA9IHRha2UoXCJjaGVja1wiKTtcbiAgdGhpcy5wb3N0ICAgICAgICAgICAgICA9IHRha2UoXCJwb3N0XCIpO1xuICB0aGlzLnByZSAgICAgICAgICAgICAgID0gdGFrZShcInByZVwiKTtcblxuICB0aGlzLmV4cGVyaW1lbnRhbCA9ICEhdGFrZShcImV4cGVyaW1lbnRhbFwiKTtcbiAgdGhpcy5wbGF5Z3JvdW5kICAgPSAhIXRha2UoXCJwbGF5Z3JvdW5kXCIpO1xuICB0aGlzLnNlY29uZFBhc3MgICA9ICEhdGFrZShcInNlY29uZFBhc3NcIik7XG4gIHRoaXMub3B0aW9uYWwgICAgID0gISF0YWtlKFwib3B0aW9uYWxcIik7XG5cbiAgdGhpcy5oYW5kbGVycyA9IHRoaXMubm9ybWFsaXplKHRyYW5zZm9ybWVyKTtcbiAgdGhpcy5vcHRzICAgICA9IG9wdHMgfHwge307XG4gIHRoaXMua2V5ICAgICAgPSBrZXk7XG59XG5cblRyYW5zZm9ybWVyLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKSkge1xuICAgIHRyYW5zZm9ybWVyID0geyBhc3Q6IHRyYW5zZm9ybWVyIH07XG4gIH1cblxuICB0cmF2ZXJzZS5leHBsb2RlKHRyYW5zZm9ybWVyKTtcblxuICBlYWNoKHRyYW5zZm9ybWVyLCBmdW5jdGlvbiAoZm5zLCB0eXBlKSB7XG4gICAgLy8gaGlkZGVuIHByb3BlcnR5XG4gICAgaWYgKHR5cGVbMF0gPT09IFwiX1wiKSB7XG4gICAgICBzZWxmW3R5cGVdID0gZm5zO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBcImVudGVyXCIgfHwgdHlwZSA9PT0gXCJleGl0XCIpIHJldHVybjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGZucykpIGZucyA9IHsgZW50ZXI6IGZucyB9O1xuXG4gICAgaWYgKCFpc09iamVjdChmbnMpKSByZXR1cm47XG5cbiAgICBpZiAoIWZucy5lbnRlcikgZm5zLmVudGVyID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIGlmICghZm5zLmV4aXQpIGZucy5leGl0ID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gICAgdHJhbnNmb3JtZXJbdHlwZV0gPSBmbnM7XG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc2Zvcm1lcjtcbn07XG5cblRyYW5zZm9ybWVyLnByb3RvdHlwZS5idWlsZFBhc3MgPSBmdW5jdGlvbiAoZmlsZSkge1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybWVyUGFzcyhmaWxlLCB0aGlzKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17fVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydHk7XG4gIGlmIChub2RlLmNvbXB1dGVkICYmIHQuaXNMaXRlcmFsKHByb3ApICYmIHQuaXNWYWxpZElkZW50aWZpZXIocHJvcC52YWx1ZSkpIHtcbiAgICAvLyBmb29bXCJiYXJcIl0gPT4gZm9vLmJhclxuICAgIG5vZGUucHJvcGVydHkgPSB0LmlkZW50aWZpZXIocHJvcC52YWx1ZSk7XG4gICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFub2RlLmNvbXB1dGVkICYmIHQuaXNJZGVudGlmaWVyKHByb3ApICYmICF0LmlzVmFsaWRJZGVudGlmaWVyKHByb3AubmFtZSkpIHtcbiAgICAvLyBmb28uZGVmYXVsdCAtPiBmb29bXCJkZWZhdWx0XCJdXG4gICAgbm9kZS5wcm9wZXJ0eSA9IHQubGl0ZXJhbChwcm9wLm5hbWUpO1xuICAgIG5vZGUuY29tcHV0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLlByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGtleSA9IG5vZGUua2V5O1xuICBpZiAodC5pc0xpdGVyYWwoa2V5KSAmJiB0LmlzVmFsaWRJZGVudGlmaWVyKGtleS52YWx1ZSkpIHtcbiAgICAvLyBcImZvb1wiOiBcImJhclwiIC0+IGZvbzogXCJiYXJcIlxuICAgIG5vZGUua2V5ID0gdC5pZGVudGlmaWVyKGtleS52YWx1ZSk7XG4gICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFub2RlLmNvbXB1dGVkICYmIHQuaXNJZGVudGlmaWVyKGtleSkgJiYgIXQuaXNWYWxpZElkZW50aWZpZXIoa2V5Lm5hbWUpKSB7XG4gICAgLy8gZGVmYXVsdDogXCJiYXJcIiAtPiBcImRlZmF1bHRcIjogXCJiYXJcIlxuICAgIG5vZGUua2V5ID0gdC5saXRlcmFsKGtleS5uYW1lKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVmaW5lTWFwID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZGVmaW5lLW1hcFwiKTtcbnZhciB0ICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5pc1Byb3BlcnR5KG5vZGUpICYmIChub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKTtcbn07XG5cbmV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBtdXRhdG9yTWFwID0ge307XG4gIHZhciBoYXNBbnkgPSBmYWxzZTtcblxuICBub2RlLnByb3BlcnRpZXMgPSBub2RlLnByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpIHtcbiAgICAgIGhhc0FueSA9IHRydWU7XG4gICAgICBkZWZpbmVNYXAucHVzaChtdXRhdG9yTWFwLCBwcm9wLmtleSwgcHJvcC5raW5kLCBwcm9wLmNvbXB1dGVkLCBwcm9wLnZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWhhc0FueSkgcmV0dXJuO1xuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoXCJPYmplY3RcIiksIHQuaWRlbnRpZmllcihcImRlZmluZVByb3BlcnRpZXNcIikpLFxuICAgIFtub2RlLCBkZWZpbmVNYXAuYnVpbGQobXV0YXRvck1hcCldXG4gICk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gdC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuXG5leHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdC5lbnN1cmVCbG9jayhub2RlKTtcblxuICBub2RlLl9hbGlhc0Z1bmN0aW9uID0gXCJhcnJvd1wiO1xuICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcblxuICByZXR1cm4gbm9kZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbnZhciB2aXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKCF0LmlzUmVmZXJlbmNlZElkZW50aWZpZXIobm9kZSwgcGFyZW50KSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlY2xhcmVkID0gc3RhdGUubGV0UmVmc1tub2RlLm5hbWVdO1xuICAgIGlmICghZGVjbGFyZWQpIHJldHVybjtcblxuICAgIC8vIGRlY2xhcmVkIG5vZGUgaXMgZGlmZmVyZW50IGluIHRoaXMgc2NvcGVcbiAgICBpZiAoc2NvcGUuZ2V0QmluZGluZ0lkZW50aWZpZXIobm9kZS5uYW1lKSAhPT0gZGVjbGFyZWQpIHJldHVybjtcblxuICAgIHZhciBhc3NlcnQgPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgc3RhdGUuZmlsZS5hZGRIZWxwZXIoXCJ0ZW1wb3JhbC1hc3NlcnQtZGVmaW5lZFwiKSxcbiAgICAgIFtub2RlLCB0LmxpdGVyYWwobm9kZS5uYW1lKSwgc3RhdGUuZmlsZS5hZGRIZWxwZXIoXCJ0ZW1wb3JhbC11bmRlZmluZWRcIildXG4gICAgKTtcblxuICAgIHRoaXMuc2tpcCgpO1xuXG4gICAgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJlbnQpIHx8IHQuaXNVcGRhdGVFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICAgIGlmIChwYXJlbnQuX2lnbm9yZUJsb2NrU2NvcGluZ1REWikgcmV0dXJuO1xuICAgICAgdGhpcy5wYXJlbnRQYXRoLnJlcGxhY2VOb2RlKHQuc2VxdWVuY2VFeHByZXNzaW9uKFthc3NlcnQsIHBhcmVudF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHQubG9naWNhbEV4cHJlc3Npb24oXCImJlwiLCBhc3NlcnQsIG5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5cbmV4cG9ydHMuTG9vcCA9XG5leHBvcnRzLlByb2dyYW0gPVxuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBsZXRSZWZzID0gbm9kZS5fbGV0UmVmZXJlbmNlcztcbiAgaWYgKCFsZXRSZWZzKSByZXR1cm47XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGxldFJlZnM6IGxldFJlZnMsXG4gICAgZmlsZTogICAgZmlsZVxuICB9O1xuXG4gIHNjb3BlLnRyYXZlcnNlKG5vZGUsIHZpc2l0b3IsIHN0YXRlKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRyYXZlcnNlID0gcmVxdWlyZShcIi4uLy4uLy4uL3RyYXZlcnNhbFwiKTtcbnZhciBvYmplY3QgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oZWxwZXJzL29iamVjdFwiKTtcbnZhciB1dGlsICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xudmFyIHZhbHVlcyAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvdmFsdWVzXCIpO1xudmFyIGV4dGVuZCAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvZXh0ZW5kXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpICYmIChub2RlLmtpbmQgPT09IFwibGV0XCIgfHwgbm9kZS5raW5kID09PSBcImNvbnN0XCIpO1xufTtcblxudmFyIGlzTGV0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIXQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLl9sZXQpIHJldHVybiB0cnVlO1xuICBpZiAobm9kZS5raW5kICE9PSBcImxldFwiKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8yNTVcbiAgaWYgKGlzTGV0SW5pdGFibGUobm9kZSwgcGFyZW50KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGRlY2xhci5pbml0ID0gZGVjbGFyLmluaXQgfHwgdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUuX2xldCA9IHRydWU7XG4gIG5vZGUua2luZCA9IFwidmFyXCI7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzTGV0SW5pdGFibGUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiAhdC5pc0ZvcihwYXJlbnQpIHx8IHQuaXNGb3IocGFyZW50KSAmJiBwYXJlbnQubGVmdCAhPT0gbm9kZTtcbn07XG5cbnZhciBpc1ZhciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHsga2luZDogXCJ2YXJcIiB9KSAmJiAhaXNMZXQobm9kZSwgcGFyZW50KTtcbn07XG5cbnZhciBzdGFuZGFyZGl6ZUxldHMgPSBmdW5jdGlvbiAoZGVjbGFycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY2xhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWxldGUgZGVjbGFyc1tpXS5fbGV0O1xuICB9XG59O1xuXG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAoIWlzTGV0KG5vZGUsIHBhcmVudCkpIHJldHVybjtcblxuICBpZiAoaXNMZXRJbml0YWJsZShub2RlKSAmJiBmaWxlLnRyYW5zZm9ybWVyc1tcImVzNi5ibG9ja1Njb3BpbmdURFpcIl0uY2FuUnVuKCkpIHtcbiAgICB2YXIgbm9kZXMgPSBbbm9kZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgaWYgKGRlY2wuaW5pdCkge1xuICAgICAgICB2YXIgYXNzaWduID0gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbC5pZCwgZGVjbC5pbml0KTtcbiAgICAgICAgYXNzaWduLl9pZ25vcmVCbG9ja1Njb3BpbmdURFogPSB0cnVlO1xuICAgICAgICBub2Rlcy5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudChhc3NpZ24pKTtcbiAgICAgIH1cbiAgICAgIGRlY2wuaW5pdCA9IGZpbGUuYWRkSGVscGVyKFwidGVtcG9yYWwtdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIG5vZGUuX2Jsb2NrSG9pc3QgPSAyO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG59O1xuXG5leHBvcnRzLkxvb3AgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgaW5pdCA9IG5vZGUubGVmdCB8fCBub2RlLmluaXQ7XG4gIGlmIChpc0xldChpbml0LCBub2RlKSkge1xuICAgIHQuZW5zdXJlQmxvY2sobm9kZSk7XG4gICAgbm9kZS5ib2R5Ll9sZXREZWNsYXJhdG9ycyA9IFtpbml0XTtcbiAgfVxuICB2YXIgYmxvY2tTY29waW5nID0gbmV3IEJsb2NrU2NvcGluZyhub2RlLCBub2RlLmJvZHksIHBhcmVudCwgc2NvcGUsIGZpbGUpO1xuICBibG9ja1Njb3BpbmcucnVuKCk7XG59O1xuXG5leHBvcnRzLlByb2dyYW0gPVxuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAoIXQuaXNMb29wKHBhcmVudCkpIHtcbiAgICB2YXIgYmxvY2tTY29waW5nID0gbmV3IEJsb2NrU2NvcGluZyhmYWxzZSwgYmxvY2ssIHBhcmVudCwgc2NvcGUsIGZpbGUpO1xuICAgIGJsb2NrU2NvcGluZy5ydW4oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbnxOb2RlfSBsb29wUGFyZW50XG4gKiBAcGFyYW0ge05vZGV9IGJsb2NrXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtTY29wZX0gc2NvcGVcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICovXG5cbmZ1bmN0aW9uIEJsb2NrU2NvcGluZyhsb29wUGFyZW50LCBibG9jaywgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB0aGlzLmxvb3BQYXJlbnQgPSBsb29wUGFyZW50O1xuICB0aGlzLnBhcmVudCAgICAgPSBwYXJlbnQ7XG4gIHRoaXMuc2NvcGUgICAgICA9IHNjb3BlO1xuICB0aGlzLmJsb2NrICAgICAgPSBibG9jaztcbiAgdGhpcy5maWxlICAgICAgID0gZmlsZTtcblxuICB0aGlzLm91dHNpZGVMZXRSZWZlcmVuY2VzID0gb2JqZWN0KCk7XG4gIHRoaXMuaGFzTGV0UmVmZXJlbmNlcyAgICAgPSBmYWxzZTtcbiAgdGhpcy5sZXRSZWZlcmVuY2VzICAgICAgICA9IGJsb2NrLl9sZXRSZWZlcmVuY2VzID0gb2JqZWN0KCk7XG4gIHRoaXMuYm9keSAgICAgICAgICAgICAgICAgPSBbXTtcbn1cblxuLyoqXG4gKiBTdGFydCB0aGUgYmFsbCByb2xsaW5nLlxuICovXG5cbkJsb2NrU2NvcGluZy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrO1xuICBpZiAoYmxvY2suX2xldERvbmUpIHJldHVybjtcbiAgYmxvY2suX2xldERvbmUgPSB0cnVlO1xuXG4gIHZhciBuZWVkc0Nsb3N1cmUgPSB0aGlzLmdldExldFJlZmVyZW5jZXMoKTtcblxuICAvLyB0aGlzIGlzIGEgYmxvY2sgd2l0aGluIGEgYEZ1bmN0aW9uL1Byb2dyYW1gIHNvIHdlIGNhbiBzYWZlbHkgbGVhdmUgaXQgYmVcbiAgaWYgKHQuaXNGdW5jdGlvbih0aGlzLnBhcmVudCkgfHwgdC5pc1Byb2dyYW0odGhpcy5ibG9jaykpIHJldHVybjtcblxuICAvLyB3ZSBjYW4gc2tpcCBldmVyeXRoaW5nXG4gIGlmICghdGhpcy5oYXNMZXRSZWZlcmVuY2VzKSByZXR1cm47XG5cbiAgaWYgKG5lZWRzQ2xvc3VyZSkge1xuICAgIHRoaXMud3JhcENsb3N1cmUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlbWFwKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2Uobm9kZSwgcGFyZW50LCBzY29wZSwgcmVtYXBzKSB7XG4gIGlmICghdC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCkpIHJldHVybjtcblxuICB2YXIgcmVtYXAgPSByZW1hcHNbbm9kZS5uYW1lXTtcbiAgaWYgKCFyZW1hcCkgcmV0dXJuO1xuXG4gIHZhciBvd25CaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZ0lkZW50aWZpZXIobm9kZS5uYW1lKTtcbiAgaWYgKG93bkJpbmRpbmcgPT09IHJlbWFwLmJpbmRpbmcpIHtcbiAgICBub2RlLm5hbWUgPSByZW1hcC51aWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2NvcGUgYWxyZWFkeSBoYXMgaXQncyBvd24gYmluZGluZyB0aGF0IGRvZXNuJ3RcbiAgICAvLyBtYXRjaCB0aGUgb25lIHdlIGhhdmUgYSBzdG9yZWQgcmVwbGFjZW1lbnQgZm9yXG4gICAgaWYgKHRoaXMpIHRoaXMuc2tpcCgpO1xuICB9XG59XG5cbnZhciByZXBsYWNlVmlzaXRvciA9IHtcbiAgZW50ZXI6IHJlcGxhY2Vcbn07XG5cbmZ1bmN0aW9uIHRyYXZlcnNlUmVwbGFjZShub2RlLCBwYXJlbnQsIHNjb3BlLCByZW1hcHMpIHtcbiAgcmVwbGFjZShub2RlLCBwYXJlbnQsIHNjb3BlLCByZW1hcHMpO1xuICBzY29wZS50cmF2ZXJzZShub2RlLCByZXBsYWNlVmlzaXRvciwgcmVtYXBzKTtcbn1cblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICovXG5cbkJsb2NrU2NvcGluZy5wcm90b3R5cGUucmVtYXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYXNSZW1hcHMgPSBmYWxzZTtcbiAgdmFyIGxldFJlZnMgICA9IHRoaXMubGV0UmVmZXJlbmNlcztcbiAgdmFyIHNjb3BlICAgICA9IHRoaXMuc2NvcGU7XG5cbiAgLy8gYWxyaWdodCwgc28gc2luY2Ugd2UgYXJlbid0IHdyYXBwaW5nIHRoaXMgYmxvY2sgaW4gYSBjbG9zdXJlXG4gIC8vIHdlIGhhdmUgdG8gY2hlY2sgaWYgYW55IG9mIG91ciBsZXQgdmFyaWFibGVzIGNvbGxpZGUgd2l0aFxuICAvLyB0aG9zZSBpbiB1cHBlciBzY29wZXMgYW5kIHRoZW4gaWYgdGhleSBkbywgZ2VuZXJhdGUgYSB1aWRcbiAgLy8gZm9yIHRoZW0gYW5kIHJlcGxhY2UgYWxsIHJlZmVyZW5jZXMgd2l0aCBpdFxuICB2YXIgcmVtYXBzID0gb2JqZWN0KCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGxldFJlZnMpIHtcbiAgICAvLyBqdXN0IGFuIElkZW50aWZpZXIgbm9kZSB3ZSBjb2xsZWN0ZWQgaW4gYGdldExldFJlZmVyZW5jZXNgXG4gICAgLy8gdGhpcyBpcyB0aGUgZGVmaW5pbmcgaWRlbnRpZmllciBvZiBhIGRlY2xhcmF0aW9uXG4gICAgdmFyIHJlZiA9IGxldFJlZnNba2V5XTtcblxuICAgIGlmIChzY29wZS5wYXJlbnRIYXNCaW5kaW5nKGtleSkgfHwgc2NvcGUuaGFzR2xvYmFsKGtleSkpIHtcbiAgICAgIHZhciB1aWQgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIocmVmLm5hbWUpLm5hbWU7XG4gICAgICByZWYubmFtZSA9IHVpZDtcblxuICAgICAgaGFzUmVtYXBzID0gdHJ1ZTtcbiAgICAgIHJlbWFwc1trZXldID0gcmVtYXBzW3VpZF0gPSB7XG4gICAgICAgIGJpbmRpbmc6IHJlZixcbiAgICAgICAgdWlkOiB1aWRcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNSZW1hcHMpIHJldHVybjtcblxuICAvL1xuXG4gIHZhciBsb29wUGFyZW50ID0gdGhpcy5sb29wUGFyZW50O1xuICBpZiAobG9vcFBhcmVudCkge1xuICAgIHRyYXZlcnNlUmVwbGFjZShsb29wUGFyZW50LnJpZ2h0LCBsb29wUGFyZW50LCBzY29wZSwgcmVtYXBzKTtcbiAgICB0cmF2ZXJzZVJlcGxhY2UobG9vcFBhcmVudC50ZXN0LCBsb29wUGFyZW50LCBzY29wZSwgcmVtYXBzKTtcbiAgICB0cmF2ZXJzZVJlcGxhY2UobG9vcFBhcmVudC51cGRhdGUsIGxvb3BQYXJlbnQsIHNjb3BlLCByZW1hcHMpO1xuICB9XG5cbiAgc2NvcGUudHJhdmVyc2UodGhpcy5ibG9jaywgcmVwbGFjZVZpc2l0b3IsIHJlbWFwcyk7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKi9cblxuQmxvY2tTY29waW5nLnByb3RvdHlwZS53cmFwQ2xvc3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJsb2NrID0gdGhpcy5ibG9jaztcblxuICB2YXIgb3V0c2lkZVJlZnMgPSB0aGlzLm91dHNpZGVMZXRSZWZlcmVuY2VzO1xuXG4gIC8vIHJlbWFwIGxvb3AgaGVhZHMgd2l0aCBjb2xsaWRpbmcgdmFyaWFibGVzXG4gIGlmICh0aGlzLmxvb3BQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG91dHNpZGVSZWZzKSB7XG4gICAgICB2YXIgaWQgPSBvdXRzaWRlUmVmc1tuYW1lXTtcblxuICAgICAgaWYgKHRoaXMuc2NvcGUuaGFzR2xvYmFsKGlkLm5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBvdXRzaWRlUmVmc1tpZC5uYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMubGV0UmVmZXJlbmNlc1tpZC5uYW1lXTtcblxuICAgICAgICB0aGlzLnNjb3BlLnJlbmFtZShpZC5uYW1lKTtcblxuICAgICAgICB0aGlzLmxldFJlZmVyZW5jZXNbaWQubmFtZV0gPSBpZDtcbiAgICAgICAgb3V0c2lkZVJlZnNbaWQubmFtZV0gPSBpZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSdyZSBpbnNpZGUgb2YgYSBmb3IgbG9vcCB0aGVuIHdlIHNlYXJjaCB0byBzZWUgaWYgdGhlcmUgYXJlIGFueVxuICAvLyBgYnJlYWtgcywgYGNvbnRpbnVlYHMsIGByZXR1cm5gcyBldGNcbiAgdGhpcy5oYXMgPSB0aGlzLmNoZWNrTG9vcCgpO1xuXG4gIC8vIGhvaXN0IHZhciByZWZlcmVuY2VzIHRvIHJldGFpbiBzY29wZVxuICB0aGlzLmhvaXN0VmFyRGVjbGFyYXRpb25zKCk7XG5cbiAgLy8gdHVybiBvdXRzaWRlTGV0UmVmZXJlbmNlcyBpbnRvIGFuIGFycmF5XG4gIHZhciBwYXJhbXMgPSB2YWx1ZXMob3V0c2lkZVJlZnMpO1xuXG4gIC8vIGJ1aWxkIHRoZSBjbG9zdXJlIHRoYXQgd2UncmUgZ29pbmcgdG8gd3JhcCB0aGUgYmxvY2sgd2l0aFxuICB2YXIgZm4gPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMsIHQuYmxvY2tTdGF0ZW1lbnQoYmxvY2suYm9keSkpO1xuICBmbi5fYWxpYXNGdW5jdGlvbiA9IHRydWU7XG5cbiAgLy8gcmVwbGFjZSB0aGUgY3VycmVudCBibG9jayBib2R5IHdpdGggdGhlIG9uZSB3ZSdyZSBnb2luZyB0byBidWlsZFxuICBibG9jay5ib2R5ID0gdGhpcy5ib2R5O1xuXG4gIC8vIGJ1aWxkIGEgY2FsbCBhbmQgYSB1bmlxdWUgaWQgdGhhdCB3ZSBjYW4gYXNzaWduIHRoZSByZXR1cm4gdmFsdWUgdG9cbiAgdmFyIGNhbGwgPSB0LmNhbGxFeHByZXNzaW9uKGZuLCBwYXJhbXMpO1xuICB2YXIgcmV0ICA9IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwicmV0XCIpO1xuXG4gIC8vIGhhbmRsZSBnZW5lcmF0b3JzXG4gIHZhciBoYXNZaWVsZCA9IHRyYXZlcnNlLmhhc1R5cGUoZm4uYm9keSwgdGhpcy5zY29wZSwgXCJZaWVsZEV4cHJlc3Npb25cIiwgdC5GVU5DVElPTl9UWVBFUyk7XG4gIGlmIChoYXNZaWVsZCkge1xuICAgIGZuLmdlbmVyYXRvciA9IHRydWU7XG4gICAgY2FsbCA9IHQueWllbGRFeHByZXNzaW9uKGNhbGwsIHRydWUpO1xuICB9XG5cbiAgLy8gaGFuZGxlcnMgYXN5bmMgZnVuY3Rpb25zXG4gIHZhciBoYXNBc3luYyA9IHRyYXZlcnNlLmhhc1R5cGUoZm4uYm9keSwgdGhpcy5zY29wZSwgXCJBd2FpdEV4cHJlc3Npb25cIiwgdC5GVU5DVElPTl9UWVBFUyk7XG4gIGlmIChoYXNBc3luYykge1xuICAgIGZuLmFzeW5jID0gdHJ1ZTtcbiAgICBjYWxsID0gdC5hd2FpdEV4cHJlc3Npb24oY2FsbCwgdHJ1ZSk7XG4gIH1cblxuICB0aGlzLmJ1aWxkKHJldCwgY2FsbCk7XG59O1xuXG52YXIgbGV0UmVmZXJlbmNlRnVuY3Rpb25WaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgLy8gbm90IGEgZGlyZWN0IHJlZmVyZW5jZVxuICAgIGlmICghdC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCkpIHJldHVybjtcblxuICAgIC8vIHRoaXMgc2NvcGUgaGFzIGEgdmFyaWFibGUgd2l0aCB0aGUgc2FtZSBuYW1lIHNvIGl0IGNvdWxkbid0IGJlbG9uZ1xuICAgIC8vIHRvIG91ciBsZXQgc2NvcGVcbiAgICBpZiAoc2NvcGUuaGFzT3duQmluZGluZyhub2RlLm5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBub3QgYSBwYXJ0IG9mIG91ciBzY29wZVxuICAgIGlmICghc3RhdGUubGV0UmVmZXJlbmNlc1tub2RlLm5hbWVdKSByZXR1cm47XG5cbiAgICBzdGF0ZS5jbG9zdXJpZnkgPSB0cnVlO1xuICB9XG59O1xuXG52YXIgbGV0UmVmZXJlbmNlQmxvY2tWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgICAgc2NvcGUudHJhdmVyc2Uobm9kZSwgbGV0UmVmZXJlbmNlRnVuY3Rpb25WaXNpdG9yLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gdGhpcy5za2lwKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKi9cblxuQmxvY2tTY29waW5nLnByb3RvdHlwZS5nZXRMZXRSZWZlcmVuY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrO1xuXG4gIHZhciBkZWNsYXJhdG9ycyA9IGJsb2NrLl9sZXREZWNsYXJhdG9ycyB8fCBbXTtcbiAgdmFyIGRlY2xhcjtcblxuICAvL1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY2xhcmF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjbGFyID0gZGVjbGFyYXRvcnNbaV07XG4gICAgZXh0ZW5kKHRoaXMub3V0c2lkZUxldFJlZmVyZW5jZXMsIHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKGRlY2xhcikpO1xuICB9XG5cbiAgLy9cbiAgaWYgKGJsb2NrLmJvZHkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2suYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgZGVjbGFyID0gYmxvY2suYm9keVtpXTtcbiAgICAgIGlmIChpc0xldChkZWNsYXIsIGJsb2NrKSkge1xuICAgICAgICBkZWNsYXJhdG9ycyA9IGRlY2xhcmF0b3JzLmNvbmNhdChkZWNsYXIuZGVjbGFyYXRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL1xuICBmb3IgKGkgPSAwOyBpIDwgZGVjbGFyYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNsYXIgPSBkZWNsYXJhdG9yc1tpXTtcbiAgICB2YXIga2V5cyA9IHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKGRlY2xhcik7XG4gICAgZXh0ZW5kKHRoaXMubGV0UmVmZXJlbmNlcywga2V5cyk7XG4gICAgdGhpcy5oYXNMZXRSZWZlcmVuY2VzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIG5vIGxldCByZWZlcmVuY2VzIHNvIHdlIGNhbiBqdXN0IHF1aXRcbiAgaWYgKCF0aGlzLmhhc0xldFJlZmVyZW5jZXMpIHJldHVybjtcblxuICAvLyBzZXQgbGV0IHJlZmVyZW5jZXMgdG8gcGxhaW4gdmFyIHJlZmVyZW5jZXNcbiAgc3RhbmRhcmRpemVMZXRzKGRlY2xhcmF0b3JzKTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgbGV0UmVmZXJlbmNlczogdGhpcy5sZXRSZWZlcmVuY2VzLFxuICAgIGNsb3N1cmlmeTogICAgIGZhbHNlXG4gIH07XG5cbiAgLy8gdHJhdmVyc2UgdGhyb3VnaCB0aGlzIGJsb2NrLCBzdG9wcGluZyBvbiBmdW5jdGlvbnMgYW5kIGNoZWNraW5nIGlmIHRoZXlcbiAgLy8gY29udGFpbiBhbnkgbG9jYWwgbGV0IHJlZmVyZW5jZXNcbiAgdGhpcy5zY29wZS50cmF2ZXJzZSh0aGlzLmJsb2NrLCBsZXRSZWZlcmVuY2VCbG9ja1Zpc2l0b3IsIHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUuY2xvc3VyaWZ5O1xufTtcblxudmFyIGxvb3BOb2RlVG8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodC5pc0JyZWFrU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgfSBlbHNlIGlmICh0LmlzQ29udGludWVTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICB9XG59O1xuXG52YXIgbG9vcFZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICB2YXIgcmVwbGFjZTtcblxuICAgIGlmICh0LmlzTG9vcChub2RlKSkge1xuICAgICAgc3RhdGUuaWdub3JlTGFiZWxlc3MgPSB0cnVlO1xuICAgICAgc2NvcGUudHJhdmVyc2Uobm9kZSwgbG9vcFZpc2l0b3IsIHN0YXRlKTtcbiAgICAgIHN0YXRlLmlnbm9yZUxhYmVsZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSB8fCB0LmlzTG9vcChub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xuICAgIH1cblxuICAgIHZhciBsb29wVGV4dCA9IGxvb3BOb2RlVG8obm9kZSk7XG5cbiAgICBpZiAobG9vcFRleHQpIHtcbiAgICAgIGlmIChub2RlLmxhYmVsKSB7XG4gICAgICAgIC8vIHdlIHNob3VsZG4ndCBiZSB0cmFuc2Zvcm1pbmcgdGhpcyBiZWNhdXNlIGl0IGV4aXN0cyBzb21ld2hlcmUgaW5zaWRlXG4gICAgICAgIGlmIChzdGF0ZS5pbm5lckxhYmVscy5pbmRleE9mKG5vZGUubGFiZWwubmFtZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvb3BUZXh0ID0gbG9vcFRleHQgKyBcInxcIiArIG5vZGUubGFiZWwubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHNob3VsZG4ndCBiZSB0cmFuc2Zvcm1pbmcgdGhlc2Ugc3RhdGVtZW50cyBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXkgZG9uJ3QgcmVmZXIgdG8gdGhlIGFjdHVhbCBsb29wIHdlJ3JlIHNjb3BpZnlpbmdcbiAgICAgICAgaWYgKHN0YXRlLmlnbm9yZUxhYmVsZXNzKSByZXR1cm47XG5cbiAgICAgICAgLy8gYnJlYWsgc3RhdGVtZW50cyBtZWFuIHNvbWV0aGluZyBkaWZmZXJlbnQgaW4gdGhpcyBjb250ZXh0XG4gICAgICAgIGlmICh0LmlzQnJlYWtTdGF0ZW1lbnQobm9kZSkgJiYgdC5pc1N3aXRjaENhc2UocGFyZW50KSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5oYXNCcmVha0NvbnRpbnVlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLm1hcFtsb29wVGV4dF0gPSBub2RlO1xuICAgICAgcmVwbGFjZSA9IHQubGl0ZXJhbChsb29wVGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNSZXR1cm5TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIHN0YXRlLmhhc1JldHVybiA9IHRydWU7XG4gICAgICByZXBsYWNlID0gdC5vYmplY3RFeHByZXNzaW9uKFtcbiAgICAgICAgdC5wcm9wZXJ0eShcImluaXRcIiwgdC5pZGVudGlmaWVyKFwidlwiKSwgbm9kZS5hcmd1bWVudCB8fCB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIikpXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgcmVwbGFjZSA9IHQucmV0dXJuU3RhdGVtZW50KHJlcGxhY2UpO1xuICAgICAgcmV0dXJuIHQuaW5oZXJpdHMocmVwbGFjZSwgbm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgbG9vcExhYmVsVmlzaXRvciA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBzdGF0ZSkge1xuICAgIGlmICh0LmlzTGFiZWxlZFN0YXRlbWVudChub2RlKSkge1xuICAgICAgc3RhdGUuaW5uZXJMYWJlbHMucHVzaChub2RlLmxhYmVsLm5hbWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJZiB3ZSdyZSBpbnNpZGUgb2YgYSBsb29wIHRoZW4gdHJhdmVyc2UgaXQgYW5kIGNoZWNrIGlmIGl0IGhhcyBvbmUgb2ZcbiAqIHRoZSBmb2xsb3dpbmcgbm9kZSB0eXBlcyBgUmV0dXJuU3RhdGVtZW50YCwgYEJyZWFrU3RhdGVtZW50YCxcbiAqIGBDb250aW51ZVN0YXRlbWVudGAgYW5kIHJlcGxhY2UgaXQgd2l0aCBhIHJldHVybiB2YWx1ZSB0aGF0IHdlIGNhbiB0cmFja1xuICogbGF0ZXIgb24uXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5CbG9ja1Njb3BpbmcucHJvdG90eXBlLmNoZWNrTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGhhc0JyZWFrQ29udGludWU6IGZhbHNlLFxuICAgIGlnbm9yZUxhYmVsZXNzOiAgIGZhbHNlLFxuICAgIGlubmVyTGFiZWxzOiAgICAgIFtdLFxuICAgIGhhc1JldHVybjogICAgICAgIGZhbHNlLFxuICAgIGlzTG9vcDogICAgICAgICAgICEhdGhpcy5sb29wUGFyZW50LFxuICAgIG1hcDogICAgICAgICAgICAgIHt9XG4gIH07XG5cbiAgdGhpcy5zY29wZS50cmF2ZXJzZSh0aGlzLmJsb2NrLCBsb29wTGFiZWxWaXNpdG9yLCBzdGF0ZSk7XG4gIHRoaXMuc2NvcGUudHJhdmVyc2UodGhpcy5ibG9jaywgbG9vcFZpc2l0b3IsIHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG52YXIgaG9pc3RWYXJEZWNsYXJhdGlvbnNWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHNlbGYpIHtcbiAgICBpZiAodC5pc0ZvclN0YXRlbWVudChub2RlKSkge1xuICAgICAgaWYgKGlzVmFyKG5vZGUuaW5pdCwgbm9kZSkpIHtcbiAgICAgICAgbm9kZS5pbml0ID0gdC5zZXF1ZW5jZUV4cHJlc3Npb24oc2VsZi5wdXNoRGVjbGFyKG5vZGUuaW5pdCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodC5pc0Zvcihub2RlKSkge1xuICAgICAgaWYgKGlzVmFyKG5vZGUubGVmdCwgbm9kZSkpIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5sZWZ0LmRlY2xhcmF0aW9uc1swXS5pZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFyKG5vZGUsIHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBzZWxmLnB1c2hEZWNsYXIobm9kZSkubWFwKHQuZXhwcmVzc2lvblN0YXRlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0LmlzRnVuY3Rpb24obm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSG9pc3QgYWxsIHZhciBkZWNsYXJhdGlvbnMgaW4gdGhpcyBibG9jayB0byBiZWZvcmUgaXQgc28gdGhleSByZXRhaW4gc2NvcGVcbiAqIG9uY2Ugd2Ugd3JhcCBldmVyeXRoaW5nIGluIGEgY2xvc3VyZS5cbiAqL1xuXG5CbG9ja1Njb3BpbmcucHJvdG90eXBlLmhvaXN0VmFyRGVjbGFyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICB0cmF2ZXJzZSh0aGlzLmJsb2NrLCBob2lzdFZhckRlY2xhcmF0aW9uc1Zpc2l0b3IsIHRoaXMuc2NvcGUsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBUdXJuIGEgYFZhcmlhYmxlRGVjbGFyYXRpb25gIGludG8gYW4gYXJyYXkgb2YgYEFzc2lnbm1lbnRFeHByZXNzaW9uc2Agd2l0aFxuICogdGhlaXIgZGVjbGFyYXRpb25zIGhvaXN0ZWQgdG8gYmVmb3JlIHRoZSBjbG9zdXJlIHdyYXBwZXIuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFZhcmlhYmxlRGVjbGFyYXRpb25cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5CbG9ja1Njb3BpbmcucHJvdG90eXBlLnB1c2hEZWNsYXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLmJvZHkucHVzaCh0LnZhcmlhYmxlRGVjbGFyYXRpb24obm9kZS5raW5kLCBub2RlLmRlY2xhcmF0aW9ucy5tYXAoZnVuY3Rpb24gKGRlY2xhcikge1xuICAgIHJldHVybiB0LnZhcmlhYmxlRGVjbGFyYXRvcihkZWNsYXIuaWQpO1xuICB9KSkpO1xuXG4gIHZhciByZXBsYWNlID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uc1tpXTtcbiAgICBpZiAoIWRlY2xhci5pbml0KSBjb250aW51ZTtcblxuICAgIHZhciBleHByID0gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCk7XG4gICAgcmVwbGFjZS5wdXNoKHQuaW5oZXJpdHMoZXhwciwgZGVjbGFyKSk7XG4gIH1cblxuICByZXR1cm4gcmVwbGFjZTtcbn07XG5cbi8qKlxuICogUHVzaCB0aGUgY2xvc3VyZSB0byB0aGUgYm9keS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHJldCBJZGVudGlmaWVyXG4gKiBAcGFyYW0ge05vZGV9IGNhbGwgQ2FsbEV4cHJlc3Npb25cbiAqL1xuXG5CbG9ja1Njb3BpbmcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHJldCwgY2FsbCkge1xuICB2YXIgaGFzID0gdGhpcy5oYXM7XG4gIGlmIChoYXMuaGFzUmV0dXJuIHx8IGhhcy5oYXNCcmVha0NvbnRpbnVlKSB7XG4gICAgdGhpcy5idWlsZEhhcyhyZXQsIGNhbGwpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudChjYWxsKSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHJldCBJZGVudGlmaWVyXG4gKiBAcGFyYW0ge05vZGV9IGNhbGwgQ2FsbEV4cHJlc3Npb25cbiAqL1xuXG5CbG9ja1Njb3BpbmcucHJvdG90eXBlLmJ1aWxkSGFzID0gZnVuY3Rpb24gKHJldCwgY2FsbCkge1xuICB2YXIgYm9keSA9IHRoaXMuYm9keTtcblxuICBib2R5LnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihyZXQsIGNhbGwpXG4gIF0pKTtcblxuICB2YXIgbG9vcFBhcmVudCA9IHRoaXMubG9vcFBhcmVudDtcbiAgdmFyIHJldENoZWNrO1xuICB2YXIgaGFzID0gdGhpcy5oYXM7XG4gIHZhciBjYXNlcyA9IFtdO1xuXG4gIGlmIChoYXMuaGFzUmV0dXJuKSB7XG4gICAgLy8gdHlwZW9mIHJldCA9PT0gXCJvYmplY3RcIlxuICAgIHJldENoZWNrID0gdXRpbC50ZW1wbGF0ZShcImxldC1zY29waW5nLXJldHVyblwiLCB7XG4gICAgICBSRVRVUk46IHJldFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGhhcy5oYXNCcmVha0NvbnRpbnVlKSB7XG4gICAgaWYgKCFsb29wUGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXMgbm8gbG9vcCBwYXJlbnQgYnV0IHdlJ3JlIHRyeWluZyB0byByZWFzc2lnbiBicmVha3MgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiYW5kIGNvbnRpbnVlcywgc29tZXRoaW5nIGlzIGdvaW5nIHdyb25nIGhlcmUuXCIpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBoYXMubWFwKSB7XG4gICAgICBjYXNlcy5wdXNoKHQuc3dpdGNoQ2FzZSh0LmxpdGVyYWwoa2V5KSwgW2hhcy5tYXBba2V5XV0pKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzLmhhc1JldHVybikge1xuICAgICAgY2FzZXMucHVzaCh0LnN3aXRjaENhc2UobnVsbCwgW3JldENoZWNrXSkpO1xuICAgIH1cblxuICAgIGlmIChjYXNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzaW5nbGUgPSBjYXNlc1swXTtcbiAgICAgIGJvZHkucHVzaCh0aGlzLmZpbGUuYXR0YWNoQXV4aWxpYXJ5Q29tbWVudCh0LmlmU3RhdGVtZW50KFxuICAgICAgICB0LmJpbmFyeUV4cHJlc3Npb24oXCI9PT1cIiwgcmV0LCBzaW5nbGUudGVzdCksXG4gICAgICAgIHNpbmdsZS5jb25zZXF1ZW50WzBdXG4gICAgICApKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkucHVzaCh0aGlzLmZpbGUuYXR0YWNoQXV4aWxpYXJ5Q29tbWVudCh0LnN3aXRjaFN0YXRlbWVudChyZXQsIGNhc2VzKSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFzLmhhc1JldHVybikge1xuICAgICAgYm9keS5wdXNoKHRoaXMuZmlsZS5hdHRhY2hBdXhpbGlhcnlDb21tZW50KHJldENoZWNrKSk7XG4gICAgfVxuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZXBsYWNlU3VwZXJzID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvcmVwbGFjZS1zdXBlcnNcIik7XG52YXIgbmFtZU1ldGhvZCAgICA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25hbWUtbWV0aG9kXCIpO1xudmFyIGRlZmluZU1hcCAgICAgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9kZWZpbmUtbWFwXCIpO1xudmFyIG1lc3NhZ2VzICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVzc2FnZXNcIik7XG52YXIgdXRpbCAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSB0LmlzQ2xhc3M7XG5cbmV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHJldHVybiBuZXcgQ2xhc3NUcmFuc2Zvcm1lcihub2RlLCBmaWxlLCBzY29wZSwgdHJ1ZSkucnVuKCk7XG59O1xuXG5leHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghbm9kZS5pZCkge1xuICAgIGlmICh0LmlzUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQudmFsdWUgPT09IG5vZGUgJiYgIXBhcmVudC5jb21wdXRlZCAmJiB0LmlzSWRlbnRpZmllcihwYXJlbnQua2V5KSkge1xuICAgICAgLy8gdmFyIG8gPSB7IGZvbzogY2xhc3Mge30gfTtcbiAgICAgIG5vZGUuaWQgPSBwYXJlbnQua2V5O1xuICAgIH1cblxuICAgIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdG9yKHBhcmVudCkgJiYgdC5pc0lkZW50aWZpZXIocGFyZW50LmlkKSkge1xuICAgICAgLy8gdmFyIGZvbyA9IGNsYXNzIHt9O1xuICAgICAgbm9kZS5pZCA9IHBhcmVudC5pZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IENsYXNzVHJhbnNmb3JtZXIobm9kZSwgZmlsZSwgc2NvcGUsIGZhbHNlKS5ydW4oKTtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTY29wZX0gc2NvcGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNTdGF0ZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBDbGFzc1RyYW5zZm9ybWVyKG5vZGUsIGZpbGUsIHNjb3BlLCBpc1N0YXRlbWVudCkge1xuICB0aGlzLmlzU3RhdGVtZW50ID0gaXNTdGF0ZW1lbnQ7XG4gIHRoaXMuc2NvcGUgICAgICAgPSBzY29wZTtcbiAgdGhpcy5ub2RlICAgICAgICA9IG5vZGU7XG4gIHRoaXMuZmlsZSAgICAgICAgPSBmaWxlO1xuXG4gIHRoaXMuaGFzSW5zdGFuY2VNdXRhdG9ycyA9IGZhbHNlO1xuICB0aGlzLmhhc1N0YXRpY011dGF0b3JzICAgPSBmYWxzZTtcblxuICB0aGlzLmluc3RhbmNlTXV0YXRvck1hcCA9IHt9O1xuICB0aGlzLnN0YXRpY011dGF0b3JNYXAgICA9IHt9O1xuICB0aGlzLmhhc0NvbnN0cnVjdG9yICAgICA9IGZhbHNlO1xuICB0aGlzLmNsYXNzTmFtZSAgICAgICAgICA9IG5vZGUuaWQgfHwgc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiY2xhc3NcIik7XG4gIHRoaXMuc3VwZXJOYW1lICAgICAgICAgID0gbm9kZS5zdXBlckNsYXNzIHx8IHQuaWRlbnRpZmllcihcIkZ1bmN0aW9uXCIpO1xuICB0aGlzLmhhc1N1cGVyICAgICAgICAgICA9ICEhbm9kZS5zdXBlckNsYXNzO1xuICB0aGlzLmlzTG9vc2UgICAgICAgICAgICA9IGZpbGUuaXNMb29zZShcImVzNi5jbGFzc2VzXCIpO1xufVxuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbkNsYXNzVHJhbnNmb3JtZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1cGVyTmFtZSA9IHRoaXMuc3VwZXJOYW1lO1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gIHZhciBmaWxlICAgICAgPSB0aGlzLmZpbGU7XG5cbiAgLy9cblxuICB2YXIgYm9keSA9IHRoaXMuYm9keSA9IFtdO1xuXG4gIHZhciBjb25zdHJ1Y3RvckJvZHkgPSB0LmJsb2NrU3RhdGVtZW50KFtcbiAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5jYWxsRXhwcmVzc2lvbihmaWxlLmFkZEhlbHBlcihcImNsYXNzLWNhbGwtY2hlY2tcIiksIFtcbiAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgIGNsYXNzTmFtZVxuICAgIF0pKVxuICBdKTtcbiAgdmFyIGNvbnN0cnVjdG9yO1xuXG4gIGlmICh0aGlzLm5vZGUuaWQpIHtcbiAgICBjb25zdHJ1Y3RvciA9IHQuZnVuY3Rpb25EZWNsYXJhdGlvbihjbGFzc05hbWUsIFtdLCBjb25zdHJ1Y3RvckJvZHkpO1xuICAgIGJvZHkucHVzaChjb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3RydWN0b3IgPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBbXSwgY29uc3RydWN0b3JCb2R5KTtcbiAgICBib2R5LnB1c2godC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGNsYXNzTmFtZSwgY29uc3RydWN0b3IpXG4gICAgXSkpO1xuICB9XG4gIHRoaXMuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcblxuICB2YXIgY2xvc3VyZVBhcmFtcyA9IFtdO1xuICB2YXIgY2xvc3VyZUFyZ3MgPSBbXTtcblxuICAvL1xuXG4gIGlmICh0aGlzLmhhc1N1cGVyKSB7XG4gICAgY2xvc3VyZUFyZ3MucHVzaChzdXBlck5hbWUpO1xuXG4gICAgaWYgKCF0LmlzSWRlbnRpZmllcihzdXBlck5hbWUpKSB7XG4gICAgICBzdXBlck5hbWUgPSB0aGlzLnNjb3BlLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUoc3VwZXJOYW1lLCB0aGlzLmZpbGUpO1xuICAgIH1cblxuICAgIGNsb3N1cmVQYXJhbXMucHVzaChzdXBlck5hbWUpO1xuXG4gICAgdGhpcy5zdXBlck5hbWUgPSBzdXBlck5hbWU7XG4gICAgYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwiaW5oZXJpdHNcIiksIFtjbGFzc05hbWUsIHN1cGVyTmFtZV0pKSk7XG4gIH1cblxuICB0aGlzLmJ1aWxkQm9keSgpO1xuXG4gIHQuaW5oZXJpdHNDb21tZW50cyhib2R5WzBdLCB0aGlzLm5vZGUpO1xuXG4gIHZhciBpbml0O1xuXG4gIGlmIChib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIG9ubHkgYSBjb25zdHJ1Y3RvciBzbyBubyBuZWVkIGZvciBhIGNsb3N1cmUgY29udGFpbmVyXG4gICAgaW5pdCA9IHQudG9FeHByZXNzaW9uKGNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBib2R5LnB1c2godC5yZXR1cm5TdGF0ZW1lbnQoY2xhc3NOYW1lKSk7XG4gICAgaW5pdCA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBjbG9zdXJlUGFyYW1zLCB0LmJsb2NrU3RhdGVtZW50KGJvZHkpKSxcbiAgICAgIGNsb3N1cmVBcmdzXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzU3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHQudmFyaWFibGVEZWNsYXJhdGlvbihcImxldFwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihjbGFzc05hbWUsIGluaXQpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqL1xuXG5DbGFzc1RyYW5zZm9ybWVyLnByb3RvdHlwZS5idWlsZEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gIHZhciBjbGFzc05hbWUgICA9IHRoaXMuY2xhc3NOYW1lO1xuICB2YXIgc3VwZXJOYW1lICAgPSB0aGlzLnN1cGVyTmFtZTtcbiAgdmFyIGNsYXNzQm9keSAgID0gdGhpcy5ub2RlLmJvZHkuYm9keTtcbiAgdmFyIGJvZHkgICAgICAgID0gdGhpcy5ib2R5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NCb2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBjbGFzc0JvZHlbaV07XG4gICAgaWYgKHQuaXNNZXRob2REZWZpbml0aW9uKG5vZGUpKSB7XG4gICAgICB2YXIgcmVwbGFjZVN1cGVycyA9IG5ldyBSZXBsYWNlU3VwZXJzKHtcbiAgICAgICAgbWV0aG9kTm9kZTogbm9kZSxcbiAgICAgICAgY2xhc3NOYW1lOiAgdGhpcy5jbGFzc05hbWUsXG4gICAgICAgIHN1cGVyTmFtZTogIHRoaXMuc3VwZXJOYW1lLFxuICAgICAgICBpc1N0YXRpYzogICBub2RlLnN0YXRpYyxcbiAgICAgICAgaXNMb29zZTogICAgdGhpcy5pc0xvb3NlLFxuICAgICAgICBzY29wZTogICAgICB0aGlzLnNjb3BlLFxuICAgICAgICBmaWxlOiAgICAgICB0aGlzLmZpbGVcbiAgICAgIH0sIHRydWUpO1xuICAgICAgcmVwbGFjZVN1cGVycy5yZXBsYWNlKCk7XG5cbiAgICAgIGlmIChub2RlLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5wdXNoQ29uc3RydWN0b3Iobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hNZXRob2Qobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0LmlzUHJpdmF0ZURlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICB0aGlzLmNsb3N1cmUgPSB0cnVlO1xuICAgICAgYm9keS51bnNoaWZ0KG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodC5pc0NsYXNzUHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHRoaXMucHVzaFByb3BlcnR5KG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdlIGhhdmUgbm8gY29uc3RydWN0b3IsIHdlIGhhdmUgYSBzdXBlciwgYW5kIHRoZSBzdXBlciBkb2Vzbid0IGFwcGVhciB0byBiZSBmYWxzeVxuICBpZiAoIXRoaXMuaGFzQ29uc3RydWN0b3IgJiYgdGhpcy5oYXNTdXBlciAmJiAhdC5pc0ZhbHN5RXhwcmVzc2lvbihzdXBlck5hbWUpKSB7XG4gICAgdmFyIGhlbHBlck5hbWUgPSBcImNsYXNzLXN1cGVyLWNvbnN0cnVjdG9yLWNhbGxcIjtcbiAgICBpZiAodGhpcy5pc0xvb3NlKSBoZWxwZXJOYW1lICs9IFwiLWxvb3NlXCI7XG4gICAgY29uc3RydWN0b3IuYm9keS5ib2R5LnB1c2godXRpbC50ZW1wbGF0ZShoZWxwZXJOYW1lLCB7XG4gICAgICBDTEFTU19OQU1FOiBjbGFzc05hbWUsXG4gICAgICBTVVBFUl9OQU1FOiB0aGlzLnN1cGVyTmFtZVxuICAgIH0sIHRydWUpKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZVByb3BzO1xuICB2YXIgc3RhdGljUHJvcHM7XG5cbiAgaWYgKHRoaXMuaGFzSW5zdGFuY2VNdXRhdG9ycykge1xuICAgIGluc3RhbmNlUHJvcHMgPSBkZWZpbmVNYXAuYnVpbGQodGhpcy5pbnN0YW5jZU11dGF0b3JNYXApO1xuICB9XG5cbiAgaWYgKHRoaXMuaGFzU3RhdGljTXV0YXRvcnMpIHtcbiAgICBzdGF0aWNQcm9wcyA9IGRlZmluZU1hcC5idWlsZCh0aGlzLnN0YXRpY011dGF0b3JNYXApO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlUHJvcHMgfHwgc3RhdGljUHJvcHMpIHtcbiAgICBzdGF0aWNQcm9wcyA9IHN0YXRpY1Byb3BzIHx8IHQubGl0ZXJhbChudWxsKTtcblxuICAgIHZhciBhcmdzID0gW2NsYXNzTmFtZSwgc3RhdGljUHJvcHNdO1xuICAgIGlmIChpbnN0YW5jZVByb3BzKSBhcmdzLnB1c2goaW5zdGFuY2VQcm9wcyk7XG5cbiAgICBib2R5LnB1c2godC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5jYWxsRXhwcmVzc2lvbih0aGlzLmZpbGUuYWRkSGVscGVyKFwicHJvdG90eXBlLXByb3BlcnRpZXNcIiksIGFyZ3MpXG4gICAgKSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHVzaCBhIG1ldGhvZCB0byBpdHMgcmVzcGVjdGl2ZSBtdXRhdG9yTWFwLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBNZXRob2REZWZpbml0aW9uXG4gKi9cblxuQ2xhc3NUcmFuc2Zvcm1lci5wcm90b3R5cGUucHVzaE1ldGhvZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBtZXRob2ROYW1lID0gbm9kZS5rZXk7XG5cbiAgdmFyIGtpbmQgPSBub2RlLmtpbmQ7XG5cbiAgaWYgKGtpbmQgPT09IFwiXCIpIHtcbiAgICBuYW1lTWV0aG9kLnByb3BlcnR5KG5vZGUsIHRoaXMuZmlsZSwgdGhpcy5zY29wZSk7XG5cbiAgICBpZiAodGhpcy5pc0xvb3NlKSB7XG4gICAgICAvLyB1c2UgYXNzaWdubWVudHMgaW5zdGVhZCBvZiBkZWZpbmUgcHJvcGVydGllcyBmb3IgbG9vc2UgY2xhc3Nlc1xuXG4gICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICBpZiAoIW5vZGUuc3RhdGljKSBjbGFzc05hbWUgPSB0Lm1lbWJlckV4cHJlc3Npb24oY2xhc3NOYW1lLCB0LmlkZW50aWZpZXIoXCJwcm90b3R5cGVcIikpO1xuICAgICAgbWV0aG9kTmFtZSA9IHQubWVtYmVyRXhwcmVzc2lvbihjbGFzc05hbWUsIG1ldGhvZE5hbWUsIG5vZGUuY29tcHV0ZWQpO1xuXG4gICAgICB2YXIgZXhwciA9IHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBtZXRob2ROYW1lLCBub2RlLnZhbHVlKSk7XG4gICAgICB0LmluaGVyaXRzQ29tbWVudHMoZXhwciwgbm9kZSk7XG4gICAgICB0aGlzLmJvZHkucHVzaChleHByKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBraW5kID0gXCJ2YWx1ZVwiO1xuICB9XG5cbiAgdmFyIG11dGF0b3JNYXAgPSB0aGlzLmluc3RhbmNlTXV0YXRvck1hcDtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgdGhpcy5oYXNTdGF0aWNNdXRhdG9ycyA9IHRydWU7XG4gICAgbXV0YXRvck1hcCA9IHRoaXMuc3RhdGljTXV0YXRvck1hcDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhc0luc3RhbmNlTXV0YXRvcnMgPSB0cnVlO1xuICB9XG5cbiAgZGVmaW5lTWFwLnB1c2gobXV0YXRvck1hcCwgbWV0aG9kTmFtZSwga2luZCwgbm9kZS5jb21wdXRlZCwgbm9kZSk7XG4gIGRlZmluZU1hcC5wdXNoKG11dGF0b3JNYXAsIG1ldGhvZE5hbWUsIFwiZW51bWVyYWJsZVwiLCBub2RlLmNvbXB1dGVkLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cblxuQ2xhc3NUcmFuc2Zvcm1lci5wcm90b3R5cGUucHVzaFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlLnZhbHVlKSByZXR1cm47XG5cbiAgdmFyIGtleTtcblxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBrZXkgPSB0Lm1lbWJlckV4cHJlc3Npb24odGhpcy5jbGFzc05hbWUsIG5vZGUua2V5KTtcbiAgICB0aGlzLmJvZHkucHVzaChcbiAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBrZXksIG5vZGUudmFsdWUpKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gdC5tZW1iZXJFeHByZXNzaW9uKHQudGhpc0V4cHJlc3Npb24oKSwgbm9kZS5rZXkpO1xuICAgIHRoaXMuY29uc3RydWN0b3IuYm9keS5ib2R5LnVuc2hpZnQoXG4gICAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwga2V5LCBub2RlLnZhbHVlKSlcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIGNvbnN0cnVjdG9yIGJvZHkgb2Ygb3VyIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbWV0aG9kIE1ldGhvZERlZmluaXRpb25cbiAqL1xuXG5DbGFzc1RyYW5zZm9ybWVyLnByb3RvdHlwZS5wdXNoQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIGlmIChtZXRob2Qua2luZCkge1xuICAgIHRocm93IHRoaXMuZmlsZS5lcnJvcldpdGhOb2RlKG1ldGhvZCwgbWVzc2FnZXMuZ2V0KFwiY2xhc3Nlc0lsbGVnYWxDb25zdHJ1Y3RvcktpbmRcIikpO1xuICB9XG5cbiAgdmFyIGNvbnN0cnVjdCA9IHRoaXMuY29uc3RydWN0b3I7XG4gIHZhciBmbiAgICAgICAgPSBtZXRob2QudmFsdWU7XG5cbiAgdGhpcy5oYXNDb25zdHJ1Y3RvciA9IHRydWU7XG5cbiAgdC5pbmhlcml0cyhjb25zdHJ1Y3QsIGZuKTtcbiAgdC5pbmhlcml0c0NvbW1lbnRzKGNvbnN0cnVjdCwgbWV0aG9kKTtcblxuICBjb25zdHJ1Y3QuX2lnbm9yZVVzZXJXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgY29uc3RydWN0LnBhcmFtcyAgICAgICAgICAgICAgICA9IGZuLnBhcmFtcztcbiAgY29uc3RydWN0LmJvZHkuYm9keSAgICAgICAgICAgICA9IGNvbnN0cnVjdC5ib2R5LmJvZHkuY29uY2F0KGZuLmJvZHkuYm9keSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZXNzYWdlc1wiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5jaGVjayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCB7IGtpbmQ6IFwiY29uc3RcIiB9KTtcbn07XG5cbnZhciB2aXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB8fCB0LmlzVXBkYXRlRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgdmFyIGlkcyA9IHQuZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUpO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIGlkcykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbbmFtZV07XG5cbiAgICAgICAgdmFyIGNvbnN0YW50ID0gc3RhdGUuY29uc3RhbnRzW25hbWVdO1xuXG4gICAgICAgIC8vIG5vIGNvbnN0YW50IGV4aXN0c1xuICAgICAgICBpZiAoIWNvbnN0YW50KSBjb250aW51ZTtcblxuICAgICAgICB2YXIgY29uc3RhbnRJZGVudGlmaWVyID0gY29uc3RhbnQuaWRlbnRpZmllcjtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYXNzaWdubWVudCBpZCBtYXRjaGVzIHRoZSBjb25zdGFudCBkZWNsYXJhdGlvbiBpZFxuICAgICAgICAvLyBpZiBpdCBkb2VzIHRoZW4gaXQgd2FzIHRoZSBpZCB1c2VkIHRvIGluaXRpYWxseSBkZWNsYXJlIHRoZVxuICAgICAgICAvLyBjb25zdGFudCBzbyB3ZSBjYW4ganVzdCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKGlkID09PSBjb25zdGFudElkZW50aWZpZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYmVlbiBhIGxvY2FsIGJpbmRpbmcgdGhhdCBzaGFkb3dzIHRoaXMgY29uc3RhbnRcbiAgICAgICAgaWYgKCFzY29wZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyhuYW1lLCBjb25zdGFudElkZW50aWZpZXIpKSBjb250aW51ZTtcblxuICAgICAgICB0aHJvdyBzdGF0ZS5maWxlLmVycm9yV2l0aE5vZGUoaWQsIG1lc3NhZ2VzLmdldChcInJlYWRPbmx5XCIsIG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHQuaXNTY29wZShub2RlLCBwYXJlbnQpKSB7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuU2NvcGFibGUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBzY29wZS50cmF2ZXJzZShub2RlLCB2aXNpdG9yLCB7XG4gICAgY29uc3RhbnRzOiBzY29wZS5nZXRBbGxCaW5kaW5nc09mS2luZChcImNvbnN0XCIpLFxuICAgIGZpbGU6ICAgICAgZmlsZVxuICB9KTtcbn07XG5cbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmtpbmQgPT09IFwiY29uc3RcIikgbm9kZS5raW5kID0gXCJsZXRcIjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lc3NhZ2VzID0gcmVxdWlyZShcIi4uLy4uLy4uL21lc3NhZ2VzXCIpO1xudmFyIHQgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gdC5pc1BhdHRlcm47XG5cbmZ1bmN0aW9uIERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lcihvcHRzKSB7XG4gIHRoaXMuYmxvY2tIb2lzdCA9IG9wdHMuYmxvY2tIb2lzdDtcbiAgdGhpcy5vcGVyYXRvciAgID0gb3B0cy5vcGVyYXRvcjtcbiAgdGhpcy5ub2RlcyAgICAgID0gb3B0cy5ub2RlcztcbiAgdGhpcy5zY29wZSAgICAgID0gb3B0cy5zY29wZTtcbiAgdGhpcy5maWxlICAgICAgID0gb3B0cy5maWxlO1xuICB0aGlzLmtpbmQgICAgICAgPSBvcHRzLmtpbmQ7XG59XG5cbkRlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUuYnVpbGRWYXJpYWJsZUFzc2lnbm1lbnQgPSBmdW5jdGlvbiAoaWQsIGluaXQpIHtcbiAgdmFyIG9wID0gdGhpcy5vcGVyYXRvcjtcbiAgaWYgKHQuaXNNZW1iZXJFeHByZXNzaW9uKGlkKSkgb3AgPSBcIj1cIjtcblxuICB2YXIgbm9kZTtcblxuICBpZiAob3ApIHtcbiAgICBub2RlID0gdC5leHByZXNzaW9uU3RhdGVtZW50KHQuYXNzaWdubWVudEV4cHJlc3Npb24ob3AsIGlkLCBpbml0KSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IHQudmFyaWFibGVEZWNsYXJhdGlvbih0aGlzLmtpbmQsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KVxuICAgIF0pO1xuICB9XG5cbiAgbm9kZS5fYmxvY2tIb2lzdCA9IHRoaXMuYmxvY2tIb2lzdDtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbkRlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUuYnVpbGRWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkLCBpbml0KSB7XG4gIHZhciBkZWNsYXIgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KVxuICBdKTtcbiAgZGVjbGFyLl9ibG9ja0hvaXN0ID0gdGhpcy5ibG9ja0hvaXN0O1xuICByZXR1cm4gZGVjbGFyO1xufTtcblxuRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW0sIHBhcmVudElkKSB7XG4gIGlmICh0LmlzT2JqZWN0UGF0dGVybihlbGVtKSkge1xuICAgIHRoaXMucHVzaE9iamVjdFBhdHRlcm4oZWxlbSwgcGFyZW50SWQpO1xuICB9IGVsc2UgaWYgKHQuaXNBcnJheVBhdHRlcm4oZWxlbSkpIHtcbiAgICB0aGlzLnB1c2hBcnJheVBhdHRlcm4oZWxlbSwgcGFyZW50SWQpO1xuICB9IGVsc2UgaWYgKHQuaXNBc3NpZ25tZW50UGF0dGVybihlbGVtKSkge1xuICAgIHRoaXMucHVzaEFzc2lnbm1lbnRQYXR0ZXJuKGVsZW0sIHBhcmVudElkKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5idWlsZFZhcmlhYmxlQXNzaWdubWVudChlbGVtLCBwYXJlbnRJZCkpO1xuICB9XG59O1xuXG5EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLnB1c2hBc3NpZ25tZW50UGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBwYXJlbnRJZCkge1xuICB2YXIgdGVtcFBhcmVudElkID0gdGhpcy5zY29wZS5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKHBhcmVudElkKTtcblxuICB2YXIgZGVjbGFyID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0ZW1wUGFyZW50SWQsIHBhcmVudElkKVxuICBdKTtcbiAgZGVjbGFyLl9ibG9ja0hvaXN0ID0gdGhpcy5ibG9ja0hvaXN0O1xuICB0aGlzLm5vZGVzLnB1c2goZGVjbGFyKTtcblxuICB0aGlzLm5vZGVzLnB1c2godGhpcy5idWlsZFZhcmlhYmxlQXNzaWdubWVudChcbiAgICBwYXR0ZXJuLmxlZnQsXG4gICAgdC5jb25kaXRpb25hbEV4cHJlc3Npb24oXG4gICAgICB0LmJpbmFyeUV4cHJlc3Npb24oXCI9PT1cIiwgdGVtcFBhcmVudElkLCB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIikpLFxuICAgICAgcGF0dGVybi5yaWdodCxcbiAgICAgIHRlbXBQYXJlbnRJZFxuICAgIClcbiAgKSk7XG59O1xuXG5EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLnB1c2hPYmplY3RTcHJlYWQgPSBmdW5jdGlvbiAocGF0dGVybiwgcGFyZW50SWQsIHByb3AsIGkpIHtcbiAgLy8gZ2V0IGFsbCB0aGUga2V5cyB0aGF0IGFwcGVhciBpbiB0aGlzIG9iamVjdCBiZWZvcmUgdGhlIGN1cnJlbnQgc3ByZWFkXG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkyID0gMDsgaTIgPCBwYXR0ZXJuLnByb3BlcnRpZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgdmFyIHByb3AyID0gcGF0dGVybi5wcm9wZXJ0aWVzW2kyXTtcblxuICAgIGlmIChpMiA+PSBpKSBicmVhaztcbiAgICBpZiAodC5pc1NwcmVhZFByb3BlcnR5KHByb3AyKSkgY29udGludWU7XG5cbiAgICB2YXIga2V5ID0gcHJvcDIua2V5O1xuICAgIGlmICh0LmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICBrZXkgPSB0LmxpdGVyYWwocHJvcDIua2V5Lm5hbWUpO1xuICAgIH1cbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICBrZXlzID0gdC5hcnJheUV4cHJlc3Npb24oa2V5cyk7XG5cbiAgdmFyIHZhbHVlID0gdC5jYWxsRXhwcmVzc2lvbih0aGlzLmZpbGUuYWRkSGVscGVyKFwib2JqZWN0LXdpdGhvdXQtcHJvcGVydGllc1wiKSwgW3BhcmVudElkLCBrZXlzXSk7XG4gIHRoaXMubm9kZXMucHVzaCh0aGlzLmJ1aWxkVmFyaWFibGVBc3NpZ25tZW50KHByb3AuYXJndW1lbnQsIHZhbHVlKSk7XG59O1xuXG5EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLnB1c2hPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wLCBwYXJlbnRJZCkge1xuICBpZiAodC5pc0xpdGVyYWwocHJvcC5rZXkpKSBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcblxuICB2YXIgcGF0dGVybjIgICA9IHByb3AudmFsdWU7XG4gIHZhciBwYXR0ZXJuSWQyID0gdC5tZW1iZXJFeHByZXNzaW9uKHBhcmVudElkLCBwcm9wLmtleSwgcHJvcC5jb21wdXRlZCk7XG5cbiAgaWYgKHQuaXNQYXR0ZXJuKHBhdHRlcm4yKSkge1xuICAgIHRoaXMucHVzaChwYXR0ZXJuMiwgcGF0dGVybklkMik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYnVpbGRWYXJpYWJsZUFzc2lnbm1lbnQocGF0dGVybjIsIHBhdHRlcm5JZDIpKTtcbiAgfVxufTtcblxuRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZS5wdXNoT2JqZWN0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBwYXJlbnRJZCkge1xuICBpZiAoIXBhdHRlcm4ucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICB0aGlzLm5vZGVzLnB1c2godC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5jYWxsRXhwcmVzc2lvbih0aGlzLmZpbGUuYWRkSGVscGVyKFwib2JqZWN0LWRlc3RydWN0dXJpbmctZW1wdHlcIiksIFtwYXJlbnRJZF0pXG4gICAgKSk7XG4gIH1cblxuICBpZiAocGF0dGVybi5wcm9wZXJ0aWVzLmxlbmd0aCA+IDEgJiYgdC5pc01lbWJlckV4cHJlc3Npb24ocGFyZW50SWQpKSB7XG4gICAgdmFyIHRlbXAgPSB0aGlzLnNjb3BlLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUocGFyZW50SWQsIHRoaXMuZmlsZSk7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYnVpbGRWYXJpYWJsZURlY2xhcmF0aW9uKHRlbXAsIHBhcmVudElkKSk7XG4gICAgcGFyZW50SWQgPSB0ZW1wO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHBhdHRlcm4ucHJvcGVydGllc1tpXTtcbiAgICBpZiAodC5pc1NwcmVhZFByb3BlcnR5KHByb3ApKSB7XG4gICAgICB0aGlzLnB1c2hPYmplY3RTcHJlYWQocGF0dGVybiwgcGFyZW50SWQsIHByb3AsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hPYmplY3RQcm9wZXJ0eShwcm9wLCBwYXJlbnRJZCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGFzUmVzdCA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0LmlzUmVzdEVsZW1lbnQocGF0dGVybi5lbGVtZW50c1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLnB1c2hBcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybiwgcGFyZW50SWQpIHtcbiAgaWYgKCFwYXR0ZXJuLmVsZW1lbnRzKSByZXR1cm47XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIHJlc3QgdGhlbiB3ZSBuZWVkIGFsbCB0aGUgZWxlbWVudHNcbiAgdmFyIGNvdW50ID0gIWhhc1Jlc3QocGF0dGVybikgJiYgcGF0dGVybi5lbGVtZW50cy5sZW5ndGg7XG5cbiAgdmFyIHRvQXJyYXkgPSB0aGlzLnNjb3BlLnRvQXJyYXkocGFyZW50SWQsIGNvdW50KTtcblxuICB2YXIgX3BhcmVudElkID0gdGhpcy5zY29wZS5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKHBhcmVudElkKTtcbiAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYnVpbGRWYXJpYWJsZURlY2xhcmF0aW9uKF9wYXJlbnRJZCwgdG9BcnJheSkpO1xuICBwYXJlbnRJZCA9IF9wYXJlbnRJZDtcblxuICB0aGlzLnNjb3BlLmFzc2lnblR5cGVHZW5lcmljKHBhcmVudElkLm5hbWUsIFwiQXJyYXlcIik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZW0gPSBwYXR0ZXJuLmVsZW1lbnRzW2ldO1xuXG4gICAgLy8gaG9sZVxuICAgIGlmICghZWxlbSkgY29udGludWU7XG5cbiAgICB2YXIgbmV3UGF0dGVybklkO1xuXG4gICAgaWYgKHQuaXNSZXN0RWxlbWVudChlbGVtKSkge1xuICAgICAgbmV3UGF0dGVybklkID0gdGhpcy5zY29wZS50b0FycmF5KHBhcmVudElkKTtcblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIG5ld1BhdHRlcm5JZCA9IHQuY2FsbEV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKG5ld1BhdHRlcm5JZCwgdC5pZGVudGlmaWVyKFwic2xpY2VcIikpLCBbdC5saXRlcmFsKGkpXSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0gPSBlbGVtLmFyZ3VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXR0ZXJuSWQgPSB0Lm1lbWJlckV4cHJlc3Npb24ocGFyZW50SWQsIHQubGl0ZXJhbChpKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKGVsZW0sIG5ld1BhdHRlcm5JZCk7XG4gIH1cbn07XG5cbkRlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBwYXJlbnRJZCkge1xuICBpZiAoIXQuaXNBcnJheUV4cHJlc3Npb24ocGFyZW50SWQpICYmICF0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnRJZCkgJiYgIXQuaXNJZGVudGlmaWVyKHBhcmVudElkKSkge1xuICAgIHZhciBrZXkgPSB0aGlzLnNjb3BlLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUocGFyZW50SWQpO1xuICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJ1aWxkVmFyaWFibGVEZWNsYXJhdGlvbihrZXksIHBhcmVudElkKSk7XG4gICAgcGFyZW50SWQgPSBrZXk7XG4gIH1cblxuICB0aGlzLnB1c2gocGF0dGVybiwgcGFyZW50SWQpO1xufTtcblxuZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9XG5leHBvcnRzLkZvck9mU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG5cbiAgaWYgKHQuaXNQYXR0ZXJuKGxlZnQpKSB7XG4gICAgLy8gZm9yICh7IGxlbmd0aDogayB9IGluIHsgYWJjOiAzIH0pO1xuXG4gICAgdmFyIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG5cbiAgICBub2RlLmxlZnQgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IodGVtcClcbiAgICBdKTtcblxuICAgIHQuZW5zdXJlQmxvY2sobm9kZSk7XG5cbiAgICBub2RlLmJvZHkuYm9keS51bnNoaWZ0KHQudmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihsZWZ0LCB0ZW1wKVxuICAgIF0pKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obGVmdCkpIHJldHVybjtcblxuICB2YXIgcGF0dGVybiA9IGxlZnQuZGVjbGFyYXRpb25zWzBdLmlkO1xuICBpZiAoIXQuaXNQYXR0ZXJuKHBhdHRlcm4pKSByZXR1cm47XG5cbiAgdmFyIGtleSA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcInJlZlwiKTtcbiAgbm9kZS5sZWZ0ID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKGxlZnQua2luZCwgW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGtleSwgbnVsbClcbiAgXSk7XG5cbiAgdmFyIG5vZGVzID0gW107XG5cbiAgdmFyIGRlc3RydWN0dXJpbmcgPSBuZXcgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyKHtcbiAgICBraW5kOiBsZWZ0LmtpbmQsXG4gICAgZmlsZTogZmlsZSxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgbm9kZXM6IG5vZGVzXG4gIH0pO1xuXG4gIGRlc3RydWN0dXJpbmcuaW5pdChwYXR0ZXJuLCBrZXkpO1xuXG4gIHQuZW5zdXJlQmxvY2sobm9kZSk7XG5cbiAgdmFyIGJsb2NrID0gbm9kZS5ib2R5O1xuICBibG9jay5ib2R5ID0gbm9kZXMuY29uY2F0KGJsb2NrLmJvZHkpO1xufTtcblxuZXhwb3J0cy5GdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIHZhciBoYXNEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIgPSBmYWxzZTtcblxuICBub2RlLnBhcmFtcyA9IG5vZGUucGFyYW1zLm1hcChmdW5jdGlvbiAocGF0dGVybiwgaSkge1xuICAgIGlmICghdC5pc1BhdHRlcm4ocGF0dGVybikpIHJldHVybiBwYXR0ZXJuO1xuXG4gICAgaGFzRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyID0gdHJ1ZTtcbiAgICB2YXIgcGFyZW50SWQgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG5cbiAgICB2YXIgZGVzdHJ1Y3R1cmluZyA9IG5ldyBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIoe1xuICAgICAgYmxvY2tIb2lzdDogbm9kZS5wYXJhbXMubGVuZ3RoIC0gaSxcbiAgICAgIG5vZGVzOiAgICAgIG5vZGVzLFxuICAgICAgc2NvcGU6ICAgICAgc2NvcGUsXG4gICAgICBmaWxlOiAgICAgICBmaWxlLFxuICAgICAga2luZDogICAgICAgXCJ2YXJcIixcbiAgICB9KTtcbiAgICBkZXN0cnVjdHVyaW5nLmluaXQocGF0dGVybiwgcGFyZW50SWQpO1xuXG4gICAgcmV0dXJuIHBhcmVudElkO1xuICB9KTtcblxuICBpZiAoIWhhc0Rlc3RydWN0dXJpbmdUcmFuc2Zvcm1lcikgcmV0dXJuO1xuXG4gIHQuZW5zdXJlQmxvY2sobm9kZSk7XG5cbiAgdmFyIGJsb2NrID0gbm9kZS5ib2R5O1xuICBibG9jay5ib2R5ID0gbm9kZXMuY29uY2F0KGJsb2NrLmJvZHkpO1xufTtcblxuZXhwb3J0cy5DYXRjaENsYXVzZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBwYXR0ZXJuID0gbm9kZS5wYXJhbTtcbiAgaWYgKCF0LmlzUGF0dGVybihwYXR0ZXJuKSkgcmV0dXJuO1xuXG4gIHZhciByZWYgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG4gIG5vZGUucGFyYW0gPSByZWY7XG5cbiAgdmFyIG5vZGVzID0gW107XG5cbiAgdmFyIGRlc3RydWN0dXJpbmcgPSBuZXcgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyKHtcbiAgICBraW5kOiBcImxldFwiLFxuICAgIGZpbGU6IGZpbGUsXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIG5vZGVzOiBub2Rlc1xuICB9KTtcbiAgZGVzdHJ1Y3R1cmluZy5pbml0KHBhdHRlcm4sIHJlZik7XG5cbiAgbm9kZS5ib2R5LmJvZHkgPSBub2Rlcy5jb25jYXQobm9kZS5ib2R5LmJvZHkpO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIGV4cHIgPSBub2RlLmV4cHJlc3Npb247XG4gIGlmIChleHByLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikgcmV0dXJuO1xuICBpZiAoIXQuaXNQYXR0ZXJuKGV4cHIubGVmdCkpIHJldHVybjtcbiAgaWYgKGZpbGUuaXNDb25zZXF1ZW5jZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHJldHVybjtcblxuICB2YXIgbm9kZXMgPSBbXTtcblxuICB2YXIgcmVmID0gc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwicmVmXCIpO1xuICBub2Rlcy5wdXNoKHQudmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbXG4gICAgdC52YXJpYWJsZURlY2xhcmF0b3IocmVmLCBleHByLnJpZ2h0KVxuICBdKSk7XG5cbiAgdmFyIGRlc3RydWN0dXJpbmcgPSBuZXcgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyKHtcbiAgICBvcGVyYXRvcjogZXhwci5vcGVyYXRvcixcbiAgICBmaWxlOiBmaWxlLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICBub2Rlczogbm9kZXNcbiAgfSk7XG4gIGRlc3RydWN0dXJpbmcuaW5pdChleHByLmxlZnQsIHJlZik7XG5cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghdC5pc1BhdHRlcm4obm9kZS5sZWZ0KSkgcmV0dXJuO1xuXG4gIHZhciByZWYgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJ0ZW1wXCIpO1xuICBzY29wZS5wdXNoKHtcbiAgICBrZXk6IHJlZi5uYW1lLFxuICAgIGlkOiByZWZcbiAgfSk7XG5cbiAgdmFyIG5vZGVzID0gW107XG4gIG5vZGVzLnB1c2godC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgcmVmLCBub2RlLnJpZ2h0KSk7XG5cbiAgdmFyIGRlc3RydWN0dXJpbmcgPSBuZXcgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyKHtcbiAgICBvcGVyYXRvcjogbm9kZS5vcGVyYXRvcixcbiAgICBmaWxlOiBmaWxlLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICBub2Rlczogbm9kZXNcbiAgfSk7XG4gIGRlc3RydWN0dXJpbmcuaW5pdChub2RlLmxlZnQsIHJlZik7XG5cbiAgbm9kZXMucHVzaChyZWYpO1xuXG4gIHJldHVybiB0LnRvU2VxdWVuY2VFeHByZXNzaW9uKG5vZGVzLCBzY29wZSk7XG59O1xuXG52YXIgdmFyaWFibGVEZWNsYXJhdGlvbmhhc1BhdHRlcm4gPSBmdW5jdGlvbiAobm9kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHQuaXNQYXR0ZXJuKG5vZGUuZGVjbGFyYXRpb25zW2ldLmlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICh0LmlzRm9ySW5TdGF0ZW1lbnQocGFyZW50KSB8fCB0LmlzRm9yT2ZTdGF0ZW1lbnQocGFyZW50KSkgcmV0dXJuO1xuICBpZiAoIXZhcmlhYmxlRGVjbGFyYXRpb25oYXNQYXR0ZXJuKG5vZGUpKSByZXR1cm47XG5cbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBkZWNsYXI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuXG4gICAgdmFyIHBhdHRlcm5JZCA9IGRlY2xhci5pbml0O1xuICAgIHZhciBwYXR0ZXJuICAgPSBkZWNsYXIuaWQ7XG5cbiAgICB2YXIgZGVzdHJ1Y3R1cmluZyA9IG5ldyBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIoe1xuICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAga2luZDogIG5vZGUua2luZCxcbiAgICAgIGZpbGU6ICBmaWxlXG4gICAgfSk7XG5cbiAgICBpZiAodC5pc1BhdHRlcm4ocGF0dGVybikgJiYgcGF0dGVybklkKSB7XG4gICAgICBkZXN0cnVjdHVyaW5nLmluaXQocGF0dGVybiwgcGF0dGVybklkKTtcblxuICAgICAgaWYgKCtpICE9PSBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIHdlIGFyZW4ndCB0aGUgbGFzdCBkZWNsYXJhdG9yIHNvIGxldCdzIGp1c3QgbWFrZSB0aGVcbiAgICAgICAgLy8gbGFzdCB0cmFuc2Zvcm1lZCBub2RlIGluaGVyaXQgZnJvbSB1c1xuICAgICAgICB0LmluaGVyaXRzKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCBkZWNsYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5wdXNoKHQuaW5oZXJpdHMoZGVzdHJ1Y3R1cmluZy5idWlsZFZhcmlhYmxlQXNzaWdubWVudChkZWNsYXIuaWQsIGRlY2xhci5pbml0KSwgZGVjbGFyKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0LmlzUHJvZ3JhbShwYXJlbnQpICYmICF0LmlzQmxvY2tTdGF0ZW1lbnQocGFyZW50KSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvMTEzXG4gICAgLy8gZm9yIChsZXQgW3hdID0gWzBdOyBmYWxzZTspIHt9XG5cbiAgICBkZWNsYXIgPSBudWxsO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBkZWNsYXIgPSBkZWNsYXIgfHwgdC52YXJpYWJsZURlY2xhcmF0aW9uKG5vZGUua2luZCwgW10pO1xuXG4gICAgICBpZiAoIXQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpICYmIGRlY2xhci5raW5kICE9PSBub2RlLmtpbmQpIHtcbiAgICAgICAgdGhyb3cgZmlsZS5lcnJvcldpdGhOb2RlKG5vZGUsIG1lc3NhZ2VzLmdldChcImludmFsaWRQYXJlbnRGb3JUaGlzTm9kZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGRlY2xhci5kZWNsYXJhdGlvbnMgPSBkZWNsYXIuZGVjbGFyYXRpb25zLmNvbmNhdChub2RlLmRlY2xhcmF0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xhcjtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lc3NhZ2VzID0gcmVxdWlyZShcIi4uLy4uLy4uL21lc3NhZ2VzXCIpO1xudmFyIHV0aWwgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgdCAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSB0LmlzRm9yT2ZTdGF0ZW1lbnQ7XG5cbmV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgY2FsbGJhY2sgPSBzcGVjO1xuICBpZiAoZmlsZS5pc0xvb3NlKFwiZXM2LmZvck9mXCIpKSBjYWxsYmFjayA9IGxvb3NlO1xuXG4gIHZhciBidWlsZCAgPSBjYWxsYmFjayhub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKTtcbiAgdmFyIGRlY2xhciA9IGJ1aWxkLmRlY2xhcjtcbiAgdmFyIGxvb3AgICA9IGJ1aWxkLmxvb3A7XG4gIHZhciBibG9jayAgPSBsb29wLmJvZHk7XG5cbiAgLy8gaW5oZXJpdCBjb21tZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBsb29wXG4gIHQuaW5oZXJpdHNDb21tZW50cyhsb29wLCBub2RlKTtcblxuICAvLyBlbnN1cmUgdGhhdCBpdCdzIGEgYmxvY2sgc28gd2UgY2FuIHRha2UgYWxsIGl0cyBzdGF0ZW1lbnRzXG4gIHQuZW5zdXJlQmxvY2sobm9kZSk7XG5cbiAgLy8gYWRkIHRoZSB2YWx1ZSBkZWNsYXJhdGlvbiB0byB0aGUgbmV3IGxvb3AgYm9keVxuICBpZiAoZGVjbGFyKSB7XG4gICAgYmxvY2suYm9keS5wdXNoKGRlY2xhcik7XG4gIH1cblxuICAvLyBwdXNoIHRoZSByZXN0IG9mIHRoZSBvcmlnaW5hbCBsb29wIGJvZHkgb250byBvdXIgbmV3IGJvZHlcbiAgYmxvY2suYm9keSA9IGJsb2NrLmJvZHkuY29uY2F0KG5vZGUuYm9keS5ib2R5KTtcblxuICB0LmluaGVyaXRzKGxvb3AsIG5vZGUpO1xuXG4gIC8vIHRvZG86IGZpbmQgb3V0IHdoeSB0aGlzIGlzIG5lY2Vzc2FyeT8gIzUzOFxuICBsb29wLl9zY29wZUluZm8gPSBub2RlLl9zY29wZUluZm87XG5cbiAgcmV0dXJuIGxvb3A7XG59O1xuXG52YXIgbG9vc2UgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgdmFyIGRlY2xhciwgaWQ7XG5cbiAgaWYgKHQuaXNJZGVudGlmaWVyKGxlZnQpIHx8IHQuaXNQYXR0ZXJuKGxlZnQpKSB7XG4gICAgLy8gZm9yIChpIG9mIHRlc3QpLCBmb3IgKHsgaSB9IG9mIHRlc3QpXG4gICAgaWQgPSBsZWZ0O1xuICB9IGVsc2UgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGxlZnQpKSB7XG4gICAgLy8gZm9yICh2YXIgaSBvZiB0ZXN0KVxuICAgIGlkID0gc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwicmVmXCIpO1xuICAgIGRlY2xhciA9IHQudmFyaWFibGVEZWNsYXJhdGlvbihsZWZ0LmtpbmQsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGxlZnQuZGVjbGFyYXRpb25zWzBdLmlkLCBpZClcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBmaWxlLmVycm9yV2l0aE5vZGUobGVmdCwgbWVzc2FnZXMuZ2V0KFwidW5rbm93bkZvckhlYWRcIiwgbGVmdC50eXBlKSk7XG4gIH1cblxuICB2YXIgbG9vcCA9IHV0aWwudGVtcGxhdGUoXCJmb3Itb2YtbG9vc2VcIiwge1xuICAgIExPT1BfT0JKRUNUOiAgc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiaXRlcmF0b3JcIiksXG4gICAgSVNfQVJSQVk6ICAgICBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJpc0FycmF5XCIpLFxuICAgIE9CSkVDVDogICAgICAgbm9kZS5yaWdodCxcbiAgICBJTkRFWDogICAgICAgIHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImlcIiksXG4gICAgSUQ6ICAgICAgICAgICBpZFxuICB9KTtcblxuICBpZiAoIWRlY2xhcikge1xuICAgIC8vIG5vIGRlY2xhcmF0aW9uIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhdCB0aGUgdG9wIG9mXG4gICAgLy8gdGhlIGZvci1vZi1sb29zZSB0ZW1wbGF0ZVxuICAgIGxvb3AuYm9keS5ib2R5LnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRlY2xhcjogZGVjbGFyLFxuICAgIGxvb3A6ICAgbG9vcFxuICB9O1xufTtcblxudmFyIHNwZWMgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgdmFyIGRlY2xhcjtcblxuICB2YXIgc3RlcEtleSAgID0gc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwic3RlcFwiKTtcbiAgdmFyIHN0ZXBWYWx1ZSA9IHQubWVtYmVyRXhwcmVzc2lvbihzdGVwS2V5LCB0LmlkZW50aWZpZXIoXCJ2YWx1ZVwiKSk7XG5cbiAgaWYgKHQuaXNJZGVudGlmaWVyKGxlZnQpIHx8IHQuaXNQYXR0ZXJuKGxlZnQpKSB7XG4gICAgLy8gZm9yIChpIG9mIHRlc3QpLCBmb3IgKHsgaSB9IG9mIHRlc3QpXG4gICAgZGVjbGFyID0gdC5leHByZXNzaW9uU3RhdGVtZW50KHQuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGxlZnQsIHN0ZXBWYWx1ZSkpO1xuICB9IGVsc2UgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGxlZnQpKSB7XG4gICAgLy8gZm9yICh2YXIgaSBvZiB0ZXN0KVxuICAgIGRlY2xhciA9IHQudmFyaWFibGVEZWNsYXJhdGlvbihsZWZ0LmtpbmQsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGxlZnQuZGVjbGFyYXRpb25zWzBdLmlkLCBzdGVwVmFsdWUpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZmlsZS5lcnJvcldpdGhOb2RlKGxlZnQsIG1lc3NhZ2VzLmdldChcInVua25vd25Gb3JIZWFkXCIsIGxlZnQudHlwZSkpO1xuICB9XG5cbiAgdmFyIGxvb3AgPSB1dGlsLnRlbXBsYXRlKFwiZm9yLW9mXCIsIHtcbiAgICBJVEVSQVRPUl9LRVk6IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcIml0ZXJhdG9yXCIpLFxuICAgIFNURVBfS0VZOiAgICAgc3RlcEtleSxcbiAgICBPQkpFQ1Q6ICAgICAgIG5vZGUucmlnaHRcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZWNsYXI6IGRlY2xhcixcbiAgICBsb29wOiAgIGxvb3BcbiAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvbW9kdWxlc1wiKS5jaGVjaztcblxuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIGlmIChub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnNwZWNpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZpbGUubW9kdWxlRm9ybWF0dGVyLmltcG9ydFNwZWNpZmllcihub2RlLnNwZWNpZmllcnNbaV0sIG5vZGUsIG5vZGVzLCBwYXJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaWxlLm1vZHVsZUZvcm1hdHRlci5pbXBvcnREZWNsYXJhdGlvbihub2RlLCBub2RlcywgcGFyZW50KTtcbiAgfVxuXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBpbmhlcml0IGBfYmxvY2tIb2lzdGAgLSB0aGlzIGlzIGZvciBgX2Jsb2NrSG9pc3RgIGluIEZpbGUucHJvdG90eXBlLmFkZEltcG9ydFxuICAgIG5vZGVzWzBdLl9ibG9ja0hvaXN0ID0gbm9kZS5fYmxvY2tIb2lzdDtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG5cbmV4cG9ydHMuRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIGk7XG5cbiAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAvLyBtYWtlIHN1cmUgdmFyaWFibGUgZXhwb3J0cyBoYXZlIGFuIGluaXRpYWxpemVyXG4gICAgLy8gdGhpcyBpcyBkb25lIGhlcmUgdG8gYXZvaWQgZHVwbGljYXRpbmcgaXQgaW4gdGhlIG1vZHVsZSBmb3JtYXR0ZXJzXG4gICAgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUuZGVjbGFyYXRpb24pKSB7XG4gICAgICB2YXIgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnNbMF07XG4gICAgICBkZWNsYXIuaW5pdCA9IGRlY2xhci5pbml0IHx8IHQuaWRlbnRpZmllcihcInVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBmaWxlLm1vZHVsZUZvcm1hdHRlci5leHBvcnREZWNsYXJhdGlvbihub2RlLCBub2RlcywgcGFyZW50KTtcbiAgfSBlbHNlIGlmIChub2RlLnNwZWNpZmllcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5zcGVjaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmaWxlLm1vZHVsZUZvcm1hdHRlci5leHBvcnRTcGVjaWZpZXIobm9kZS5zcGVjaWZpZXJzW2ldLCBub2RlLCBub2RlcywgcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5fYmxvY2tIb2lzdCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZXNbaV0uX2Jsb2NrSG9pc3QgPSBub2RlLl9ibG9ja0hvaXN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlcGxhY2VTdXBlcnMgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9yZXBsYWNlLXN1cGVyc1wiKTtcbnZhciB0ICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNJZGVudGlmaWVyKG5vZGUsIHsgbmFtZTogXCJzdXBlclwiIH0pO1xufTtcblxuZXhwb3J0cy5Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghbm9kZS5tZXRob2QpIHJldHVybjtcblxuICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB2YXIgdGhpc0V4cHIgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJ0aGlzXCIpO1xuXG4gIHZhciByZXBsYWNlU3VwZXJzID0gbmV3IFJlcGxhY2VTdXBlcnMoe1xuICAgIHRvcExldmVsVGhpc1JlZmVyZW5jZTogdGhpc0V4cHIsXG4gICAgbWV0aG9kTm9kZTogICAgICAgICAgICBub2RlLFxuICAgIGNsYXNzTmFtZTogICAgICAgICAgICAgdGhpc0V4cHIsXG4gICAgaXNTdGF0aWM6ICAgICAgICAgICAgICB0cnVlLFxuICAgIHNjb3BlOiAgICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgZmlsZTogICAgICAgICAgICAgICAgICBmaWxlXG4gIH0pO1xuXG4gIHJlcGxhY2VTdXBlcnMucmVwbGFjZSgpO1xuXG4gIGlmIChyZXBsYWNlU3VwZXJzLmhhc1N1cGVyKSB7XG4gICAgdmFsdWUuYm9keS5ib2R5LnVuc2hpZnQoXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0aGlzRXhwciwgdC50aGlzRXhwcmVzc2lvbigpKVxuICAgICAgXSlcbiAgICApO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgdCAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5jaGVjayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LmlzRnVuY3Rpb24obm9kZSkgJiYgaGFzRGVmYXVsdHMobm9kZSk7XG59O1xuXG52YXIgaGFzRGVmYXVsdHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF0LmlzSWRlbnRpZmllcihub2RlLnBhcmFtc1tpXSkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpaWZlVmlzaXRvciA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBzdGF0ZSkge1xuICAgIGlmICghdC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCkpIHJldHVybjtcbiAgICBpZiAoIXN0YXRlLnNjb3BlLmhhc093bkJpbmRpbmcobm9kZS5uYW1lKSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5zY29wZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyhub2RlLm5hbWUsIG5vZGUpKSByZXR1cm47XG5cbiAgICBzdGF0ZS5paWZlID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5GdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghaGFzRGVmYXVsdHMobm9kZSkpIHJldHVybjtcblxuICB0LmVuc3VyZUJsb2NrKG5vZGUpO1xuXG4gIHZhciBib2R5ID0gW107XG5cbiAgdmFyIGFyZ3NJZGVudGlmaWVyID0gdC5pZGVudGlmaWVyKFwiYXJndW1lbnRzXCIpO1xuICBhcmdzSWRlbnRpZmllci5faWdub3JlQWxpYXNGdW5jdGlvbnMgPSB0cnVlO1xuXG4gIHZhciBsYXN0Tm9uRGVmYXVsdFBhcmFtID0gMDtcblxuICB2YXIgc3RhdGUgPSB7IGlpZmU6IGZhbHNlLCBzY29wZTogc2NvcGUgfTtcblxuICB2YXIgcHVzaERlZk5vZGUgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGkpIHtcbiAgICB2YXIgZGVmTm9kZSA9IHV0aWwudGVtcGxhdGUoXCJkZWZhdWx0LXBhcmFtZXRlclwiLCB7XG4gICAgICBWQVJJQUJMRV9OQU1FOiBsZWZ0LFxuICAgICAgREVGQVVMVF9WQUxVRTogcmlnaHQsXG4gICAgICBBUkdVTUVOVF9LRVk6ICB0LmxpdGVyYWwoaSksXG4gICAgICBBUkdVTUVOVFM6ICAgICBhcmdzSWRlbnRpZmllclxuICAgIH0sIHRydWUpO1xuICAgIGZpbGUuY2hlY2tOb2RlKGRlZk5vZGUpO1xuICAgIGRlZk5vZGUuX2Jsb2NrSG9pc3QgPSBub2RlLnBhcmFtcy5sZW5ndGggLSBpO1xuICAgIGJvZHkucHVzaChkZWZOb2RlKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcmFtID0gbm9kZS5wYXJhbXNbaV07XG5cbiAgICBpZiAoIXQuaXNBc3NpZ25tZW50UGF0dGVybihwYXJhbSkpIHtcbiAgICAgIGlmICghdC5pc1Jlc3RFbGVtZW50KHBhcmFtKSkge1xuICAgICAgICBsYXN0Tm9uRGVmYXVsdFBhcmFtID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghdC5pc0lkZW50aWZpZXIocGFyYW0pKSB7XG4gICAgICAgIHNjb3BlLnRyYXZlcnNlKHBhcmFtLCBpaWZlVmlzaXRvciwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsZS50cmFuc2Zvcm1lcnNbXCJlczYuYmxvY2tTY29waW5nVERaXCJdLmNhblJ1bigpKSB7XG4gICAgICAgIHB1c2hEZWZOb2RlKHBhcmFtLCB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIiksIGkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbGVmdCAgPSBwYXJhbS5sZWZ0O1xuICAgIHZhciByaWdodCA9IHBhcmFtLnJpZ2h0O1xuXG4gICAgdmFyIHBsYWNlaG9sZGVyID0gc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwieFwiKTtcbiAgICBwbGFjZWhvbGRlci5faXNEZWZhdWx0UGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgIG5vZGUucGFyYW1zW2ldID0gcGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoIXN0YXRlLmlpZmUpIHtcbiAgICAgIGlmICh0LmlzSWRlbnRpZmllcihyaWdodCkgJiYgc2NvcGUuaGFzT3duQmluZGluZyhyaWdodC5uYW1lKSkge1xuICAgICAgICBzdGF0ZS5paWZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlLnRyYXZlcnNlKHJpZ2h0LCBpaWZlVmlzaXRvciwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1c2hEZWZOb2RlKGxlZnQsIHJpZ2h0LCBpKTtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gY3V0IG9mZiBhbGwgdHJhaWxpbmcgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gIG5vZGUucGFyYW1zID0gbm9kZS5wYXJhbXMuc2xpY2UoMCwgbGFzdE5vbkRlZmF1bHRQYXJhbSk7XG5cbiAgaWYgKHN0YXRlLmlpZmUpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW10sIG5vZGUuYm9keSwgbm9kZS5nZW5lcmF0b3IpO1xuICAgIGNvbnRhaW5lci5fYWxpYXNGdW5jdGlvbiA9IHRydWU7XG5cbiAgICBib2R5LnB1c2godC5yZXR1cm5TdGF0ZW1lbnQodC5jYWxsRXhwcmVzc2lvbihjb250YWluZXIsIFtdKSkpO1xuXG4gICAgbm9kZS5ib2R5ID0gdC5ibG9ja1N0YXRlbWVudChib2R5KTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmJvZHkuYm9keSA9IGJvZHkuY29uY2F0KG5vZGUuYm9keS5ib2R5KTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIHQgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSB0LmlzUmVzdEVsZW1lbnQ7XG5cbnZhciBoYXNSZXN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNSZXN0RWxlbWVudChub2RlLnBhcmFtc1tub2RlLnBhcmFtcy5sZW5ndGggLSAxXSk7XG59O1xuXG5leHBvcnRzLkZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUpIHtcbiAgaWYgKCFoYXNSZXN0KG5vZGUpKSByZXR1cm47XG5cbiAgdmFyIHJlc3QgPSBub2RlLnBhcmFtcy5wb3AoKS5hcmd1bWVudDtcblxuICB2YXIgYXJnc0lkID0gdC5pZGVudGlmaWVyKFwiYXJndW1lbnRzXCIpO1xuXG4gIC8vIG90aGVyd2lzZSBgYXJndW1lbnRzYCB3aWxsIGJlIHJlbWFwcGVkIGluIGFycm93IGZ1bmN0aW9uc1xuICBhcmdzSWQuX2lnbm9yZUFsaWFzRnVuY3Rpb25zID0gdHJ1ZTtcblxuICB2YXIgc3RhcnQgPSB0LmxpdGVyYWwobm9kZS5wYXJhbXMubGVuZ3RoKTtcbiAgdmFyIGtleSA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImtleVwiKTtcbiAgdmFyIGxlbiA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImxlblwiKTtcblxuICB2YXIgYXJyS2V5ID0ga2V5O1xuICB2YXIgYXJyTGVuID0gbGVuO1xuICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgLy8gdGhpcyBtZXRob2QgaGFzIGFkZGl0aW9uYWwgcGFyYW1zLCBzbyB3ZSBuZWVkIHRvIHN1YnRyYWN0XG4gICAgLy8gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGFyZ3VtZW50IHBvc2l0aW9uIGZyb20gdGhlXG4gICAgLy8gcG9zaXRpb24gaW4gdGhlIGFycmF5IHRoYXQgd2Ugd2FudCB0byBwb3B1bGF0ZVxuICAgIGFycktleSA9IHQuYmluYXJ5RXhwcmVzc2lvbihcIi1cIiwga2V5LCBzdGFydCk7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHdvcmsgb3V0IHRoZSBzaXplIG9mIHRoZSBhcnJheSB0aGF0IHdlJ3JlXG4gICAgLy8gZ29pbmcgdG8gc3RvcmUgYWxsIHRoZSByZXN0IHBhcmFtZXRlcnNcbiAgICAvL1xuICAgIC8vIHdlIG5lZWQgdG8gYWRkIGEgY2hlY2sgdG8gYXZvaWQgY29uc3RydWN0aW5nIHRoZSBhcnJheVxuICAgIC8vIHdpdGggPDAgaWYgdGhlcmUgYXJlIGxlc3MgYXJndW1lbnRzIHRoYW4gcGFyYW1zIGFzIGl0J2xsXG4gICAgLy8gY2F1c2UgYW4gZXJyb3JcbiAgICBhcnJMZW4gPSB0LmNvbmRpdGlvbmFsRXhwcmVzc2lvbihcbiAgICAgIHQuYmluYXJ5RXhwcmVzc2lvbihcIj5cIiwgbGVuLCBzdGFydCksXG4gICAgICB0LmJpbmFyeUV4cHJlc3Npb24oXCItXCIsIGxlbiwgc3RhcnQpLFxuICAgICAgdC5saXRlcmFsKDApXG4gICAgKTtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgcGF0dGVybnNcbiAgaWYgKHQuaXNQYXR0ZXJuKHJlc3QpKSB7XG4gICAgdmFyIHBhdHRlcm4gPSByZXN0O1xuICAgIHJlc3QgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG5cbiAgICAvLyBsZXQgdGhlIGRlc3RydWN0dXJpbmcgdHJhbnNmb3JtZXIgaGFuZGxlIHRoaXNcbiAgICB2YXIgcmVzdERlY2xhciA9IHQudmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihwYXR0ZXJuLCByZXN0KVxuICAgIF0pO1xuXG4gICAgLy8gcmV0YWluIGV2YWx1YXRpb24gcG9zaXRpb25cbiAgICByZXN0RGVjbGFyLl9ibG9ja0hvaXN0ID0gbm9kZS5wYXJhbXMubGVuZ3RoICsgMTtcblxuICAgIG5vZGUuYm9keS5ib2R5LnVuc2hpZnQocmVzdERlY2xhcik7XG4gIH1cblxuICBzY29wZS5hc3NpZ25UeXBlR2VuZXJpYyhyZXN0Lm5hbWUsIFwiQXJyYXlcIik7XG5cbiAgdmFyIGxvb3AgPSB1dGlsLnRlbXBsYXRlKFwicmVzdFwiLCB7XG4gICAgQVJHVU1FTlRTOiBhcmdzSWQsXG4gICAgQVJSQVlfS0VZOiBhcnJLZXksXG4gICAgQVJSQVlfTEVOOiBhcnJMZW4sXG4gICAgU1RBUlQ6IHN0YXJ0LFxuICAgIEFSUkFZOiByZXN0LFxuICAgIEtFWToga2V5LFxuICAgIExFTjogbGVuLFxuICB9KTtcbiAgbG9vcC5fYmxvY2tIb2lzdCA9IG5vZGUucGFyYW1zLmxlbmd0aCArIDE7XG4gIG5vZGUuYm9keS5ib2R5LnVuc2hpZnQobG9vcCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNQcm9wZXJ0eShub2RlKSAmJiBub2RlLmNvbXB1dGVkO1xufTtcblxuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIGhhc0NvbXB1dGVkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoYXNDb21wdXRlZCA9IHQuaXNQcm9wZXJ0eShub2RlLnByb3BlcnRpZXNbaV0sIHsgY29tcHV0ZWQ6IHRydWUsIGtpbmQ6IFwiaW5pdFwiIH0pO1xuICAgIGlmIChoYXNDb21wdXRlZCkgYnJlYWs7XG4gIH1cblxuICBpZiAoIWhhc0NvbXB1dGVkKSByZXR1cm47XG5cbiAgdmFyIGluaXRQcm9wcyA9IFtdO1xuICB2YXIgb2JqSWQgPSBzY29wZS5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKHBhcmVudCk7XG5cbiAgLy9cblxuICB2YXIgYm9keSA9IFtdO1xuICB2YXIgY29udGFpbmVyID0gdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW10sIHQuYmxvY2tTdGF0ZW1lbnQoYm9keSkpO1xuICBjb250YWluZXIuX2FsaWFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gIC8vXG5cbiAgdmFyIGNhbGxiYWNrID0gc3BlYztcbiAgaWYgKGZpbGUuaXNMb29zZShcImVzNi5wcm9wZXJ0aWVzLmNvbXB1dGVkXCIpKSBjYWxsYmFjayA9IGxvb3NlO1xuXG4gIHZhciByZXN1bHQgPSBjYWxsYmFjayhub2RlLCBib2R5LCBvYmpJZCwgaW5pdFByb3BzLCBmaWxlKTtcbiAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuICAvL1xuXG4gIGJvZHkudW5zaGlmdCh0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKG9iaklkLCB0Lm9iamVjdEV4cHJlc3Npb24oaW5pdFByb3BzKSlcbiAgXSkpO1xuXG4gIGJvZHkucHVzaCh0LnJldHVyblN0YXRlbWVudChvYmpJZCkpO1xuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGNvbnRhaW5lciwgW10pO1xufTtcblxudmFyIGxvb3NlID0gZnVuY3Rpb24gKG5vZGUsIGJvZHksIG9iaklkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG5cbiAgICBib2R5LnB1c2godC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgXCI9XCIsXG4gICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihvYmpJZCwgcHJvcC5rZXksIHByb3AuY29tcHV0ZWQgfHwgdC5pc0xpdGVyYWwocHJvcC5rZXkpKSxcbiAgICAgICAgcHJvcC52YWx1ZVxuICAgICAgKVxuICAgICkpO1xuICB9XG59O1xuXG52YXIgc3BlYyA9IGZ1bmN0aW9uIChub2RlLCBib2R5LCBvYmpJZCwgaW5pdFByb3BzLCBmaWxlKSB7XG4gIHZhciBwcm9wcyA9IG5vZGUucHJvcGVydGllcztcbiAgdmFyIHByb3AsIGtleTtcblxuICAvLyBub3JtYWxpemUga2V5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICBpZiAocHJvcC5raW5kICE9PSBcImluaXRcIikgY29udGludWU7XG5cbiAgICBrZXkgPSBwcm9wLmtleTtcblxuICAgIGlmICghcHJvcC5jb21wdXRlZCAmJiB0LmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICBwcm9wLmtleSA9IHQubGl0ZXJhbChrZXkubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGFsbCBub24tY29tcHV0ZWQgcHJvcGVydGllcyBhbmQgYF9fcHJvdG9fX2AgcHJvcGVydGllcyB0byB0aGUgaW5pdGlhbGl6ZXJcblxuICB2YXIgYnJva2VuID0gZmFsc2U7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgaWYgKHByb3AuY29tcHV0ZWQpIHtcbiAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3Aua2luZCAhPT0gXCJpbml0XCIgfHwgIWJyb2tlbiB8fCB0LmlzTGl0ZXJhbCh0LnRvQ29tcHV0ZWRLZXkocHJvcCwgcHJvcC5rZXkpLCB7IHZhbHVlOiBcIl9fcHJvdG9fX1wiIH0pKSB7XG4gICAgICBpbml0UHJvcHMucHVzaChwcm9wKTtcbiAgICAgIHByb3BzW2ldID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgYSBzaW1wbGUgYXNzaWdubWVudCBmb3IgYWxsIFN5bWJvbCBtZW1iZXIgZXhwcmVzc2lvbnMgZHVlIHRvIHN5bWJvbCBwb2x5ZmlsbCBsaW1pdGF0aW9uc1xuICAvLyBvdGhlcndpc2UgdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICBpZiAoIXByb3ApIGNvbnRpbnVlO1xuXG4gICAga2V5ID0gcHJvcC5rZXk7XG4gICAgdmFyIGJvZHlOb2RlO1xuXG4gICAgaWYgKHByb3AuY29tcHV0ZWQgJiYgdC5pc01lbWJlckV4cHJlc3Npb24oa2V5KSAmJiB0LmlzSWRlbnRpZmllcihrZXkub2JqZWN0LCB7IG5hbWU6IFwiU3ltYm9sXCIgfSkpIHtcbiAgICAgIC8vIHsgW1N5bWJvbC5pdGVyYXRvcl06IFwiZm9vXCIgfVxuICAgICAgYm9keU5vZGUgPSB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICBcIj1cIixcbiAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKG9iaklkLCBrZXksIHRydWUpLFxuICAgICAgICBwcm9wLnZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5Tm9kZSA9IHQuY2FsbEV4cHJlc3Npb24oZmlsZS5hZGRIZWxwZXIoXCJkZWZpbmUtcHJvcGVydHlcIiksIFtvYmpJZCwga2V5LCBwcm9wLnZhbHVlXSk7XG4gICAgfVxuXG4gICAgYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudChib2R5Tm9kZSkpO1xuICB9XG5cbiAgLy8gb25seSBvbmUgbm9kZSBhbmQgaXQncyBhIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IHJldHVybnMgdGhlIG9iamVjdFxuXG4gIGlmIChib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBmaXJzdCA9IGJvZHlbMF0uZXhwcmVzc2lvbjtcblxuICAgIGlmICh0LmlzQ2FsbEV4cHJlc3Npb24oZmlyc3QpKSB7XG4gICAgICBmaXJzdC5hcmd1bWVudHNbMF0gPSB0Lm9iamVjdEV4cHJlc3Npb24oaW5pdFByb3BzKTtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG5hbWVNZXRob2QgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9uYW1lLW1ldGhvZFwiKTtcbnZhciB0ICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xudmFyIGNsb25lICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvY2xvbmVcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5pc1Byb3BlcnR5KG5vZGUpICYmIChub2RlLm1ldGhvZCB8fCBub2RlLnNob3J0aGFuZCk7XG59O1xuXG5leHBvcnRzLlByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgaWYgKG5vZGUubWV0aG9kKSB7XG4gICAgbm9kZS5tZXRob2QgPSBmYWxzZTtcbiAgICBuYW1lTWV0aG9kLnByb3BlcnR5KG5vZGUsIGZpbGUsIHNjb3BlKTtcbiAgfVxuXG4gIGlmIChub2RlLnNob3J0aGFuZCkge1xuICAgIG5vZGUuc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgbm9kZS5rZXkgPSB0LnJlbW92ZUNvbW1lbnRzKGNsb25lKG5vZGUua2V5KSk7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGluY2x1ZGVzID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2luY2x1ZGVzXCIpO1xudmFyIHQgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLmNoZWNrID0gdC5pc1NwcmVhZEVsZW1lbnQ7XG5cbnZhciBnZXRTcHJlYWRMaXRlcmFsID0gZnVuY3Rpb24gKHNwcmVhZCwgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLnRvQXJyYXkoc3ByZWFkLmFyZ3VtZW50LCB0cnVlKTtcbn07XG5cbnZhciBoYXNTcHJlYWQgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0LmlzU3ByZWFkRWxlbWVudChub2Rlc1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgYnVpbGQgPSBmdW5jdGlvbiAocHJvcHMsIHNjb3BlKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuXG4gIHZhciBfcHJvcHMgPSBbXTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9wcm9wcy5sZW5ndGgpIHJldHVybjtcbiAgICBub2Rlcy5wdXNoKHQuYXJyYXlFeHByZXNzaW9uKF9wcm9wcykpO1xuICAgIF9wcm9wcyA9IFtdO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIGlmICh0LmlzU3ByZWFkRWxlbWVudChwcm9wKSkge1xuICAgICAgcHVzaCgpO1xuICAgICAgbm9kZXMucHVzaChnZXRTcHJlYWRMaXRlcmFsKHByb3AsIHNjb3BlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wcm9wcy5wdXNoKHByb3ApO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goKTtcblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG5leHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gIHZhciBlbGVtZW50cyA9IG5vZGUuZWxlbWVudHM7XG4gIGlmICghaGFzU3ByZWFkKGVsZW1lbnRzKSkgcmV0dXJuO1xuXG4gIHZhciBub2RlcyA9IGJ1aWxkKGVsZW1lbnRzLCBzY29wZSk7XG4gIHZhciBmaXJzdCA9IG5vZGVzLnNoaWZ0KCk7XG5cbiAgaWYgKCF0LmlzQXJyYXlFeHByZXNzaW9uKGZpcnN0KSkge1xuICAgIG5vZGVzLnVuc2hpZnQoZmlyc3QpO1xuICAgIGZpcnN0ID0gdC5hcnJheUV4cHJlc3Npb24oW10pO1xuICB9XG5cbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKGZpcnN0LCB0LmlkZW50aWZpZXIoXCJjb25jYXRcIikpLCBub2Rlcyk7XG59O1xuXG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUpIHtcbiAgdmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cztcbiAgaWYgKCFoYXNTcHJlYWQoYXJncykpIHJldHVybjtcblxuICB2YXIgY29udGV4dExpdGVyYWwgPSB0LmlkZW50aWZpZXIoXCJ1bmRlZmluZWRcIik7XG5cbiAgbm9kZS5hcmd1bWVudHMgPSBbXTtcblxuICB2YXIgbm9kZXM7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdLmFyZ3VtZW50Lm5hbWUgPT09IFwiYXJndW1lbnRzXCIpIHtcbiAgICBub2RlcyA9IFthcmdzWzBdLmFyZ3VtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IGJ1aWxkKGFyZ3MsIHNjb3BlKTtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IG5vZGVzLnNoaWZ0KCk7XG4gIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICBub2RlLmFyZ3VtZW50cy5wdXNoKHQuY2FsbEV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKGZpcnN0LCB0LmlkZW50aWZpZXIoXCJjb25jYXRcIikpLCBub2RlcykpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXJndW1lbnRzLnB1c2goZmlyc3QpO1xuICB9XG5cbiAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuXG4gIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihjYWxsZWUpKSB7XG4gICAgdmFyIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVRlbXBCYXNlZE9uTm9kZShjYWxsZWUub2JqZWN0KTtcbiAgICBpZiAodGVtcCkge1xuICAgICAgY2FsbGVlLm9iamVjdCA9IHQuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIHRlbXAsIGNhbGxlZS5vYmplY3QpO1xuICAgICAgY29udGV4dExpdGVyYWwgPSB0ZW1wO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0TGl0ZXJhbCA9IGNhbGxlZS5vYmplY3Q7XG4gICAgfVxuICAgIHQuYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uKGNhbGxlZSwgdC5pZGVudGlmaWVyKFwiYXBwbHlcIikpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuY2FsbGVlID0gdC5tZW1iZXJFeHByZXNzaW9uKG5vZGUuY2FsbGVlLCB0LmlkZW50aWZpZXIoXCJhcHBseVwiKSk7XG4gIH1cblxuICBub2RlLmFyZ3VtZW50cy51bnNoaWZ0KGNvbnRleHRMaXRlcmFsKTtcbn07XG5cbmV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHM7XG4gIGlmICghaGFzU3ByZWFkKGFyZ3MpKSByZXR1cm47XG5cbiAgdmFyIG5hdGl2ZVR5cGUgPSB0LmlzSWRlbnRpZmllcihub2RlLmNhbGxlZSkgJiYgaW5jbHVkZXModC5OQVRJVkVfVFlQRV9OQU1FUywgbm9kZS5jYWxsZWUubmFtZSk7XG5cbiAgdmFyIG5vZGVzID0gYnVpbGQoYXJncywgc2NvcGUpO1xuXG4gIGlmIChuYXRpdmVUeXBlKSB7XG4gICAgbm9kZXMudW5zaGlmdCh0LmFycmF5RXhwcmVzc2lvbihbdC5saXRlcmFsKG51bGwpXSkpO1xuICB9XG5cbiAgdmFyIGZpcnN0ID0gbm9kZXMuc2hpZnQoKTtcblxuICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgYXJncyA9IHQuY2FsbEV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKGZpcnN0LCB0LmlkZW50aWZpZXIoXCJjb25jYXRcIikpLCBub2Rlcyk7XG4gIH0gZWxzZSB7XG4gICAgYXJncyA9IGZpcnN0O1xuICB9XG5cbiAgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICByZXR1cm4gdC5uZXdFeHByZXNzaW9uKFxuICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwiYmluZFwiKSwgdC5pZGVudGlmaWVyKFwiYXBwbHlcIikpLFxuICAgICAgICBbbm9kZS5jYWxsZWUsIGFyZ3NdXG4gICAgICApLFxuICAgICAgW11cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwiYXBwbHktY29uc3RydWN0b3JcIiksIFtub2RlLmNhbGxlZSwgYXJnc10pO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWR1Y2VSaWdodCA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9yZWR1Y2VSaWdodFwiKTtcbnZhciBtZXNzYWdlcyAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZXNzYWdlc1wiKTtcbnZhciBmbGF0dGVuICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvYXJyYXkvZmxhdHRlblwiKTtcbnZhciB1dGlsICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIG1hcCAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL21hcFwiKTtcbnZhciB0ICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gcmV0dXJuQmxvY2soZXhwcikge1xuICByZXR1cm4gdC5ibG9ja1N0YXRlbWVudChbdC5yZXR1cm5TdGF0ZW1lbnQoZXhwcildKTtcbn1cblxuZnVuY3Rpb24gVGFpbENhbGxUcmFuc2Zvcm1lcihub2RlLCBzY29wZSwgZmlsZSkge1xuICB0aGlzLmhhc1RhaWxSZWN1cnNpb24gPSBmYWxzZTtcbiAgdGhpcy5uZWVkc0FyZ3VtZW50cyAgID0gZmFsc2U7XG4gIHRoaXMuc2V0c0FyZ3VtZW50cyAgICA9IGZhbHNlO1xuICB0aGlzLm5lZWRzVGhpcyAgICAgICAgPSBmYWxzZTtcbiAgdGhpcy5vd25lcklkICAgICAgICAgID0gbm9kZS5pZDtcbiAgdGhpcy52YXJzICAgICAgICAgICAgID0gW107XG5cbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmZpbGUgID0gZmlsZTtcbiAgdGhpcy5ub2RlICA9IG5vZGU7XG59XG5cblRhaWxDYWxsVHJhbnNmb3JtZXIucHJvdG90eXBlLmdldEFyZ3VtZW50c0lkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hcmd1bWVudHNJZCA9IHRoaXMuYXJndW1lbnRzSWQgfHwgdGhpcy5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJhcmd1bWVudHNcIik7XG59O1xuXG5UYWlsQ2FsbFRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRUaGlzSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRoaXNJZCA9IHRoaXMudGhpc0lkIHx8IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwidGhpc1wiKTtcbn07XG5cblRhaWxDYWxsVHJhbnNmb3JtZXIucHJvdG90eXBlLmdldExlZnRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVmdElkID0gdGhpcy5sZWZ0SWQgfHwgdGhpcy5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJsZWZ0XCIpO1xufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0RnVuY3Rpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZnVuY3Rpb25JZCA9IHRoaXMuZnVuY3Rpb25JZCB8fCB0aGlzLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImZ1bmN0aW9uXCIpO1xufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG5cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSB0aGlzLm5vZGUucGFyYW1zO1xuICAgIHRoaXMucGFyYW1EZWNscyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgIGlmICghcGFyYW0uX2lzRGVmYXVsdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMucGFyYW1EZWNscy5wdXNoKHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgIHBhcmFtc1tpXSA9IHRoaXMuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwieFwiKVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG59O1xuXG5UYWlsQ2FsbFRyYW5zZm9ybWVyLnByb3RvdHlwZS5oYXNEZW9wdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIG93bmVySWQgaGFzIGJlZW4gcmVhc3NpZ25lZCwgaWYgaXQgaGFzIHRoZW4gaXQncyBub3Qgc2FmZSB0b1xuICAvLyBwZXJmb3JtIG9wdGltaXNhdGlvbnNcbiAgdmFyIG93bmVySWRJbmZvID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nSW5mbyh0aGlzLm93bmVySWQubmFtZSk7XG4gIHJldHVybiBvd25lcklkSW5mbyAmJiBvd25lcklkSW5mby5yZWFzc2lnbmVkO1xufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICB2YXIgbm9kZSAgPSB0aGlzLm5vZGU7XG5cbiAgLy8gb25seSB0YWlsIHJlY3Vyc2lvbiBjYW4gYmUgb3B0aW1pemVkIGFzIGZvciBub3csIHNvIHdlIGNhbiBza2lwIGFub255bW91c1xuICAvLyBmdW5jdGlvbnMgZW50aXJlbHlcbiAgdmFyIG93bmVySWQgPSB0aGlzLm93bmVySWQ7XG4gIGlmICghb3duZXJJZCkgcmV0dXJuO1xuXG4gIC8vIHRyYXZlcnNlIHRoZSBmdW5jdGlvbiBhbmQgbG9vayBmb3IgdGFpbCByZWN1cnNpb25cbiAgc2NvcGUudHJhdmVyc2Uobm9kZSwgZmlyc3RQYXNzLCB0aGlzKTtcblxuICBpZiAoIXRoaXMuaGFzVGFpbFJlY3Vyc2lvbikgcmV0dXJuO1xuXG4gIGlmICh0aGlzLmhhc0Rlb3B0KCkpIHtcbiAgICB0aGlzLmZpbGUubG9nRGVvcHQobm9kZSwgbWVzc2FnZXMuZ2V0KFwidGFpbENhbGxSZWFzc2lnbm1lbnREZW9wdFwiKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy9cblxuICBzY29wZS50cmF2ZXJzZShub2RlLCBzZWNvbmRQYXNzLCB0aGlzKTtcblxuICBpZiAoIXRoaXMubmVlZHNUaGlzIHx8ICF0aGlzLm5lZWRzQXJndW1lbnRzKSB7XG4gICAgc2NvcGUudHJhdmVyc2Uobm9kZSwgdGhpcmRQYXNzLCB0aGlzKTtcbiAgfVxuXG4gIHZhciBib2R5ID0gdC5lbnN1cmVCbG9jayhub2RlKS5ib2R5O1xuXG4gIGlmICh0aGlzLnZhcnMubGVuZ3RoID4gMCkge1xuICAgIHZhciBkZWNsYXJhdGlvbnMgPSBmbGF0dGVuKG1hcCh0aGlzLnZhcnMsIGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICByZXR1cm4gZGVjbC5kZWNsYXJhdGlvbnM7XG4gICAgfSwgdGhpcykpO1xuICAgIHZhciBzdGF0ZW1lbnQgPSByZWR1Y2VSaWdodChkZWNsYXJhdGlvbnMsIGZ1bmN0aW9uIChleHByLCBkZWNsKSB7XG4gICAgICByZXR1cm4gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbC5pZCwgZXhwcik7XG4gICAgfSwgdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpKTtcbiAgICBib2R5LnVuc2hpZnQodC5leHByZXNzaW9uU3RhdGVtZW50KHN0YXRlbWVudCkpO1xuICB9XG5cbiAgdmFyIHBhcmFtRGVjbHMgPSB0aGlzLnBhcmFtRGVjbHM7XG4gIGlmIChwYXJhbURlY2xzLmxlbmd0aCA+IDApIHtcbiAgICBib2R5LnVuc2hpZnQodC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIHBhcmFtRGVjbHMpKTtcbiAgfVxuXG4gIG5vZGUuYm9keSA9IHV0aWwudGVtcGxhdGUoXCJ0YWlsLWNhbGwtYm9keVwiLCB7XG4gICAgVEhJU19JRDogICAgICAgdGhpcy50aGlzSWQsXG4gICAgQVJHVU1FTlRTX0lEOiAgdGhpcy5hcmd1bWVudHNJZCxcbiAgICBGVU5DVElPTl9JRDogICB0aGlzLmdldEZ1bmN0aW9uSWQoKSxcbiAgICBCTE9DSzogICAgICAgICBub2RlLmJvZHlcbiAgfSk7XG5cbiAgdmFyIHRvcFZhcnMgPSBbXTtcblxuICBpZiAodGhpcy5uZWVkc1RoaXMpIHtcbiAgICB0b3BWYXJzLnB1c2godC52YXJpYWJsZURlY2xhcmF0b3IodGhpcy5nZXRUaGlzSWQoKSwgdC50aGlzRXhwcmVzc2lvbigpKSk7XG4gIH1cblxuICBpZiAodGhpcy5uZWVkc0FyZ3VtZW50cyB8fCB0aGlzLnNldHNBcmd1bWVudHMpIHtcbiAgICB2YXIgZGVjbCA9IHQudmFyaWFibGVEZWNsYXJhdG9yKHRoaXMuZ2V0QXJndW1lbnRzSWQoKSk7XG4gICAgaWYgKHRoaXMubmVlZHNBcmd1bWVudHMpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHQuaWRlbnRpZmllcihcImFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgdG9wVmFycy5wdXNoKGRlY2wpO1xuICB9XG5cbiAgdmFyIGxlZnRJZCA9IHRoaXMubGVmdElkO1xuICBpZiAobGVmdElkKSB7XG4gICAgdG9wVmFycy5wdXNoKHQudmFyaWFibGVEZWNsYXJhdG9yKGxlZnRJZCkpO1xuICB9XG5cbiAgaWYgKHRvcFZhcnMubGVuZ3RoID4gMCkge1xuICAgIG5vZGUuYm9keS5ib2R5LnVuc2hpZnQodC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIHRvcFZhcnMpKTtcbiAgfVxufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUuc3ViVHJhbnNmb3JtID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgdmFyIGhhbmRsZXIgPSB0aGlzW1wic3ViVHJhbnNmb3JtXCIgKyBub2RlLnR5cGVdO1xuICBpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCBub2RlKTtcbn07XG5cblRhaWxDYWxsVHJhbnNmb3JtZXIucHJvdG90eXBlLnN1YlRyYW5zZm9ybUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjYWxsQ29uc2VxdWVudCA9IHRoaXMuc3ViVHJhbnNmb3JtKG5vZGUuY29uc2VxdWVudCk7XG4gIHZhciBjYWxsQWx0ZXJuYXRlID0gdGhpcy5zdWJUcmFuc2Zvcm0obm9kZS5hbHRlcm5hdGUpO1xuICBpZiAoIWNhbGxDb25zZXF1ZW50ICYmICFjYWxsQWx0ZXJuYXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgdGVybmFyeSBvcGVyYXRvciBoYWQgdGFpbCByZWN1cnNpb24gaW4gdmFsdWUsIGNvbnZlcnQgdG8gb3B0aW1pemVkIGlmLXN0YXRlbWVudFxuICBub2RlLnR5cGUgPSBcIklmU3RhdGVtZW50XCI7XG4gIG5vZGUuY29uc2VxdWVudCA9IGNhbGxDb25zZXF1ZW50ID8gdC50b0Jsb2NrKGNhbGxDb25zZXF1ZW50KSA6IHJldHVybkJsb2NrKG5vZGUuY29uc2VxdWVudCk7XG5cbiAgaWYgKGNhbGxBbHRlcm5hdGUpIHtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHQuaXNJZlN0YXRlbWVudChjYWxsQWx0ZXJuYXRlKSA/IGNhbGxBbHRlcm5hdGUgOiB0LnRvQmxvY2soY2FsbEFsdGVybmF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSByZXR1cm5CbG9jayhub2RlLmFsdGVybmF0ZSk7XG4gIH1cblxuICByZXR1cm4gW25vZGVdO1xufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUuc3ViVHJhbnNmb3JtTG9naWNhbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBvbmx5IGNhbGwgaW4gcmlnaHQtdmFsdWUgb2YgY2FuIGJlIG9wdGltaXplZFxuICB2YXIgY2FsbFJpZ2h0ID0gdGhpcy5zdWJUcmFuc2Zvcm0obm9kZS5yaWdodCk7XG4gIGlmICghY2FsbFJpZ2h0KSByZXR1cm47XG5cbiAgLy8gY2FjaGUgbGVmdCB2YWx1ZSBhcyBpdCBtaWdodCBoYXZlIHNpZGUtZWZmZWN0c1xuICB2YXIgbGVmdElkID0gdGhpcy5nZXRMZWZ0SWQoKTtcbiAgdmFyIHRlc3RFeHByID0gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICBcIj1cIixcbiAgICBsZWZ0SWQsXG4gICAgbm9kZS5sZWZ0XG4gICk7XG5cbiAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiJiZcIikge1xuICAgIHRlc3RFeHByID0gdC51bmFyeUV4cHJlc3Npb24oXCIhXCIsIHRlc3RFeHByKTtcbiAgfVxuXG4gIHJldHVybiBbdC5pZlN0YXRlbWVudCh0ZXN0RXhwciwgcmV0dXJuQmxvY2sobGVmdElkKSldLmNvbmNhdChjYWxsUmlnaHQpO1xufTtcblxuVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUuc3ViVHJhbnNmb3JtU2VxdWVuY2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHNlcSA9IG5vZGUuZXhwcmVzc2lvbnM7XG5cbiAgLy8gb25seSBsYXN0IGVsZW1lbnQgY2FuIGJlIG9wdGltaXplZFxuICB2YXIgbGFzdENhbGwgPSB0aGlzLnN1YlRyYW5zZm9ybShzZXFbc2VxLmxlbmd0aCAtIDFdKTtcbiAgaWYgKCFsYXN0Q2FsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHJlbW92ZSBjb252ZXJ0ZWQgZXhwcmVzc2lvbiBmcm9tIHNlcXVlbmNlXG4gIC8vIGFuZCBjb252ZXJ0IHRvIHJlZ3VsYXIgZXhwcmVzc2lvbiBpZiBuZWVkZWRcbiAgaWYgKC0tc2VxLmxlbmd0aCA9PT0gMSkge1xuICAgIG5vZGUgPSBzZXFbMF07XG4gIH1cblxuICByZXR1cm4gW3QuZXhwcmVzc2lvblN0YXRlbWVudChub2RlKV0uY29uY2F0KGxhc3RDYWxsKTtcbn07XG5cblRhaWxDYWxsVHJhbnNmb3JtZXIucHJvdG90eXBlLnN1YlRyYW5zZm9ybUNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlLCB0aGlzQmluZGluZywgYXJncztcblxuICBpZiAodC5pc01lbWJlckV4cHJlc3Npb24oY2FsbGVlLCB7IGNvbXB1dGVkOiBmYWxzZSB9KSAmJiB0LmlzSWRlbnRpZmllcihjYWxsZWUucHJvcGVydHkpKSB7XG4gICAgc3dpdGNoIChjYWxsZWUucHJvcGVydHkubmFtZSkge1xuICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgYXJncyA9IHQuYXJyYXlFeHByZXNzaW9uKG5vZGUuYXJndW1lbnRzLnNsaWNlKDEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJhcHBseVwiOlxuICAgICAgICBhcmdzID0gbm9kZS5hcmd1bWVudHNbMV0gfHwgdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNCaW5kaW5nID0gbm9kZS5hcmd1bWVudHNbMF07XG4gICAgY2FsbGVlID0gY2FsbGVlLm9iamVjdDtcbiAgfVxuXG4gIC8vIG9ubHkgdGFpbCByZWN1cnNpb24gY2FuIGJlIG9wdGltaXplZCBhcyBmb3Igbm93XG4gIGlmICghdC5pc0lkZW50aWZpZXIoY2FsbGVlKSB8fCAhdGhpcy5zY29wZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyhjYWxsZWUubmFtZSwgdGhpcy5vd25lcklkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuaGFzVGFpbFJlY3Vyc2lvbiA9IHRydWU7XG5cbiAgaWYgKHRoaXMuaGFzRGVvcHQoKSkgcmV0dXJuO1xuXG4gIHZhciBib2R5ID0gW107XG5cbiAgaWYgKCF0LmlzVGhpc0V4cHJlc3Npb24odGhpc0JpbmRpbmcpKSB7XG4gICAgYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgXCI9XCIsXG4gICAgICB0aGlzLmdldFRoaXNJZCgpLFxuICAgICAgdGhpc0JpbmRpbmcgfHwgdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpXG4gICAgKSkpO1xuICB9XG5cbiAgaWYgKCFhcmdzKSB7XG4gICAgYXJncyA9IHQuYXJyYXlFeHByZXNzaW9uKG5vZGUuYXJndW1lbnRzKTtcbiAgfVxuXG4gIHZhciBhcmd1bWVudHNJZCA9IHRoaXMuZ2V0QXJndW1lbnRzSWQoKTtcbiAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0UGFyYW1zKCk7XG5cbiAgYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgIFwiPVwiLFxuICAgIGFyZ3VtZW50c0lkLFxuICAgIGFyZ3NcbiAgKSkpO1xuXG4gIHZhciBpLCBwYXJhbTtcblxuICBpZiAodC5pc0FycmF5RXhwcmVzc2lvbihhcmdzKSkge1xuICAgIHZhciBlbGVtcyA9IGFyZ3MuZWxlbWVudHM7XG4gICAgZm9yIChpID0gMDsgaSA8IGVsZW1zLmxlbmd0aCAmJiBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgIHZhciBlbGVtID0gZWxlbXNbaV0gfHwgKGVsZW1zW2ldID0gdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpKTtcbiAgICAgIGlmICghcGFyYW0uX2lzRGVmYXVsdFBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGVsZW1zW2ldID0gdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgcGFyYW0sIGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldHNBcmd1bWVudHMgPSB0cnVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgaWYgKCFwYXJhbS5faXNEZWZhdWx0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgYm9keS5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICAgIFwiPVwiLFxuICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihhcmd1bWVudHNJZCwgdC5saXRlcmFsKGkpLCB0cnVlKVxuICAgICAgICApKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYm9keS5wdXNoKHQuY29udGludWVTdGF0ZW1lbnQodGhpcy5nZXRGdW5jdGlvbklkKCkpKTtcblxuICByZXR1cm4gYm9keTtcbn07XG5cbi8vIGxvb2tzIGZvciBhbmQgcmVwbGFjZXMgdGFpbCByZWN1cnNpb24gY2FsbHNcbnZhciBmaXJzdFBhc3MgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAodC5pc0lmU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodC5pc1JldHVyblN0YXRlbWVudChub2RlLmFsdGVybmF0ZSkpIHtcbiAgICAgICAgdC5lbnN1cmVCbG9jayhub2RlLCBcImFsdGVybmF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQuaXNSZXR1cm5TdGF0ZW1lbnQobm9kZS5jb25zZXF1ZW50KSkge1xuICAgICAgICB0LmVuc3VyZUJsb2NrKG5vZGUsIFwiY29uc2VxdWVudFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHQuaXNSZXR1cm5TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgcmV0dXJuIHN0YXRlLnN1YlRyYW5zZm9ybShub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKHQuaXNUcnlTdGF0ZW1lbnQocGFyZW50KSkge1xuICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5ibG9jaykge1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmZpbmFsaXplciAmJiBub2RlICE9PSBwYXJlbnQuZmluYWxpemVyKSB7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSB7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICAgIHN0YXRlLnZhcnMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGhvaXN0cyB1cCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMsIHJlcGxhY2VzIGB0aGlzYCBhbmQgYGFyZ3VtZW50c2AgYW5kIG1hcmtzXG4vLyB0aGVtIGFzIG5lZWRlZFxudmFyIHNlY29uZFBhc3MgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAodC5pc1RoaXNFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICBzdGF0ZS5uZWVkc1RoaXMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0YXRlLmdldFRoaXNJZCgpO1xuICAgIH0gZWxzZSBpZiAodC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCwgeyBuYW1lOiBcImFyZ3VtZW50c1wiIH0pKSB7XG4gICAgICBzdGF0ZS5uZWVkc0FyZ3VtZW50cyA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdGUuZ2V0QXJndW1lbnRzSWQoKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgICBpZiAodC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IHQudmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbXG4gICAgICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3Iobm9kZS5pZCwgdC50b0V4cHJlc3Npb24obm9kZSkpXG4gICAgICAgIF0pO1xuICAgICAgICBub2RlLl9ibG9ja0hvaXN0ID0gMjtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBvcHRpbWl6ZXMgcmVjdXJzaW9uIGJ5IHJlbW92aW5nIGB0aGlzYCBhbmQgYGFyZ3VtZW50c2AgaWYgdGhleSBhcmVuJ3QgdXNlZFxudmFyIHRoaXJkUGFzcyA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBzdGF0ZSkge1xuICAgIGlmICghdC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHJldHVybjtcblxuICAgIHZhciBleHByID0gbm9kZS5leHByZXNzaW9uO1xuICAgIGlmICghdC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKGV4cHIpKSByZXR1cm47XG5cbiAgICBpZiAoIXN0YXRlLm5lZWRzVGhpcyAmJiBleHByLmxlZnQgPT09IHN0YXRlLmdldFRoaXNJZCgpKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXN0YXRlLm5lZWRzQXJndW1lbnRzICYmIGV4cHIubGVmdCA9PT0gc3RhdGUuZ2V0QXJndW1lbnRzSWQoKSAmJiB0LmlzQXJyYXlFeHByZXNzaW9uKGV4cHIucmlnaHQpKSB7XG4gICAgICByZXR1cm4gbWFwKGV4cHIucmlnaHQuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoZWxlbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuRnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgdGFpbENhbGwgPSBuZXcgVGFpbENhbGxUcmFuc2Zvcm1lcihub2RlLCBzY29wZSwgZmlsZSk7XG4gIHRhaWxDYWxsLnJ1bigpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxudmFyIGJ1aWxkQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gdC5iaW5hcnlFeHByZXNzaW9uKFwiK1wiLCBsZWZ0LCByaWdodCk7XG59O1xuXG5leHBvcnRzLmNoZWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSkgfHwgdC5pc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlKTtcbn07XG5cbmV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgdmFyIHF1YXNpID0gbm9kZS5xdWFzaTtcblxuICB2YXIgc3RyaW5ncyA9IFtdO1xuICB2YXIgcmF3ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFzaS5xdWFzaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlbSA9IHF1YXNpLnF1YXNpc1tpXTtcbiAgICBzdHJpbmdzLnB1c2godC5saXRlcmFsKGVsZW0udmFsdWUuY29va2VkKSk7XG4gICAgcmF3LnB1c2godC5saXRlcmFsKGVsZW0udmFsdWUucmF3KSk7XG4gIH1cblxuICBzdHJpbmdzID0gdC5hcnJheUV4cHJlc3Npb24oc3RyaW5ncyk7XG4gIHJhdyA9IHQuYXJyYXlFeHByZXNzaW9uKHJhdyk7XG5cbiAgdmFyIHRlbXBsYXRlTmFtZSA9IFwidGFnZ2VkLXRlbXBsYXRlLWxpdGVyYWxcIjtcbiAgaWYgKGZpbGUuaXNMb29zZShcImVzNi50ZW1wbGF0ZUxpdGVyYWxzXCIpKSB0ZW1wbGF0ZU5hbWUgKz0gXCItbG9vc2VcIjtcbiAgYXJncy5wdXNoKHQuY2FsbEV4cHJlc3Npb24oZmlsZS5hZGRIZWxwZXIodGVtcGxhdGVOYW1lKSwgW3N0cmluZ3MsIHJhd10pKTtcblxuICBhcmdzID0gYXJncy5jb25jYXQocXVhc2kuZXhwcmVzc2lvbnMpO1xuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKG5vZGUudGFnLCBhcmdzKTtcbn07XG5cbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBub2RlLnF1YXNpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVtID0gbm9kZS5xdWFzaXNbaV07XG5cbiAgICBub2Rlcy5wdXNoKHQubGl0ZXJhbChlbGVtLnZhbHVlLmNvb2tlZCkpO1xuXG4gICAgdmFyIGV4cHIgPSBub2RlLmV4cHJlc3Npb25zLnNoaWZ0KCk7XG4gICAgaWYgKGV4cHIpIG5vZGVzLnB1c2goZXhwcik7XG4gIH1cblxuICBpZiAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgIC8vIHJlbW92ZSByZWR1bmRhbnQgJycgYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblxuICAgIHZhciBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHQuaXNMaXRlcmFsKGxhc3QsIHsgdmFsdWU6IFwiXCIgfSkpIG5vZGVzLnBvcCgpO1xuXG4gICAgdmFyIHJvb3QgPSBidWlsZEJpbmFyeUV4cHJlc3Npb24obm9kZXMuc2hpZnQoKSwgbm9kZXMuc2hpZnQoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJvb3QgPSBidWlsZEJpbmFyeUV4cHJlc3Npb24ocm9vdCwgbm9kZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1swXTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgcmV3cml0ZVBhdHRlcm4gPSByZXF1aXJlKFwicmVnZXhwdS9yZXdyaXRlLXBhdHRlcm5cIik7XG52YXIgcHVsbCAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2FycmF5L3B1bGxcIik7XG52YXIgdCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5pc0xpdGVyYWwobm9kZSkgJiYgbm9kZS5yZWdleCAmJiBub2RlLnJlZ2V4LmZsYWdzLmluZGV4T2YoXCJ1XCIpID49IDA7XG59O1xuXG5leHBvcnRzLkxpdGVyYWwgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgcmVnZXggPSBub2RlLnJlZ2V4O1xuICBpZiAoIXJlZ2V4KSByZXR1cm47XG5cbiAgdmFyIGZsYWdzID0gcmVnZXguZmxhZ3Muc3BsaXQoXCJcIik7XG4gIGlmIChyZWdleC5mbGFncy5pbmRleE9mKFwidVwiKSA8IDApIHJldHVybjtcbiAgcHVsbChmbGFncywgXCJ1XCIpO1xuXG4gIHJlZ2V4LnBhdHRlcm4gPSByZXdyaXRlUGF0dGVybihyZWdleC5wYXR0ZXJuLCByZWdleC5mbGFncyk7XG4gIHJlZ2V4LmZsYWdzICAgPSBmbGFncy5qb2luKFwiXCIpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1hYnN0cmFjdC1yZWZzXG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgdCAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5leHBlcmltZW50YWwgPSB0cnVlO1xuXG52YXIgY29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudCwgY2FsbCwgcmV0LCBmaWxlKSB7XG4gIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChwYXJlbnQpICYmICFmaWxlLmlzQ29uc2VxdWVuY2VFeHByZXNzaW9uU3RhdGVtZW50KHBhcmVudCkpIHtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHJldHVybiB2YWx1ZXNcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICBpZiAodC5pc1NlcXVlbmNlRXhwcmVzc2lvbihjYWxsKSkge1xuICAgICAgZXhwcnMgPSBjYWxsLmV4cHJlc3Npb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBycy5wdXNoKGNhbGwpO1xuICAgIH1cbiAgICBleHBycy5wdXNoKHJldCk7XG4gICAgcmV0dXJuIHQuc2VxdWVuY2VFeHByZXNzaW9uKGV4cHJzKTtcbiAgfVxufTtcblxuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICBpZiAoIXQuaXNWaXJ0dWFsUHJvcGVydHlFeHByZXNzaW9uKGxlZnQpKSByZXR1cm47XG5cbiAgdmFyIHZhbHVlID0gbm9kZS5yaWdodDtcbiAgdmFyIHRlbXA7XG5cbiAgLy8gd2UgbmVlZCB0byByZXR1cm4gYG5vZGUucmlnaHRgXG4gIGlmICghdC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQocGFyZW50KSkge1xuICAgIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVRlbXBCYXNlZE9uTm9kZShub2RlLnJpZ2h0KTtcbiAgICBpZiAodGVtcCkgdmFsdWUgPSB0ZW1wO1xuICB9XG5cbiAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7XG4gICAgdmFsdWUgPSB0LmJpbmFyeUV4cHJlc3Npb24oXG4gICAgICBub2RlLm9wZXJhdG9yWzBdLFxuICAgICAgdXRpbC50ZW1wbGF0ZShcImFic3RyYWN0LWV4cHJlc3Npb24tZ2V0XCIsIHtcbiAgICAgICAgUFJPUEVSVFk6IG5vZGUucHJvcGVydHksXG4gICAgICAgIE9CSkVDVDogICBub2RlLm9iamVjdFxuICAgICAgfSksXG4gICAgICB2YWx1ZVxuICAgICk7XG4gIH1cblxuICB2YXIgY2FsbCA9IHV0aWwudGVtcGxhdGUoXCJhYnN0cmFjdC1leHByZXNzaW9uLXNldFwiLCB7XG4gICAgUFJPUEVSVFk6IGxlZnQucHJvcGVydHksXG4gICAgT0JKRUNUOiAgIGxlZnQub2JqZWN0LFxuICAgIFZBTFVFOiAgICB2YWx1ZVxuICB9KTtcblxuICBpZiAodGVtcCkge1xuICAgIGNhbGwgPSB0LnNlcXVlbmNlRXhwcmVzc2lvbihbXG4gICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCB0ZW1wLCBub2RlLnJpZ2h0KSxcbiAgICAgIGNhbGxcbiAgICBdKTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIocGFyZW50LCBjYWxsLCB2YWx1ZSwgZmlsZSk7XG59O1xuXG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBhcmcgPSBub2RlLmFyZ3VtZW50O1xuICBpZiAoIXQuaXNWaXJ0dWFsUHJvcGVydHlFeHByZXNzaW9uKGFyZykpIHJldHVybjtcbiAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiZGVsZXRlXCIpIHJldHVybjtcblxuICB2YXIgY2FsbCA9IHV0aWwudGVtcGxhdGUoXCJhYnN0cmFjdC1leHByZXNzaW9uLWRlbGV0ZVwiLCB7XG4gICAgUFJPUEVSVFk6IGFyZy5wcm9wZXJ0eSxcbiAgICBPQkpFQ1Q6ICAgYXJnLm9iamVjdFxuICB9KTtcblxuICByZXR1cm4gY29udGFpbmVyKHBhcmVudCwgY2FsbCwgdC5saXRlcmFsKHRydWUpLCBmaWxlKTtcbn07XG5cbmV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSkge1xuICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gIGlmICghdC5pc1ZpcnR1YWxQcm9wZXJ0eUV4cHJlc3Npb24oY2FsbGVlKSkgcmV0dXJuO1xuXG4gIHZhciB0ZW1wID0gc2NvcGUuZ2VuZXJhdGVUZW1wQmFzZWRPbk5vZGUoY2FsbGVlLm9iamVjdCk7XG5cbiAgdmFyIGNhbGwgPSB1dGlsLnRlbXBsYXRlKFwiYWJzdHJhY3QtZXhwcmVzc2lvbi1jYWxsXCIsIHtcbiAgICBQUk9QRVJUWTogY2FsbGVlLnByb3BlcnR5LFxuICAgIE9CSkVDVDogICB0ZW1wIHx8IGNhbGxlZS5vYmplY3RcbiAgfSk7XG5cbiAgY2FsbC5hcmd1bWVudHMgPSBjYWxsLmFyZ3VtZW50cy5jb25jYXQobm9kZS5hcmd1bWVudHMpO1xuXG4gIGlmICh0ZW1wKSB7XG4gICAgcmV0dXJuIHQuc2VxdWVuY2VFeHByZXNzaW9uKFtcbiAgICAgIHQuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIHRlbXAsIGNhbGxlZS5vYmplY3QpLFxuICAgICAgY2FsbFxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG59O1xuXG5leHBvcnRzLlZpcnR1YWxQcm9wZXJ0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdXRpbC50ZW1wbGF0ZShcImFic3RyYWN0LWV4cHJlc3Npb24tZ2V0XCIsIHtcbiAgICBQUk9QRVJUWTogbm9kZS5wcm9wZXJ0eSxcbiAgICBPQkpFQ1Q6ICAgbm9kZS5vYmplY3RcbiAgfSk7XG59O1xuXG5leHBvcnRzLlByaXZhdGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBub2RlLmRlY2xhcmF0aW9ucy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHQudmFyaWFibGVEZWNsYXJhdG9yKGlkLCB0Lm5ld0V4cHJlc3Npb24odC5pZGVudGlmaWVyKFwiV2Vha01hcFwiKSwgW10pKTtcbiAgfSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYnVpbGRDb21wcmVoZW5zaW9uID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvYnVpbGQtY29tcHJlaGVuc2lvblwiKTtcbnZhciB0cmF2ZXJzZSAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHJhdmVyc2FsXCIpO1xudmFyIHV0aWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIHQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5leHBlcmltZW50YWwgPSB0cnVlO1xuXG5leHBvcnRzLkNvbXByZWhlbnNpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJyYXk7XG4gIGlmIChub2RlLmdlbmVyYXRvcikgY2FsbGJhY2sgPSBnZW5lcmF0b3I7XG4gIHJldHVybiBjYWxsYmFjayhub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKTtcbn07XG5cbnZhciBnZW5lcmF0b3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgYm9keSA9IFtdO1xuICB2YXIgY29udGFpbmVyID0gdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW10sIHQuYmxvY2tTdGF0ZW1lbnQoYm9keSksIHRydWUpO1xuICBjb250YWluZXIuX2FsaWFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gIGJvZHkucHVzaChidWlsZENvbXByZWhlbnNpb24obm9kZSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC55aWVsZEV4cHJlc3Npb24obm9kZS5ib2R5KSk7XG4gIH0pKTtcblxuICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihjb250YWluZXIsIFtdKTtcbn07XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciB1aWQgPSBzY29wZS5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKHBhcmVudCwgZmlsZSk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHV0aWwudGVtcGxhdGUoXCJhcnJheS1jb21wcmVoZW5zaW9uLWNvbnRhaW5lclwiLCB7XG4gICAgS0VZOiB1aWRcbiAgfSk7XG4gIGNvbnRhaW5lci5jYWxsZWUuX2FsaWFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gIHZhciBibG9jayA9IGNvbnRhaW5lci5jYWxsZWUuYm9keTtcbiAgdmFyIGJvZHkgID0gYmxvY2suYm9keTtcblxuICBpZiAodHJhdmVyc2UuaGFzVHlwZShub2RlLCBzY29wZSwgXCJZaWVsZEV4cHJlc3Npb25cIiwgdC5GVU5DVElPTl9UWVBFUykpIHtcbiAgICBjb250YWluZXIuY2FsbGVlLmdlbmVyYXRvciA9IHRydWU7XG4gICAgY29udGFpbmVyID0gdC55aWVsZEV4cHJlc3Npb24oY29udGFpbmVyLCB0cnVlKTtcbiAgfVxuXG4gIHZhciByZXR1cm5TdGF0ZW1lbnQgPSBib2R5LnBvcCgpO1xuXG4gIGJvZHkucHVzaChidWlsZENvbXByZWhlbnNpb24obm9kZSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlsLnRlbXBsYXRlKFwiYXJyYXktcHVzaFwiLCB7XG4gICAgICBTVEFURU1FTlQ6IG5vZGUuYm9keSxcbiAgICAgIEtFWTogICAgICAgdWlkXG4gICAgfSwgdHJ1ZSk7XG4gIH0pKTtcbiAgYm9keS5wdXNoKHJldHVyblN0YXRlbWVudCk7XG5cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL2V4cG9uZW50aWF0aW9uLW9wZXJhdG9yXG5cbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gdHJ1ZTtcblxudmFyIGJ1aWxkID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvYnVpbGQtYmluYXJ5LWFzc2lnbm1lbnQtb3BlcmF0b3ItdHJhbnNmb3JtZXJcIik7XG52YXIgdCAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbnZhciBNQVRIX1BPVyA9IHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoXCJNYXRoXCIpLCB0LmlkZW50aWZpZXIoXCJwb3dcIikpO1xuXG5idWlsZChleHBvcnRzLCB7XG4gIG9wZXJhdG9yOiBcIioqXCIsXG5cbiAgYnVpbGQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKE1BVEhfUE9XLCBbbGVmdCwgcmlnaHRdKTtcbiAgfVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtcmVzdC1zcHJlYWRcblxudmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gdHJ1ZTtcblxuZXhwb3J0cy5tYW5pcHVsYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmIChvcHRzLndoaXRlbGlzdC5sZW5ndGgpIG9wdHMud2hpdGVsaXN0LnB1c2goXCJlczYuZGVzdHJ1Y3R1cmluZ1wiKTtcbn07XG5cbnZhciBoYXNTcHJlYWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0LmlzU3ByZWFkUHJvcGVydHkobm9kZS5wcm9wZXJ0aWVzW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghaGFzU3ByZWFkKG5vZGUpKSByZXR1cm47XG5cbiAgdmFyIGFyZ3MgPSBbXTtcbiAgdmFyIHByb3BzID0gW107XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwcm9wcy5sZW5ndGgpIHJldHVybjtcbiAgICBhcmdzLnB1c2godC5vYmplY3RFeHByZXNzaW9uKHByb3BzKSk7XG4gICAgcHJvcHMgPSBbXTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgIGlmICh0LmlzU3ByZWFkUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHB1c2goKTtcbiAgICAgIGFyZ3MucHVzaChwcm9wLmFyZ3VtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICB9XG4gIH1cblxuICBwdXNoKCk7XG5cbiAgaWYgKCF0LmlzT2JqZWN0RXhwcmVzc2lvbihhcmdzWzBdKSkge1xuICAgIGFyZ3MudW5zaGlmdCh0Lm9iamVjdEV4cHJlc3Npb24oW10pKTtcbiAgfVxuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwiZXh0ZW5kc1wiKSwgYXJncyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVzZVN0cmljdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vb3RoZXIvdXNlLXN0cmljdFwiKSxcblxuICBcInZhbGlkYXRpb24udW5kZWNsYXJlZFZhcmlhYmxlQ2hlY2tcIjogICAgcmVxdWlyZShcIi4vdmFsaWRhdGlvbi91bmRlY2xhcmVkLXZhcmlhYmxlLWNoZWNrXCIpLFxuICBcInZhbGlkYXRpb24ubm9Gb3JJbk9mQXNzaWdubWVudFwiOiAgICAgICAgcmVxdWlyZShcIi4vdmFsaWRhdGlvbi9uby1mb3ItaW4tb2YtYXNzaWdubWVudFwiKSxcbiAgXCJ2YWxpZGF0aW9uLnNldHRlcnNcIjogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vc2V0dGVyc1wiKSxcbiAgXCJ2YWxpZGF0aW9uLnJlYWN0XCI6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vcmVhY3RcIiksXG4gIFwic3BlYy5ibG9ja1Njb3BlZEZ1bmN0aW9uc1wiOiAgICAgICAgICAgICByZXF1aXJlKFwiLi9zcGVjL2Jsb2NrLXNjb3BlZC1mdW5jdGlvbnNcIiksXG5cbiAgXCJwbGF5Z3JvdW5kLm1hbGxldE9wZXJhdG9yXCI6ICAgICAgICAgICAgIHJlcXVpcmUoXCIuL3BsYXlncm91bmQvbWFsbGV0LW9wZXJhdG9yXCIpLFxuICBcInBsYXlncm91bmQubWV0aG9kQmluZGluZ1wiOiAgICAgICAgICAgICAgcmVxdWlyZShcIi4vcGxheWdyb3VuZC9tZXRob2QtYmluZGluZ1wiKSxcbiAgXCJwbGF5Z3JvdW5kLm1lbW9pemF0aW9uT3BlcmF0b3JcIjogICAgICAgIHJlcXVpcmUoXCIuL3BsYXlncm91bmQvbWVtb2l6YXRpb24tb3BlcmF0b3JcIiksXG4gIFwicGxheWdyb3VuZC5vYmplY3RHZXR0ZXJNZW1vaXphdGlvblwiOiAgICByZXF1aXJlKFwiLi9wbGF5Z3JvdW5kL29iamVjdC1nZXR0ZXItbWVtb2l6YXRpb25cIiksXG5cbiAgcmVhY3RDb21wYXQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9vdGhlci9yZWFjdC1jb21wYXRcIiksXG4gIGZsb3c6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vb3RoZXIvZmxvd1wiKSxcbiAgcmVhY3Q6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9vdGhlci9yZWFjdFwiKSxcblxuICBfbW9kdWxlczogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2ludGVybmFsL21vZHVsZXNcIiksXG5cbiAgLy8gbmVlZHMgdG8gYmUgYmVmb3JlIGByZWdlbmVyYXRvcmAgZHVlIHRvIGdlbmVyYXRvciBjb21wcmVoZW5zaW9uc1xuICAvLyBuZWVkcyB0byBiZSBiZWZvcmUgYF9hbGlhc0Z1bmN0aW9uYFxuICBcImVzNy5jb21wcmVoZW5zaW9uc1wiOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM3L2NvbXByZWhlbnNpb25zXCIpLFxuXG4gIC8vIG5lZWRzIHRvIGJlIGJlZm9yZSBgX2FsaWFzRnVuY3Rpb25gXG4gIFwiZXM2LmFycm93RnVuY3Rpb25zXCI6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvYXJyb3ctZnVuY3Rpb25zXCIpLFxuXG4gIFwiZXM2LmNsYXNzZXNcIjogICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvY2xhc3Nlc1wiKSxcblxuICBhc3luY1RvR2VuZXJhdG9yOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL290aGVyL2FzeW5jLXRvLWdlbmVyYXRvclwiKSxcbiAgYmx1ZWJpcmRDb3JvdXRpbmVzOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9vdGhlci9ibHVlYmlyZC1jb3JvdXRpbmVzXCIpLFxuXG4gIFwiZXM2Lm9iamVjdFN1cGVyXCI6ICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvb2JqZWN0LXN1cGVyXCIpLFxuICBcImVzNy5vYmplY3RSZXN0U3ByZWFkXCI6ICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM3L29iamVjdC1yZXN0LXNwcmVhZFwiKSxcbiAgXCJlczcuZXhwb25lbnRpYXRpb25PcGVyYXRvclwiOiAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNy9leHBvbmVudGlhdGlvbi1vcGVyYXRvclwiKSxcbiAgXCJlczYudGVtcGxhdGVMaXRlcmFsc1wiOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNi90ZW1wbGF0ZS1saXRlcmFsc1wiKSxcblxuICBcImVzNS5wcm9wZXJ0aWVzLm11dGF0b3JzXCI6ICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM1L3Byb3BlcnRpZXMubXV0YXRvcnNcIiksXG4gIFwiZXM2LnByb3BlcnRpZXMuc2hvcnRoYW5kXCI6ICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvcHJvcGVydGllcy5zaG9ydGhhbmRcIiksXG5cbiAgLy8gbmVlZHMgdG8gYmUgYmVmb3JlIGBfYWxpYXNGdW5jdGlvbmAgZHVlIHRvIGRlZmluZSBwcm9wZXJ0eSBjbG9zdXJlXG4gIFwiZXM2LnByb3BlcnRpZXMuY29tcHV0ZWRcIjogICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvcHJvcGVydGllcy5jb21wdXRlZFwiKSxcblxuICBcImVzNi5mb3JPZlwiOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM2L2Zvci1vZlwiKSxcblxuICBcImVzNi51bmljb2RlUmVnZXhcIjogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM2L3VuaWNvZGUtcmVnZXhcIiksXG4gIFwiZXM3LmFic3RyYWN0UmVmZXJlbmNlc1wiOiAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczcvYWJzdHJhY3QtcmVmZXJlbmNlc1wiKSxcblxuICBcImVzNi5jb25zdGFudHNcIjogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM2L2NvbnN0YW50c1wiKSxcblxuICAvLyBuZWVkcyB0byBiZSBiZWZvcmUgYGVzNi5wYXJhbWV0ZXJzLmRlZmF1bHRgIGFzIGRlZmF1bHQgcGFyYW1ldGVycyB3aWxsIGRlc3Ryb3kgdGhlIHJlc3QgcGFyYW1cbiAgXCJlczYucGFyYW1ldGVycy5yZXN0XCI6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNi9wYXJhbWV0ZXJzLnJlc3RcIiksXG5cbiAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgYGVzNi5wYXJhbWV0ZXJzLnJlc3RgIGFzIHdlIHVzZSBgdG9BcnJheWAgYW5kIGF2b2lkIHR1cm5pbmcgYW4gYWxyZWFkeSBrbm93biBhcnJheSBpbnRvIG9uZVxuICBcImVzNi5zcHJlYWRcIjogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXM2L3NwcmVhZFwiKSxcblxuICAvLyBuZWVkcyB0byBiZSBiZWZvcmUgYGVzNi5ibG9ja1Njb3BpbmdgIGFzIGRlZmF1bHQgcGFyYW1ldGVycyBoYXZlIGEgVERaXG4gIFwiZXM2LnBhcmFtZXRlcnMuZGVmYXVsdFwiOiAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvcGFyYW1ldGVycy5kZWZhdWx0XCIpLFxuXG4gIC8vIG5lZWRzIHRvIGJlIGJlZm9yZSBgZXM2LmJsb2NrU2NvcGluZ2AgYXMgbGV0IHZhcmlhYmxlcyBtYXkgYmUgcHJvZHVjZWRcbiAgXCJlczYuZGVzdHJ1Y3R1cmluZ1wiOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNi9kZXN0cnVjdHVyaW5nXCIpLFxuXG4gIC8vIG5lZWRzIHRvIGJlIGJlZm9yZSBgX2FsaWFzRnVuY3Rpb25gIGR1ZSB0byBibG9jayBzY29wZXMgc29tZXRpbWVzIGJlaW5nIHdyYXBwZWQgaW4gYVxuICAvLyBjbG9zdXJlXG4gIFwiZXM2LmJsb2NrU2NvcGluZ1wiOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvYmxvY2stc2NvcGluZ1wiKSxcblxuICAvLyBuZWVkcyB0byBiZSBhZnRlciBgZXM2LmJsb2NrU2NvcGluZ2AgZHVlIHRvIG5lZWRpbmcgYGxldFJlZmVyZW5jZXNgIHNldCBvbiBibG9ja3NcbiAgXCJlczYuYmxvY2tTY29waW5nVERaXCI6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNi9ibG9jay1zY29waW5nLXRkelwiKSxcblxuICAvLyBuZWVkcyB0byBiZSBhZnRlciBgZXM2LnBhcmFtZXRlcnMuKmAgYW5kIGBlczYuYmxvY2tTY29waW5nYCBkdWUgdG8gbmVlZGluZyBwdXJlXG4gIC8vIGlkZW50aWZpZXJzIGluIHBhcmFtZXRlcnMgYW5kIHZhcmlhYmxlIGRlY2xhcmF0b3JzXG4gIFwiZXM2LnRhaWxDYWxsXCI6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9lczYvdGFpbC1jYWxsXCIpLFxuXG4gIHJlZ2VuZXJhdG9yOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vb3RoZXIvcmVnZW5lcmF0b3JcIiksXG5cbiAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgYHJlZ2VuZXJhdG9yYCBkdWUgdG8gbmVlZGluZyBgcmVnZW5lcmF0b3JSdW50aW1lYCByZWZlcmVuY2VzXG4gIC8vIG5lZWRzIHRvIGJlIGFmdGVyIGBlczYuZm9yT2ZgIGR1ZSB0byBuZWVkaW5nIGBTeW1ib2wuaXRlcmF0b3JgIHJlZmVyZW5jZXNcbiAgLy8gbmVlZHMgdG8gYmUgYmVmb3JlIGBlczYubW9kdWxlc2AgZHVlIHRvIGR5bmFtaWMgaW1wb3J0c1xuICBzZWxmQ29udGFpbmVkOiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL290aGVyL3NlbGYtY29udGFpbmVkXCIpLFxuXG4gIC8vIG5lZWRzIHRvIGJlIGJlZm9yZSBgX2Jsb2NrSG9pc3RgIGR1ZSB0byBmdW5jdGlvbiBob2lzdGluZyBldGNcbiAgXCJlczYubW9kdWxlc1wiOiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL2VzNi9tb2R1bGVzXCIpLFxuXG4gIF9ibG9ja0hvaXN0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vaW50ZXJuYWwvYmxvY2staG9pc3RcIiksXG5cbiAgXCJzcGVjLnByb3RvVG9Bc3NpZ25cIjogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCIuL3NwZWMvcHJvdG8tdG8tYXNzaWduXCIpLFxuXG4gIF9kZWNsYXJhdGlvbnM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vaW50ZXJuYWwvZGVjbGFyYXRpb25zXCIpLFxuXG4gIF9hbGlhc0Z1bmN0aW9uczogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vaW50ZXJuYWwvYWxpYXMtZnVuY3Rpb25zXCIpLFxuXG4gIFwic3BlYy50eXBlb2ZTeW1ib2xcIjogICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9zcGVjL3R5cGVvZi1zeW1ib2xcIiksXG4gIFwic3BlYy51bmRlZmluZWRUb1ZvaWRcIjogICAgICAgICAgICAgICAgICByZXF1aXJlKFwiLi9zcGVjL3VuZGVmaW5lZC10by12b2lkXCIpLFxuICBcInNwZWMuZnVuY3Rpb25OYW1lXCI6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vc3BlYy9mdW5jdGlvbi1uYW1lXCIpLFxuXG4gIF9tb2R1bGVGb3JtYXR0ZXI6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vaW50ZXJuYWwvbW9kdWxlLWZvcm1hdHRlclwiKSxcblxuICBcImVzMy5wcm9wZXJ0eUxpdGVyYWxzXCI6ICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZXMzL3Byb3BlcnR5LWxpdGVyYWxzXCIpLFxuICBcImVzMy5tZW1iZXJFeHByZXNzaW9uTGl0ZXJhbHNcIjogICAgICAgICAgcmVxdWlyZShcIi4vZXMzL21lbWJlci1leHByZXNzaW9uLWxpdGVyYWxzXCIpLFxuXG4gIFwibWluaWZpY2F0aW9uLnJlbW92ZURlYnVnZ2VyXCI6ICAgICAgICAgICByZXF1aXJlKFwiLi9taW5pZmljYXRpb24vcmVtb3ZlLWRlYnVnZ2VyXCIpLFxuICBcIm1pbmlmaWNhdGlvbi5yZW1vdmVDb25zb2xlQ2FsbHNcIjogICAgICAgcmVxdWlyZShcIi4vbWluaWZpY2F0aW9uL3JlbW92ZS1jb25zb2xlLWNhbGxzXCIpLFxuICBcIm1pbmlmaWNhdGlvbi5kZWFkQ29kZUVsaW1pbmF0aW9uXCI6ICAgICAgcmVxdWlyZShcIi4vbWluaWZpY2F0aW9uL2RlYWQtY29kZS1lbGltaW5hdGlvblwiKSxcbiAgXCJtaW5pZmljYXRpb24ucmVuYW1lTG9jYWxWYXJpYWJsZXNcIjogICAgIHJlcXVpcmUoXCIuL21pbmlmaWNhdGlvbi9yZW5hbWUtbG9jYWwtdmFyaWFibGVzXCIpLFxuXG4gIF9jbGVhblVwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vaW50ZXJuYWwvY2xlYW51cFwiKVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxudmFyIGZ1bmN0aW9uQ2hpbGRyZW5WaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKHQuaXNGdW5jdGlvbihub2RlKSAmJiAhbm9kZS5fYWxpYXNGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcCgpO1xuICAgIH1cblxuICAgIGlmIChub2RlLl9pZ25vcmVBbGlhc0Z1bmN0aW9ucykgcmV0dXJuIHRoaXMuc2tpcCgpO1xuXG4gICAgdmFyIGdldElkO1xuXG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpICYmIG5vZGUubmFtZSA9PT0gXCJhcmd1bWVudHNcIikge1xuICAgICAgZ2V0SWQgPSBzdGF0ZS5nZXRBcmd1bWVudHNJZDtcbiAgICB9IGVsc2UgaWYgKHQuaXNUaGlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgZ2V0SWQgPSBzdGF0ZS5nZXRUaGlzSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodC5pc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KSkgcmV0dXJuIGdldElkKCk7XG4gIH1cbn07XG5cbnZhciBmdW5jdGlvblZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAoIW5vZGUuX2FsaWFzRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0LmlzRnVuY3Rpb24obm9kZSkpIHtcbiAgICAgICAgLy8gc3RvcCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlIGFzIGl0J2xsIGJlIGhpdCBhZ2FpbiBieSB0aGlzIHRyYW5zZm9ybWVyXG4gICAgICAgIHJldHVybiB0aGlzLnNraXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmF2ZXJzZSBhbGwgY2hpbGQgbm9kZXMgb2YgdGhpcyBmdW5jdGlvbiBhbmQgZmluZCBgYXJndW1lbnRzYCBhbmQgYHRoaXNgXG4gICAgc2NvcGUudHJhdmVyc2Uobm9kZSwgZnVuY3Rpb25DaGlsZHJlblZpc2l0b3IsIHN0YXRlKTtcblxuICAgIHJldHVybiB0aGlzLnNraXAoKTtcbiAgfVxufTtcblxudmFyIGdvID0gZnVuY3Rpb24gKGdldEJvZHksIG5vZGUsIHNjb3BlKSB7XG4gIHZhciBhcmd1bWVudHNJZDtcbiAgdmFyIHRoaXNJZDtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgZ2V0QXJndW1lbnRzSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNJZCA9IGFyZ3VtZW50c0lkIHx8IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImFyZ3VtZW50c1wiKTtcbiAgICB9LFxuICAgIGdldFRoaXNJZDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNJZCA9IHRoaXNJZCB8fCBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJ0aGlzXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyB0cmF2ZXJzZSB0aGUgZnVuY3Rpb24gYW5kIGZpbmQgYWxsIGFsaWFzIGZ1bmN0aW9ucyBzbyB3ZSBjYW4gYWxpYXNcbiAgLy8gYGFyZ3VtZW50c2AgYW5kIGB0aGlzYCBpZiBuZWNlc3NhcnlcbiAgc2NvcGUudHJhdmVyc2Uobm9kZSwgZnVuY3Rpb25WaXNpdG9yLCBzdGF0ZSk7XG5cbiAgdmFyIGJvZHk7XG5cbiAgdmFyIHB1c2hEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgIGJvZHkgPSBib2R5IHx8IGdldEJvZHkoKTtcbiAgICBib2R5LnVuc2hpZnQodC52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KVxuICAgIF0pKTtcbiAgfTtcblxuICBpZiAoYXJndW1lbnRzSWQpIHtcbiAgICBwdXNoRGVjbGFyYXRpb24oYXJndW1lbnRzSWQsIHQuaWRlbnRpZmllcihcImFyZ3VtZW50c1wiKSk7XG4gIH1cblxuICBpZiAodGhpc0lkKSB7XG4gICAgcHVzaERlY2xhcmF0aW9uKHRoaXNJZCwgdC50aGlzRXhwcmVzc2lvbigpKTtcbiAgfVxufTtcblxuZXhwb3J0cy5Qcm9ncmFtID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUpIHtcbiAgZ28oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub2RlLmJvZHk7XG4gIH0sIG5vZGUsIHNjb3BlKTtcbn07XG5cbmV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9XG5leHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gIGdvKGZ1bmN0aW9uICgpIHtcbiAgICB0LmVuc3VyZUJsb2NrKG5vZGUpO1xuICAgIHJldHVybiBub2RlLmJvZHkuYm9keTtcbiAgfSwgbm9kZSwgc2NvcGUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXNlU3RyaWN0ID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvdXNlLXN0cmljdFwiKTtcbnZhciBncm91cEJ5ICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZ3JvdXBCeVwiKTtcbnZhciBmbGF0dGVuICAgPSByZXF1aXJlKFwibG9kYXNoL2FycmF5L2ZsYXR0ZW5cIik7XG52YXIgdmFsdWVzICAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvdmFsdWVzXCIpO1xuXG4vLyBQcmlvcml0eTpcbi8vXG4vLyAgLSAwIFdlIHdhbnQgdGhpcyB0byBiZSBhdCB0aGUgKip2ZXJ5KiogYm90dG9tXG4vLyAgLSAxIERlZmF1bHQgbm9kZSBwb3NpdGlvblxuLy8gIC0gMiBQcmlvcml0eSBvdmVyIG5vcm1hbCBub2Rlc1xuLy8gIC0gMyBXZSB3YW50IHRoaXMgdG8gYmUgYXQgdGhlICoqdmVyeSoqIHRvcFxuXG5leHBvcnRzLkJsb2NrU3RhdGVtZW50ID1cbmV4cG9ydHMuUHJvZ3JhbSA9IHtcbiAgZXhpdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgaGFzQ2hhbmdlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBib2R5Tm9kZSA9IG5vZGUuYm9keVtpXTtcbiAgICAgIGlmIChib2R5Tm9kZSAmJiBib2R5Tm9kZS5fYmxvY2tIb2lzdCAhPSBudWxsKSBoYXNDaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWhhc0NoYW5nZSkgcmV0dXJuO1xuXG4gICAgdXNlU3RyaWN0LndyYXAobm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vZGVQcmlvcml0aWVzID0gZ3JvdXBCeShub2RlLmJvZHksIGZ1bmN0aW9uIChib2R5Tm9kZSkge1xuICAgICAgICB2YXIgcHJpb3JpdHkgPSBib2R5Tm9kZS5fYmxvY2tIb2lzdDtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09IG51bGwpIHByaW9yaXR5ID0gMTtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB0cnVlKSBwcmlvcml0eSA9IDI7XG4gICAgICAgIHJldHVybiBwcmlvcml0eTtcbiAgICAgIH0pO1xuXG4gICAgICBub2RlLmJvZHkgPSBmbGF0dGVuKHZhbHVlcyhub2RlUHJpb3JpdGllcykucmV2ZXJzZSgpKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsImV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbnNbMF07XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHVzZVN0cmljdCA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3VzZS1zdHJpY3RcIik7XG52YXIgdCAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLnNlY29uZFBhc3MgPSB0cnVlO1xuXG5leHBvcnRzLkJsb2NrU3RhdGVtZW50ID1cbmV4cG9ydHMuUHJvZ3JhbSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghbm9kZS5fZGVjbGFyYXRpb25zKSByZXR1cm47XG5cbiAgdmFyIGtpbmRzID0ge307XG4gIHZhciBraW5kO1xuXG4gIHVzZVN0cmljdC53cmFwKG5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpIGluIG5vZGUuX2RlY2xhcmF0aW9ucykge1xuICAgICAgdmFyIGRlY2xhciA9IG5vZGUuX2RlY2xhcmF0aW9uc1tpXTtcblxuICAgICAga2luZCA9IGRlY2xhci5raW5kIHx8IFwidmFyXCI7XG4gICAgICB2YXIgZGVjbGFyTm9kZSA9IHQudmFyaWFibGVEZWNsYXJhdG9yKGRlY2xhci5pZCwgZGVjbGFyLmluaXQpO1xuXG4gICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgbm9kZS5ib2R5LnVuc2hpZnQoZmlsZS5hdHRhY2hBdXhpbGlhcnlDb21tZW50KHQudmFyaWFibGVEZWNsYXJhdGlvbihraW5kLCBbZGVjbGFyTm9kZV0pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBraW5kc1traW5kXSA9IGtpbmRzW2tpbmRdIHx8IFtdO1xuICAgICAgICBraW5kc1traW5kXS5wdXNoKGRlY2xhck5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoa2luZCBpbiBraW5kcykge1xuICAgICAgbm9kZS5ib2R5LnVuc2hpZnQoZmlsZS5hdHRhY2hBdXhpbGlhcnlDb21tZW50KHQudmFyaWFibGVEZWNsYXJhdGlvbihraW5kLCBraW5kc1traW5kXSkpKTtcbiAgICB9XG4gIH0pO1xuXG4gIG5vZGUuX2RlY2xhcmF0aW9ucyA9IG51bGw7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1c2VTdHJpY3QgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy91c2Utc3RyaWN0XCIpO1xuXG5leHBvcnRzLlByb2dyYW0gPSBmdW5jdGlvbiAocHJvZ3JhbSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAoIWZpbGUudHJhbnNmb3JtZXJzW1wiZXM2Lm1vZHVsZXNcIl0uY2FuUnVuKCkpIHJldHVybjtcblxuICB1c2VTdHJpY3Qud3JhcChwcm9ncmFtLCBmdW5jdGlvbiAoKSB7XG4gICAgcHJvZ3JhbS5ib2R5ID0gZmlsZS5keW5hbWljSW1wb3J0cy5jb25jYXQocHJvZ3JhbS5ib2R5KTtcbiAgfSk7XG5cbiAgaWYgKGZpbGUubW9kdWxlRm9ybWF0dGVyLnRyYW5zZm9ybSkge1xuICAgIGZpbGUubW9kdWxlRm9ybWF0dGVyLnRyYW5zZm9ybShwcm9ncmFtKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBpbiB0aGlzIHRyYW5zZm9ybWVyIHdlIGhhdmUgdG8gc3BsaXQgdXAgY2xhc3NlcyBhbmQgZnVuY3Rpb24gZGVjbGFyYXRpb25zXG4vLyBmcm9tIHRoZWlyIGV4cG9ydHMuIHdoeT8gYmVjYXVzZSBzb21ldGltZXMgd2UgbmVlZCB0byByZXBsYWNlIGNsYXNzZXMgd2l0aFxuLy8gbm9kZXMgdGhhdCBhcmVuJ3QgYWxsb3dlZCBpbiB0aGUgc2FtZSBjb250ZXh0cy4gYWxzbywgaWYgeW91J3JlIGV4cG9ydGluZ1xuLy8gYSBnZW5lcmF0b3IgZnVuY3Rpb24gYXMgYSBkZWZhdWx0IHRoZW4gcmVnZW5lcmF0b3Igd2lsbCBkZXN0cm95IHRoZSBleHBvcnRcbi8vIGRlY2xhcmF0aW9uIGFuZCBsZWF2ZSBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIGl0J3MgcGxhY2UuLi4geWVhaCwgaGFuZHkuXG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG52YXIgcmVzb2x2ZU1vZHVsZVNvdXJjZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciByZXNvbHZlTW9kdWxlU291cmNlID0gZmlsZS5vcHRzLnJlc29sdmVNb2R1bGVTb3VyY2U7XG4gIGlmIChub2RlLnNvdXJjZSAmJiByZXNvbHZlTW9kdWxlU291cmNlKSB7XG4gICAgbm9kZS5zb3VyY2UudmFsdWUgPSByZXNvbHZlTW9kdWxlU291cmNlKG5vZGUuc291cmNlLnZhbHVlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5jaGVjayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LmlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkgfHwgdC5pc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xufTtcblxuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IHJlc29sdmVNb2R1bGVTb3VyY2U7XG5cbmV4cG9ydHMuRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSkge1xuICByZXNvbHZlTW9kdWxlU291cmNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgdmFyIGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb247XG5cbiAgaWYgKG5vZGUuZGVmYXVsdCkge1xuICAgIGlmICh0LmlzQ2xhc3NEZWNsYXJhdGlvbihkZWNsYXIpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gZGVjbGFyLmlkO1xuICAgICAgcmV0dXJuIFtkZWNsYXIsIG5vZGVdO1xuICAgIH0gZWxzZSBpZiAodC5pc0NsYXNzRXhwcmVzc2lvbihkZWNsYXIpKSB7XG4gICAgICB2YXIgdGVtcCA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcImRlZmF1bHRcIik7XG4gICAgICBkZWNsYXIgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0ZW1wLCBkZWNsYXIpXG4gICAgICBdKTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0ZW1wO1xuICAgICAgcmV0dXJuIFtkZWNsYXIsIG5vZGVdO1xuICAgIH0gZWxzZSBpZiAodC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgbm9kZS5fYmxvY2tIb2lzdCA9IDI7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gZGVjbGFyLmlkO1xuICAgICAgcmV0dXJuIFtkZWNsYXIsIG5vZGVdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzICA9IFt0LmltcG9ydFNwZWNpZmllcihkZWNsYXIuaWQsIGRlY2xhci5pZCldO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICBub2RlLl9ibG9ja0hvaXN0ID0gMjtcbiAgICAgIHJldHVybiBbZGVjbGFyLCBub2RlXTtcbiAgICB9XG4gIH1cbn07XG4iLCJ2YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5cbmV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8vIHJlbW92ZSBjb25zZXF1ZW5jZS1sZXNzIGV4cHJlc3Npb25zIHN1Y2ggYXMgbG9jYWwgdmFyaWFibGVzIGFuZCBsaXRlcmFsc1xuICAvLyBub3RlOiB3aWxsIHJlbW92ZSBkaXJlY3RpdmVzXG4gIC8vXG4gIC8vICAgdmFyIGZvbyA9IHRydWU7IGZvbzsgLT4gdmFyIGZvbyA9IHRydWU7XG4gIC8vICAgXCJmb29cIjsgLT5cbiAgLy9cblxuICB2YXIgZXhwciA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgaWYgKHQuaXNMaXRlcmFsKGV4cHIpIHx8ICh0LmlzSWRlbnRpZmllcihub2RlKSAmJiB0Lmhhc0JpbmRpbmcobm9kZS5uYW1lKSkpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLklmU3RhdGVtZW50ID0ge1xuICBleGl0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIHRvZG86IGluIHNjZW5hcmlvcyB3aGVyZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGNvbnNlcXVlbnQgb3JcbiAgICAvLyBhbHRlcm5hdGUgd2Ugc2hvdWxkIGRyb3AgdGhlIGJsb2NrIHN0YXRlbWVudCBpZiBpdCBjb250YWlucyBub1xuICAgIC8vIGJsb2NrIHNjb3BlZCB2YXJpYWJsZXNcblxuICAgIHZhciBjb25zZXF1ZW50ID0gbm9kZS5jb25zZXF1ZW50O1xuICAgIHZhciBhbHRlcm5hdGUgID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgdmFyIHRlc3QgICAgICAgPSBub2RlLnRlc3Q7XG5cbiAgICAvLyB3ZSBjYW4gY2hlY2sgaWYgYSB0ZXN0IHdpbGwgYmUgdHJ1dGh5IDEwMCUgYW5kIGlmIHNvIHRoZW4gd2UgY2FuIGlubGluZVxuICAgIC8vIHRoZSBjb25zZXF1ZW50IGFuZCBjb21wbGV0ZWx5IGlnbm9yZSB0aGUgYWx0ZXJuYXRlXG4gICAgLy9cbiAgICAvLyAgIGlmICh0cnVlKSB7IGZvbzsgfSAtPiB7IGZvbzsgfVxuICAgIC8vICAgaWYgKFwiZm9vXCIpIHsgZm9vOyB9IC0+IHsgZm9vOyB9XG4gICAgLy9cblxuICAgIGlmICh0LmlzTGl0ZXJhbCh0ZXN0KSAmJiB0ZXN0LnZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uc2VxdWVudDtcbiAgICB9XG5cbiAgICAvLyB3ZSBjYW4gY2hlY2sgaWYgYSB0ZXN0IHdpbGwgYmUgZmFsc3kgMTAwJSBhbmQgaWYgc28gd2UgY2FuIGlubGluZSB0aGVcbiAgICAvLyBhbHRlcm5hdGUgaWYgdGhlcmUgaXMgb25lIGFuZCBjb21wbGV0ZWx5IHJlbW92ZSB0aGUgY29uc2VxdWVudFxuICAgIC8vXG4gICAgLy8gICBpZiAoXCJcIikgeyBiYXI7IH0gZWxzZSB7IGZvbzsgfSAtPiB7IGZvbzsgfVxuICAgIC8vICAgaWYgKFwiXCIpIHsgYmFyOyB9IC0+XG4gICAgLy9cblxuICAgIGlmICh0LmlzRmFsc3lFeHByZXNzaW9uKHRlc3QpKSB7XG4gICAgICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWx0ZXJuYXRlIGJsb2NrcyB0aGF0IGFyZSBlbXB0eVxuICAgIC8vXG4gICAgLy8gICBpZiAoZm9vKSB7IGZvbzsgfSBlbHNlIHt9IC0+IGlmIChmb28pIHsgZm9vOyB9XG4gICAgLy9cblxuICAgIGlmICh0LmlzQmxvY2tTdGF0ZW1lbnQoYWx0ZXJuYXRlKSAmJiAhYWx0ZXJuYXRlLmJvZHkubGVuZ3RoKSB7XG4gICAgICBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbnNlcXVlbnQgYmxvY2sgaXMgZW1wdHkgdHVybiBhbHRlcm5hdGUgYmxvY2tzIGludG8gYSBjb25zZXF1ZW50XG4gICAgLy8gYW5kIGZsaXAgdGhlIHRlc3RcbiAgICAvL1xuICAgIC8vICAgaWYgKGZvbykge30gZWxzZSB7IGJhcjsgfSAtPiBpZiAoIWZvbykgeyBiYXI7IH1cbiAgICAvL1xuXG4gICAgaWYgKHQuYmxvY2tTdGF0ZW1lbnQoY29uc2VxdWVudCkgJiYgIWNvbnNlcXVlbnQuYm9keS5sZW5ndGggJiYgdC5pc0Jsb2NrU3RhdGVtZW50KGFsdGVybmF0ZSkgJiYgYWx0ZXJuYXRlLmJvZHkubGVuZ3RoKSB7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlICA9IG51bGw7XG4gICAgICBub2RlLnRlc3QgICAgICAgPSB0LnVuYXJ5RXhwcmVzc2lvbihcIiFcIiwgdGVzdCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG52YXIgaXNDb25zb2xlID0gdC5idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihcImNvbnNvbGVcIiwgdHJ1ZSk7XG5cbmV4cG9ydHMub3B0aW9uYWwgPSB0cnVlO1xuXG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICBpZiAoaXNDb25zb2xlKG5vZGUuY2FsbGVlKSkge1xuICAgIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgICB0aGlzLnBhcmVudFBhdGgucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59O1xuIiwidmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMub3B0aW9uYWwgPSB0cnVlO1xuXG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodC5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uLCB7IG5hbWU6IFwiZGVidWdnZXJcIiB9KSkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cbn07XG4iLCIvL3ZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLm9wdGlvbmFsID0gdHJ1ZTtcblxuZXhwb3J0cy5TY29wYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy9mb3IgKHZhciBuYW1lIGluIHNjb3BlLmJpbmRpbmdzKSB7XG4gIC8vICBzY29wZS5yZW5hbWUobmFtZSwgc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiYVwiKS5uYW1lKTtcbiAgLy99XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZW1hcEFzeW5jVG9HZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9yZW1hcC1hc3luYy10by1nZW5lcmF0b3JcIik7XG52YXIgYmx1ZWJpcmRDb3JvdXRpbmVzICAgID0gcmVxdWlyZShcIi4vYmx1ZWJpcmQtY29yb3V0aW5lc1wiKTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5cbmV4cG9ydHMubWFuaXB1bGF0ZU9wdGlvbnMgPSBibHVlYmlyZENvcm91dGluZXMubWFuaXB1bGF0ZU9wdGlvbnM7XG5cbmV4cG9ydHMuRnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAoIW5vZGUuYXN5bmMgfHwgbm9kZS5nZW5lcmF0b3IpIHJldHVybjtcblxuICByZXR1cm4gcmVtYXBBc3luY1RvR2VuZXJhdG9yKG5vZGUsIGZpbGUuYWRkSGVscGVyKFwiYXN5bmMtdG8tZ2VuZXJhdG9yXCIpLCBzY29wZSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZW1hcEFzeW5jVG9HZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9yZW1hcC1hc3luYy10by1nZW5lcmF0b3JcIik7XG52YXIgdCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLm1hbmlwdWxhdGVPcHRpb25zID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cy5leHBlcmltZW50YWwgPSB0cnVlO1xuICBvcHRzLmJsYWNrbGlzdC5wdXNoKFwicmVnZW5lcmF0b3JcIik7XG59O1xuXG5leHBvcnRzLm9wdGlvbmFsID0gdHJ1ZTtcblxuZXhwb3J0cy5GdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICghbm9kZS5hc3luYyB8fCBub2RlLmdlbmVyYXRvcikgcmV0dXJuO1xuXG4gIHJldHVybiByZW1hcEFzeW5jVG9HZW5lcmF0b3IoXG4gICAgbm9kZSxcbiAgICB0Lm1lbWJlckV4cHJlc3Npb24oZmlsZS5hZGRJbXBvcnQoXCJibHVlYmlyZFwiLCBudWxsLCB0cnVlKSwgdC5pZGVudGlmaWVyKFwiY29yb3V0aW5lXCIpKSxcbiAgICBzY29wZVxuICApO1xufTtcbiIsInZhciB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLmV4cHJlc3Npb247XG59O1xuXG5leHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUuaXNUeXBlKSB0aGlzLnJlbW92ZSgpO1xufTtcblxuZXhwb3J0cy5FeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0LmlzVHlwZUFsaWFzKG5vZGUuZGVjbGFyYXRpb24pKSB0aGlzLnJlbW92ZSgpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVhY3QgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9yZWFjdFwiKTtcbnZhciB0ICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5tYW5pcHVsYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMuYmxhY2tsaXN0LnB1c2goXCJyZWFjdFwiKTtcbn07XG5cbmV4cG9ydHMub3B0aW9uYWwgPSB0cnVlO1xuXG5yZXF1aXJlKFwiLi4vLi4vaGVscGVycy9idWlsZC1yZWFjdC10cmFuc2Zvcm1lclwiKShleHBvcnRzLCB7XG4gIHByZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgc3RhdGUuY2FsbGVlID0gc3RhdGUudGFnRXhwcjtcbiAgfSxcblxuICBwb3N0OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBpZiAocmVhY3QuaXNDb21wYXRUYWcoc3RhdGUudGFnTmFtZSkpIHtcbiAgICAgIHN0YXRlLmNhbGwgPSB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcIlJlYWN0XCIpLCB0LmlkZW50aWZpZXIoXCJET01cIikpLFxuICAgICAgICAgIHN0YXRlLnRhZ0V4cHIsXG4gICAgICAgICAgdC5pc0xpdGVyYWwoc3RhdGUudGFnRXhwcilcbiAgICAgICAgKSxcbiAgICAgICAgc3RhdGUuYXJnc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWFjdCA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3JlYWN0XCIpO1xudmFyIHQgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5yZXF1aXJlKFwiLi4vLi4vaGVscGVycy9idWlsZC1yZWFjdC10cmFuc2Zvcm1lclwiKShleHBvcnRzLCB7XG4gIHByZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBzdGF0ZS50YWdOYW1lO1xuICAgIHZhciBhcmdzICAgID0gc3RhdGUuYXJncztcbiAgICBpZiAocmVhY3QuaXNDb21wYXRUYWcodGFnTmFtZSkpIHtcbiAgICAgIGFyZ3MucHVzaCh0LmxpdGVyYWwodGFnTmFtZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnB1c2goc3RhdGUudGFnRXhwcik7XG4gICAgfVxuICB9LFxuXG4gIHBvc3Q6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHN0YXRlLmNhbGxlZSA9IHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoXCJSZWFjdFwiKSwgdC5pZGVudGlmaWVyKFwiY3JlYXRlRWxlbWVudFwiKSk7XG4gIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWdlbmVyYXRvciA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1iYWJlbFwiKTtcbnZhciB0ICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5jaGVjayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0LmlzRnVuY3Rpb24obm9kZSkgJiYgKG5vZGUuYXN5bmMgfHwgbm9kZS5nZW5lcmF0b3IpO1xufTtcblxuZXhwb3J0cy5Qcm9ncmFtID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKGFzdCkge1xuICAgIHJlZ2VuZXJhdG9yLnRyYW5zZm9ybShhc3QpO1xuICAgIHRoaXMuc3RvcCgpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbmNsdWRlcyA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9pbmNsdWRlc1wiKTtcbnZhciB1dGlsICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGNvcmUgICAgID0gcmVxdWlyZShcImNvcmUtanMvbGlicmFyeVwiKTtcbnZhciBoYXMgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvb2JqZWN0L2hhc1wiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxudmFyIGlzU3ltYm9saXRlcmF0b3IgPSB0LmJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiU3ltYm9sLml0ZXJhdG9yXCIpO1xuXG52YXIgY29yZUhhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5hbWUgIT09IFwiX1wiICYmIGhhcyhjb3JlLCBub2RlLm5hbWUpO1xufTtcblxudmFyIEFMSUFTQUJMRV9DT05TVFJVQ1RPUlMgPSBbXG4gIFwiU3ltYm9sXCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIk1hcFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJTZXRcIixcbiAgXCJXZWFrU2V0XCJcbl07XG5cbnZhciBhc3RWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgICB2YXIgcHJvcDtcblxuICAgIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSAmJiB0LmlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQpKSB7XG4gICAgICAvLyBBcnJheS5mcm9tIC0+IF9jb3JlLkFycmF5LmZyb21cbiAgICAgIHZhciBvYmogPSBub2RlLm9iamVjdDtcbiAgICAgIHByb3AgPSBub2RlLnByb3BlcnR5O1xuXG4gICAgICBpZiAoIXQuaXNSZWZlcmVuY2VkKG9iaiwgbm9kZSkpIHJldHVybjtcblxuICAgICAgaWYgKCFub2RlLmNvbXB1dGVkICYmIGNvcmVIYXMob2JqKSAmJiBoYXMoY29yZVtvYmoubmFtZV0sIHByb3AubmFtZSkgJiYgIXNjb3BlLmdldEJpbmRpbmdJZGVudGlmaWVyKG9iai5uYW1lKSkge1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgcmV0dXJuIHQucHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbihub2RlLCBmaWxlLmdldChcImNvcmVJZGVudGlmaWVyXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHQuaXNSZWZlcmVuY2VkSWRlbnRpZmllcihub2RlLCBwYXJlbnQpICYmICF0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpICYmIGluY2x1ZGVzKEFMSUFTQUJMRV9DT05TVFJVQ1RPUlMsIG5vZGUubmFtZSkgJiYgIXNjb3BlLmdldEJpbmRpbmdJZGVudGlmaWVyKG5vZGUubmFtZSkpIHtcbiAgICAgIC8vIFN5bWJvbCgpIC0+IF9jb3JlLlN5bWJvbCgpOyBuZXcgUHJvbWlzZSAtPiBuZXcgX2NvcmUuUHJvbWlzZVxuICAgICAgcmV0dXJuIHQubWVtYmVyRXhwcmVzc2lvbihmaWxlLmdldChcImNvcmVJZGVudGlmaWVyXCIpLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgLy8gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSAtPiBfY29yZS4kZm9yLmdldEl0ZXJhdG9yKGFycilcblxuICAgICAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIXQuaXNNZW1iZXJFeHByZXNzaW9uKGNhbGxlZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghY2FsbGVlLmNvbXB1dGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHByb3AgPSBjYWxsZWUucHJvcGVydHk7XG4gICAgICBpZiAoIWlzU3ltYm9saXRlcmF0b3IocHJvcCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIHV0aWwudGVtcGxhdGUoXCJjb3JlanMtaXRlcmF0b3JcIiwge1xuICAgICAgICBDT1JFX0lEOiBmaWxlLmdldChcImNvcmVJZGVudGlmaWVyXCIpLFxuICAgICAgICBWQUxVRTogICBjYWxsZWUub2JqZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHQuaXNCaW5hcnlFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICAvLyBTeW1ib2wuaXRlcmF0b3IgaW4gYXJyIC0+IGNvcmUuJGZvci5pc0l0ZXJhYmxlKGFycilcblxuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiaW5cIikgcmV0dXJuO1xuXG4gICAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgICAgIGlmICghaXNTeW1ib2xpdGVyYXRvcihsZWZ0KSkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4gdXRpbC50ZW1wbGF0ZShcImNvcmVqcy1pcy1pdGVyYXRvclwiLCB7XG4gICAgICAgIENPUkVfSUQ6IGZpbGUuZ2V0KFwiY29yZUlkZW50aWZpZXJcIiksXG4gICAgICAgIFZBTFVFOiAgIG5vZGUucmlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5cbmV4cG9ydHMubWFuaXB1bGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAob3B0cy53aGl0ZWxpc3QubGVuZ3RoKSBvcHRzLndoaXRlbGlzdC5wdXNoKFwiZXM2Lm1vZHVsZXNcIik7XG59O1xuXG5leHBvcnRzLlByb2dyYW0gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBzY29wZS50cmF2ZXJzZShub2RlLCBhc3RWaXNpdG9yLCBmaWxlKTtcbn07XG5cbmV4cG9ydHMucHJlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgZmlsZS5zZXREeW5hbWljKFwicnVudGltZUlkZW50aWZpZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmaWxlLmFkZEltcG9ydChcImJhYmVsLXJ1bnRpbWUvaGVscGVyc1wiLCBcImJhYmVsSGVscGVyc1wiKTtcbiAgfSk7XG5cbiAgZmlsZS5zZXREeW5hbWljKFwiY29yZUlkZW50aWZpZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmaWxlLmFkZEltcG9ydChcImJhYmVsLXJ1bnRpbWUvY29yZS1qc1wiLCBcImNvcmVcIik7XG4gIH0pO1xuXG4gIGZpbGUuc2V0RHluYW1pYyhcInJlZ2VuZXJhdG9ySWRlbnRpZmllclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZpbGUuYWRkSW1wb3J0KFwiYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZVwiKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLklkZW50aWZpZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAodC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCwgeyBuYW1lOiBcInJlZ2VuZXJhdG9yUnVudGltZVwiIH0pKSB7XG4gICAgcmV0dXJuIGZpbGUuZ2V0KFwicmVnZW5lcmF0b3JJZGVudGlmaWVyXCIpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1c2VTdHJpY3QgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy91c2Utc3RyaWN0XCIpO1xudmFyIG1lc3NhZ2VzICA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZXNzYWdlc1wiKTtcbnZhciB0ICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gIGlmICghdXNlU3RyaWN0Lmhhcyhwcm9ncmFtKSkge1xuICAgIHByb2dyYW0uYm9keS51bnNoaWZ0KHQuZXhwcmVzc2lvblN0YXRlbWVudCh0LmxpdGVyYWwoXCJ1c2Ugc3RyaWN0XCIpKSk7XG4gIH1cbn07XG5cbmV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9XG5leHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5za2lwKCk7XG59O1xuXG5leHBvcnRzLlRoaXNFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpO1xufTtcblxuZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICh0LmlzSWRlbnRpZmllcihub2RlLmNhbGxlZSwgeyBuYW1lOiBcImV2YWxcIiB9KSkge1xuICAgIHRocm93IGZpbGUuZXJyb3JXaXRoTm9kZShub2RlLCBtZXNzYWdlcy5nZXQoXCJldmFsSW5TdHJpY3RNb2RlXCIpKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVzc2FnZXNcIik7XG52YXIgYnVpbGQgICAgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9idWlsZC1jb25kaXRpb25hbC1hc3NpZ25tZW50LW9wZXJhdG9yLXRyYW5zZm9ybWVyXCIpO1xudmFyIHQgICAgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLnBsYXlncm91bmQgPSB0cnVlO1xuXG5idWlsZChleHBvcnRzLCB7XG4gIGlzOiBmdW5jdGlvbiAobm9kZSwgZmlsZSkge1xuICAgIHZhciBpcyA9IHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSAmJiBub2RlLm9wZXJhdG9yID09PSBcInx8PVwiO1xuICAgIGlmIChpcykge1xuICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgICBpZiAoIXQuaXNNZW1iZXJFeHByZXNzaW9uKGxlZnQpICYmICF0LmlzSWRlbnRpZmllcihsZWZ0KSkge1xuICAgICAgICB0aHJvdyBmaWxlLmVycm9yV2l0aE5vZGUobGVmdCwgbWVzc2FnZXMuZ2V0KFwiZXhwZWN0ZWRNZW1iZXJFeHByZXNzaW9uT3JJZGVudGlmaWVyXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBidWlsZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdC51bmFyeUV4cHJlc3Npb24oXCIhXCIsIG5vZGUsIHRydWUpO1xuICB9XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYnVpbGQgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9idWlsZC1jb25kaXRpb25hbC1hc3NpZ25tZW50LW9wZXJhdG9yLXRyYW5zZm9ybWVyXCIpO1xudmFyIHQgICAgID0gcmVxdWlyZShcIi4uLy4uLy4uL3R5cGVzXCIpO1xuXG5leHBvcnRzLnBsYXlncm91bmQgPSB0cnVlO1xuXG5idWlsZChleHBvcnRzLCB7XG4gIGlzOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBpcyA9IHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSAmJiBub2RlLm9wZXJhdG9yID09PSBcIj89XCI7XG4gICAgaWYgKGlzKSB0LmFzc2VydE1lbWJlckV4cHJlc3Npb24obm9kZS5sZWZ0KTtcbiAgICByZXR1cm4gaXM7XG4gIH0sXG5cbiAgYnVpbGQ6IGZ1bmN0aW9uIChub2RlLCBmaWxlKSB7XG4gICAgcmV0dXJuIHQudW5hcnlFeHByZXNzaW9uKFxuICAgICAgXCIhXCIsXG4gICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oZmlsZS5hZGRIZWxwZXIoXCJoYXMtb3duXCIpLCB0LmlkZW50aWZpZXIoXCJjYWxsXCIpKSxcbiAgICAgICAgW25vZGUub2JqZWN0LCBub2RlLnByb3BlcnR5XVxuICAgICAgKSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5wbGF5Z3JvdW5kID0gdHJ1ZTtcblxuZXhwb3J0cy5CaW5kTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gIHZhciBvYmplY3QgPSBub2RlLm9iamVjdDtcbiAgdmFyIHByb3AgICA9IG5vZGUucHJvcGVydHk7XG5cbiAgdmFyIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVRlbXBCYXNlZE9uTm9kZShub2RlLm9iamVjdCk7XG4gIGlmICh0ZW1wKSBvYmplY3QgPSB0ZW1wO1xuXG4gIHZhciBjYWxsID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICB0Lm1lbWJlckV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcCksIHQuaWRlbnRpZmllcihcImJpbmRcIikpLFxuICAgIFtvYmplY3RdLmNvbmNhdChub2RlLmFyZ3VtZW50cylcbiAgKTtcblxuICBpZiAodGVtcCkge1xuICAgIHJldHVybiB0LnNlcXVlbmNlRXhwcmVzc2lvbihbXG4gICAgICB0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCB0ZW1wLCBub2RlLm9iamVjdCksXG4gICAgICBjYWxsXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cbn07XG5cbmV4cG9ydHMuQmluZEZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlKSB7XG4gIHZhciBidWlsZENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBwYXJhbSA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcInZhbFwiKTtcbiAgICByZXR1cm4gdC5mdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgW3BhcmFtXSwgdC5ibG9ja1N0YXRlbWVudChbXG4gICAgICB0LnJldHVyblN0YXRlbWVudCh0LmNhbGxFeHByZXNzaW9uKHQubWVtYmVyRXhwcmVzc2lvbihwYXJhbSwgbm9kZS5jYWxsZWUpLCBhcmdzKSlcbiAgICBdKSk7XG4gIH07XG5cbiAgdmFyIHRlbXAgPSBzY29wZS5nZW5lcmF0ZVRlbXAoXCJhcmdzXCIpO1xuXG4gIHJldHVybiB0LnNlcXVlbmNlRXhwcmVzc2lvbihbXG4gICAgdC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdGVtcCwgdC5hcnJheUV4cHJlc3Npb24obm9kZS5hcmd1bWVudHMpKSxcbiAgICBidWlsZENhbGwobm9kZS5hcmd1bWVudHMubWFwKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKHRlbXAsIHQubGl0ZXJhbChpKSwgdHJ1ZSk7XG4gICAgfSkpXG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5wbGF5Z3JvdW5kID0gdHJ1ZTtcblxudmFyIHZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSByZXR1cm4gdGhpcy5za2lwKCk7XG5cbiAgICBpZiAodC5pc1JldHVyblN0YXRlbWVudChub2RlKSAmJiBub2RlLmFyZ3VtZW50KSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdC5tZW1iZXJFeHByZXNzaW9uKHQuY2FsbEV4cHJlc3Npb24oc3RhdGUuZmlsZS5hZGRIZWxwZXIoXCJkZWZpbmUtcHJvcGVydHlcIiksIFtcbiAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICBzdGF0ZS5rZXksXG4gICAgICAgIG5vZGUuYXJndW1lbnRcbiAgICAgIF0pLCBzdGF0ZS5rZXksIHRydWUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5Qcm9wZXJ0eSA9XG5leHBvcnRzLk1ldGhvZERlZmluaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAobm9kZS5raW5kICE9PSBcIm1lbW9cIikgcmV0dXJuO1xuICBub2RlLmtpbmQgPSBcImdldFwiO1xuXG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIHQuZW5zdXJlQmxvY2sodmFsdWUpO1xuXG4gIHZhciBrZXkgPSBub2RlLmtleTtcblxuICBpZiAodC5pc0lkZW50aWZpZXIoa2V5KSAmJiAhbm9kZS5jb21wdXRlZCkge1xuICAgIGtleSA9IHQubGl0ZXJhbChrZXkubmFtZSk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSB7XG4gICAga2V5OiAga2V5LFxuICAgIGZpbGU6IGZpbGVcbiAgfTtcblxuICBzY29wZS50cmF2ZXJzZSh2YWx1ZSwgdmlzaXRvciwgc3RhdGUpO1xuXG4gIHJldHVybiBub2RlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIGlmICgodC5pc0Z1bmN0aW9uKHBhcmVudCkgJiYgcGFyZW50LmJvZHkgPT09IG5vZGUpIHx8IHQuaXNFeHBvcnREZWNsYXJhdGlvbihwYXJlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZnVuYyA9IG5vZGUuYm9keVtpXTtcbiAgICBpZiAoIXQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGZ1bmMpKSBjb250aW51ZTtcblxuICAgIHZhciBkZWNsYXIgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJsZXRcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoZnVuYy5pZCwgdC50b0V4cHJlc3Npb24oZnVuYykpXG4gICAgXSk7XG5cbiAgICAvLyBob2lzdCBpdCB1cCBhYm92ZSBldmVyeXRoaW5nIGVsc2VcbiAgICBkZWNsYXIuX2Jsb2NrSG9pc3QgPSAyO1xuXG4gICAgLy8gdG9kbzogbmFtZSB0aGlzXG4gICAgZnVuYy5pZCA9IG51bGw7XG5cbiAgICBub2RlLmJvZHlbaV0gPSBkZWNsYXI7XG5cbiAgICBmaWxlLmNoZWNrTm9kZShkZWNsYXIpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgdCAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxudmFyIHByb3BlcnR5RnVuY3Rpb25WaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKHQuaXNSZWZlcmVuY2VkSWRlbnRpZmllcihub2RlLCBwYXJlbnQsIHsgbmFtZTogc3RhdGUubmFtZSB9KSAmJiBzY29wZS5nZXRCaW5kaW5nSWRlbnRpZmllcihub2RlLm5hbWUpID09PSBzdGF0ZS5iaW5kaW5nKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZ2V0T3V0ZXIoKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgaWYgKG5vZGUuaWQpIHJldHVybjtcbiAgdmFyIGlkO1xuICBpZiAodC5pc1Byb3BlcnR5KHBhcmVudCkpIHtcbiAgICBpZCA9IHBhcmVudC5rZXk7XG4gIH0gZWxzZSBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRvcihwYXJlbnQpKSB7XG4gICAgaWQgPSBwYXJlbnQuaWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZ0lkZW50aWZpZXIoaWQubmFtZSk7XG4gIHZhciBvdXRlcklkLCBzZWxmR2xvYmFsSWQ7XG4gIHNjb3BlLnRyYXZlcnNlKG5vZGUsIHByb3BlcnR5RnVuY3Rpb25WaXNpdG9yLCB7XG4gICAgbmFtZTogaWQubmFtZSxcbiAgICBiaW5kaW5nOiBiaW5kaW5nLFxuXG4gICAgZ2V0T3V0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghYmluZGluZykge1xuICAgICAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIHNlbGZHbG9iYWxJZCB8fCAoc2VsZkdsb2JhbElkID0gZmlsZS5hZGRIZWxwZXIoXCJzZWxmLWdsb2JhbFwiKSksXG4gICAgICAgICAgaWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICBvdXRlcklkIHx8IChvdXRlcklkID0gc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiZ2V0T3V0ZXJcIikpLFxuICAgICAgICBbXVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICBub2RlLmlkID0gaWQ7XG4gIGlmIChvdXRlcklkKSB7XG4gICAgcmV0dXJuIHV0aWwudGVtcGxhdGUoXCJuYW1lZC1mdW5jXCIsIHtcbiAgICAgIEdFVF9PVVRFUl9JRDogb3V0ZXJJZCxcbiAgICAgIElEOiAgICAgICAgICAgaWQsXG4gICAgICBGVU5DVElPTjogICAgIG5vZGVcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG52YXIgcHVsbCA9IHJlcXVpcmUoXCJsb2Rhc2gvYXJyYXkvcHVsbFwiKTtcblxudmFyIGlzUHJvdG9LZXkgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5pc0xpdGVyYWwodC50b0NvbXB1dGVkS2V5KG5vZGUsIG5vZGUua2V5KSwgeyB2YWx1ZTogXCJfX3Byb3RvX19cIiB9KTtcbn07XG5cbnZhciBpc1Byb3RvQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgcmV0dXJuIHQuaXNNZW1iZXJFeHByZXNzaW9uKGxlZnQpICYmIHQuaXNMaXRlcmFsKHQudG9Db21wdXRlZEtleShsZWZ0LCBsZWZ0LnByb3BlcnR5KSwgeyB2YWx1ZTogXCJfX3Byb3RvX19cIiB9KTtcbn07XG5cbnZhciBidWlsZERlZmF1bHRzQ2FsbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwciwgcmVmLCBmaWxlKSB7XG4gIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5jYWxsRXhwcmVzc2lvbihmaWxlLmFkZEhlbHBlcihcImRlZmF1bHRzXCIpLCBbcmVmLCBleHByLnJpZ2h0XSkpO1xufTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5leHBvcnRzLnNlY29uZFBhc3MgPSB0cnVlO1xuXG5leHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgaWYgKCFpc1Byb3RvQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkpIHJldHVybjtcblxuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIGxlZnQgID0gbm9kZS5sZWZ0Lm9iamVjdDtcbiAgdmFyIHRlbXAgID0gc2NvcGUuZ2VuZXJhdGVUZW1wQmFzZWRPbk5vZGUobm9kZS5sZWZ0Lm9iamVjdCk7XG5cbiAgbm9kZXMucHVzaCh0LmV4cHJlc3Npb25TdGF0ZW1lbnQodC5hc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdGVtcCwgbGVmdCkpKTtcbiAgbm9kZXMucHVzaChidWlsZERlZmF1bHRzQ2FsbEV4cHJlc3Npb24obm9kZSwgdGVtcCwgZmlsZSkpO1xuICBpZiAodGVtcCkgbm9kZXMucHVzaCh0ZW1wKTtcblxuICByZXR1cm4gdC50b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcyk7XG59O1xuXG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICB2YXIgZXhwciA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgaWYgKCF0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oZXhwciwgeyBvcGVyYXRvcjogXCI9XCIgfSkpIHJldHVybjtcblxuICBpZiAoaXNQcm90b0Fzc2lnbm1lbnRFeHByZXNzaW9uKGV4cHIpKSB7XG4gICAgcmV0dXJuIGJ1aWxkRGVmYXVsdHNDYWxsRXhwcmVzc2lvbihleHByLCBleHByLmxlZnQub2JqZWN0LCBmaWxlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgdmFyIHByb3RvO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG5cbiAgICBpZiAoaXNQcm90b0tleShwcm9wKSkge1xuICAgICAgcHJvdG8gPSBwcm9wLnZhbHVlO1xuICAgICAgcHVsbChub2RlLnByb3BlcnRpZXMsIHByb3ApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm90bykge1xuICAgIHZhciBhcmdzID0gW3Qub2JqZWN0RXhwcmVzc2lvbihbXSksIHByb3RvXTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCkgYXJncy5wdXNoKG5vZGUpO1xuICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwiZXh0ZW5kc1wiKSwgYXJncyk7XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMub3B0aW9uYWwgPSB0cnVlO1xuXG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHRoaXMuc2tpcCgpO1xuXG4gIGlmIChub2RlLm9wZXJhdG9yID09PSBcInR5cGVvZlwiKSB7XG4gICAgdmFyIGNhbGwgPSB0LmNhbGxFeHByZXNzaW9uKGZpbGUuYWRkSGVscGVyKFwidHlwZW9mXCIpLCBbbm9kZS5hcmd1bWVudF0pO1xuICAgIGlmICh0LmlzSWRlbnRpZmllcihub2RlLmFyZ3VtZW50KSkge1xuICAgICAgdmFyIHVuZGVmTGl0ZXJhbCA9IHQubGl0ZXJhbChcInVuZGVmaW5lZFwiKTtcbiAgICAgIHJldHVybiB0LmNvbmRpdGlvbmFsRXhwcmVzc2lvbihcbiAgICAgICAgdC5iaW5hcnlFeHByZXNzaW9uKFwiPT09XCIsIHQudW5hcnlFeHByZXNzaW9uKFwidHlwZW9mXCIsIG5vZGUuYXJndW1lbnQpLCB1bmRlZkxpdGVyYWwpLFxuICAgICAgICB1bmRlZkxpdGVyYWwsXG4gICAgICAgIGNhbGxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5vcHRpb25hbCA9IHRydWU7XG5cbmV4cG9ydHMuSWRlbnRpZmllciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUubmFtZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0LmlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHQudW5hcnlFeHByZXNzaW9uKFwidm9pZFwiLCB0LmxpdGVyYWwoMCksIHRydWUpO1xuICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZXNzYWdlc1wiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuZXhwb3J0cy5jaGVjayA9IHQuaXNGb3I7XG5cbmV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPVxuZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHNjb3BlLCBmaWxlKSB7XG4gIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obGVmdCkpIHtcbiAgICB2YXIgZGVjbGFyID0gbGVmdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgaWYgKGRlY2xhci5pbml0KSB0aHJvdyBmaWxlLmVycm9yV2l0aE5vZGUoZGVjbGFyLCBtZXNzYWdlcy5nZXQoXCJub0Fzc2lnbm1lbnRzSW5Gb3JIZWFkXCIpKTtcbiAgfVxufTtcbiIsInZhciBtZXNzYWdlcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tZXNzYWdlc1wiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi8uLi90eXBlc1wiKTtcblxuLy8gY2hlY2sgaWYgdGhlIGlucHV0IExpdGVyYWwgYHNvdXJjZWAgaXMgYW4gYWx0ZXJuYXRlIGNhc2luZyBvZiBcInJlYWN0XCJcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbGUpIHtcbiAgaWYgKHQuaXNMaXRlcmFsKHNvdXJjZSkpIHtcbiAgICB2YXIgbmFtZSAgPSBzb3VyY2UudmFsdWU7XG4gICAgdmFyIGxvd2VyID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyID09PSBcInJlYWN0XCIgJiYgbmFtZSAhPT0gbG93ZXIpIHtcbiAgICAgIHRocm93IGZpbGUuZXJyb3JXaXRoTm9kZShzb3VyY2UsIG1lc3NhZ2VzLmdldChcImRpZFlvdU1lYW5cIiwgXCJyZWFjdFwiKSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUuY2FsbGVlLCB7IG5hbWU6IFwicmVxdWlyZVwiIH0pICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNoZWNrKG5vZGUuYXJndW1lbnRzWzBdLCBmaWxlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9XG5leHBvcnRzLkV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIGZpbGUpIHtcbiAgY2hlY2sobm9kZS5zb3VyY2UsIGZpbGUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVzc2FnZXNcIik7XG5cbmV4cG9ydHMuY2hlY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS5raW5kID09PSBcInNldFwiO1xufTtcblxuZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID1cbmV4cG9ydHMuUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAobm9kZS5raW5kID09PSBcInNldFwiICYmIG5vZGUudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IGZpbGUuZXJyb3JXaXRoTm9kZShub2RlLnZhbHVlLCBtZXNzYWdlcy5nZXQoXCJzZXR0ZXJzSW52YWxpZFBhcmFtTGVuZ3RoXCIpKTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbGV2ZW5zaHRlaW4gPSByZXF1aXJlKFwibGV2ZW5cIik7XG52YXIgbWVzc2FnZXMgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWVzc2FnZXNcIik7XG52YXIgdCAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vLi4vdHlwZXNcIik7XG5cbmV4cG9ydHMub3B0aW9uYWwgPSB0cnVlO1xuXG5leHBvcnRzLklkZW50aWZpZXIgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgZmlsZSkge1xuICBpZiAoIXQuaXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCkpIHJldHVybjtcbiAgaWYgKHNjb3BlLmhhc0JpbmRpbmcobm9kZS5uYW1lKSkgcmV0dXJuO1xuXG4gIC8vIGdldCB0aGUgY2xvc2VzdCBkZWNsYXJhdGlvbiB0byBvZmZlciBhcyBhIHN1Z2dlc3Rpb25cbiAgLy8gdGhlIHZhcmlhYmxlIG5hbWUgbWF5IGhhdmUganVzdCBiZWVuIG1pc3R5cGVkXG5cbiAgdmFyIGJpbmRpbmdzID0gc2NvcGUuZ2V0QWxsQmluZGluZ3MoKTtcblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIHNob3J0ZXN0ID0gLTE7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBiaW5kaW5ncykge1xuICAgIHZhciBkaXN0YW5jZSA9IGxldmVuc2h0ZWluKG5vZGUubmFtZSwgbmFtZSk7XG4gICAgaWYgKGRpc3RhbmNlIDw9IDAgfHwgZGlzdGFuY2UgPiAzKSBjb250aW51ZTtcbiAgICBpZiAoZGlzdGFuY2UgPD0gc2hvcnRlc3QpIGNvbnRpbnVlO1xuXG4gICAgY2xvc2VzdCA9IG5hbWU7XG4gICAgc2hvcnRlc3QgPSBkaXN0YW5jZTtcbiAgfVxuXG4gIHZhciBtc2c7XG4gIGlmIChjbG9zZXN0KSB7XG4gICAgbXNnID0gbWVzc2FnZXMuZ2V0KFwidW5kZWNsYXJlZFZhcmlhYmxlU3VnZ2VzdGlvblwiLCBub2RlLm5hbWUsIGNsb3Nlc3QpO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IG1lc3NhZ2VzLmdldChcInVuZGVjbGFyZWRWYXJpYWJsZVwiLCBub2RlLm5hbWUpO1xuICB9XG5cbiAgLy9cblxuICB0aHJvdyBmaWxlLmVycm9yV2l0aE5vZGUobm9kZSwgbXNnLCBSZWZlcmVuY2VFcnJvcik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhdmVyc2FsQ29udGV4dDtcblxudmFyIFRyYXZlcnNhbFBhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xudmFyIGZsYXR0ZW4gICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2FycmF5L2ZsYXR0ZW5cIik7XG52YXIgY29tcGFjdCAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvYXJyYXkvY29tcGFjdFwiKTtcblxuZnVuY3Rpb24gVHJhdmVyc2FsQ29udGV4dChzY29wZSwgb3B0cywgc3RhdGUsIHBhcmVudFBhdGgpIHtcbiAgdGhpcy5zaG91bGRGbGF0dGVuID0gZmFsc2U7XG4gIHRoaXMucGFyZW50UGF0aCAgICA9IHBhcmVudFBhdGg7XG5cbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIHRoaXMub3B0cyAgPSBvcHRzO1xufVxuXG5UcmF2ZXJzYWxDb250ZXh0LnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNob3VsZEZsYXR0ZW4gPSB0cnVlO1xufTtcblxuVHJhdmVyc2FsQ29udGV4dC5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG9iaiwga2V5KSB7XG4gIHZhciBpdGVyYXRpb24gPSBuZXcgVHJhdmVyc2FsUGF0aCh0aGlzLCBub2RlLCBvYmosIGtleSk7XG4gIHJldHVybiBpdGVyYXRpb24udmlzaXQoKTtcbn07XG5cblRyYXZlcnNhbENvbnRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICB2YXIgbm9kZXMgPSBub2RlW2tleV07XG4gIGlmICghbm9kZXMpIHJldHVybjtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXROb2RlKG5vZGUsIG5vZGUsIGtleSk7XG4gIH1cblxuICAvLyBub3RoaW5nIHRvIHRyYXZlcnNlIVxuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSAmJiB0aGlzLnZpc2l0Tm9kZShub2RlLCBub2RlcywgaSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnNob3VsZEZsYXR0ZW4pIHtcbiAgICBub2RlW2tleV0gPSBmbGF0dGVuKG5vZGVba2V5XSk7XG5cbiAgICBpZiAoa2V5ID09PSBcImJvZHlcIikge1xuICAgICAgLy8gd2UgY2FuIHNhZmVseSBjb21wYWN0IHRoaXNcbiAgICAgIG5vZGVba2V5XSA9IGNvbXBhY3Qobm9kZVtrZXldKTtcbiAgICB9XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZTtcblxudmFyIFRyYXZlcnNhbENvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0XCIpO1xudmFyIGluY2x1ZGVzICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vaW5jbHVkZXNcIik7XG52YXIgdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gdHJhdmVyc2UocGFyZW50LCBvcHRzLCBzY29wZSwgc3RhdGUpIHtcbiAgaWYgKCFwYXJlbnQpIHJldHVybjtcblxuICBpZiAoIW9wdHMubm9TY29wZSAmJiAhc2NvcGUpIHtcbiAgICBpZiAocGFyZW50LnR5cGUgIT09IFwiUHJvZ3JhbVwiICYmIHBhcmVudC50eXBlICE9PSBcIkZpbGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIGEgc2NvcGUgdW5sZXNzIHRyYXZlcnNpbmcgYSBQcm9ncmFtL0ZpbGUgZ290IGEgXCIgKyBwYXJlbnQudHlwZSArIFwiIG5vZGVcIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGlmICghb3B0cy5lbnRlcikgb3B0cy5lbnRlciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgaWYgKCFvcHRzLmV4aXQpIG9wdHMuZXhpdCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuICAvLyBhcnJheSBvZiBub2Rlc1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYXZlcnNlLm5vZGUocGFyZW50W2ldLCBvcHRzLCBzY29wZSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cmF2ZXJzZS5ub2RlKHBhcmVudCwgb3B0cywgc2NvcGUsIHN0YXRlKTtcbiAgfVxufVxuXG50cmF2ZXJzZS5ub2RlID0gZnVuY3Rpb24gKG5vZGUsIG9wdHMsIHNjb3BlLCBzdGF0ZSwgcGFyZW50UGF0aCkge1xuICB2YXIga2V5cyA9IHQuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuXG4gIHZhciBjb250ZXh0ID0gbmV3IFRyYXZlcnNhbENvbnRleHQoc2NvcGUsIG9wdHMsIHN0YXRlLCBwYXJlbnRQYXRoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvbnRleHQudmlzaXQobm9kZSwga2V5c1tpXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XG4gIG5vZGUuX2RlY2xhcmF0aW9ucyA9IG51bGw7XG4gIG5vZGUuZXh0ZW5kZWRSYW5nZSA9IG51bGw7XG4gIG5vZGUuX3Njb3BlSW5mbyA9IG51bGw7XG4gIG5vZGUudG9rZW5zID0gbnVsbDtcbiAgbm9kZS5yYW5nZSA9IG51bGw7XG4gIG5vZGUuc3RhcnQgPSBudWxsO1xuICBub2RlLmVuZCA9IG51bGw7XG4gIG5vZGUubG9jID0gbnVsbDtcbiAgbm9kZS5yYXcgPSBudWxsO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUudHJhaWxpbmdDb21tZW50cykpIHtcbiAgICBjbGVhckNvbW1lbnRzKG5vZGUudHJhaWxpbmdDb21tZW50cyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlLmxlYWRpbmdDb21tZW50cykpIHtcbiAgICBjbGVhckNvbW1lbnRzKG5vZGUubGVhZGluZ0NvbW1lbnRzKTtcbiAgfVxufVxuXG52YXIgY2xlYXJWaXNpdG9yID0ge1xuICBub1Njb3BlOiB0cnVlLFxuICBlbnRlcjogY2xlYXJOb2RlXG59O1xuXG5mdW5jdGlvbiBjbGVhckNvbW1lbnRzKGNvbW1lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjbGVhck5vZGUoY29tbWVudHNbaV0pO1xuICB9XG59XG5cbnRyYXZlcnNlLnJlbW92ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHJlZSkge1xuICBjbGVhck5vZGUodHJlZSk7XG4gIHRyYXZlcnNlKHRyZWUsIGNsZWFyVmlzaXRvcik7XG5cbiAgcmV0dXJuIHRyZWU7XG59O1xuXG50cmF2ZXJzZS5leHBsb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICBmb3IgKHZhciB0eXBlIGluIG9iaikge1xuICAgIHZhciBmbnMgPSBvYmpbdHlwZV07XG5cbiAgICB2YXIgYWxpYXNlcyA9IHQuRkxJUFBFRF9BTElBU19LRVlTW3R5cGVdO1xuICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JqW2FsaWFzZXNbaV1dID0gZm5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gaGFzQmxhY2tsaXN0ZWRUeXBlKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IHN0YXRlLnR5cGUpIHtcbiAgICBzdGF0ZS5oYXMgPSB0cnVlO1xuICAgIHRoaXMuc2tpcCgpO1xuICB9XG59XG5cbnRyYXZlcnNlLmhhc1R5cGUgPSBmdW5jdGlvbiAodHJlZSwgc2NvcGUsIHR5cGUsIGJsYWNrbGlzdFR5cGVzKSB7XG4gIC8vIHRoZSBub2RlIHdlJ3JlIHNlYXJjaGluZyBpbiBpcyBibGFja2xpc3RlZFxuICBpZiAoaW5jbHVkZXMoYmxhY2tsaXN0VHlwZXMsIHRyZWUudHlwZSkpIHJldHVybiBmYWxzZTtcblxuICAvLyB0aGUgdHlwZSB3ZSdyZSBsb29raW5nIGZvciBpcyB0aGUgc2FtZSBhcyB0aGUgcGFzc2VkIG5vZGVcbiAgaWYgKHRyZWUudHlwZSA9PT0gdHlwZSkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGhhczogIGZhbHNlLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcblxuICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgYmxhY2tsaXN0OiBibGFja2xpc3RUeXBlcyxcbiAgICBlbnRlcjogaGFzQmxhY2tsaXN0ZWRUeXBlXG4gIH0sIHNjb3BlLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLmhhcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmF2ZXJzYWxQYXRoO1xuXG4vKiBqc2hpbnQgbWF4cGFyYW1zOjcgKi9cblxudmFyIHRyYXZlcnNlID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG52YXIgaW5jbHVkZXMgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vaW5jbHVkZXNcIik7XG52YXIgU2NvcGUgICAgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciB0ICAgICAgICA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcblxuZnVuY3Rpb24gVHJhdmVyc2FsUGF0aChjb250ZXh0LCBwYXJlbnQsIG9iaiwga2V5KSB7XG4gIHRoaXMuc2hvdWxkUmVtb3ZlID0gZmFsc2U7XG4gIHRoaXMuc2hvdWxkU2tpcCAgID0gZmFsc2U7XG4gIHRoaXMuc2hvdWxkU3RvcCAgID0gZmFsc2U7XG5cbiAgdGhpcy5wYXJlbnRQYXRoID0gY29udGV4dC5wYXJlbnRQYXRoO1xuICB0aGlzLmNvbnRleHQgICAgPSBjb250ZXh0O1xuICB0aGlzLnN0YXRlICAgICAgPSB0aGlzLmNvbnRleHQuc3RhdGU7XG4gIHRoaXMub3B0cyAgICAgICA9IHRoaXMuY29udGV4dC5vcHRzO1xuXG4gIHRoaXMua2V5ICAgICA9IGtleTtcbiAgdGhpcy5vYmogICAgID0gb2JqO1xuXG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLnNjb3BlICA9IFRyYXZlcnNhbFBhdGguZ2V0U2NvcGUodGhpcy5nZXROb2RlKCksIHBhcmVudCwgY29udGV4dC5zY29wZSk7XG4gIHRoaXMuc3RhdGUgID0gY29udGV4dC5zdGF0ZTtcbn1cblxuVHJhdmVyc2FsUGF0aC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNob3VsZFJlbW92ZSA9IHRydWU7XG4gIHRoaXMuc2hvdWxkU2tpcCAgID0gdHJ1ZTtcbn07XG5cblRyYXZlcnNhbFBhdGgucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2hvdWxkU2tpcCA9IHRydWU7XG59O1xuXG5UcmF2ZXJzYWxQYXRoLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNob3VsZFN0b3AgPSB0cnVlO1xuICB0aGlzLnNob3VsZFNraXAgPSB0cnVlO1xufTtcblxuVHJhdmVyc2FsUGF0aC5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250ZXh0LmZsYXR0ZW4oKTtcbn07XG5cblRyYXZlcnNhbFBhdGguZ2V0U2NvcGUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSkge1xuICB2YXIgb3VyU2NvcGUgPSBzY29wZTtcblxuICAvLyB3ZSdyZSBlbnRlcmluZyBhIG5ldyBzY29wZSBzbyBsZXQncyBjb25zdHJ1Y3QgaXQhXG4gIGlmICh0LmlzU2NvcGUobm9kZSwgcGFyZW50KSkge1xuICAgIG91clNjb3BlID0gbmV3IFNjb3BlKG5vZGUsIHBhcmVudCwgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIG91clNjb3BlO1xufTtcblxuVHJhdmVyc2FsUGF0aC5wcm90b3R5cGUubWF5YmVSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNob3VsZFJlbW92ZSkge1xuICAgIHRoaXMuc2V0Tm9kZShudWxsKTtcbiAgICB0aGlzLmZsYXR0ZW4oKTtcbiAgfVxufTtcblxuVHJhdmVyc2FsUGF0aC5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHRoaXMub2JqW3RoaXMua2V5XSA9IHZhbDtcbn07XG5cblRyYXZlcnNhbFBhdGgucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm9ialt0aGlzLmtleV07XG59O1xuXG5UcmF2ZXJzYWxQYXRoLnByb3RvdHlwZS5yZXBsYWNlTm9kZSA9IGZ1bmN0aW9uIChyZXBsYWNlbWVudCkge1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpO1xuXG4gIC8vIGluaGVyaXQgY29tbWVudHMgZnJvbSBvcmlnaW5hbCBub2RlIHRvIHRoZSBmaXJzdCByZXBsYWNlbWVudCBub2RlXG4gIHZhciBpbmhlcml0VG8gPSByZXBsYWNlbWVudDtcbiAgaWYgKGlzQXJyYXkpIGluaGVyaXRUbyA9IHJlcGxhY2VtZW50WzBdO1xuICBpZiAoaW5oZXJpdFRvKSB0LmluaGVyaXRzQ29tbWVudHMoaW5oZXJpdFRvLCB0aGlzLmdldE5vZGUoKSk7XG5cbiAgLy8gcmVwbGFjZSB0aGUgbm9kZVxuICB0aGlzLnNldE5vZGUocmVwbGFjZW1lbnQpO1xuXG4gIHZhciBmaWxlID0gdGhpcy5zY29wZSAmJiB0aGlzLnNjb3BlLmZpbGU7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmlsZS5jaGVja05vZGUocmVwbGFjZW1lbnRbaV0sIHRoaXMuc2NvcGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLmNoZWNrTm9kZShyZXBsYWNlbWVudCwgdGhpcy5zY29wZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gd2UncmUgcmVwbGFjaW5nIGEgc3RhdGVtZW50IG9yIGJsb2NrIG5vZGUgd2l0aCBhbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHNvIHdlIGJldHRlclxuICAvLyBlbnN1cmUgdGhhdCBpdCdzIGEgYmxvY2tcbiAgaWYgKGlzQXJyYXkpIHtcbiAgICBpZiAoaW5jbHVkZXModC5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUywgdGhpcy5rZXkpICYmICF0LmlzQmxvY2tTdGF0ZW1lbnQodGhpcy5vYmopKSB7XG4gICAgICB0LmVuc3VyZUJsb2NrKHRoaXMub2JqLCB0aGlzLmtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5mbGF0dGVuKCk7XG4gIH1cbn07XG5cblRyYXZlcnNhbFBhdGgucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICB2YXIgZm4gICA9IG9wdHNba2V5XSB8fCBvcHRzO1xuICBpZiAob3B0c1tub2RlLnR5cGVdKSBmbiA9IG9wdHNbbm9kZS50eXBlXVtrZXldIHx8IGZuO1xuXG4gIHZhciByZXBsYWNlbWVudCA9IGZuLmNhbGwodGhpcywgbm9kZSwgdGhpcy5wYXJlbnQsIHRoaXMuc2NvcGUsIHRoaXMuc3RhdGUpO1xuXG4gIGlmIChyZXBsYWNlbWVudCkge1xuICAgIHRoaXMucmVwbGFjZU5vZGUocmVwbGFjZW1lbnQpO1xuICAgIG5vZGUgPSByZXBsYWNlbWVudDtcbiAgfVxuXG4gIHRoaXMubWF5YmVSZW1vdmUoKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cblRyYXZlcnNhbFBhdGgucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcblxuICAvLyB0eXBlIGlzIGJsYWNrbGlzdGVkXG4gIGlmIChvcHRzLmJsYWNrbGlzdCAmJiBvcHRzLmJsYWNrbGlzdC5pbmRleE9mKG5vZGUudHlwZSkgPiAtMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2FsbChcImVudGVyXCIpO1xuXG4gIGlmICh0aGlzLnNob3VsZFNraXApIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xuICB9XG5cbiAgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgLy8gdHJhdmVyc2Ugb3ZlciB0aGVzZSByZXBsYWNlbWVudCBub2RlcyB3ZSBwdXJwb3NlbHkgZG9uJ3QgY2FsbCBleGl0Tm9kZVxuICAgIC8vIGFzIHRoZSBvcmlnaW5hbCBub2RlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2Uubm9kZShub2RlW2ldLCBvcHRzLCB0aGlzLnNjb3BlLCB0aGlzLnN0YXRlLCB0aGlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2Uubm9kZShub2RlLCBvcHRzLCB0aGlzLnNjb3BlLCB0aGlzLnN0YXRlLCB0aGlzKTtcbiAgICB0aGlzLmNhbGwoXCJleGl0XCIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2hvdWxkU3RvcDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBTY29wZTtcblxudmFyIGluY2x1ZGVzID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2luY2x1ZGVzXCIpO1xudmFyIHRyYXZlcnNlID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC9kZWZhdWx0c1wiKTtcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciBnbG9iYWxzICA9IHJlcXVpcmUoXCJnbG9iYWxzXCIpO1xudmFyIGZsYXR0ZW4gID0gcmVxdWlyZShcImxvZGFzaC9hcnJheS9mbGF0dGVuXCIpO1xudmFyIGV4dGVuZCAgID0gcmVxdWlyZShcImxvZGFzaC9vYmplY3QvZXh0ZW5kXCIpO1xudmFyIG9iamVjdCAgID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvb2JqZWN0XCIpO1xudmFyIGVhY2ggICAgID0gcmVxdWlyZShcImxvZGFzaC9jb2xsZWN0aW9uL2VhY2hcIik7XG52YXIgdCAgICAgICAgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5cbi8qKlxuICogVGhpcyBzZWFyY2hlcyB0aGUgY3VycmVudCBcInNjb3BlXCIgYW5kIGNvbGxlY3RzIGFsbCByZWZlcmVuY2VzL2JpbmRpbmdzXG4gKiB3aXRoaW4uXG4gKlxuICogQHBhcmFtIHtOb2RlfSBibG9ja1xuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRCbG9ja1xuICogQHBhcmFtIHtTY29wZX0gW3BhcmVudF1cbiAqIEBwYXJhbSB7RmlsZX0gW2ZpbGVdXG4gKi9cblxuZnVuY3Rpb24gU2NvcGUoYmxvY2ssIHBhcmVudEJsb2NrLCBwYXJlbnQsIGZpbGUpIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuZmlsZSAgID0gcGFyZW50ID8gcGFyZW50LmZpbGUgOiBmaWxlO1xuXG4gIHRoaXMucGFyZW50QmxvY2sgPSBwYXJlbnRCbG9jaztcbiAgdGhpcy5ibG9jayAgICAgICA9IGJsb2NrO1xuXG4gIHRoaXMuY3Jhd2woKTtcbn1cblxuU2NvcGUuZ2xvYmFscyA9IGZsYXR0ZW4oW2dsb2JhbHMuYnVpbHRpbiwgZ2xvYmFscy5icm93c2VyLCBnbG9iYWxzLm5vZGVdLm1hcChPYmplY3Qua2V5cykpO1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0gW3N0YXRlXVxuICovXG5cblNjb3BlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRzLCBzdGF0ZSkge1xuICB0cmF2ZXJzZShub2RlLCBvcHRzLCB0aGlzLCBzdGF0ZSk7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lPVwidGVtcFwiXVxuICovXG5cblNjb3BlLnByb3RvdHlwZS5nZW5lcmF0ZVRlbXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaWQgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllcihuYW1lIHx8IFwidGVtcFwiKTtcbiAgdGhpcy5wdXNoKHtcbiAgICBrZXk6IGlkLm5hbWUsXG4gICAgaWQ6IGlkXG4gIH0pO1xuICByZXR1cm4gaWQ7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuXG5TY29wZS5wcm90b3R5cGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGlkID0gdC5pZGVudGlmaWVyKHRoaXMuZ2VuZXJhdGVVaWQobmFtZSkpO1xuICB0aGlzLmdldEZ1bmN0aW9uUGFyZW50KCkucmVnaXN0ZXJCaW5kaW5nKFwidWlkXCIsIGlkKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cblxuU2NvcGUucHJvdG90eXBlLmdlbmVyYXRlVWlkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgbmFtZSA9IHQudG9JZGVudGlmaWVyKG5hbWUpLnJlcGxhY2UoL15fKy8sIFwiXCIpO1xuXG4gIHZhciB1aWQ7XG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHVpZCA9IHRoaXMuX2dlbmVyYXRlVWlkKG5hbWUsIGkpO1xuICAgIGkrKztcbiAgfSB3aGlsZSAodGhpcy5oYXNCaW5kaW5nKHVpZCkgfHwgdGhpcy5oYXNHbG9iYWwodWlkKSk7XG4gIHJldHVybiB1aWQ7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuX2dlbmVyYXRlVWlkID0gZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgdmFyIGlkID0gbmFtZTtcbiAgaWYgKGkgPiAxKSBpZCArPSBpO1xuICByZXR1cm4gXCJfXCIgKyBpZDtcbn07XG5cbi8qXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuU2NvcGUucHJvdG90eXBlLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIGlmICh0LmlzQXNzaWdubWVudEV4cHJlc3Npb24ocGFyZW50KSkge1xuICAgIG5vZGUgPSBwYXJlbnQubGVmdDtcbiAgfSBlbHNlIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdG9yKHBhcmVudCkpIHtcbiAgICBub2RlID0gcGFyZW50LmlkO1xuICB9IGVsc2UgaWYgKHQuaXNQcm9wZXJ0eShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlLmtleTtcbiAgfVxuXG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIHZhciBhZGQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgYWRkKG5vZGUub2JqZWN0KTtcbiAgICAgIGFkZChub2RlLnByb3BlcnR5KTtcbiAgICB9IGVsc2UgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgICBwYXJ0cy5wdXNoKG5vZGUubmFtZSk7XG4gICAgfSBlbHNlIGlmICh0LmlzTGl0ZXJhbChub2RlKSkge1xuICAgICAgcGFydHMucHVzaChub2RlLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgYWRkKG5vZGUuY2FsbGVlKTtcbiAgICB9XG4gIH07XG5cbiAgYWRkKG5vZGUpO1xuXG4gIHZhciBpZCA9IHBhcnRzLmpvaW4oXCIkXCIpO1xuICBpZCA9IGlkLnJlcGxhY2UoL15fLywgXCJcIikgfHwgXCJyZWZcIjtcblxuICByZXR1cm4gdGhpcy5nZW5lcmF0ZVVpZElkZW50aWZpZXIoaWQpO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cblNjb3BlLnByb3RvdHlwZS5nZW5lcmF0ZVRlbXBCYXNlZE9uTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0LmlzSWRlbnRpZmllcihub2RlKSAmJiB0aGlzLmhhc0JpbmRpbmcobm9kZS5uYW1lKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlkID0gdGhpcy5nZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKG5vZGUpO1xuICB0aGlzLnB1c2goe1xuICAgIGtleTogaWQubmFtZSxcbiAgICBpZDogaWRcbiAgfSk7XG4gIHJldHVybiBpZDtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5jaGVja0Jsb2NrU2NvcGVkQ29sbGlzaW9ucyA9IGZ1bmN0aW9uIChraW5kLCBuYW1lLCBpZCkge1xuICB2YXIgbG9jYWwgPSB0aGlzLmdldE93bkJpbmRpbmdJbmZvKG5hbWUpO1xuICBpZiAoIWxvY2FsKSByZXR1cm47XG5cbiAgaWYgKGtpbmQgPT09IFwicGFyYW1cIikgcmV0dXJuO1xuICBpZiAoa2luZCA9PT0gXCJob2lzdGVkXCIgJiYgbG9jYWwua2luZCA9PT0gXCJsZXRcIikgcmV0dXJuO1xuXG4gIGlmIChsb2NhbC5raW5kID09PSBcImxldFwiIHx8IGxvY2FsLmtpbmQgPT09IFwiY29uc3RcIiB8fCBsb2NhbC5raW5kID09PSBcIm1vZHVsZVwiKSB7XG4gICAgdGhyb3cgdGhpcy5maWxlLmVycm9yV2l0aE5vZGUoaWQsIG1lc3NhZ2VzLmdldChcInNjb3BlRHVwbGljYXRlRGVjbGFyYXRpb25cIiwgbmFtZSksIFR5cGVFcnJvcik7XG4gIH1cbn07XG5cblNjb3BlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSkge1xuICBuZXdOYW1lID0gbmV3TmFtZSB8fCB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllcihvbGROYW1lKS5uYW1lO1xuXG4gIHZhciBpbmZvID0gdGhpcy5nZXRCaW5kaW5nSW5mbyhvbGROYW1lKTtcbiAgaWYgKCFpbmZvKSByZXR1cm47XG5cbiAgdmFyIGJpbmRpbmcgPSBpbmZvLmlkZW50aWZpZXI7XG4gIHZhciBzY29wZSA9IGluZm8uc2NvcGU7XG5cbiAgc2NvcGUudHJhdmVyc2Uoc2NvcGUuYmxvY2ssIHtcbiAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUpIHtcbiAgICAgIGlmICh0LmlzUmVmZXJlbmNlZElkZW50aWZpZXIobm9kZSwgcGFyZW50KSAmJiBub2RlLm5hbWUgPT09IG9sZE5hbWUpIHtcbiAgICAgICAgbm9kZS5uYW1lID0gbmV3TmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodC5pc0RlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICAgIHZhciBpZHMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycyhub2RlKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBpZHMpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gb2xkTmFtZSkgaWRzW25hbWVdLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHQuaXNTY29wZShub2RlLCBwYXJlbnQpKSB7XG4gICAgICAgIGlmICghc2NvcGUuYmluZGluZ0lkZW50aWZpZXJFcXVhbHMob2xkTmFtZSwgYmluZGluZykpIHtcbiAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jbGVhck93bkJpbmRpbmcob2xkTmFtZSk7XG4gIHNjb3BlLmJpbmRpbmdzW25ld05hbWVdID0gaW5mbztcblxuICBiaW5kaW5nLm5hbWUgPSBuZXdOYW1lO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmluZmVyVHlwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkpIHtcbiAgICB0YXJnZXQgPSBub2RlLmluaXQ7XG4gIH1cblxuICBpZiAodC5pc0FycmF5RXhwcmVzc2lvbih0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKHQuaWRlbnRpZmllcihcIkFycmF5XCIpKTtcbiAgfVxuXG4gIGlmICh0LmlzT2JqZWN0RXhwcmVzc2lvbih0YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHQuaXNMaXRlcmFsKHRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodC5pc0NhbGxFeHByZXNzaW9uKHRhcmdldCkgJiYgdC5pc0lkZW50aWZpZXIodGFyZ2V0LmNhbGxlZSkpIHtcbiAgICB2YXIgZnVuY0luZm8gPSB0aGlzLmdldEJpbmRpbmdJbmZvKHRhcmdldC5jYWxsZWUubmFtZSk7XG4gICAgaWYgKGZ1bmNJbmZvKSB7XG4gICAgICB2YXIgZnVuY05vZGUgPSBmdW5jSW5mby5ub2RlO1xuICAgICAgcmV0dXJuICFmdW5jSW5mby5yZWFzc2lnbmVkICYmIHQuaXNGdW5jdGlvbihmdW5jTm9kZSkgJiYgbm9kZS5yZXR1cm5UeXBlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0LmlzSWRlbnRpZmllcih0YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5TY29wZS5wcm90b3R5cGUuaXNUeXBlR2VuZXJpYyA9IGZ1bmN0aW9uIChuYW1lLCBnZW5lcmljTmFtZSkge1xuICB2YXIgaW5mbyA9IHRoaXMuZ2V0QmluZGluZ0luZm8obmFtZSk7XG4gIGlmICghaW5mbykgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciB0eXBlID0gaW5mby50eXBlQW5ub3RhdGlvbjtcbiAgcmV0dXJuIHQuaXNHZW5lcmljVHlwZUFubm90YXRpb24odHlwZSkgJiYgdC5pc0lkZW50aWZpZXIodHlwZS5pZCwgeyBuYW1lOiBnZW5lcmljTmFtZSB9KTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5hc3NpZ25UeXBlR2VuZXJpYyA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XG4gIHRoaXMuYXNzaWduVHlwZShuYW1lLCB0LmdlbmVyaWNUeXBlQW5ub3RhdGlvbih0LmlkZW50aWZpZXIodHlwZSkpKTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5hc3NpZ25UeXBlID0gZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgdmFyIGluZm8gPSB0aGlzLmdldEJpbmRpbmdJbmZvKG5hbWUpO1xuICBpZiAoIWluZm8pIHJldHVybjtcblxuICBpbmZvLmlkZW50aWZpZXIudHlwZUFubm90YXRpb24gPSBpbmZvLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXRUeXBlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBpZCwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBhbm5vdGF0aW9uOiBudWxsLFxuICAgIGluZmVycmVkOiBmYWxzZVxuICB9O1xuXG4gIHZhciB0eXBlO1xuXG4gIGlmIChpZC50eXBlQW5ub3RhdGlvbikge1xuICAgIHR5cGUgPSBpZC50eXBlQW5ub3RhdGlvbjtcbiAgfVxuXG4gIGlmICghdHlwZSkge1xuICAgIGluZm8uaW5mZXJyZWQgPSB0cnVlO1xuICAgIHR5cGUgPSB0aGlzLmluZmVyVHlwZShub2RlKTtcbiAgfVxuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKHQuaXNUeXBlQW5ub3RhdGlvbih0eXBlKSkgdHlwZSA9IHR5cGUudHlwZUFubm90YXRpb247XG4gICAgaW5mby5hbm5vdGF0aW9uID0gdHlwZTtcbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAobm9kZSwgaSkge1xuICB2YXIgZmlsZSA9IHRoaXMuZmlsZTtcblxuICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkgJiYgdGhpcy5pc1R5cGVHZW5lcmljKG5vZGUubmFtZSwgXCJBcnJheVwiKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKHQuaXNBcnJheUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGlmICh0LmlzSWRlbnRpZmllcihub2RlLCB7IG5hbWU6IFwiYXJndW1lbnRzXCIgfSkpIHtcbiAgICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbih0Lm1lbWJlckV4cHJlc3Npb24oZmlsZS5hZGRIZWxwZXIoXCJzbGljZVwiKSwgdC5pZGVudGlmaWVyKFwiY2FsbFwiKSksIFtub2RlXSk7XG4gIH1cblxuICB2YXIgaGVscGVyTmFtZSA9IFwidG8tYXJyYXlcIjtcbiAgdmFyIGFyZ3MgPSBbbm9kZV07XG4gIGlmIChpID09PSB0cnVlKSB7XG4gICAgaGVscGVyTmFtZSA9IFwidG8tY29uc3VtYWJsZS1hcnJheVwiO1xuICB9IGVsc2UgaWYgKGkpIHtcbiAgICBhcmdzLnB1c2godC5saXRlcmFsKGkpKTtcbiAgICBoZWxwZXJOYW1lID0gXCJzbGljZWQtdG8tYXJyYXlcIjtcbiAgfVxuICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihmaWxlLmFkZEhlbHBlcihoZWxwZXJOYW1lKSwgYXJncyk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuY2xlYXJPd25CaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMuYmluZGluZ3NbbmFtZV07XG59O1xuXG5TY29wZS5wcm90b3R5cGUucmVnaXN0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0LmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSkge1xuICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwiaG9pc3RlZFwiLCBub2RlKTtcbiAgfSBlbHNlIGlmICh0LmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKG5vZGUua2luZCwgbm9kZS5kZWNsYXJhdGlvbnNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0LmlzQ2xhc3NEZWNsYXJhdGlvbihub2RlKSkge1xuICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwibGV0XCIsIG5vZGUpO1xuICB9IGVsc2UgaWYgKHQuaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSB8fCB0LmlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcIm1vZHVsZVwiLCBub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcInVua25vd25cIiwgbm9kZSk7XG4gIH1cbn07XG5cblNjb3BlLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmdSZWFzc2lnbm1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWRzID0gdC5nZXRCaW5kaW5nSWRlbnRpZmllcnMobm9kZSk7XG4gIGZvciAodmFyIG5hbWUgaW4gaWRzKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmdldEJpbmRpbmdJbmZvKG5hbWUpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLnJlYXNzaWduZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoaW5mby50eXBlQW5ub3RhdGlvbkluZmVycmVkKSB7XG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIGluZmVycmVkIHR5cGVBbm5vdGF0aW9uXG4gICAgICAgIGluZm8udHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuU2NvcGUucHJvdG90eXBlLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uIChraW5kLCBub2RlKSB7XG4gIGlmICgha2luZCkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwibm8gYGtpbmRgXCIpO1xuXG4gIHZhciBpZHMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycyhub2RlKTtcblxuICBmb3IgKHZhciBuYW1lIGluIGlkcykge1xuICAgIHZhciBpZCA9IGlkc1tuYW1lXTtcblxuICAgIHRoaXMuY2hlY2tCbG9ja1Njb3BlZENvbGxpc2lvbnMoa2luZCwgbmFtZSwgaWQpO1xuXG4gICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbihuYW1lLCBpZCwgbm9kZSk7XG5cbiAgICB0aGlzLmJpbmRpbmdzW25hbWVdID0ge1xuICAgICAgdHlwZUFubm90YXRpb25JbmZlcnJlZDogdHlwZUluZm8uaW5mZXJyZWQsXG4gICAgICB0eXBlQW5ub3RhdGlvbjogICAgICAgICB0eXBlSW5mby5hbm5vdGF0aW9uLFxuICAgICAgcmVhc3NpZ25lZDogICAgICAgICAgICAgZmFsc2UsXG4gICAgICBpZGVudGlmaWVyOiAgICAgICAgICAgICBpZCxcbiAgICAgIHNjb3BlOiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICBub2RlOiAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAga2luZDogICAgICAgICAgICAgICAgICAga2luZFxuICAgIH07XG4gIH1cbn07XG5cblNjb3BlLnByb3RvdHlwZS5yZWdpc3RlclZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoZGVjbGFyKSB7XG4gIHZhciBkZWNsYXJzID0gZGVjbGFyLmRlY2xhcmF0aW9ucztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNsYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoZGVjbGFyc1tpXSwgZGVjbGFyLmtpbmQpO1xuICB9XG59O1xuXG52YXIgZnVuY3Rpb25WYXJpYWJsZVZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAodC5pc0Zvcihub2RlKSkge1xuICAgICAgZWFjaCh0LkZPUl9JTklUX0tFWVMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGRlY2xhciA9IG5vZGVba2V5XTtcbiAgICAgICAgaWYgKHQuaXNWYXIoZGVjbGFyKSkgc3RhdGUuc2NvcGUucmVnaXN0ZXJCaW5kaW5nKFwidmFyXCIsIGRlY2xhcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGJsb2NrIGlzIGEgZnVuY3Rpb24gc28gd2UnbGwgc3RvcCBzaW5jZSBub25lIG9mIHRoZSB2YXJpYWJsZXNcbiAgICAvLyBkZWNsYXJlZCB3aXRoaW4gYXJlIGFjY2Vzc2libGVcbiAgICBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSByZXR1cm4gdGhpcy5za2lwKCk7XG5cbiAgICAvLyBmdW5jdGlvbiBpZGVudGlmaWVyIGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgc2NvcGVcbiAgICBpZiAoc3RhdGUuYmxvY2tJZCAmJiBub2RlID09PSBzdGF0ZS5ibG9ja0lkKSByZXR1cm47XG5cbiAgICAvLyBkZWxlZ2F0ZSBibG9jayBzY29wZSBoYW5kbGluZyB0byB0aGUgYGJsb2NrVmFyaWFibGVWaXNpdG9yYFxuICAgIGlmICh0LmlzQmxvY2tTY29wZWQobm9kZSkpIHJldHVybjtcblxuICAgIC8vIHRoaXMgd2lsbCBiZSBoaXQgYWdhaW4gb25jZSB3ZSB0cmF2ZXJzZSBpbnRvIGl0IGFmdGVyIHRoaXMgaXRlcmF0aW9uXG4gICAgaWYgKHQuaXNFeHBvcnREZWNsYXJhdGlvbihub2RlKSAmJiB0LmlzRGVjbGFyYXRpb24obm9kZS5kZWNsYXJhdGlvbikpIHJldHVybjtcblxuICAgIC8vIHdlJ3ZlIHJhbiBpbnRvIGEgZGVjbGFyYXRpb24hXG4gICAgaWYgKHQuaXNEZWNsYXJhdGlvbihub2RlKSkgc3RhdGUuc2NvcGUucmVnaXN0ZXJEZWNsYXJhdGlvbihub2RlKTtcbiAgfVxufTtcblxuU2NvcGUucHJvdG90eXBlLmFkZEdsb2JhbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMuZ2xvYmFsc1tub2RlLm5hbWVdID0gbm9kZTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5oYXNHbG9iYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIGRvIHtcbiAgICBpZiAoc2NvcGUuZ2xvYmFsc1tuYW1lXSkgcmV0dXJuIHRydWU7XG4gIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgcHJvZ3JhbVJlZmVyZW5jZVZpc2l0b3IgPSB7XG4gIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzY29wZSwgc3RhdGUpIHtcbiAgICBpZiAodC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKG5vZGUsIHBhcmVudCkgJiYgIXNjb3BlLmhhc0JpbmRpbmcobm9kZS5uYW1lKSkge1xuICAgICAgc3RhdGUuYWRkR2xvYmFsKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodC5pc0xhYmVsZWRTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIHN0YXRlLmFkZEdsb2JhbChub2RlKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB8fCB0LmlzVXBkYXRlRXhwcmVzc2lvbihub2RlKSB8fCAodC5pc1VuYXJ5RXhwcmVzc2lvbihub2RlKSAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiKSkge1xuICAgICAgc2NvcGUucmVnaXN0ZXJCaW5kaW5nUmVhc3NpZ25tZW50KG5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGJsb2NrVmFyaWFibGVWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIHN0YXRlKSB7XG4gICAgaWYgKHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpIHx8IHQuaXNCbG9ja1Njb3BlZChub2RlKSkge1xuICAgICAgc3RhdGUucmVnaXN0ZXJEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHQuaXNTY29wZShub2RlLCBwYXJlbnQpKSB7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gIH1cbn07XG5cblNjb3BlLnByb3RvdHlwZS5jcmF3bCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJsb2NrICA9IHRoaXMuYmxvY2s7XG4gIHZhciBpO1xuXG4gIC8vXG5cbiAgdmFyIGluZm8gPSBibG9jay5fc2NvcGVJbmZvO1xuICBpZiAoaW5mbykge1xuICAgIGV4dGVuZCh0aGlzLCBpbmZvKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbmZvID0gYmxvY2suX3Njb3BlSW5mbyA9IHtcbiAgICBiaW5kaW5nczogb2JqZWN0KCksXG4gICAgZ2xvYmFsczogIG9iamVjdCgpXG4gIH07XG5cbiAgZXh0ZW5kKHRoaXMsIGluZm8pO1xuXG4gIC8vIEZvclN0YXRlbWVudCAtIGxlZnQsIGluaXRcblxuICBpZiAodC5pc0xvb3AoYmxvY2spKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHQuRk9SX0lOSVRfS0VZUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBibG9ja1t0LkZPUl9JTklUX0tFWVNbaV1dO1xuICAgICAgaWYgKHQuaXNCbG9ja1Njb3BlZChub2RlKSkgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJsZXRcIiwgbm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHQuaXNCbG9ja1N0YXRlbWVudChibG9jay5ib2R5KSkge1xuICAgICAgYmxvY2sgPSBibG9jay5ib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbiAtIGlkXG5cbiAgaWYgKHQuaXNGdW5jdGlvbkV4cHJlc3Npb24oYmxvY2spICYmIGJsb2NrLmlkKSB7XG4gICAgaWYgKCF0LmlzUHJvcGVydHkodGhpcy5wYXJlbnRCbG9jaywgeyBtZXRob2Q6IHRydWUgfSkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwidmFyXCIsIGJsb2NrLmlkKTtcbiAgICB9XG4gIH1cblxuICAvLyBGdW5jdGlvbiAtIHBhcmFtcywgcmVzdFxuXG4gIGlmICh0LmlzRnVuY3Rpb24oYmxvY2spKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJwYXJhbVwiLCBibG9jay5wYXJhbXNbaV0pO1xuICAgIH1cbiAgICB0aGlzLnRyYXZlcnNlKGJsb2NrLmJvZHksIGJsb2NrVmFyaWFibGVWaXNpdG9yLCB0aGlzKTtcbiAgfVxuXG4gIC8vIFByb2dyYW0sIEJsb2NrU3RhdGVtZW50LCBGdW5jdGlvbiAtIGxldCB2YXJpYWJsZXNcblxuICBpZiAodC5pc0Jsb2NrU3RhdGVtZW50KGJsb2NrKSB8fCB0LmlzUHJvZ3JhbShibG9jaykpIHtcbiAgICB0aGlzLnRyYXZlcnNlKGJsb2NrLCBibG9ja1ZhcmlhYmxlVmlzaXRvciwgdGhpcyk7XG4gIH1cblxuICAvLyBDYXRjaENsYXVzZSAtIHBhcmFtXG5cbiAgaWYgKHQuaXNDYXRjaENsYXVzZShibG9jaykpIHtcbiAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcImxldFwiLCBibG9jay5wYXJhbSk7XG4gIH1cblxuICAvLyBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiAtIGJsb2Nrc1xuXG4gIGlmICh0LmlzQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24oYmxvY2spKSB7XG4gICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoXCJsZXRcIiwgYmxvY2spO1xuICB9XG5cbiAgLy8gUHJvZ3JhbSwgRnVuY3Rpb24gLSB2YXIgdmFyaWFibGVzXG5cbiAgaWYgKHQuaXNQcm9ncmFtKGJsb2NrKSB8fCB0LmlzRnVuY3Rpb24oYmxvY2spKSB7XG4gICAgdGhpcy50cmF2ZXJzZShibG9jaywgZnVuY3Rpb25WYXJpYWJsZVZpc2l0b3IsIHtcbiAgICAgIGJsb2NrSWQ6IGJsb2NrLmlkLFxuICAgICAgc2NvcGU6ICAgdGhpc1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUHJvZ3JhbVxuXG4gIGlmICh0LmlzUHJvZ3JhbShibG9jaykpIHtcbiAgICB0aGlzLnRyYXZlcnNlKGJsb2NrLCBwcm9ncmFtUmVmZXJlbmNlVmlzaXRvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cblNjb3BlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIGJsb2NrID0gdGhpcy5ibG9jaztcblxuICBpZiAodC5pc0xvb3AoYmxvY2spIHx8IHQuaXNDYXRjaENsYXVzZShibG9jaykgfHwgdC5pc0Z1bmN0aW9uKGJsb2NrKSkge1xuICAgIHQuZW5zdXJlQmxvY2soYmxvY2spO1xuICAgIGJsb2NrID0gYmxvY2suYm9keTtcbiAgfVxuXG4gIGlmICh0LmlzQmxvY2tTdGF0ZW1lbnQoYmxvY2spIHx8IHQuaXNQcm9ncmFtKGJsb2NrKSkge1xuICAgIGJsb2NrLl9kZWNsYXJhdGlvbnMgPSBibG9jay5fZGVjbGFyYXRpb25zIHx8IHt9O1xuICAgIGJsb2NrLl9kZWNsYXJhdGlvbnNbb3B0cy5rZXldID0ge1xuICAgICAga2luZDogb3B0cy5raW5kLFxuICAgICAgaWQ6IG9wdHMuaWQsXG4gICAgICBpbml0OiBvcHRzLmluaXRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgYWRkIGEgZGVjbGFyYXRpb24gaGVyZSBpbiBub2RlIHR5cGUgXCIgKyBibG9jay50eXBlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHVwIHRoZSBzY29wZSB0cmVlIHVudGlsIHdlIGhpdCBlaXRoZXIgYSBGdW5jdGlvbiBvciByZWFjaCB0aGVcbiAqIHZlcnkgdG9wIGFuZCBoaXQgUHJvZ3JhbS5cbiAqL1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0RnVuY3Rpb25QYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzY29wZSA9IHRoaXM7XG4gIHdoaWxlIChzY29wZS5wYXJlbnQgJiYgIXQuaXNGdW5jdGlvbihzY29wZS5ibG9jaykpIHtcbiAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgfVxuICByZXR1cm4gc2NvcGU7XG59O1xuXG4vKipcbiAqIFdhbGtzIHRoZSBzY29wZSB0cmVlIGFuZCBnYXRoZXJzICoqYWxsKiogYmluZGluZ3MuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0QWxsQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZHMgPSBvYmplY3QoKTtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuICBkbyB7XG4gICAgZGVmYXVsdHMoaWRzLCBzY29wZS5iaW5kaW5ncyk7XG4gICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gIH0gd2hpbGUgKHNjb3BlKTtcblxuICByZXR1cm4gaWRzO1xufTtcblxuLyoqXG4gKiBXYWxrcyB0aGUgc2NvcGUgdHJlZSBhbmQgZ2F0aGVycyBhbGwgZGVjbGFyYXRpb25zIG9mIGBraW5kYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2luZFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0QWxsQmluZGluZ3NPZktpbmQgPSBmdW5jdGlvbiAoa2luZCkge1xuICB2YXIgaWRzID0gb2JqZWN0KCk7XG5cbiAgdmFyIHNjb3BlID0gdGhpcztcbiAgZG8ge1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NvcGUuYmluZGluZ3MpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gc2NvcGUuYmluZGluZ3NbbmFtZV07XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSBraW5kKSBpZHNbbmFtZV0gPSBiaW5kaW5nO1xuICAgIH1cbiAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgfSB3aGlsZSAoc2NvcGUpO1xuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vLyBtaXNjXG5cblNjb3BlLnByb3RvdHlwZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyA9IGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG4gIHJldHVybiB0aGlzLmdldEJpbmRpbmdJZGVudGlmaWVyKG5hbWUpID09PSBub2RlO1xufTtcblxuLy8gZ2V0XG5cblNjb3BlLnByb3RvdHlwZS5nZXRCaW5kaW5nSW5mbyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgZG8ge1xuICAgIHZhciBiaW5kaW5nID0gc2NvcGUuZ2V0T3duQmluZGluZ0luZm8obmFtZSk7XG4gICAgaWYgKGJpbmRpbmcpIHJldHVybiBiaW5kaW5nO1xuICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0T3duQmluZGluZ0luZm8gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXRCaW5kaW5nSWRlbnRpZmllciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBpbmZvID0gdGhpcy5nZXRCaW5kaW5nSW5mbyhuYW1lKTtcbiAgcmV0dXJuIGluZm8gJiYgaW5mby5pZGVudGlmaWVyO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmdldE93bkJpbmRpbmdJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICByZXR1cm4gYmluZGluZyAmJiBiaW5kaW5nLmlkZW50aWZpZXI7XG59O1xuXG4vLyBoYXNcblxuU2NvcGUucHJvdG90eXBlLmhhc093bkJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISF0aGlzLmdldE93bkJpbmRpbmdJbmZvKG5hbWUpO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmhhc0JpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcbiAgaWYgKHRoaXMuaGFzT3duQmluZGluZyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gIGlmICh0aGlzLnBhcmVudEhhc0JpbmRpbmcobmFtZSkpIHJldHVybiB0cnVlO1xuICBpZiAoaW5jbHVkZXMoU2NvcGUuZ2xvYmFscywgbmFtZSkpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5TY29wZS5wcm90b3R5cGUucGFyZW50SGFzQmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oYXNCaW5kaW5nKG5hbWUpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6IFtcIlN0YXRlbWVudFwiXSxcbiAgXCJCcmVha1N0YXRlbWVudFwiOiAgICAgIFtcIlN0YXRlbWVudFwiXSxcbiAgXCJDb250aW51ZVN0YXRlbWVudFwiOiAgIFtcIlN0YXRlbWVudFwiXSxcbiAgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOiAgIFtcIlN0YXRlbWVudFwiXSxcbiAgXCJEb1doaWxlU3RhdGVtZW50XCI6ICAgIFtcIlN0YXRlbWVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdLFxuICBcIklmU3RhdGVtZW50XCI6ICAgICAgICAgW1wiU3RhdGVtZW50XCJdLFxuICBcIlJldHVyblN0YXRlbWVudFwiOiAgICAgW1wiU3RhdGVtZW50XCJdLFxuICBcIlN3aXRjaFN0YXRlbWVudFwiOiAgICAgW1wiU3RhdGVtZW50XCJdLFxuICBcIlRocm93U3RhdGVtZW50XCI6ICAgICAgW1wiU3RhdGVtZW50XCJdLFxuICBcIlRyeVN0YXRlbWVudFwiOiAgICAgICAgW1wiU3RhdGVtZW50XCJdLFxuICBcIldoaWxlU3RhdGVtZW50XCI6ICAgICAgW1wiU3RhdGVtZW50XCIsIFwiTG9vcFwiLCBcIldoaWxlXCIsIFwiU2NvcGFibGVcIl0sXG4gIFwiV2l0aFN0YXRlbWVudFwiOiAgICAgICBbXCJTdGF0ZW1lbnRcIl0sXG4gIFwiRW1wdHlTdGF0ZW1lbnRcIjogICAgICBbXCJTdGF0ZW1lbnRcIl0sXG4gIFwiTGFiZWxlZFN0YXRlbWVudFwiOiAgICBbXCJTdGF0ZW1lbnRcIl0sXG4gIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgXCJFeHBvcnREZWNsYXJhdGlvblwiOiAgIFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBcIkltcG9ydERlY2xhcmF0aW9uXCI6ICAgW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIFwiUHJpdmF0ZURlY2xhcmF0aW9uXCI6ICBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcblxuICBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJFeHByZXNzaW9uXCJdLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjogICAgIFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJGdW5jdGlvblwiXSxcbiAgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjogICAgICBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiRXhwcmVzc2lvblwiXSxcblxuICBcIkltcG9ydFNwZWNpZmllclwiOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIFwiRXhwb3J0U3BlY2lmaWVyXCI6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcblxuICBcIkJsb2NrU3RhdGVtZW50XCI6IFtcIlN0YXRlbWVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBcIlByb2dyYW1cIjogICAgICAgIFtcIlNjb3BhYmxlXCJdLFxuICBcIkNhdGNoQ2xhdXNlXCI6ICAgIFtcIlNjb3BhYmxlXCJdLFxuXG4gIFwiTG9naWNhbEV4cHJlc3Npb25cIjogW1wiQmluYXJ5XCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgXCJCaW5hcnlFeHByZXNzaW9uXCI6ICBbXCJCaW5hcnlcIiwgXCJFeHByZXNzaW9uXCJdLFxuXG4gIFwiVW5hcnlFeHByZXNzaW9uXCI6IFtcIlVuYXJ5TGlrZVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIFwiU3ByZWFkUHJvcGVydHlcIjogIFtcIlVuYXJ5TGlrZVwiXSxcbiAgXCJTcHJlYWRFbGVtZW50XCI6ICAgW1wiVW5hcnlMaWtlXCJdLFxuXG4gIFwiQ2xhc3NEZWNsYXJhdGlvblwiOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIkNsYXNzXCJdLFxuICBcIkNsYXNzRXhwcmVzc2lvblwiOiAgW1wiQ2xhc3NcIiwgXCJFeHByZXNzaW9uXCJdLFxuXG4gIFwiRm9yT2ZTdGF0ZW1lbnRcIjogW1wiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiU2NvcGFibGVcIiwgXCJMb29wXCJdLFxuICBcIkZvckluU3RhdGVtZW50XCI6IFtcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIlNjb3BhYmxlXCIsIFwiTG9vcFwiXSxcbiAgXCJGb3JTdGF0ZW1lbnRcIjogICBbXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJTY29wYWJsZVwiLCBcIkxvb3BcIl0sXG5cbiAgXCJPYmplY3RQYXR0ZXJuXCI6ICAgICBbXCJQYXR0ZXJuXCJdLFxuICBcIkFycmF5UGF0dGVyblwiOiAgICAgIFtcIlBhdHRlcm5cIl0sXG4gIFwiQXNzaWdubWVudFBhdHRlcm5cIjogW1wiUGF0dGVyblwiXSxcblxuICBcIlByb3BlcnR5XCI6ICAgW1wiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIFwiSlNYRWxlbWVudFwiOiBbXCJVc2VyV2hpdGVzcGFjYWJsZVwiLCBcIkV4cHJlc3Npb25cIl0sXG5cbiAgXCJBcnJheUV4cHJlc3Npb25cIjogICAgICAgICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjogICAgICBbXCJFeHByZXNzaW9uXCJdLFxuICBcIkF3YWl0RXhwcmVzc2lvblwiOiAgICAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJCaW5kRnVuY3Rpb25FeHByZXNzaW9uXCI6ICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiQmluZE1lbWJlckV4cHJlc3Npb25cIjogICAgICBbXCJFeHByZXNzaW9uXCJdLFxuICBcIkNhbGxFeHByZXNzaW9uXCI6ICAgICAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJDb21wcmVoZW5zaW9uRXhwcmVzc2lvblwiOiAgIFtcIkV4cHJlc3Npb25cIiwgXCJTY29wYWJsZVwiXSxcbiAgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjogICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiSWRlbnRpZmllclwiOiAgICAgICAgICAgICAgICBbXCJFeHByZXNzaW9uXCJdLFxuICBcIkxpdGVyYWxcIjogICAgICAgICAgICAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJNZW1iZXJFeHByZXNzaW9uXCI6ICAgICAgICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiTmV3RXhwcmVzc2lvblwiOiAgICAgICAgICAgICBbXCJFeHByZXNzaW9uXCJdLFxuICBcIk9iamVjdEV4cHJlc3Npb25cIjogICAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjogICAgICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6ICBbXCJFeHByZXNzaW9uXCJdLFxuICBcIlRoaXNFeHByZXNzaW9uXCI6ICAgICAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJVcGRhdGVFeHByZXNzaW9uXCI6ICAgICAgICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiVmlydHVhbFByb3BlcnR5RXhwcmVzc2lvblwiOiBbXCJFeHByZXNzaW9uXCJdLFxuICBcIkpTWEVtcHR5RXhwcmVzc2lvblwiOiAgICAgICAgW1wiRXhwcmVzc2lvblwiXSxcbiAgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6ICAgICAgIFtcIkV4cHJlc3Npb25cIl0sXG4gIFwiWWllbGRFeHByZXNzaW9uXCI6ICAgICAgICAgICBbXCJFeHByZXNzaW9uXCJdLFxuXG4gIFwiSlNYQXR0cmlidXRlXCI6ICAgICAgICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYQ2xvc2luZ0VsZW1lbnRcIjogICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYRWxlbWVudFwiOiAgICAgICAgICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYRW1wdHlFeHByZXNzaW9uXCI6ICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiOiBbXCJKU1hcIl0sXG4gIFwiSlNYSWRlbnRpZmllclwiOiAgICAgICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOiAgICBbXCJKU1hcIl0sXG4gIFwiSlNYTmFtZXNwYWNlZE5hbWVcIjogICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYT3BlbmluZ0VsZW1lbnRcIjogICAgICBbXCJKU1hcIl0sXG4gIFwiSlNYU3ByZWFkQXR0cmlidXRlXCI6ICAgICBbXCJKU1hcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJBcnJheUV4cHJlc3Npb25cIjoge1xuICAgIFwiZWxlbWVudHNcIjogbnVsbFxuICB9LFxuXG4gIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjoge1xuICAgIFwicGFyYW1zXCI6IG51bGwsXG4gICAgXCJib2R5XCI6IG51bGxcbiAgfSxcblxuICBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6IHtcbiAgICBcIm9wZXJhdG9yXCI6IG51bGwsXG4gICAgXCJsZWZ0XCI6IG51bGwsXG4gICAgXCJyaWdodFwiOiBudWxsXG4gIH0sXG5cbiAgXCJCaW5hcnlFeHByZXNzaW9uXCI6IHtcbiAgICBcIm9wZXJhdG9yXCI6IG51bGwsXG4gICAgXCJsZWZ0XCI6IG51bGwsXG4gICAgXCJyaWdodFwiOiBudWxsXG4gIH0sXG5cbiAgXCJCbG9ja1N0YXRlbWVudFwiOiB7XG4gICAgXCJib2R5XCI6IG51bGxcbiAgfSxcblxuICBcIkNhbGxFeHByZXNzaW9uXCI6IHtcbiAgICBcImNhbGxlZVwiOiBudWxsLFxuICAgIFwiYXJndW1lbnRzXCI6IG51bGxcbiAgfSxcblxuICBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOiB7XG4gICAgXCJ0ZXN0XCI6IG51bGwsXG4gICAgXCJjb25zZXF1ZW50XCI6IG51bGwsXG4gICAgXCJhbHRlcm5hdGVcIjogbnVsbFxuICB9LFxuXG4gIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOiB7XG4gICAgXCJleHByZXNzaW9uXCI6IG51bGxcbiAgfSxcblxuICBcIkZpbGVcIjoge1xuICAgIFwicHJvZ3JhbVwiOiBudWxsLFxuICAgIFwiY29tbWVudHNcIjogbnVsbCxcbiAgICBcInRva2Vuc1wiOiBudWxsXG4gIH0sXG5cbiAgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjoge1xuICAgIFwiaWRcIjogbnVsbCxcbiAgICBcInBhcmFtc1wiOiBudWxsLFxuICAgIFwiYm9keVwiOiBudWxsLFxuICAgIFwiZ2VuZXJhdG9yXCI6IGZhbHNlXG4gIH0sXG5cbiAgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6IHtcbiAgICBcImlkXCI6IG51bGwsXG4gICAgXCJwYXJhbXNcIjogbnVsbCxcbiAgICBcImJvZHlcIjogbnVsbCxcbiAgICBcImdlbmVyYXRvclwiOiBmYWxzZVxuICB9LFxuXG4gIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCI6IHtcbiAgICBcImlkXCI6IG51bGwsXG4gICAgXCJ0eXBlUGFyYW1ldGVyc1wiOiBudWxsXG4gIH0sXG5cbiAgXCJJZGVudGlmaWVyXCI6IHtcbiAgICBcIm5hbWVcIjogbnVsbFxuICB9LFxuXG4gIFwiSWZTdGF0ZW1lbnRcIjoge1xuICAgIFwidGVzdFwiOiBudWxsLFxuICAgIFwiY29uc2VxdWVudFwiOiBudWxsLFxuICAgIFwiYWx0ZXJuYXRlXCI6IG51bGxcbiAgfSxcblxuICBcIkltcG9ydERlY2xhcmF0aW9uXCI6IHtcbiAgICBcInNwZWNpZmllcnNcIjogbnVsbCxcbiAgICBcInNvdXJjZVwiOiBudWxsXG4gIH0sXG5cbiAgXCJJbXBvcnRTcGVjaWZpZXJcIjoge1xuICAgIFwiaWRcIjogbnVsbCxcbiAgICBcIm5hbWVcIjogbnVsbFxuICB9LFxuXG4gIFwiTGl0ZXJhbFwiOiB7XG4gICAgXCJ2YWx1ZVwiOiBudWxsXG4gIH0sXG5cbiAgXCJMb2dpY2FsRXhwcmVzc2lvblwiOiB7XG4gICAgXCJvcGVyYXRvclwiOiBudWxsLFxuICAgIFwibGVmdFwiOiBudWxsLFxuICAgIFwicmlnaHRcIjogbnVsbFxuICB9LFxuXG4gIFwiTWVtYmVyRXhwcmVzc2lvblwiOiB7XG4gICAgXCJvYmplY3RcIjogbnVsbCxcbiAgICBcInByb3BlcnR5XCI6IG51bGwsXG4gICAgXCJjb21wdXRlZFwiOiBmYWxzZVxuICB9LFxuXG4gIFwiTWV0aG9kRGVmaW5pdGlvblwiOiB7XG4gICAgXCJrZXlcIjogbnVsbCxcbiAgICBcInZhbHVlXCI6IG51bGwsXG4gICAgXCJjb21wdXRlZFwiOiBmYWxzZSxcbiAgICBcInN0YXRpY1wiOiBmYWxzZSxcbiAgICBcImtpbmRcIjogbnVsbFxuICB9LFxuXG4gIFwiTmV3RXhwcmVzc2lvblwiOiB7XG4gICAgXCJjYWxsZWVcIjogbnVsbCxcbiAgICBcImFyZ3VtZW50c1wiOiBudWxsXG4gIH0sXG5cbiAgXCJPYmplY3RFeHByZXNzaW9uXCI6IHtcbiAgICBcInByb3BlcnRpZXNcIjogbnVsbFxuICB9LFxuXG4gIFwiUHJvZ3JhbVwiOiB7XG4gICAgXCJib2R5XCI6IG51bGxcbiAgfSxcblxuICBcIlByb3BlcnR5XCI6IHtcbiAgICBcImtpbmRcIjogbnVsbCxcbiAgICBcImtleVwiOiBudWxsLFxuICAgIFwidmFsdWVcIjogbnVsbCxcbiAgICBcImNvbXB1dGVkXCI6IGZhbHNlXG4gIH0sXG5cbiAgXCJSZXR1cm5TdGF0ZW1lbnRcIjoge1xuICAgIFwiYXJndW1lbnRcIjogbnVsbFxuICB9LFxuXG4gIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6IHtcbiAgICBcImV4cHJlc3Npb25zXCI6IG51bGxcbiAgfSxcblxuICBcIlRocm93RXhwcmVzc2lvblwiOiB7XG4gICAgXCJhcmd1bWVudFwiOiBudWxsXG4gIH0sXG5cbiAgXCJVbmFyeUV4cHJlc3Npb25cIjoge1xuICAgIFwib3BlcmF0b3JcIjogbnVsbCxcbiAgICBcImFyZ3VtZW50XCI6IG51bGwsXG4gICAgXCJwcmVmaXhcIjogbnVsbFxuICB9LFxuXG4gIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOiB7XG4gICAgXCJraW5kXCI6IG51bGwsXG4gICAgXCJkZWNsYXJhdGlvbnNcIjogbnVsbFxuICB9LFxuXG4gIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6IHtcbiAgICBcImlkXCI6IG51bGwsXG4gICAgXCJpbml0XCI6IG51bGxcbiAgfSxcblxuICBcIldpdGhTdGF0ZW1lbnRcIjoge1xuICAgIFwib2JqZWN0XCI6IG51bGwsXG4gICAgXCJib2R5XCI6IG51bGxcbiAgfSxcblxuICBcIllpZWxkRXhwcmVzc2lvblwiOiB7XG4gICAgXCJhcmd1bWVudFwiOiBudWxsLFxuICAgIFwiZGVsZWdhdGVcIjogbnVsbFxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHRvRmFzdFByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi4vaGVscGVycy90by1mYXN0LXByb3BlcnRpZXNcIik7XG52YXIgaXNTdHJpbmcgICAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9pc1N0cmluZ1wiKTtcbnZhciBjb21wYWN0ICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9hcnJheS9jb21wYWN0XCIpO1xudmFyIGVzdXRpbHMgICAgICAgICAgPSByZXF1aXJlKFwiZXN1dGlsc1wiKTtcbnZhciBvYmplY3QgICAgICAgICAgID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvb2JqZWN0XCIpO1xudmFyIGVhY2ggICAgICAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL2NvbGxlY3Rpb24vZWFjaFwiKTtcbnZhciB1bmlxICAgICAgICAgICAgID0gcmVxdWlyZShcImxvZGFzaC9hcnJheS91bmlxXCIpO1xuXG52YXIgdCA9IGV4cG9ydHM7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGBpc1tUeXBlXWAgYW5kIGBhc3NlcnRbVHlwZV1gIGdlbmVyYXRlZCBmdW5jdGlvbnMgZm9yIGEgZ2l2ZW4gYHR5cGVgLlxuICogUGFzcyBgc2tpcEFsaWFzQ2hlY2tgIHRvIGZvcmNlIGl0IHRvIGRpcmVjdGx5IGNvbXBhcmUgYG5vZGUudHlwZWAgd2l0aCBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7Qm9vbGVhbj99IHNraXBBbGlhc0NoZWNrXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHR5cGUsIHNraXBBbGlhc0NoZWNrKSB7XG4gIHZhciBpcyA9IHRbXCJpc1wiICsgdHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgb3B0cykge1xuICAgIHJldHVybiB0LmlzKHR5cGUsIG5vZGUsIG9wdHMsIHNraXBBbGlhc0NoZWNrKTtcbiAgfTtcblxuICB0W1wiYXNzZXJ0XCIgKyB0eXBlXSA9IGZ1bmN0aW9uIChub2RlLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgaWYgKCFpcyhub2RlLCBvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBvcHRpb24gXCIgKyBKU09OLnN0cmluZ2lmeShvcHRzKSk7XG4gICAgfVxuICB9O1xufVxuXG50LlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gW1wiY29uc2VxdWVudFwiLCBcImJvZHlcIl07XG50Lk5BVElWRV9UWVBFX05BTUVTICAgICAgID0gW1wiQXJyYXlcIiwgXCJPYmplY3RcIiwgXCJOdW1iZXJcIiwgXCJCb29sZWFuXCIsIFwiRGF0ZVwiLCBcIkFycmF5XCIsIFwiU3RyaW5nXCJdO1xudC5GT1JfSU5JVF9LRVlTICAgICAgICAgICA9IFtcImxlZnRcIiwgXCJpbml0XCJdO1xuXG50LlZJU0lUT1JfS0VZUyA9IHJlcXVpcmUoXCIuL3Zpc2l0b3Ita2V5c1wiKTtcbnQuQUxJQVNfS0VZUyAgID0gcmVxdWlyZShcIi4vYWxpYXMta2V5c1wiKTtcblxudC5GTElQUEVEX0FMSUFTX0tFWVMgPSB7fTtcblxuZWFjaCh0LlZJU0lUT1JfS0VZUywgZnVuY3Rpb24gKGtleXMsIHR5cGUpIHtcbiAgcmVnaXN0ZXJUeXBlKHR5cGUsIHRydWUpO1xufSk7XG5cbmVhY2godC5BTElBU19LRVlTLCBmdW5jdGlvbiAoYWxpYXNlcywgdHlwZSkge1xuICBlYWNoKGFsaWFzZXMsIGZ1bmN0aW9uIChhbGlhcykge1xuICAgIHZhciB0eXBlcyA9IHQuRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXSA9IHQuRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXSB8fCBbXTtcbiAgICB0eXBlcy5wdXNoKHR5cGUpO1xuICB9KTtcbn0pO1xuXG5lYWNoKHQuRkxJUFBFRF9BTElBU19LRVlTLCBmdW5jdGlvbiAodHlwZXMsIHR5cGUpIHtcbiAgdFt0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIl9UWVBFU1wiXSA9IHR5cGVzO1xuICByZWdpc3RlclR5cGUodHlwZSwgZmFsc2UpO1xufSk7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGBub2RlYCBpcyBvZiBnaXZlbiBgdHlwZWAuXG4gKlxuICogRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgdXNlIHRoaXMgaW5zdGVhZCBvZiBgaXNbVHlwZV1gIHdoZW4gYHR5cGVgIGlzIHVua25vd24uXG4gKiBPcHRpb25hbGx5LCBwYXNzIGBza2lwQWxpYXNDaGVja2AgdG8gZGlyZWN0bHkgY29tcGFyZSBgbm9kZS50eXBlYCB3aXRoIGB0eXBlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdHNcbiAqIEBwYXJhbSB7Qm9vbGVhbj99IHNraXBBbGlhc0NoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNPZlR5cGVcbiAqL1xuXG50LmlzID0gZnVuY3Rpb24gKHR5cGUsIG5vZGUsIG9wdHMsIHNraXBBbGlhc0NoZWNrKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciB0eXBlTWF0Y2hlcyA9IHR5cGUgPT09IG5vZGUudHlwZTtcblxuICBpZiAoIXR5cGVNYXRjaGVzICYmICFza2lwQWxpYXNDaGVjaykge1xuICAgIHZhciBhbGlhc2VzID0gdC5GTElQUEVEX0FMSUFTX0tFWVNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGFsaWFzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHR5cGVNYXRjaGVzID0gYWxpYXNlcy5pbmRleE9mKG5vZGUudHlwZSkgPiAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXR5cGVNYXRjaGVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHQuc2hhbGxvd0VxdWFsKG5vZGUsIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vL1xuXG50LkJVSUxERVJfS0VZUyA9IHJlcXVpcmUoXCIuL2J1aWxkZXIta2V5c1wiKTtcblxuZWFjaCh0LlZJU0lUT1JfS0VZUywgZnVuY3Rpb24gKGtleXMsIHR5cGUpIHtcbiAgaWYgKHQuQlVJTERFUl9LRVlTW3R5cGVdKSByZXR1cm47XG5cbiAgdmFyIGRlZnMgPSB7fTtcbiAgZWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVmc1trZXldID0gbnVsbDtcbiAgfSk7XG4gIHQuQlVJTERFUl9LRVlTW3R5cGVdID0gZGVmcztcbn0pO1xuXG5lYWNoKHQuQlVJTERFUl9LRVlTLCBmdW5jdGlvbiAoa2V5cywgdHlwZSkge1xuICB0W3R5cGVbMF0udG9Mb3dlckNhc2UoKSArIHR5cGUuc2xpY2UoMSldID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub2RlID0ge307XG4gICAgbm9kZS5zdGFydCA9IG51bGw7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcblxuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAodmFyIGtleSBpbiBrZXlzKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2krK107XG4gICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIGFyZyA9IGtleXNba2V5XTtcbiAgICAgIG5vZGVba2V5XSA9IGFyZztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxudC50b0NvbXB1dGVkS2V5ID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICBpZiAoIW5vZGUuY29tcHV0ZWQpIHtcbiAgICBpZiAodC5pc0lkZW50aWZpZXIoa2V5KSkga2V5ID0gdC5saXRlcmFsKGtleS5uYW1lKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufTtcblxuLypcbiAqIFNoYWxsb3dseSBjaGVja3MgdG8gc2VlIGlmIHRoZSBwYXNzZWQgYG5vZGVgIGlzIGZhbHN5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG50LmlzRmFsc3lFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHQuaXNMaXRlcmFsKG5vZGUpKSB7XG4gICAgcmV0dXJuICFub2RlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFR1cm4gYW4gYXJyYXkgb2Ygc3RhdGVtZW50IGBub2Rlc2AgaW50byBhIGBTZXF1ZW5jZUV4cHJlc3Npb25gLlxuICpcbiAqIFZhcmlhYmxlIGRlY2xhcmF0aW9ucyBhcmUgdHVybmVkIGludG8gc2ltcGxlIGFzc2lnbm1lbnRzIGFuZCB0aGVpclxuICogZGVjbGFyYXRpb25zIGhvaXN0ZWQgdG8gdGhlIHRvcCBvZiB0aGUgY3VycmVudCBzY29wZS5cbiAqXG4gKiBFeHByZXNzaW9uIHN0YXRlbWVudHMgYXJlIGp1c3QgcmVzb2x2ZWQgdG8gdGhlaXIgc3RhbmRhcmQgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBub2Rlc1xuICogQHBhcmFtIHtTY29wZX0gc2NvcGVcbiAqL1xuXG50LnRvU2VxdWVuY2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGVzLCBzY29wZSkge1xuICB2YXIgZXhwcnMgPSBbXTtcblxuICBlYWNoKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0LmlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlKTtcbiAgICB9IGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlLmV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAodC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICAgIGVhY2gobm9kZS5kZWNsYXJhdGlvbnMsIGZ1bmN0aW9uIChkZWNsYXIpIHtcbiAgICAgICAgc2NvcGUucHVzaCh7XG4gICAgICAgICAga2luZDogbm9kZS5raW5kLFxuICAgICAgICAgIGtleTogZGVjbGFyLmlkLm5hbWUsXG4gICAgICAgICAgaWQ6IGRlY2xhci5pZFxuICAgICAgICB9KTtcbiAgICAgICAgZXhwcnMucHVzaCh0LmFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBkZWNsYXIuaWQsIGRlY2xhci5pbml0KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChleHBycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZXhwcnNbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHQuc2VxdWVuY2VFeHByZXNzaW9uKGV4cHJzKTtcbiAgfVxufTtcblxuLypcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFjdHVhbFxuICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG50LnNoYWxsb3dFcXVhbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKGFjdHVhbFtrZXldICE9PSBleHBlY3RlZFtrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lbWJlclxuICogQHBhcmFtIHtPYmplY3R9IGFwcGVuZFxuICogQHBhcmFtIHtCb29sZWFufSBbY29tcHV0ZWRdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBtZW1iZXJcbiAqL1xuXG50LmFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChtZW1iZXIsIGFwcGVuZCwgY29tcHV0ZWQpIHtcbiAgbWVtYmVyLm9iamVjdCAgID0gdC5tZW1iZXJFeHByZXNzaW9uKG1lbWJlci5vYmplY3QsIG1lbWJlci5wcm9wZXJ0eSwgbWVtYmVyLmNvbXB1dGVkKTtcbiAgbWVtYmVyLnByb3BlcnR5ID0gYXBwZW5kO1xuICBtZW1iZXIuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICByZXR1cm4gbWVtYmVyO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcHBlbmRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG1lbWJlclxuICovXG5cbnQucHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChtZW1iZXIsIGFwcGVuZCkge1xuICBtZW1iZXIub2JqZWN0ID0gdC5tZW1iZXJFeHByZXNzaW9uKGFwcGVuZCwgbWVtYmVyLm9iamVjdCk7XG4gIHJldHVybiBtZW1iZXI7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbnB1dCBgbm9kZWAgaXMgYSByZWZlcmVuY2UgdG8gYSBib3VuZCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxudC5pc1JlZmVyZW5jZWQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIC8vIHllczogUEFSRU5UW05PREVdXG4gIC8vIHllczogTk9ERS5jaGlsZFxuICAvLyBubzogcGFyZW50LkNISUxEXG4gIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSAmJiBwYXJlbnQuY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFyZW50Lm9iamVjdCA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyB5ZXM6IHsgW05PREVdOiBcIlwiIH1cbiAgLy8gbm86IHsgTk9ERTogXCJcIiB9XG4gIGlmICh0LmlzUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHBhcmVudC5jb21wdXRlZDtcbiAgfVxuXG4gIC8vIG5vOiB2YXIgTk9ERSA9IGluaXQ7XG4gIC8vIHllczogdmFyIGlkID0gTk9ERTtcbiAgaWYgKHQuaXNWYXJpYWJsZURlY2xhcmF0b3IocGFyZW50KSkge1xuICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG4gIH1cblxuICAvLyBubzogZnVuY3Rpb24gTk9ERSgpIHt9XG4gIC8vIG5vOiBmdW5jdGlvbiBmb28oTk9ERSkge31cbiAgaWYgKHQuaXNGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnQucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyYW0gPSBwYXJlbnQucGFyYW1zW2ldO1xuICAgICAgaWYgKHBhcmFtID09PSBub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudC5pZCAhPT0gbm9kZTtcbiAgfVxuXG4gIC8vIG5vOiBjbGFzcyBOT0RFIHt9XG4gIGlmICh0LmlzQ2xhc3MocGFyZW50KSkge1xuICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG4gIH1cblxuICAvLyB5ZXM6IGNsYXNzIHsgW05PREVdKCl7fSB9XG4gIGlmICh0LmlzTWV0aG9kRGVmaW5pdGlvbihwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHBhcmVudC5rZXkgPT09IG5vZGUgJiYgcGFyZW50LmNvbXB1dGVkO1xuICB9XG5cbiAgLy8gbm86IE5PREU6IGZvciAoOzspIHt9XG4gIGlmICh0LmlzTGFiZWxlZFN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbm86IHRyeSB7fSBjYXRjaCAoTk9ERSkge31cbiAgaWYgKHQuaXNDYXRjaENsYXVzZShwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHBhcmVudC5wYXJhbSAhPT0gbm9kZTtcbiAgfVxuXG4gIC8vIG5vOiBmdW5jdGlvbiBmb28oLi4uTk9ERSkge31cbiAgaWYgKHQuaXNSZXN0RWxlbWVudChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbm86IFtOT0RFID0gZm9vXSA9IFtdO1xuICAvLyB5ZXM6IFtmb28gPSBOT0RFXSA9IFtdO1xuICBpZiAodC5pc0Fzc2lnbm1lbnRQYXR0ZXJuKHBhcmVudCkpIHtcbiAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuICB9XG5cbiAgLy8gbm86IFtOT0RFXSA9IFtdO1xuICAvLyBubzogKHsgTk9ERSB9KSA9IFtdO1xuICBpZiAodC5pc1BhdHRlcm4ocGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG5vOiBpbXBvcnQgTk9ERSBmcm9tIFwiYmFyXCI7XG4gIGlmICh0LmlzSW1wb3J0U3BlY2lmaWVyKHBhcmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBubzogaW1wb3J0ICogYXMgTk9ERSBmcm9tIFwiZm9vXCI7XG4gIGlmICh0LmlzSW1wb3J0QmF0Y2hTcGVjaWZpZXIocGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG5vOiBjbGFzcyBGb28geyBwcml2YXRlIE5PREU7IH1cbiAgaWYgKHQuaXNQcml2YXRlRGVjbGFyYXRpb24ocGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5wdXQgYG5vZGVgIGlzIGFuIGBJZGVudGlmaWVyYCBhbmQgYGlzUmVmZXJlbmNlZGAuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFybWEge05vZGV9IHBhcmVudFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxudC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgb3B0cykge1xuICByZXR1cm4gdC5pc0lkZW50aWZpZXIobm9kZSwgb3B0cykgJiYgdC5pc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGlucHV0IGBuYW1lYCBpcyBhIHZhbGlkIGlkZW50aWZpZXIgbmFtZVxuICogYW5kIGlzbid0IGEgcmVzZXJ2ZWQgd29yZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxudC5pc1ZhbGlkSWRlbnRpZmllciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1N0cmluZyhuYW1lKSAmJiBlc3V0aWxzLmtleXdvcmQuaXNJZGVudGlmaWVyTmFtZShuYW1lKSAmJiAhZXN1dGlscy5rZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkRVM2KG5hbWUsIHRydWUpO1xufTtcblxuLypcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblxudC50b0lkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAodC5pc0lkZW50aWZpZXIobmFtZSkpIHJldHVybiBuYW1lLm5hbWU7XG5cbiAgbmFtZSA9IG5hbWUgKyBcIlwiO1xuXG4gIC8vIHJlcGxhY2UgYWxsIG5vbi12YWxpZCBpZGVudGlmaWVycyB3aXRoIGRhc2hlc1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOSRfXS9nLCBcIi1cIik7XG5cbiAgLy8gcmVtb3ZlIGFsbCBkYXNoZXMgYW5kIG51bWJlcnMgZnJvbSBzdGFydCBvZiBuYW1lXG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL15bLTAtOV0rLywgXCJcIik7XG5cbiAgLy8gY2FtZWwgY2FzZVxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLVxcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG4gIH0pO1xuXG4gIGlmICghdC5pc1ZhbGlkSWRlbnRpZmllcihuYW1lKSkge1xuICAgIG5hbWUgPSBcIl9cIiArIG5hbWU7XG4gIH1cblxuICByZXR1cm4gbmFtZSB8fCBcIl9cIjtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmc9fSBrZXlcbiAqL1xuXG50LmVuc3VyZUJsb2NrID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICBrZXkgPSBrZXkgfHwgXCJib2R5XCI7XG4gIHJldHVybiBub2RlW2tleV0gPSB0LnRvQmxvY2sobm9kZVtrZXldLCBub2RlKTtcbn07XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkIHdpbGwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZVxuICogaW5wdXQgYG5vZGVgIGBNZW1iZXJFeHByZXNzaW9uYCBtYXRjaGVzIHRoZSBpbnB1dCBgbWF0Y2hgLlxuICpcbiAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgbWF0Y2ggYFJlYWN0LmNyZWF0ZUNsYXNzYCBpdCB3b3VsZCBtYXRjaCB0aGVcbiAqIHBhcnNlZCBub2RlcyBvZiBgUmVhY3QuY3JlYXRlQ2xhc3NgIGFuZCBgUmVhY3RbXCJjcmVhdGVDbGFzc1wiXWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIERvdC1kZWxpbWl0ZWQgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd1BhcnRpYWxdIEFsbG93IGEgcGFydGlhbCBtYXRjaFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5cbnQuYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbiAobWF0Y2gsIGFsbG93UGFydGlhbCkge1xuICB2YXIgcGFydHMgPSBtYXRjaC5zcGxpdChcIi5cIik7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChtZW1iZXIpIHtcbiAgICAvLyBub3QgYSBtZW1iZXIgZXhwcmVzc2lvblxuICAgIGlmICghdC5pc01lbWJlckV4cHJlc3Npb24obWVtYmVyKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHNlYXJjaCA9IFttZW1iZXJdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgICB2YXIgbm9kZSA9IHNlYXJjaC5zaGlmdCgpO1xuXG4gICAgICBpZiAoYWxsb3dQYXJ0aWFsICYmIGkgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQuaXNJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgICAgIC8vIHRoaXMgcGFydCBkb2Vzbid0IG1hdGNoXG4gICAgICAgIGlmIChwYXJ0c1tpXSAhPT0gbm9kZS5uYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHQuaXNMaXRlcmFsKG5vZGUpKSB7XG4gICAgICAgIC8vIHRoaXMgcGFydCBkb2Vzbid0IG1hdGNoXG4gICAgICAgIGlmIChwYXJ0c1tpXSAhPT0gbm9kZS52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0LmlzTWVtYmVyRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCAmJiAhdC5pc0xpdGVyYWwobm9kZS5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4ndCBkZWFsIHdpdGggdGhpc1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChub2RlLm9iamVjdCk7XG4gICAgICAgICAgc2VhcmNoLnB1c2gobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGNhbid0IGRlYWwgd2l0aCB0aGlzXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdG9vIG1hbnkgcGFydHNcbiAgICAgIGlmICgrK2kgPiBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVdXG4gKiBAcmV0dXJucyB7T2JqZWN0fEJvb2xlYW59XG4gKi9cblxudC50b1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBpZ25vcmUpIHtcbiAgaWYgKHQuaXNTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBtdXN0SGF2ZUlkID0gZmFsc2U7XG4gIHZhciBuZXdUeXBlO1xuXG4gIGlmICh0LmlzQ2xhc3Mobm9kZSkpIHtcbiAgICBtdXN0SGF2ZUlkID0gdHJ1ZTtcbiAgICBuZXdUeXBlID0gXCJDbGFzc0RlY2xhcmF0aW9uXCI7XG4gIH0gZWxzZSBpZiAodC5pc0Z1bmN0aW9uKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiB0LmV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gIH1cblxuICBpZiAobXVzdEhhdmVJZCAmJiAhbm9kZS5pZCkge1xuICAgIG5ld1R5cGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghbmV3VHlwZSkge1xuICAgIGlmIChpZ25vcmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHR1cm4gXCIgKyBub2RlLnR5cGUgKyBcIiB0byBhIHN0YXRlbWVudFwiKTtcbiAgICB9XG4gIH1cblxuICBub2RlLnR5cGUgPSBuZXdUeXBlO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmV4cG9ydHMudG9FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGlmICh0LmlzQ2xhc3Mobm9kZSkpIHtcbiAgICBub2RlLnR5cGUgPSBcIkNsYXNzRXhwcmVzc2lvblwiO1xuICB9IGVsc2UgaWYgKHQuaXNGdW5jdGlvbihub2RlKSkge1xuICAgIG5vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIH1cblxuICBpZiAodC5pc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdHVybiBcIiArIG5vZGUudHlwZSArIFwiIHRvIGFuIGV4cHJlc3Npb25cIik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG50LnRvQmxvY2sgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gIGlmICh0LmlzQmxvY2tTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGlmICh0LmlzRW1wdHlTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBub2RlID0gW107XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBpZiAoIXQuaXNTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0LmlzRnVuY3Rpb24ocGFyZW50KSkge1xuICAgICAgICBub2RlID0gdC5yZXR1cm5TdGF0ZW1lbnQobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdC5leHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBbbm9kZV07XG4gIH1cblxuICByZXR1cm4gdC5ibG9ja1N0YXRlbWVudChub2RlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBiaW5kaW5nIGlkZW50aWZpZXJzIGFzc29jaWF0ZWQgd2l0aFxuICogdGhlIGlucHV0IGBub2RlYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHJldHVybnMge0FycmF5fE9iamVjdH1cbiAqL1xuXG50LmdldEJpbmRpbmdJZGVudGlmaWVycyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBzZWFyY2ggPSBbXS5jb25jYXQobm9kZSk7XG4gIHZhciBpZHMgICAgPSBvYmplY3QoKTtcblxuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIHZhciBpZCA9IHNlYXJjaC5zaGlmdCgpO1xuICAgIGlmICghaWQpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtleXMgPSB0LmdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLnR5cGVdO1xuXG4gICAgaWYgKHQuaXNJZGVudGlmaWVyKGlkKSkge1xuICAgICAgaWRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfSBlbHNlIGlmICh0LmlzSW1wb3J0U3BlY2lmaWVyKGlkKSkge1xuICAgICAgc2VhcmNoLnB1c2goaWQubmFtZSB8fCBpZC5pZCk7XG4gICAgfSBlbHNlIGlmICh0LmlzRXhwb3J0RGVjbGFyYXRpb24oaWQpKSB7XG4gICAgICBpZiAodC5pc0RlY2xhcmF0aW9uKG5vZGUuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKG5vZGUuZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBzZWFyY2ggPSBzZWFyY2guY29uY2F0KGlkW2tleV0gfHwgW10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG50LmdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzID0ge1xuICBVbmFyeUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogW1wibGVmdFwiXSxcbiAgSW1wb3J0QmF0Y2hTcGVjaWZpZXI6IFtcIm5hbWVcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcjogW1wiaWRcIl0sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBDbGFzc0RlY2xhcmF0aW9uOiBbXCJpZFwiXSxcbiAgU3ByZWFkRWxlbWVudDogW1wiYXJndW1lbnRcIl0sXG4gIFJlc3RFbGVtZW50OiBbXCJhcmd1bWVudFwiXSxcbiAgVXBkYXRlRXhwcmVzc2lvbjogW1wiYXJndW1lbnRcIl0sXG4gIFNwcmVhZFByb3BlcnR5OiBbXCJhcmd1bWVudFwiXSxcbiAgUHJvcGVydHk6IFtcInZhbHVlXCJdLFxuICBDb21wcmVoZW5zaW9uQmxvY2s6IFtcImxlZnRcIl0sXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBbXCJsZWZ0XCJdLFxuICBQcml2YXRlRGVjbGFyYXRpb246IFtcImRlY2xhcmF0aW9uc1wiXSxcbiAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IFtcImJsb2Nrc1wiXSxcbiAgSW1wb3J0RGVjbGFyYXRpb246IFtcInNwZWNpZmllcnNcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRpb246IFtcImRlY2xhcmF0aW9uc1wiXSxcbiAgQXJyYXlQYXR0ZXJuOiBbXCJlbGVtZW50c1wiXSxcbiAgT2JqZWN0UGF0dGVybjogW1wicHJvcGVydGllc1wiXVxufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG50LmlzTGV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpICYmIChub2RlLmtpbmQgIT09IFwidmFyXCIgfHwgbm9kZS5fbGV0KTtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxudC5pc0Jsb2NrU2NvcGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpIHx8IHQuaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUpIHx8IHQuaXNMZXQobm9kZSk7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cbnQuaXNWYXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgeyBraW5kOiBcInZhclwiIH0pICYmICFub2RlLl9sZXQ7XG59O1xuXG4vL1xuXG50LkNPTU1FTlRfS0VZUyA9IFtcImxlYWRpbmdDb21tZW50c1wiLCBcInRyYWlsaW5nQ29tbWVudHNcIl07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNoaWxkXG4gKi9cblxudC5yZW1vdmVDb21tZW50cyA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICBlYWNoKHQuQ09NTUVOVF9LRVlTLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIGNoaWxkW2tleV07XG4gIH0pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjaGlsZFxuICovXG5cbnQuaW5oZXJpdHNDb21tZW50cyA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG4gIGVhY2godC5DT01NRU5UX0tFWVMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjaGlsZFtrZXldICA9IHVuaXEoY29tcGFjdChbXS5jb25jYXQoY2hpbGRba2V5XSwgcGFyZW50W2tleV0pKSk7XG4gIH0pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuXG4vKipcbiAqIERlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjaGlsZFxuICovXG5cbnQuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuICBjaGlsZC5fZGVjbGFyYXRpb25zID0gcGFyZW50Ll9kZWNsYXJhdGlvbnM7XG4gIGNoaWxkLl9zY29wZUluZm8gICAgPSBwYXJlbnQuX3Njb3BlSW5mbztcbiAgY2hpbGQucmFuZ2UgICAgICAgICA9IHBhcmVudC5yYW5nZTtcbiAgY2hpbGQuc3RhcnQgICAgICAgICA9IHBhcmVudC5zdGFydDtcbiAgY2hpbGQubG9jICAgICAgICAgICA9IHBhcmVudC5sb2M7XG4gIGNoaWxkLmVuZCAgICAgICAgICAgPSBwYXJlbnQuZW5kO1xuICB0LmluaGVyaXRzQ29tbWVudHMoY2hpbGQsIHBhcmVudCk7XG4gIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbnQuZ2V0TGFzdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlcyA9IG5vZGVzLmNvbmNhdCh0LmdldExhc3RTdGF0ZW1lbnRzKG5vZGUpKTtcbiAgfTtcblxuICBpZiAodC5pc0lmU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgYWRkKG5vZGUuY29uc2VxdWVudCk7XG4gICAgYWRkKG5vZGUuYWx0ZXJuYXRlKTtcbiAgfSBlbHNlIGlmICh0LmlzRm9yKG5vZGUpIHx8IHQuaXNXaGlsZShub2RlKSkge1xuICAgIGFkZChub2RlLmJvZHkpO1xuICB9IGVsc2UgaWYgKHQuaXNQcm9ncmFtKG5vZGUpIHx8IHQuaXNCbG9ja1N0YXRlbWVudChub2RlKSkge1xuICAgIGFkZChub2RlLmJvZHlbbm9kZS5ib2R5Lmxlbmd0aCAtIDFdKTtcbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY2lmaWVyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5cbnQuZ2V0U3BlY2lmaWVyTmFtZSA9IGZ1bmN0aW9uIChzcGVjaWZpZXIpIHtcbiAgcmV0dXJuIHNwZWNpZmllci5uYW1lIHx8IHNwZWNpZmllci5pZDtcbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY2lmaWVyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5cbnQuZ2V0U3BlY2lmaWVySWQgPSBmdW5jdGlvbiAoc3BlY2lmaWVyKSB7XG4gIGlmIChzcGVjaWZpZXIuZGVmYXVsdCkge1xuICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJkZWZhdWx0XCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzcGVjaWZpZXIuaWQ7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzY3JpcHRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY2lmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG50LmlzU3BlY2lmaWVyRGVmYXVsdCA9IGZ1bmN0aW9uIChzcGVjaWZpZXIpIHtcbiAgcmV0dXJuIHNwZWNpZmllci5kZWZhdWx0IHx8IHQuaXNJZGVudGlmaWVyKHNwZWNpZmllci5pZCkgJiYgc3BlY2lmaWVyLmlkLm5hbWUgPT09IFwiZGVmYXVsdFwiO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cbnQuaXNTY29wZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHQuaXNCbG9ja1N0YXRlbWVudChub2RlKSkge1xuICAgIGlmICh0LmlzTG9vcChwYXJlbnQuYmxvY2ssIHsgYm9keTogbm9kZSB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0LmlzRnVuY3Rpb24ocGFyZW50LmJsb2NrLCB7IGJvZHk6IG5vZGUgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdC5pc1Njb3BhYmxlKG5vZGUpO1xufTtcblxudG9GYXN0UHJvcGVydGllcyh0KTtcbnRvRmFzdFByb3BlcnRpZXModC5WSVNJVE9SX0tFWVMpO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkFycmF5RXhwcmVzc2lvblwiOiAgICAgICAgICAgW1wiZWxlbWVudHNcIl0sXG4gIFwiQXJyYXlQYXR0ZXJuXCI6ICAgICAgICAgICAgICBbXCJlbGVtZW50c1wiXSxcbiAgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOiAgIFtcInBhcmFtc1wiLCBcImRlZmF1bHRzXCIsIFwicmVzdFwiLCBcImJvZHlcIl0sXG4gIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjogICAgICBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIFwiQXNzaWdubWVudFBhdHRlcm5cIjogICAgICAgICBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIFwiQXdhaXRFeHByZXNzaW9uXCI6ICAgICAgICAgICBbXCJhcmd1bWVudFwiXSxcbiAgXCJCaW5hcnlFeHByZXNzaW9uXCI6ICAgICAgICAgIFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgXCJCaW5kRnVuY3Rpb25FeHByZXNzaW9uXCI6ICAgIFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiXSxcbiAgXCJCaW5kTWVtYmVyRXhwcmVzc2lvblwiOiAgICAgIFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCIsIFwiYXJndW1lbnRzXCJdLFxuICBcIkJsb2NrU3RhdGVtZW50XCI6ICAgICAgICAgICAgW1wiYm9keVwiXSxcbiAgXCJCcmVha1N0YXRlbWVudFwiOiAgICAgICAgICAgIFtcImxhYmVsXCJdLFxuICBcIkNhbGxFeHByZXNzaW9uXCI6ICAgICAgICAgICAgW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCJdLFxuICBcIkNhdGNoQ2xhdXNlXCI6ICAgICAgICAgICAgICAgW1wicGFyYW1cIiwgXCJib2R5XCJdLFxuICBcIkNsYXNzQm9keVwiOiAgICAgICAgICAgICAgICAgW1wiYm9keVwiXSxcbiAgXCJDbGFzc0RlY2xhcmF0aW9uXCI6ICAgICAgICAgIFtcImlkXCIsIFwiYm9keVwiLCBcInN1cGVyQ2xhc3NcIl0sXG4gIFwiQ2xhc3NFeHByZXNzaW9uXCI6ICAgICAgICAgICBbXCJpZFwiLCBcImJvZHlcIiwgXCJzdXBlckNsYXNzXCJdLFxuICBcIkNvbXByZWhlbnNpb25CbG9ja1wiOiAgICAgICAgW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiXSxcbiAgXCJDb21wcmVoZW5zaW9uRXhwcmVzc2lvblwiOiAgIFtcImZpbHRlclwiLCBcImJsb2Nrc1wiLCBcImJvZHlcIl0sXG4gIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6ICAgICBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiXSxcbiAgXCJDb250aW51ZVN0YXRlbWVudFwiOiAgICAgICAgIFtcImxhYmVsXCJdLFxuICBcIkRlYnVnZ2VyU3RhdGVtZW50XCI6ICAgICAgICAgW10sXG4gIFwiRG9XaGlsZVN0YXRlbWVudFwiOiAgICAgICAgICBbXCJib2R5XCIsIFwidGVzdFwiXSxcbiAgXCJFbXB0eVN0YXRlbWVudFwiOiAgICAgICAgICAgIFtdLFxuICBcIkV4cG9ydEJhdGNoU3BlY2lmaWVyXCI6ICAgICAgW10sXG4gIFwiRXhwb3J0RGVjbGFyYXRpb25cIjogICAgICAgICBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIl0sXG4gIFwiRXhwb3J0U3BlY2lmaWVyXCI6ICAgICAgICAgICBbXCJpZFwiLCBcIm5hbWVcIl0sXG4gIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOiAgICAgICBbXCJleHByZXNzaW9uXCJdLFxuICBcIkZpbGVcIjogICAgICAgICAgICAgICAgICAgICAgW1wicHJvZ3JhbVwiXSxcbiAgXCJGb3JJblN0YXRlbWVudFwiOiAgICAgICAgICAgIFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIl0sXG4gIFwiRm9yT2ZTdGF0ZW1lbnRcIjogICAgICAgICAgICBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBcIkZvclN0YXRlbWVudFwiOiAgICAgICAgICAgICAgW1wiaW5pdFwiLCBcInRlc3RcIiwgXCJ1cGRhdGVcIiwgXCJib2R5XCJdLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjogICAgICAgW1wiaWRcIiwgXCJwYXJhbXNcIiwgXCJkZWZhdWx0c1wiLCBcInJlc3RcIiwgXCJib2R5XCJdLFxuICBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOiAgICAgICAgW1wiaWRcIiwgXCJwYXJhbXNcIiwgXCJkZWZhdWx0c1wiLCBcInJlc3RcIiwgXCJib2R5XCJdLFxuICBcIklkZW50aWZpZXJcIjogICAgICAgICAgICAgICAgW10sXG4gIFwiSWZTdGF0ZW1lbnRcIjogICAgICAgICAgICAgICBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiXSxcbiAgXCJJbXBvcnRCYXRjaFNwZWNpZmllclwiOiAgICAgIFtcImlkXCJdLFxuICBcIkltcG9ydERlY2xhcmF0aW9uXCI6ICAgICAgICAgW1wic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgXCJJbXBvcnRTcGVjaWZpZXJcIjogICAgICAgICAgIFtcImlkXCIsIFwibmFtZVwiXSxcbiAgXCJMYWJlbGVkU3RhdGVtZW50XCI6ICAgICAgICAgIFtcImxhYmVsXCIsIFwiYm9keVwiXSxcbiAgXCJMaXRlcmFsXCI6ICAgICAgICAgICAgICAgICAgIFtdLFxuICBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6ICAgICAgICAgW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBcIk1lbWJlckV4cHJlc3Npb25cIjogICAgICAgICAgW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIFwiTWV0aG9kRGVmaW5pdGlvblwiOiAgICAgICAgICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgXCJOZXdFeHByZXNzaW9uXCI6ICAgICAgICAgICAgIFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiXSxcbiAgXCJPYmplY3RFeHByZXNzaW9uXCI6ICAgICAgICAgIFtcInByb3BlcnRpZXNcIl0sXG4gIFwiT2JqZWN0UGF0dGVyblwiOiAgICAgICAgICAgICBbXCJwcm9wZXJ0aWVzXCJdLFxuICBcIlByaXZhdGVEZWNsYXJhdGlvblwiOiAgICAgICAgW1wiZGVjbGFyYXRpb25zXCJdLFxuICBcIlByb2dyYW1cIjogICAgICAgICAgICAgICAgICAgW1wiYm9keVwiXSxcbiAgXCJQcm9wZXJ0eVwiOiAgICAgICAgICAgICAgICAgIFtcImtleVwiLCBcInZhbHVlXCJdLFxuICBcIlJlc3RFbGVtZW50XCI6ICAgICAgICAgICAgICAgW1wiYXJndW1lbnRcIl0sXG4gIFwiUmV0dXJuU3RhdGVtZW50XCI6ICAgICAgICAgICBbXCJhcmd1bWVudFwiXSxcbiAgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjogICAgICAgIFtcImV4cHJlc3Npb25zXCJdLFxuICBcIlNwcmVhZEVsZW1lbnRcIjogICAgICAgICAgICAgW1wiYXJndW1lbnRcIl0sXG4gIFwiU3ByZWFkUHJvcGVydHlcIjogICAgICAgICAgICBbXCJhcmd1bWVudFwiXSxcbiAgXCJTd2l0Y2hDYXNlXCI6ICAgICAgICAgICAgICAgIFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCJdLFxuICBcIlN3aXRjaFN0YXRlbWVudFwiOiAgICAgICAgICAgW1wiZGlzY3JpbWluYW50XCIsIFwiY2FzZXNcIl0sXG4gIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6ICBbXCJ0YWdcIiwgXCJxdWFzaVwiXSxcbiAgXCJUZW1wbGF0ZUVsZW1lbnRcIjogICAgICAgICAgIFtdLFxuICBcIlRlbXBsYXRlTGl0ZXJhbFwiOiAgICAgICAgICAgW1wicXVhc2lzXCIsIFwiZXhwcmVzc2lvbnNcIl0sXG4gIFwiVGhpc0V4cHJlc3Npb25cIjogICAgICAgICAgICBbXSxcbiAgXCJUaHJvd1N0YXRlbWVudFwiOiAgICAgICAgICAgIFtcImFyZ3VtZW50XCJdLFxuICBcIlRyeVN0YXRlbWVudFwiOiAgICAgICAgICAgICAgW1wiYmxvY2tcIiwgXCJoYW5kbGVyc1wiLCBcImhhbmRsZXJcIiwgXCJndWFyZGVkSGFuZGxlcnNcIiwgXCJmaW5hbGl6ZXJcIl0sXG4gIFwiVW5hcnlFeHByZXNzaW9uXCI6ICAgICAgICAgICBbXCJhcmd1bWVudFwiXSxcbiAgXCJVcGRhdGVFeHByZXNzaW9uXCI6ICAgICAgICAgIFtcImFyZ3VtZW50XCJdLFxuICBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjogICAgICAgW1wiZGVjbGFyYXRpb25zXCJdLFxuICBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOiAgICAgICAgW1wiaWRcIiwgXCJpbml0XCJdLFxuICBcIlZpcnR1YWxQcm9wZXJ0eUV4cHJlc3Npb25cIjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIFwiV2hpbGVTdGF0ZW1lbnRcIjogICAgICAgICAgICBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgXCJXaXRoU3RhdGVtZW50XCI6ICAgICAgICAgICAgIFtcIm9iamVjdFwiLCBcImJvZHlcIl0sXG4gIFwiWWllbGRFeHByZXNzaW9uXCI6ICAgICAgICAgICBbXCJhcmd1bWVudFwiXSxcblxuICBcIkFueVR5cGVBbm5vdGF0aW9uXCI6ICAgICAgICAgICBbXSxcbiAgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCI6ICAgICAgICAgW10sXG4gIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCI6ICAgICAgIFtdLFxuICBcIkNsYXNzUHJvcGVydHlcIjogICAgICAgICAgICAgICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAgXCJEZWNsYXJlQ2xhc3NcIjogICAgICAgICAgICAgICAgW10sXG4gIFwiRGVjbGFyZUZ1bmN0aW9uXCI6ICAgICAgICAgICAgIFtdLFxuICBcIkRlY2xhcmVNb2R1bGVcIjogICAgICAgICAgICAgICBbXSxcbiAgXCJEZWNsYXJlVmFyaWFibGVcIjogICAgICAgICAgICAgW10sXG4gIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiOiAgICAgIFtdLFxuICBcIkZ1bmN0aW9uVHlwZVBhcmFtXCI6ICAgICAgICAgICBbXSxcbiAgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIjogICAgICAgW10sXG4gIFwiSW50ZXJmYWNlRXh0ZW5kc1wiOiAgICAgICAgICAgIFtdLFxuICBcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6ICAgICAgICBbXSxcbiAgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOiAgW10sXG4gIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOiAgICAgIFtdLFxuICBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCI6ICAgICAgICBbXSxcbiAgXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIjogW10sXG4gIFwiU3RyaW5nVHlwZUFubm90YXRpb25cIjogICAgICAgIFtdLFxuICBcIlR1cGxlVHlwZUFubm90YXRpb25cIjogICAgICAgICBbXSxcbiAgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiOiAgICAgICAgW10sXG4gIFwiVHlwZUFsaWFzXCI6ICAgICAgICAgICAgICAgICAgIFtdLFxuICBcIlR5cGVBbm5vdGF0aW9uXCI6ICAgICAgICAgICAgICBbXSxcbiAgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjogICAgICAgICAgW1wiZXhwcmVzc2lvblwiXSxcbiAgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIjogICAgW10sXG4gIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjogIFtdLFxuICBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI6ICAgICAgICBbXSxcbiAgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCI6ICAgICAgW10sXG4gIFwiT2JqZWN0VHlwZUluZGV4ZXJcIjogICAgICAgICAgIFtdLFxuICBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOiAgICAgICAgICBbXSxcbiAgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiOiAgICAgW10sXG4gIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiOiAgICAgICAgIFtdLFxuICBcIlZvaWRUeXBlQW5ub3RhdGlvblwiOiAgICAgICAgICBbXSxcblxuICBcIkpTWEF0dHJpYnV0ZVwiOiAgICAgICAgICAgICAgW1wibmFtZVwiLCBcInZhbHVlXCJdLFxuICBcIkpTWENsb3NpbmdFbGVtZW50XCI6ICAgICAgICAgW1wibmFtZVwiXSxcbiAgXCJKU1hFbGVtZW50XCI6ICAgICAgICAgICAgICAgIFtcIm9wZW5pbmdFbGVtZW50XCIsIFwiY2xvc2luZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiXSxcbiAgXCJKU1hFbXB0eUV4cHJlc3Npb25cIjogICAgICAgIFtdLFxuICBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIjogICAgW1wiZXhwcmVzc2lvblwiXSxcbiAgXCJKU1hJZGVudGlmaWVyXCI6ICAgICAgICAgICAgIFtdLFxuICBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjogICAgICAgW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIFwiSlNYTmFtZXNwYWNlZE5hbWVcIjogICAgICAgICBbXCJuYW1lc3BhY2VcIiwgXCJuYW1lXCJdLFxuICBcIkpTWE9wZW5pbmdFbGVtZW50XCI6ICAgICAgICAgW1wibmFtZVwiLCBcImF0dHJpYnV0ZXNcIl0sXG4gIFwiSlNYU3ByZWFkQXR0cmlidXRlXCI6ICAgICAgICBbXCJhcmd1bWVudFwiXVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuL3BhdGNoXCIpO1xuXG52YXIgY2xvbmVEZWVwICA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9jbG9uZURlZXBcIik7XG52YXIgY29udGFpbnMgICA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9jb250YWluc1wiKTtcbnZhciB0cmF2ZXJzZSAgID0gcmVxdWlyZShcIi4vdHJhdmVyc2FsXCIpO1xudmFyIGlzU3RyaW5nICAgPSByZXF1aXJlKFwibG9kYXNoL2xhbmcvaXNTdHJpbmdcIik7XG52YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvbGFuZy9pc1JlZ0V4cFwiKTtcbnZhciBpc0VtcHR5ICAgID0gcmVxdWlyZShcImxvZGFzaC9sYW5nL2lzRW1wdHlcIik7XG52YXIgcGFyc2UgICAgICA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvcGFyc2VcIik7XG52YXIgZGVidWcgICAgICA9IHJlcXVpcmUoXCJkZWJ1Zy9ub2RlXCIpO1xudmFyIHBhdGggICAgICAgPSByZXF1aXJlKFwicGF0aFwiKTtcbnZhciB1dGlsICAgICAgID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgZWFjaCAgICAgICA9IHJlcXVpcmUoXCJsb2Rhc2gvY29sbGVjdGlvbi9lYWNoXCIpO1xudmFyIGhhcyAgICAgICAgPSByZXF1aXJlKFwibG9kYXNoL29iamVjdC9oYXNcIik7XG52YXIgZnMgICAgICAgICA9IHJlcXVpcmUoXCJmc1wiKTtcbnZhciB0ICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSB1dGlsLmluaGVyaXRzO1xuXG5leHBvcnRzLmRlYnVnID0gZGVidWcoXCJiYWJlbFwiKTtcblxuZXhwb3J0cy5jYW5Db21waWxlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBhbHRFeHRzKSB7XG4gIHZhciBleHRzID0gYWx0RXh0cyB8fCBleHBvcnRzLmNhbkNvbXBpbGUuRVhURU5TSU9OUztcbiAgdmFyIGV4dCA9IHBhdGguZXh0bmFtZShmaWxlbmFtZSk7XG4gIHJldHVybiBjb250YWlucyhleHRzLCBleHQpO1xufTtcblxuZXhwb3J0cy5jYW5Db21waWxlLkVYVEVOU0lPTlMgPSBbXCIuanNcIiwgXCIuanN4XCIsIFwiLmVzNlwiLCBcIi5lc1wiXTtcblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24gKGxvYykge1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUobG9jKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IHZhbC5zcGxpdChcIixcIikgOiBbXTtcbn07XG5cbmV4cG9ydHMucmVnZXhpZnkgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICghdmFsKSByZXR1cm4gbmV3IFJlZ0V4cCgvLl4vKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgdmFsID0gdmFsLmpvaW4oXCJ8XCIpO1xuICBpZiAoaXNTdHJpbmcodmFsKSkgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcbiAgaWYgKGlzUmVnRXhwKHZhbCkpIHJldHVybiB2YWw7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbGxlZ2FsIHR5cGUgZm9yIHJlZ2V4aWZ5XCIpO1xufTtcblxuZXhwb3J0cy5hcnJheWlmeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKCF2YWwpIHJldHVybiBbXTtcbiAgaWYgKGlzU3RyaW5nKHZhbCkpIHJldHVybiBleHBvcnRzLmxpc3QodmFsKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlsbGVnYWwgdHlwZSBmb3IgYXJyYXlpZnlcIik7XG59O1xuXG52YXIgdGVtcGxhdGVWaXNpdG9yID0ge1xuICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgc2NvcGUsIG5vZGVzKSB7XG4gICAgaWYgKHQuaXNFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgIH1cbiAgICBpZiAodC5pc0lkZW50aWZpZXIobm9kZSkgJiYgaGFzKG5vZGVzLCBub2RlLm5hbWUpKSB7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICAgIHJldHVybiBub2Rlc1tub2RlLm5hbWVdO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBub2Rlcywga2VlcEV4cHJlc3Npb24pIHtcbiAgdmFyIHRlbXBsYXRlID0gZXhwb3J0cy50ZW1wbGF0ZXNbbmFtZV07XG4gIGlmICghdGVtcGxhdGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInVua25vd24gdGVtcGxhdGUgXCIgKyBuYW1lKTtcblxuICBpZiAobm9kZXMgPT09IHRydWUpIHtcbiAgICBrZWVwRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgbm9kZXMgPSBudWxsO1xuICB9XG5cbiAgdGVtcGxhdGUgPSBjbG9uZURlZXAodGVtcGxhdGUpO1xuXG4gIGlmICghaXNFbXB0eShub2RlcykpIHtcbiAgICB0cmF2ZXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVWaXNpdG9yLCBudWxsLCBub2Rlcyk7XG4gIH1cblxuICBpZiAodGVtcGxhdGUuYm9keS5sZW5ndGggPiAxKSByZXR1cm4gdGVtcGxhdGUuYm9keTtcblxuICB2YXIgbm9kZSA9IHRlbXBsYXRlLmJvZHlbMF07XG5cbiAgaWYgKCFrZWVwRXhwcmVzc2lvbiAmJiB0LmlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn07XG5cbmV4cG9ydHMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uIChsb2MsIGNvZGUpIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHsgZmlsZW5hbWU6IGxvYyB9LCBjb2RlKS5wcm9ncmFtO1xuICByZXR1cm4gdHJhdmVyc2UucmVtb3ZlUHJvcGVydGllcyhhc3QpO1xufTtcblxudmFyIGxvYWRUZW1wbGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZW1wbGF0ZXMgPSB7fTtcblxuICB2YXIgdGVtcGxhdGVzTG9jID0gX19kaXJuYW1lICsgXCIvdHJhbnNmb3JtYXRpb24vdGVtcGxhdGVzXCI7XG4gIGlmICghZnMuZXhpc3RzU3luYyh0ZW1wbGF0ZXNMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdGVtcGxhdGVzIGRpcmVjdG9yeSAtIHRoaXMgaXMgbW9zdCBsaWtlbHkgdGhlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJyZXN1bHQgb2YgYSBicm9rZW4gYG5wbSBwdWJsaXNoYC4gUGxlYXNlIHJlcG9ydCB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlc1wiKTtcbiAgfVxuXG4gIGVhY2goZnMucmVhZGRpclN5bmModGVtcGxhdGVzTG9jKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZVswXSA9PT0gXCIuXCIpIHJldHVybjtcblxuICAgIHZhciBrZXkgID0gcGF0aC5iYXNlbmFtZShuYW1lLCBwYXRoLmV4dG5hbWUobmFtZSkpO1xuICAgIHZhciBsb2MgID0gdGVtcGxhdGVzTG9jICsgXCIvXCIgKyBuYW1lO1xuICAgIHZhciBjb2RlID0gZnMucmVhZEZpbGVTeW5jKGxvYywgXCJ1dGY4XCIpO1xuXG4gICAgdGVtcGxhdGVzW2tleV0gPSBleHBvcnRzLnBhcnNlVGVtcGxhdGUobG9jLCBjb2RlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlbXBsYXRlcztcbn07XG5cbnRyeSB7XG4gIGV4cG9ydHMudGVtcGxhdGVzID0gcmVxdWlyZShcIi4uLy4uL3RlbXBsYXRlcy5qc29uXCIpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGlmIChlcnIuY29kZSAhPT0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIpIHRocm93IGVycjtcblxuICBleHBvcnRzLnRlbXBsYXRlcyA9IGxvYWRUZW1wbGF0ZXMoKTtcbn1cbiIsIi8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgdmFyaW91cyBjb250cmlidXRvcnMgYW5kXG4vLyByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzXG4vLyBhbmQgd2hpdGVzcGFjZSkgd2VyZSB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5XG4vLyBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuLy9cbi8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4vaXNzdWVzXG4vL1xuLy8gVGhpcyBmaWxlIGRlZmluZXMgdGhlIG1haW4gcGFyc2VyIGludGVyZmFjZS4gVGhlIGxpYnJhcnkgYWxzbyBjb21lc1xuLy8gd2l0aCBhIFtlcnJvci10b2xlcmFudCBwYXJzZXJdW2RhbW1pdF0gYW5kIGFuXG4vLyBbYWJzdHJhY3Qgc3ludGF4IHRyZWUgd2Fsa2VyXVt3YWxrXSwgZGVmaW5lZCBpbiBvdGhlciBmaWxlcy5cbi8vXG4vLyBbZGFtbWl0XTogYWNvcm5fbG9vc2UuanNcbi8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cbihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSByZXR1cm4gbW9kKGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCJdLCBtb2QpOyAvLyBBTURcbiAgbW9kKHJvb3QuYWNvcm4gfHwgKHJvb3QuYWNvcm4gPSB7fSkpOyAvLyBQbGFpbiBicm93c2VyIGVudlxufSkodGhpcywgZnVuY3Rpb24oZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLnZlcnNpb24gPSBcIjAuMTEuMVwiO1xuXG4gIC8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4gIC8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kXG4gIC8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuICAvLyBBUEldW2FwaV0sIHdpdGggdGhlIGNhdmVhdCB0aGF0IGlubGluZSBYTUwgaXMgbm90IHJlY29nbml6ZWQuXG4gIC8vXG4gIC8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbiAgdmFyIG9wdGlvbnMsIGlucHV0LCBpbnB1dExlbiwgc291cmNlRmlsZTtcblxuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oaW5wdCwgb3B0cykge1xuICAgIGlucHV0ID0gU3RyaW5nKGlucHQpOyBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgIGluaXRUb2tlblN0YXRlKCk7XG4gICAgdmFyIHN0YXJ0UG9zID0gb3B0aW9ucy5sb2NhdGlvbnMgPyBbdG9rUG9zLCBjdXJQb3NpdGlvbigpXSA6IHRva1BvcztcbiAgICBpbml0UGFyc2VyU3RhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5zdHJpY3RNb2RlKSB7XG4gICAgICBzdHJpY3QgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VUb3BMZXZlbChvcHRpb25zLnByb2dyYW0gfHwgc3RhcnROb2RlQXQoc3RhcnRQb3MpKTtcbiAgfTtcblxuICAvLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbiAgLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc3RyaWN0TW9kZTogZmFsc2UsXG4gICAgcGxheWdyb3VuZDogZmFsc2UsXG4gICAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdFxuICAgIC8vIGJlIGVpdGhlciAzLCBvciA1LCBvciA2LiBUaGlzIGluZmx1ZW5jZXMgc3VwcG9ydCBmb3Igc3RyaWN0XG4gICAgLy8gbW9kZSwgdGhlIHNldCBvZiByZXNlcnZlZCB3b3Jkcywgc3VwcG9ydCBmb3IgZ2V0dGVycyBhbmRcbiAgICAvLyBzZXR0ZXJzIGFuZCBvdGhlciBmZWF0dXJlcy5cbiAgICBlY21hVmVyc2lvbjogNSxcbiAgICAvLyBUdXJuIG9uIGBzdHJpY3RTZW1pY29sb25zYCB0byBwcmV2ZW50IHRoZSBwYXJzZXIgZnJvbSBkb2luZ1xuICAgIC8vIGF1dG9tYXRpYyBzZW1pY29sb24gaW5zZXJ0aW9uLlxuICAgIHN0cmljdFNlbWljb2xvbnM6IGZhbHNlLFxuICAgIC8vIFdoZW4gYGFsbG93VHJhaWxpbmdDb21tYXNgIGlzIGZhbHNlLCB0aGUgcGFyc2VyIHdpbGwgbm90IGFsbG93XG4gICAgLy8gdHJhaWxpbmcgY29tbWFzIGluIGFycmF5IGFuZCBvYmplY3QgbGl0ZXJhbHMuXG4gICAgYWxsb3dUcmFpbGluZ0NvbW1hczogdHJ1ZSxcbiAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgbm90IGVuZm9yY2VkLiBFbmFibGVcbiAgICAvLyBgZm9yYmlkUmVzZXJ2ZWRgIHRvIGVuZm9yY2UgdGhlbS4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlXG4gICAgLy8gdmFsdWUgXCJldmVyeXdoZXJlXCIsIHJlc2VydmVkIHdvcmRzIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmVcbiAgICAvLyB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICAgIGZvcmJpZFJlc2VydmVkOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgICAvLyBlcnJvci5cbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAgIC8vIGFwcGVhcmluZyBhdCB0aGUgdG9wIG9mIHRoZSBwcm9ncmFtLlxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gICAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAgIC8vIG5vZGVzLlxuICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgICAvLyBmb3JtYXQgYXMgdG9rZW5pemUoKSByZXR1cm5zLiBOb3RlIHRoYXQgeW91IGFyZSBub3RcbiAgICAvLyBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbFxuICAgIC8vIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAgIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAgIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gICAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gICAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gICAgLy8gYHRydWVgLlxuICAgIC8vXG4gICAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAgIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAgIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gICAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAgIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAgIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4gIC8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbiAgLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbihpbnB0LCBwb3MsIG9wdHMpIHtcbiAgICBpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICBpbml0VG9rZW5TdGF0ZShwb3MpO1xuICAgIGluaXRQYXJzZXJTdGF0ZSgpO1xuICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oKTtcbiAgfTtcblxuICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07XG4gICAgc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZSB8fCBudWxsO1xuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKSB7XG4gICAgICB2YXIgY29tbWVudHMgPSBvcHRpb25zLm9uQ29tbWVudDtcbiAgICAgIG9wdGlvbnMub25Db21tZW50ID0gZnVuY3Rpb24gKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICAgIHR5cGU6IGJsb2NrID8gJ0Jsb2NrJyA6ICdMaW5lJyxcbiAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgICAgICBjb21tZW50LmxvYy5zdGFydCA9IHN0YXJ0TG9jO1xuICAgICAgICAgIGNvbW1lbnQubG9jLmVuZCA9IGVuZExvYztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlzS2V5d29yZCA9IGlzRWNtYTZLZXl3b3JkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0tleXdvcmQgPSBpc0VjbWE1QW5kTGVzc0tleXdvcmQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuICAvLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuICAvLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAvLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4gIC8vIGludG8uXG5cbiAgdmFyIGdldExpbmVJbmZvID0gZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGZ1bmN0aW9uKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICBsaW5lQnJlYWsubGFzdEluZGV4ID0gY3VyO1xuICAgICAgdmFyIG1hdGNoID0gbGluZUJyZWFrLmV4ZWMoaW5wdXQpO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgY3VyID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9IGVsc2UgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7bGluZTogbGluZSwgY29sdW1uOiBvZmZzZXQgLSBjdXJ9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFRva2VuKCkge1xuICAgIHRoaXMudHlwZSA9IHRva1R5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHRva1ZhbDtcbiAgICB0aGlzLnN0YXJ0ID0gdG9rU3RhcnQ7XG4gICAgdGhpcy5lbmQgPSB0b2tFbmQ7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgdGhpcy5sb2MuZW5kID0gdG9rRW5kTG9jO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICB0aGlzLnJhbmdlID0gW3Rva1N0YXJ0LCB0b2tFbmRdO1xuICB9XG5cbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuXG4gIC8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4gIC8vIFRoZSBgdG9rZW5pemVgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cbiAgLy8gQmVjYXVzZSB0aGUgdG9rZW5pemVyIGlzIG9wdGltaXplZCBmb3IgYmVpbmcgZWZmaWNpZW50bHkgdXNlZCBieVxuICAvLyB0aGUgQWNvcm4gcGFyc2VyIGl0c2VsZiwgdGhpcyBpbnRlcmZhY2UgaXMgc29tZXdoYXQgY3J1ZGUgYW5kIG5vdFxuICAvLyB2ZXJ5IG1vZHVsYXIuIFBlcmZvcm1pbmcgYW5vdGhlciBwYXJzZSBvciBjYWxsIHRvIGB0b2tlbml6ZWAgd2lsbFxuICAvLyByZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUsIGFuZCBpbnZhbGlkYXRlIGV4aXN0aW5nIHRva2VuaXplcnMuXG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uKGlucHQsIG9wdHMpIHtcbiAgICBpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICBpbml0VG9rZW5TdGF0ZSgpO1xuICAgIHNraXBTcGFjZSgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgICBsYXN0RW5kID0gdG9rRW5kO1xuICAgICAgcmVhZFRva2VuKCk7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKCk7XG4gICAgfVxuICAgIGdldFRva2VuLmp1bXBUbyA9IGZ1bmN0aW9uKHBvcywgZXhwckFsbG93ZWQpIHtcbiAgICAgIHRva1BvcyA9IHBvcztcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB0b2tDdXJMaW5lID0gMTtcbiAgICAgICAgdG9rTGluZVN0YXJ0ID0gbGluZUJyZWFrLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCBwb3MpIHtcbiAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva0V4cHJBbGxvd2VkID0gISFleHByQWxsb3dlZDtcbiAgICAgIHNraXBTcGFjZSgpO1xuICAgIH07XG4gICAgZ2V0VG9rZW4uY3VycmVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFRva2VuKCk7IH07XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnZXRUb2tlbltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldFRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSBfZW9mLFxuICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VG9rZW4ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGdldFRva2VuO1xuICB9O1xuXG4gIC8vIFN0YXRlIGlzIGtlcHQgaW4gKGNsb3N1cmUtKWdsb2JhbCB2YXJpYWJsZXMuIFdlIGFscmVhZHkgc2F3IHRoZVxuICAvLyBgb3B0aW9uc2AsIGBpbnB1dGAsIGFuZCBgaW5wdXRMZW5gIHZhcmlhYmxlcyBhYm92ZS5cblxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cblxuICB2YXIgdG9rUG9zO1xuXG4gIC8vIFRoZSBzdGFydCBhbmQgZW5kIG9mZnNldHMgb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG5cbiAgdmFyIHRva1N0YXJ0LCB0b2tFbmQ7XG5cbiAgLy8gV2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIHRydWUsIHRoZXNlIGhvbGQgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHRoZSB0b2tlbnMgc3RhcnQgYW5kIGVuZCBsaW5lL2NvbHVtbiBwYWlycy5cblxuICB2YXIgdG9rU3RhcnRMb2MsIHRva0VuZExvYztcblxuICAvLyBUaGUgdHlwZSBhbmQgdmFsdWUgb2YgdGhlIGN1cnJlbnQgdG9rZW4uIFRva2VuIHR5cGVzIGFyZSBvYmplY3RzLFxuICAvLyBuYW1lZCBieSB2YXJpYWJsZXMgYWdhaW5zdCB3aGljaCB0aGV5IGNhbiBiZSBjb21wYXJlZCwgYW5kXG4gIC8vIGhvbGRpbmcgcHJvcGVydGllcyB0aGF0IGRlc2NyaWJlIHRoZW0gKGluZGljYXRpbmcsIGZvciBleGFtcGxlLFxuICAvLyB0aGUgcHJlY2VkZW5jZSBvZiBhbiBpbmZpeCBvcGVyYXRvciwgYW5kIHRoZSBvcmlnaW5hbCBuYW1lIG9mIGFcbiAgLy8ga2V5d29yZCB0b2tlbikuIFRoZSBraW5kIG9mIHZhbHVlIHRoYXQncyBoZWxkIGluIGB0b2tWYWxgIGRlcGVuZHNcbiAgLy8gb24gdGhlIHR5cGUgb2YgdGhlIHRva2VuLiBGb3IgbGl0ZXJhbHMsIGl0IGlzIHRoZSBsaXRlcmFsIHZhbHVlLFxuICAvLyBmb3Igb3BlcmF0b3JzLCB0aGUgb3BlcmF0b3IgbmFtZSwgYW5kIHNvIG9uLlxuXG4gIHZhciB0b2tUeXBlLCB0b2tWYWw7XG5cbiAgLy8gSW50ZXJuYWwgc3RhdGUgZm9yIHRoZSB0b2tlbml6ZXIuIFRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gZGl2aXNpb25cbiAgLy8gb3BlcmF0b3JzIGFuZCByZWd1bGFyIGV4cHJlc3Npb25zLCBpdCByZW1lbWJlcnMgd2hldGhlciB0aGUgbGFzdFxuICAvLyB0b2tlbiB3YXMgb25lIHRoYXQgaXMgYWxsb3dlZCB0byBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uLiBJblxuICAvLyBzb21lIGNhc2VzLCBub3RhYmx5IGFmdGVyICcpJyBvciAnfScgdG9rZW5zLCB0aGUgc2l0dWF0aW9uXG4gIC8vIGRlcGVuZHMgb24gdGhlIGNvbnRleHQgYmVmb3JlIHRoZSBtYXRjaGluZyBvcGVuaW5nIGJyYWNrZXQsIHNvXG4gIC8vIHRva0NvbnRleHQga2VlcHMgYSBzdGFjayBvZiBpbmZvcm1hdGlvbiBhYm91dCBjdXJyZW50IGJyYWNrZXRlZFxuICAvLyBmb3Jtcy5cblxuICB2YXIgdG9rQ29udGV4dCwgdG9rRXhwckFsbG93ZWQ7XG5cbiAgLy8gV2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIHRydWUsIHRoZXNlIGFyZSB1c2VkIHRvIGtlZXBcbiAgLy8gdHJhY2sgb2YgdGhlIGN1cnJlbnQgbGluZSwgYW5kIGtub3cgd2hlbiBhIG5ldyBsaW5lIGhhcyBiZWVuXG4gIC8vIGVudGVyZWQuXG5cbiAgdmFyIHRva0N1ckxpbmUsIHRva0xpbmVTdGFydDtcblxuICAvLyBUaGVzZSBzdG9yZSB0aGUgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyB1c2VmdWxcbiAgLy8gd2hlbiBmaW5pc2hpbmcgYSBub2RlIGFuZCBhc3NpZ25pbmcgaXRzIGBlbmRgIHBvc2l0aW9uLlxuXG4gIHZhciBsYXN0U3RhcnQsIGxhc3RFbmQsIGxhc3RFbmRMb2M7XG5cbiAgLy8gVGhpcyBpcyB0aGUgcGFyc2VyJ3Mgc3RhdGUuIGBpbkZ1bmN0aW9uYCBpcyB1c2VkIHRvIHJlamVjdFxuICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRzIG91dHNpZGUgb2YgZnVuY3Rpb25zLCBgaW5HZW5lcmF0b3JgIHRvXG4gIC8vIHJlamVjdCBgeWllbGRgcyBvdXRzaWRlIG9mIGdlbmVyYXRvcnMsIGBsYWJlbHNgIHRvIHZlcmlmeVxuICAvLyB0aGF0IGBicmVha2AgYW5kIGBjb250aW51ZWAgaGF2ZSBzb21ld2hlcmUgdG8ganVtcCB0bywgYW5kXG4gIC8vIGBzdHJpY3RgIGluZGljYXRlcyB3aGV0aGVyIHN0cmljdCBtb2RlIGlzIG9uLlxuXG4gIHZhciBpbkZ1bmN0aW9uLCBpbkdlbmVyYXRvciwgaW5Bc3luYywgbGFiZWxzLCBzdHJpY3QsXG4gICAgaW5YSlNDaGlsZCwgaW5YSlNUYWcsIGluVHlwZTtcblxuICBmdW5jdGlvbiBpbml0UGFyc2VyU3RhdGUoKSB7XG4gICAgbGFzdFN0YXJ0ID0gbGFzdEVuZCA9IHRva1BvcztcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIGxhc3RFbmRMb2MgPSBjdXJQb3NpdGlvbigpO1xuICAgIGluRnVuY3Rpb24gPSBpbkdlbmVyYXRvciA9IGluQXN5bmMgPSBmYWxzZTtcbiAgICBsYWJlbHMgPSBbXTtcbiAgICBza2lwU3BhY2UoKTtcbiAgICByZWFkVG9rZW4oKTtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbiAgLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbiAgLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4gIC8vIG1lc3NhZ2UuXG5cbiAgZnVuY3Rpb24gcmFpc2UocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKGlucHV0LCBwb3MpO1xuICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRva1BvcztcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICAvLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxuICB2YXIgZW1wdHkgPSBbXTtcblxuICAvLyAjIyBUb2tlbiB0eXBlc1xuXG4gIC8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4gIC8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuICAvLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuICAvLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbiAgLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbiAgLy8gVGhlc2UgYXJlIHRoZSBnZW5lcmFsIHR5cGVzLiBUaGUgYHR5cGVgIHByb3BlcnR5IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBtYWtlIHRoZW0gcmVjb2duaXplYWJsZSB3aGVuIGRlYnVnZ2luZy5cblxuICB2YXIgX251bSA9IHt0eXBlOiBcIm51bVwifSwgX3JlZ2V4cCA9IHt0eXBlOiBcInJlZ2V4cFwifSwgX3N0cmluZyA9IHt0eXBlOiBcInN0cmluZ1wifTtcbiAgdmFyIF9uYW1lID0ge3R5cGU6IFwibmFtZVwifSwgX2VvZiA9IHt0eXBlOiBcImVvZlwifTtcbiAgdmFyIF9qc3hOYW1lID0ge3R5cGU6IFwianN4TmFtZVwifTtcblxuICAvLyBUaGVzZSBhcmUgSlNYLXNwZWNpZmljIHRva2VuIHR5cGVzXG5cbiAgdmFyIF94anNOYW1lID0ge3R5cGU6IFwieGpzTmFtZVwifSwgX3hqc1RleHQgPSB7dHlwZTogXCJ4anNUZXh0XCJ9O1xuXG4gIC8vIEtleXdvcmQgdG9rZW5zLiBUaGUgYGtleXdvcmRgIHByb3BlcnR5IChhbHNvIHVzZWQgaW4ga2V5d29yZC1saWtlXG4gIC8vIG9wZXJhdG9ycykgaW5kaWNhdGVzIHRoYXQgdGhlIHRva2VuIG9yaWdpbmF0ZWQgZnJvbSBhblxuICAvLyBpZGVudGlmaWVyLWxpa2Ugd29yZCwgd2hpY2ggaXMgdXNlZCB3aGVuIHBhcnNpbmcgcHJvcGVydHkgbmFtZXMuXG4gIC8vXG4gIC8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4gIC8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbiAgLy8gYmUgZm9sbG93ZWQgYnkgYW4gZXhwcmVzc2lvbiAodGh1cywgYSBzbGFzaCBhZnRlciB0aGVtIHdvdWxkIGJlIGFcbiAgLy8gcmVndWxhciBleHByZXNzaW9uKS5cbiAgLy9cbiAgLy8gYGlzTG9vcGAgbWFya3MgYSBrZXl3b3JkIGFzIHN0YXJ0aW5nIGEgbG9vcCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHRvIGtub3cgd2hlbiBwYXJzaW5nIGEgbGFiZWwsIGluIG9yZGVyIHRvIGFsbG93IG9yIGRpc2FsbG93XG4gIC8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbiAgdmFyIF9icmVhayA9IHtrZXl3b3JkOiBcImJyZWFrXCJ9LCBfY2FzZSA9IHtrZXl3b3JkOiBcImNhc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9jYXRjaCA9IHtrZXl3b3JkOiBcImNhdGNoXCJ9O1xuICB2YXIgX2NvbnRpbnVlID0ge2tleXdvcmQ6IFwiY29udGludWVcIn0sIF9kZWJ1Z2dlciA9IHtrZXl3b3JkOiBcImRlYnVnZ2VyXCJ9LCBfZGVmYXVsdCA9IHtrZXl3b3JkOiBcImRlZmF1bHRcIn07XG4gIHZhciBfZG8gPSB7a2V5d29yZDogXCJkb1wiLCBpc0xvb3A6IHRydWV9LCBfZWxzZSA9IHtrZXl3b3JkOiBcImVsc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZmluYWxseSA9IHtrZXl3b3JkOiBcImZpbmFsbHlcIn0sIF9mb3IgPSB7a2V5d29yZDogXCJmb3JcIiwgaXNMb29wOiB0cnVlfSwgX2Z1bmN0aW9uID0ge2tleXdvcmQ6IFwiZnVuY3Rpb25cIn07XG4gIHZhciBfaWYgPSB7a2V5d29yZDogXCJpZlwifSwgX3JldHVybiA9IHtrZXl3b3JkOiBcInJldHVyblwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3N3aXRjaCA9IHtrZXl3b3JkOiBcInN3aXRjaFwifTtcbiAgdmFyIF90aHJvdyA9IHtrZXl3b3JkOiBcInRocm93XCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfdHJ5ID0ge2tleXdvcmQ6IFwidHJ5XCJ9LCBfdmFyID0ge2tleXdvcmQ6IFwidmFyXCJ9O1xuICB2YXIgX2xldCA9IHtrZXl3b3JkOiBcImxldFwifSwgX2NvbnN0ID0ge2tleXdvcmQ6IFwiY29uc3RcIn07XG4gIHZhciBfd2hpbGUgPSB7a2V5d29yZDogXCJ3aGlsZVwiLCBpc0xvb3A6IHRydWV9LCBfd2l0aCA9IHtrZXl3b3JkOiBcIndpdGhcIn0sIF9uZXcgPSB7a2V5d29yZDogXCJuZXdcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfdGhpcyA9IHtrZXl3b3JkOiBcInRoaXNcIn07XG4gIHZhciBfY2xhc3MgPSB7a2V5d29yZDogXCJjbGFzc1wifSwgX2V4dGVuZHMgPSB7a2V5d29yZDogXCJleHRlbmRzXCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2V4cG9ydCA9IHtrZXl3b3JkOiBcImV4cG9ydFwifSwgX2ltcG9ydCA9IHtrZXl3b3JkOiBcImltcG9ydFwifTtcbiAgdmFyIF95aWVsZCA9IHtrZXl3b3JkOiBcInlpZWxkXCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIC8vIFRoZSBrZXl3b3JkcyB0aGF0IGRlbm90ZSB2YWx1ZXMuXG5cbiAgdmFyIF9udWxsID0ge2tleXdvcmQ6IFwibnVsbFwiLCBhdG9tVmFsdWU6IG51bGx9LCBfdHJ1ZSA9IHtrZXl3b3JkOiBcInRydWVcIiwgYXRvbVZhbHVlOiB0cnVlfTtcbiAgdmFyIF9mYWxzZSA9IHtrZXl3b3JkOiBcImZhbHNlXCIsIGF0b21WYWx1ZTogZmFsc2V9O1xuXG4gIC8vIFNvbWUga2V5d29yZHMgYXJlIHRyZWF0ZWQgYXMgcmVndWxhciBvcGVyYXRvcnMuIGBpbmAgc29tZXRpbWVzXG4gIC8vICh3aGVuIHBhcnNpbmcgYGZvcmApIG5lZWRzIHRvIGJlIHRlc3RlZCBhZ2FpbnN0IHNwZWNpZmljYWxseSwgc29cbiAgLy8gd2UgYXNzaWduIGEgdmFyaWFibGUgbmFtZSB0byBpdCBmb3IgcXVpY2sgY29tcGFyaW5nLlxuXG4gIHZhciBfaW4gPSB7a2V5d29yZDogXCJpblwiLCBiaW5vcDogNywgYmVmb3JlRXhwcjogdHJ1ZX07XG5cbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRUeXBlcyA9IHtcImJyZWFrXCI6IF9icmVhaywgXCJjYXNlXCI6IF9jYXNlLCBcImNhdGNoXCI6IF9jYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICBcImNvbnRpbnVlXCI6IF9jb250aW51ZSwgXCJkZWJ1Z2dlclwiOiBfZGVidWdnZXIsIFwiZGVmYXVsdFwiOiBfZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICBcImRvXCI6IF9kbywgXCJlbHNlXCI6IF9lbHNlLCBcImZpbmFsbHlcIjogX2ZpbmFsbHksIFwiZm9yXCI6IF9mb3IsXG4gICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBfZnVuY3Rpb24sIFwiaWZcIjogX2lmLCBcInJldHVyblwiOiBfcmV0dXJuLCBcInN3aXRjaFwiOiBfc3dpdGNoLFxuICAgICAgICAgICAgICAgICAgICAgIFwidGhyb3dcIjogX3Rocm93LCBcInRyeVwiOiBfdHJ5LCBcInZhclwiOiBfdmFyLCBcImxldFwiOiBfbGV0LCBcImNvbnN0XCI6IF9jb25zdCxcbiAgICAgICAgICAgICAgICAgICAgICBcIndoaWxlXCI6IF93aGlsZSwgXCJ3aXRoXCI6IF93aXRoLFxuICAgICAgICAgICAgICAgICAgICAgIFwibnVsbFwiOiBfbnVsbCwgXCJ0cnVlXCI6IF90cnVlLCBcImZhbHNlXCI6IF9mYWxzZSwgXCJuZXdcIjogX25ldywgXCJpblwiOiBfaW4sXG4gICAgICAgICAgICAgICAgICAgICAgXCJpbnN0YW5jZW9mXCI6IHtrZXl3b3JkOiBcImluc3RhbmNlb2ZcIiwgYmlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9LCBcInRoaXNcIjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlb2ZcIjoge2tleXdvcmQ6IFwidHlwZW9mXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJ2b2lkXCI6IHtrZXl3b3JkOiBcInZvaWRcIiwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImRlbGV0ZVwiOiB7a2V5d29yZDogXCJkZWxldGVcIiwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IF9jbGFzcywgXCJleHRlbmRzXCI6IF9leHRlbmRzLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZXhwb3J0XCI6IF9leHBvcnQsIFwiaW1wb3J0XCI6IF9pbXBvcnQsIFwieWllbGRcIjogX3lpZWxkfTtcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy4gQWdhaW4sIHRoZSBgdHlwZWAgcHJvcGVydHkgaXMgcHVyZWx5IGZvciBkZWJ1Z2dpbmcuXG5cbiAgdmFyIF9icmFja2V0TCA9IHt0eXBlOiBcIltcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9icmFja2V0UiA9IHt0eXBlOiBcIl1cIn0sIF9icmFjZUwgPSB7dHlwZTogXCJ7XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JyYWNlUiA9IHt0eXBlOiBcIn1cIn0sIF9wYXJlbkwgPSB7dHlwZTogXCIoXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfcGFyZW5SID0ge3R5cGU6IFwiKVwifTtcbiAgdmFyIF9jb21tYSA9IHt0eXBlOiBcIixcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9zZW1pID0ge3R5cGU6IFwiO1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9jb2xvbiA9IHt0eXBlOiBcIjpcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9kb3QgPSB7dHlwZTogXCIuXCJ9LCBfcXVlc3Rpb24gPSB7dHlwZTogXCI/XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2Fycm93ID0ge3R5cGU6IFwiPT5cIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF90ZW1wbGF0ZSA9IHt0eXBlOiBcInRlbXBsYXRlXCJ9O1xuICB2YXIgX2VsbGlwc2lzID0ge3R5cGU6IFwiLi4uXCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JhY2tRdW90ZSA9IHt0eXBlOiBcImBcIn0sIF9kb2xsYXJCcmFjZUwgPSB7dHlwZTogXCIke1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9qc3hUZXh0ID0ge3R5cGU6IFwianN4VGV4dFwifTtcbiAgdmFyIF9wYWFtYXlpbU5la3Vkb3RheWltID0geyB0eXBlOiBcIjo6XCIsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9oYXNoID0geyB0eXBlOiAnIycgfTtcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuIGBpc1VwZGF0ZWAgc3BlY2lmaWVzIHRoYXQgdGhlIG5vZGUgcHJvZHVjZWQgYnlcbiAgLy8gdGhlIG9wZXJhdG9yIHNob3VsZCBiZSBvZiB0eXBlIFVwZGF0ZUV4cHJlc3Npb24gcmF0aGVyIHRoYW5cbiAgLy8gc2ltcGx5IFVuYXJ5RXhwcmVzc2lvbiAoYCsrYCBhbmQgYC0tYCkuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICB2YXIgX3NsYXNoID0ge2Jpbm9wOiAxMCwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9lcSA9IHtpc0Fzc2lnbjogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYXNzaWduID0ge2lzQXNzaWduOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9pbmNEZWMgPSB7cG9zdGZpeDogdHJ1ZSwgcHJlZml4OiB0cnVlLCBpc1VwZGF0ZTogdHJ1ZX0sIF9wcmVmaXggPSB7cHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9sb2dpY2FsT1IgPSB7Ymlub3A6IDEsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2xvZ2ljYWxBTkQgPSB7Ymlub3A6IDIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdHdpc2VPUiA9IHtiaW5vcDogMywgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZVhPUiA9IHtiaW5vcDogNCwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZUFORCA9IHtiaW5vcDogNSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZXF1YWxpdHkgPSB7Ymlub3A6IDYsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3JlbGF0aW9uYWwgPSB7Ymlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdFNoaWZ0ID0ge2Jpbm9wOiA4LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9wbHVzTWluID0ge2Jpbm9wOiA5LCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX21vZHVsbyA9IHtiaW5vcDogMTAsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIC8vICcqJyBtYXkgYmUgbXVsdGlwbHkgb3IgaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gRVM2XG4gIHZhciBfc3RhciA9IHtiaW5vcDogMTAsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2V4cG9uZW50ID0ge2Jpbm9wOiAxMSwgYmVmb3JlRXhwcjogdHJ1ZSwgcmlnaHRBc3NvY2lhdGl2ZTogdHJ1ZX07XG5cbiAgLy8gSlNYIHRhZyBib3VuZGFyaWVzXG4gIHZhciBfanN4VGFnU3RhcnQgPSB7dHlwZTogXCJqc3hUYWdTdGFydFwifSwgX2pzeFRhZ0VuZCA9IHt0eXBlOiBcImpzeFRhZ0VuZFwifTtcblxuICAvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgdG9rZW4gdHlwZXMgZm9yIGV4dGVybmFsIHVzZXJzIG9mIHRoZVxuICAvLyB0b2tlbml6ZXIuXG5cbiAgZXhwb3J0cy50b2tUeXBlcyA9IHticmFja2V0TDogX2JyYWNrZXRMLCBicmFja2V0UjogX2JyYWNrZXRSLCBicmFjZUw6IF9icmFjZUwsIGJyYWNlUjogX2JyYWNlUixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbkw6IF9wYXJlbkwsIHBhcmVuUjogX3BhcmVuUiwgY29tbWE6IF9jb21tYSwgc2VtaTogX3NlbWksIGNvbG9uOiBfY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgZG90OiBfZG90LCBlbGxpcHNpczogX2VsbGlwc2lzLCBxdWVzdGlvbjogX3F1ZXN0aW9uLCBzbGFzaDogX3NsYXNoLCBlcTogX2VxLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF9uYW1lLCBlb2Y6IF9lb2YsIG51bTogX251bSwgcmVnZXhwOiBfcmVnZXhwLCBzdHJpbmc6IF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgcGFhbWF5aW1OZWt1ZG90YXlpbTogX3BhYW1heWltTmVrdWRvdGF5aW0sIGV4cG9uZW50OiBfZXhwb25lbnQsIGhhc2g6IF9oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBfYXJyb3csIHRlbXBsYXRlOiBfdGVtcGxhdGUsIHN0YXI6IF9zdGFyLCBhc3NpZ246IF9hc3NpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgYmFja1F1b3RlOiBfYmFja1F1b3RlLCBkb2xsYXJCcmFjZUw6IF9kb2xsYXJCcmFjZUwsIGpzeE5hbWU6IF9qc3hOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGpzeFRleHQ6IF9qc3hUZXh0LCBqc3hUYWdTdGFydDogX2pzeFRhZ1N0YXJ0LCBqc3hUYWdFbmQ6IF9qc3hUYWdFbmR9O1xuICBmb3IgKHZhciBrdyBpbiBrZXl3b3JkVHlwZXMpIGV4cG9ydHMudG9rVHlwZXNbXCJfXCIgKyBrd10gPSBrZXl3b3JkVHlwZXNba3ddO1xuXG4gIC8vIFRoaXMgaXMgYSB0cmljayB0YWtlbiBmcm9tIEVzcHJpbWEuIEl0IHR1cm5zIG91dCB0aGF0LCBvblxuICAvLyBub24tQ2hyb21lIGJyb3dzZXJzLCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIGluIGEgc2V0LCBhXG4gIC8vIHByZWRpY2F0ZSBjb250YWluaW5nIGEgYmlnIHVnbHkgYHN3aXRjaGAgc3RhdGVtZW50IGlzIGZhc3RlciB0aGFuXG4gIC8vIGEgcmVndWxhciBleHByZXNzaW9uLCBhbmQgb24gQ2hyb21lIHRoZSB0d28gYXJlIGFib3V0IG9uIHBhci5cbiAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIGBldmFsYCAobm9uLWxleGljYWwpIHRvIHByb2R1Y2Ugc3VjaCBhXG4gIC8vIHByZWRpY2F0ZSBmcm9tIGEgc3BhY2Utc2VwYXJhdGVkIHN0cmluZyBvZiB3b3Jkcy5cbiAgLy9cbiAgLy8gSXQgc3RhcnRzIGJ5IHNvcnRpbmcgdGhlIHdvcmRzIGJ5IGxlbmd0aC5cblxuICAvLyBSZW1vdmVkIHRvIGNyZWF0ZSBhbiBldmFsLWZyZWUgbGlicmFyeVxuXG4gIC8vIFRoZSBFQ01BU2NyaXB0IDMgcmVzZXJ2ZWQgd29yZCBsaXN0LlxuXG4gIHZhciBpc1Jlc2VydmVkV29yZDMgPSBmdW5jdGlvbiBhbm9ueW1vdXMoc3RyXG4vKiovKSB7XG5zd2l0Y2goc3RyLmxlbmd0aCl7Y2FzZSA2OnN3aXRjaChzdHIpe2Nhc2UgXCJkb3VibGVcIjpjYXNlIFwiZXhwb3J0XCI6Y2FzZSBcImltcG9ydFwiOmNhc2UgXCJuYXRpdmVcIjpjYXNlIFwicHVibGljXCI6Y2FzZSBcInN0YXRpY1wiOmNhc2UgXCJ0aHJvd3NcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA0OnN3aXRjaChzdHIpe2Nhc2UgXCJieXRlXCI6Y2FzZSBcImNoYXJcIjpjYXNlIFwiZW51bVwiOmNhc2UgXCJnb3RvXCI6Y2FzZSBcImxvbmdcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA1OnN3aXRjaChzdHIpe2Nhc2UgXCJjbGFzc1wiOmNhc2UgXCJmaW5hbFwiOmNhc2UgXCJmbG9hdFwiOmNhc2UgXCJzaG9ydFwiOmNhc2UgXCJzdXBlclwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDc6c3dpdGNoKHN0cil7Y2FzZSBcImJvb2xlYW5cIjpjYXNlIFwiZXh0ZW5kc1wiOmNhc2UgXCJwYWNrYWdlXCI6Y2FzZSBcInByaXZhdGVcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA5OnN3aXRjaChzdHIpe2Nhc2UgXCJpbnRlcmZhY2VcIjpjYXNlIFwicHJvdGVjdGVkXCI6Y2FzZSBcInRyYW5zaWVudFwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDg6c3dpdGNoKHN0cil7Y2FzZSBcImFic3RyYWN0XCI6Y2FzZSBcInZvbGF0aWxlXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgMTA6cmV0dXJuIHN0ciA9PT0gXCJpbXBsZW1lbnRzXCI7Y2FzZSAzOnJldHVybiBzdHIgPT09IFwiaW50XCI7Y2FzZSAxMjpyZXR1cm4gc3RyID09PSBcInN5bmNocm9uaXplZFwiO31cbn07XG5cbiAgLy8gRUNNQVNjcmlwdCA1IHJlc2VydmVkIHdvcmRzLlxuXG4gIHZhciBpc1Jlc2VydmVkV29yZDUgPSBmdW5jdGlvbiBhbm9ueW1vdXMoc3RyXG4vKiovKSB7XG5zd2l0Y2goc3RyLmxlbmd0aCl7Y2FzZSA1OnN3aXRjaChzdHIpe2Nhc2UgXCJjbGFzc1wiOmNhc2UgXCJzdXBlclwiOmNhc2UgXCJjb25zdFwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDY6c3dpdGNoKHN0cil7Y2FzZSBcImV4cG9ydFwiOmNhc2UgXCJpbXBvcnRcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA0OnJldHVybiBzdHIgPT09IFwiZW51bVwiO2Nhc2UgNzpyZXR1cm4gc3RyID09PSBcImV4dGVuZHNcIjt9XG59O1xuXG4gIC8vIFRoZSBhZGRpdGlvbmFsIHJlc2VydmVkIHdvcmRzIGluIHN0cmljdCBtb2RlLlxuXG4gIHZhciBpc1N0cmljdFJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGFub255bW91cyhzdHJcbi8qKi8pIHtcbnN3aXRjaChzdHIubGVuZ3RoKXtjYXNlIDk6c3dpdGNoKHN0cil7Y2FzZSBcImludGVyZmFjZVwiOmNhc2UgXCJwcm90ZWN0ZWRcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA3OnN3aXRjaChzdHIpe2Nhc2UgXCJwYWNrYWdlXCI6Y2FzZSBcInByaXZhdGVcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA2OnN3aXRjaChzdHIpe2Nhc2UgXCJwdWJsaWNcIjpjYXNlIFwic3RhdGljXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgMTA6cmV0dXJuIHN0ciA9PT0gXCJpbXBsZW1lbnRzXCI7Y2FzZSAzOnJldHVybiBzdHIgPT09IFwibGV0XCI7Y2FzZSA1OnJldHVybiBzdHIgPT09IFwieWllbGRcIjt9XG59O1xuXG4gIC8vIFRoZSBmb3JiaWRkZW4gdmFyaWFibGUgbmFtZXMgaW4gc3RyaWN0IG1vZGUuXG5cbiAgdmFyIGlzU3RyaWN0QmFkSWRXb3JkID0gZnVuY3Rpb24gYW5vbnltb3VzKHN0clxuLyoqLykge1xuc3dpdGNoKHN0cil7Y2FzZSBcImV2YWxcIjpjYXNlIFwiYXJndW1lbnRzXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1xufTtcblxuICAvLyBBbmQgdGhlIGtleXdvcmRzLlxuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGlzRWNtYTVBbmRMZXNzS2V5d29yZCA9IGZ1bmN0aW9uIGFub255bW91cyhzdHJcbi8qKi8pIHtcbnN3aXRjaChzdHIubGVuZ3RoKXtjYXNlIDQ6c3dpdGNoKHN0cil7Y2FzZSBcImNhc2VcIjpjYXNlIFwiZWxzZVwiOmNhc2UgXCJ3aXRoXCI6Y2FzZSBcIm51bGxcIjpjYXNlIFwidHJ1ZVwiOmNhc2UgXCJ2b2lkXCI6Y2FzZSBcInRoaXNcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA1OnN3aXRjaChzdHIpe2Nhc2UgXCJicmVha1wiOmNhc2UgXCJjYXRjaFwiOmNhc2UgXCJ0aHJvd1wiOmNhc2UgXCJ3aGlsZVwiOmNhc2UgXCJmYWxzZVwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDM6c3dpdGNoKHN0cil7Y2FzZSBcImZvclwiOmNhc2UgXCJ0cnlcIjpjYXNlIFwidmFyXCI6Y2FzZSBcIm5ld1wiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDY6c3dpdGNoKHN0cil7Y2FzZSBcInJldHVyblwiOmNhc2UgXCJzd2l0Y2hcIjpjYXNlIFwidHlwZW9mXCI6Y2FzZSBcImRlbGV0ZVwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDg6c3dpdGNoKHN0cil7Y2FzZSBcImNvbnRpbnVlXCI6Y2FzZSBcImRlYnVnZ2VyXCI6Y2FzZSBcImZ1bmN0aW9uXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgMjpzd2l0Y2goc3RyKXtjYXNlIFwiZG9cIjpjYXNlIFwiaWZcIjpjYXNlIFwiaW5cIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSA3OnN3aXRjaChzdHIpe2Nhc2UgXCJkZWZhdWx0XCI6Y2FzZSBcImZpbmFsbHlcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSAxMDpyZXR1cm4gc3RyID09PSBcImluc3RhbmNlb2ZcIjt9XG59O1xuXG4gIHZhciBlY21hNkFuZExlc3NLZXl3b3JkcyA9IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgbGV0IGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCB5aWVsZFwiO1xuXG4gIHZhciBpc0VjbWE2S2V5d29yZCA9IGZ1bmN0aW9uIGFub255bW91cyhzdHJcbi8qKi8pIHtcbnN3aXRjaChzdHIubGVuZ3RoKXtjYXNlIDU6c3dpdGNoKHN0cil7Y2FzZSBcImJyZWFrXCI6Y2FzZSBcImNhdGNoXCI6Y2FzZSBcInRocm93XCI6Y2FzZSBcIndoaWxlXCI6Y2FzZSBcImZhbHNlXCI6Y2FzZSBcImNvbnN0XCI6Y2FzZSBcImNsYXNzXCI6Y2FzZSBcInlpZWxkXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgNDpzd2l0Y2goc3RyKXtjYXNlIFwiY2FzZVwiOmNhc2UgXCJlbHNlXCI6Y2FzZSBcIndpdGhcIjpjYXNlIFwibnVsbFwiOmNhc2UgXCJ0cnVlXCI6Y2FzZSBcInZvaWRcIjpjYXNlIFwidGhpc1wiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDY6c3dpdGNoKHN0cil7Y2FzZSBcInJldHVyblwiOmNhc2UgXCJzd2l0Y2hcIjpjYXNlIFwidHlwZW9mXCI6Y2FzZSBcImRlbGV0ZVwiOmNhc2UgXCJleHBvcnRcIjpjYXNlIFwiaW1wb3J0XCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgMzpzd2l0Y2goc3RyKXtjYXNlIFwiZm9yXCI6Y2FzZSBcInRyeVwiOmNhc2UgXCJ2YXJcIjpjYXNlIFwibmV3XCI6Y2FzZSBcImxldFwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDg6c3dpdGNoKHN0cil7Y2FzZSBcImNvbnRpbnVlXCI6Y2FzZSBcImRlYnVnZ2VyXCI6Y2FzZSBcImZ1bmN0aW9uXCI6cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO2Nhc2UgNzpzd2l0Y2goc3RyKXtjYXNlIFwiZGVmYXVsdFwiOmNhc2UgXCJmaW5hbGx5XCI6Y2FzZSBcImV4dGVuZHNcIjpyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7Y2FzZSAyOnN3aXRjaChzdHIpe2Nhc2UgXCJkb1wiOmNhc2UgXCJpZlwiOmNhc2UgXCJpblwiOnJldHVybiB0cnVlfXJldHVybiBmYWxzZTtjYXNlIDEwOnJldHVybiBzdHIgPT09IFwiaW5zdGFuY2VvZlwiO31cbn07XG5cbiAgdmFyIGlzS2V5d29yZCA9IGlzRWNtYTVBbmRMZXNzS2V5d29yZDtcblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuICAvLyBHZW5lcmF0ZWQgYnkgYHRvb2xzL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjY5XFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDZGMC1cXHUwNkY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3QzAtXFx1MDdDOVxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTQtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk4MS1cXHUwOTgzXFx1MDlCQ1xcdTA5QkUtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlFNi1cXHUwOUVGXFx1MEEwMS1cXHUwQTAzXFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNjYtXFx1MEE3MVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQUJDXFx1MEFCRS1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjNDXFx1MEIzRS1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI4MlxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzNFLVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MENCQ1xcdTBDQkUtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwRDAxLVxcdTBEMDNcXHUwRDNFLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDgyXFx1MEQ4M1xcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFXFx1MEYzRlxcdTBGNzEtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkItXFx1MTAzRVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2RFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4RFxcdTEwOEYtXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0LVxcdTE3RDNcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MThBOVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk0RlxcdTE5QjAtXFx1MTlDMFxcdTE5QzhcXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQy1cXHUxREZGXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTYyMC1cXHVBNjI5XFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjMtXFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEYxXFx1QTkwMC1cXHVBOTA5XFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUzXFx1QTk4MC1cXHVBOTgzXFx1QTlCMy1cXHVBOUMwXFx1QTlEMC1cXHVBOUQ5XFx1QTlFNVxcdUE5RjAtXFx1QTlGOVxcdUFBMjktXFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBN0ItXFx1QUE3RFxcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUItXFx1QUFFRlxcdUFBRjVcXHVBQUY2XFx1QUJFMy1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRjEwLVxcdUZGMTlcXHVGRjNGXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICB2YXIgZGVjaW1hbE51bWJlciA9IC9eXFxkKyQvO1xuICB2YXIgaGV4TnVtYmVyID0gL15bXFxkYS1mQS1GXSskLztcblxuICAvLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuICB2YXIgbmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuICBmdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCBjb2RlID09PSAweDIwMjggfHwgY29kZSA9PSAweDIwMjk7XG4gIH1cblxuICAvLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4gIC8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZztcblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICB2YXIgaXNJZGVudGlmaWVyU3RhcnQgPSBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9O1xuXG4gIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbiAgdmFyIGlzSWRlbnRpZmllckNoYXIgPSBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gICAgaWYgKGNvZGUgPCAxMjMpcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfTtcblxuICAvLyAjIyBUb2tlbml6ZXJcblxuICAvLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbiAgLy8gYHRva1N0YXJ0TG9jYCBhbmQgYHRva0VuZExvY2AgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjdXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRva0N1ckxpbmUsIHRva1BvcyAtIHRva0xpbmVTdGFydCk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgdG9rZW4gc3RhdGUuIFVzZWQgYXQgdGhlIHN0YXJ0IG9mIGEgcGFyc2UuXG5cbiAgZnVuY3Rpb24gaW5pdFRva2VuU3RhdGUocG9zKSB7XG4gICAgaWYgKHBvcykge1xuICAgICAgdG9rUG9zID0gcG9zO1xuICAgICAgdG9rTGluZVN0YXJ0ID0gTWF0aC5tYXgoMCwgaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgcG9zKSk7XG4gICAgICB0b2tDdXJMaW5lID0gaW5wdXQuc2xpY2UoMCwgdG9rTGluZVN0YXJ0KS5zcGxpdChuZXdsaW5lKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva0N1ckxpbmUgPSAxO1xuICAgICAgdG9rUG9zID0gdG9rTGluZVN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdG9rVHlwZSA9IF9lb2Y7XG4gICAgdG9rQ29udGV4dCA9IFtiX3N0YXRdO1xuICAgIHRva0V4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICBpblR5cGUgPSBzdHJpY3QgPSBmYWxzZTtcbiAgICBpZiAodG9rUG9zID09PSAwICYmIG9wdGlvbnMuYWxsb3dIYXNoQmFuZyAmJiBpbnB1dC5zbGljZSgwLCAyKSA9PT0gJyMhJykge1xuICAgICAgc2tpcExpbmVDb21tZW50KDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcbiAgLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuXG4gIHZhciBiX3N0YXQgPSB7dG9rZW46IFwie1wiLCBpc0V4cHI6IGZhbHNlfSwgYl9leHByID0ge3Rva2VuOiBcIntcIiwgaXNFeHByOiB0cnVlfSwgYl90bXBsID0ge3Rva2VuOiBcIiR7XCIsIGlzRXhwcjogdHJ1ZX07XG4gIHZhciBwX3N0YXQgPSB7dG9rZW46IFwiKFwiLCBpc0V4cHI6IGZhbHNlfSwgcF9leHByID0ge3Rva2VuOiBcIihcIiwgaXNFeHByOiB0cnVlfTtcbiAgdmFyIHFfdG1wbCA9IHt0b2tlbjogXCJgXCIsIGlzRXhwcjogdHJ1ZX0sIGZfZXhwciA9IHt0b2tlbjogXCJmdW5jdGlvblwiLCBpc0V4cHI6IHRydWV9O1xuICB2YXIgal9vVGFnID0ge3Rva2VuOiBcIjx0YWdcIiwgaXNFeHByOiBmYWxzZX0sIGpfY1RhZyA9IHt0b2tlbjogXCI8L3RhZ1wiLCBpc0V4cHI6IGZhbHNlfSwgal9leHByID0ge3Rva2VuOiBcIjx0YWc+Li4uPC90YWc+XCIsIGlzRXhwcjogdHJ1ZX07XG5cbiAgZnVuY3Rpb24gY3VyVG9rQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdG9rQ29udGV4dFt0b2tDb250ZXh0Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSB7XG4gICAgdmFyIHBhcmVudDtcbiAgICBpZiAocHJldlR5cGUgPT09IF9jb2xvbiAmJiAocGFyZW50ID0gY3VyVG9rQ29udGV4dCgpKS50b2tlbiA9PSBcIntcIilcbiAgICAgIHJldHVybiAhcGFyZW50LmlzRXhwcjtcbiAgICBpZiAocHJldlR5cGUgPT09IF9yZXR1cm4pXG4gICAgICByZXR1cm4gbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1N0YXJ0KSk7XG4gICAgaWYgKHByZXZUeXBlID09PSBfZWxzZSB8fCBwcmV2VHlwZSA9PT0gX3NlbWkgfHwgcHJldlR5cGUgPT09IF9lb2YpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJldlR5cGUgPT0gX2JyYWNlTClcbiAgICAgIHJldHVybiBjdXJUb2tDb250ZXh0KCkgPT09IGJfc3RhdDtcbiAgICByZXR1cm4gIXRva0V4cHJBbGxvd2VkO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYHRva0VuZGAsIGB0b2tWYWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGB0b2tDb250ZXh0YCBhbmQgYHRva0V4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZVxuICAvLyBhZnRlciB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHRva1N0YXJ0YCB3aWxsIHBvaW50IGF0XG4gIC8vIHRoZSByaWdodCBwb3NpdGlvbi5cblxuICBmdW5jdGlvbiBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0b2tFbmQgPSB0b2tQb3M7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tFbmRMb2MgPSBjdXJQb3NpdGlvbigpO1xuICAgIHZhciBwcmV2VHlwZSA9IHRva1R5cGUsIHByZXNlcnZlU3BhY2UgPSBmYWxzZTtcbiAgICB0b2tUeXBlID0gdHlwZTtcbiAgICB0b2tWYWwgPSB2YWw7XG5cbiAgICAvLyBVcGRhdGUgY29udGV4dCBpbmZvXG4gICAgaWYgKHR5cGUgPT09IF9wYXJlblIgfHwgdHlwZSA9PT0gX2JyYWNlUikge1xuICAgICAgdmFyIG91dCA9IHRva0NvbnRleHQucG9wKCk7XG4gICAgICBpZiAob3V0ID09PSBiX3RtcGwpIHtcbiAgICAgICAgcHJlc2VydmVTcGFjZSA9IHRva0V4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3V0ID09PSBiX3N0YXQgJiYgY3VyVG9rQ29udGV4dCgpID09PSBmX2V4cHIpIHtcbiAgICAgICAgdG9rQ29udGV4dC5wb3AoKTtcbiAgICAgICAgdG9rRXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva0V4cHJBbGxvd2VkID0gIShvdXQgJiYgb3V0LmlzRXhwcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBfYnJhY2VMKSB7XG4gICAgICBzd2l0Y2ggKGN1clRva0NvbnRleHQoKSkge1xuICAgICAgICBjYXNlIGpfb1RhZzogdG9rQ29udGV4dC5wdXNoKGJfZXhwcik7IGJyZWFrO1xuICAgICAgICBjYXNlIGpfZXhwcjogdG9rQ29udGV4dC5wdXNoKGJfdG1wbCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0b2tDb250ZXh0LnB1c2goYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IGJfc3RhdCA6IGJfZXhwcik7XG4gICAgICB9XG4gICAgICB0b2tFeHByQWxsb3dlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBfZG9sbGFyQnJhY2VMKSB7XG4gICAgICB0b2tDb250ZXh0LnB1c2goYl90bXBsKTtcbiAgICAgIHRva0V4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gX3BhcmVuTCkge1xuICAgICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSBfaWYgfHwgcHJldlR5cGUgPT09IF9mb3IgfHwgcHJldlR5cGUgPT09IF93aXRoIHx8IHByZXZUeXBlID09PSBfd2hpbGU7XG4gICAgICB0b2tDb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gcF9zdGF0IDogcF9leHByKTtcbiAgICAgIHRva0V4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gX2luY0RlYykge1xuICAgICAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG4gICAgfSBlbHNlIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT0gX2RvdCkge1xuICAgICAgdG9rRXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gX2Z1bmN0aW9uKSB7XG4gICAgICBpZiAoY3VyVG9rQ29udGV4dCgpICE9PSBiX3N0YXQpIHtcbiAgICAgICAgdG9rQ29udGV4dC5wdXNoKGZfZXhwcik7XG4gICAgICB9XG4gICAgICB0b2tFeHByQWxsb3dlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gX2JhY2tRdW90ZSkge1xuICAgICAgaWYgKGN1clRva0NvbnRleHQoKSA9PT0gcV90bXBsKSB7XG4gICAgICAgIHRva0NvbnRleHQucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2tDb250ZXh0LnB1c2gocV90bXBsKTtcbiAgICAgICAgcHJlc2VydmVTcGFjZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0b2tFeHByQWxsb3dlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gX2pzeFRhZ1N0YXJ0KSB7XG4gICAgICB0b2tDb250ZXh0LnB1c2goal9leHByKTsgLy8gdHJlYXQgYXMgYmVnaW5uaW5nIG9mIEpTWCBleHByZXNzaW9uXG4gICAgICB0b2tDb250ZXh0LnB1c2goal9vVGFnKTsgLy8gc3RhcnQgb3BlbmluZyB0YWcgY29udGV4dFxuICAgICAgdG9rRXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IF9qc3hUYWdFbmQpIHtcbiAgICAgIHZhciBvdXQgPSB0b2tDb250ZXh0LnBvcCgpO1xuICAgICAgaWYgKG91dCA9PT0gal9vVGFnICYmIHByZXZUeXBlID09PSBfc2xhc2ggfHwgb3V0ID09PSBqX2NUYWcpIHtcbiAgICAgICAgdG9rQ29udGV4dC5wb3AoKTtcbiAgICAgICAgcHJlc2VydmVTcGFjZSA9IHRva0V4cHJBbGxvd2VkID0gY3VyVG9rQ29udGV4dCgpID09PSBqX2V4cHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVzZXJ2ZVNwYWNlID0gdG9rRXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gX2pzeFRleHQpIHtcbiAgICAgIHByZXNlcnZlU3BhY2UgPSB0b2tFeHByQWxsb3dlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBfc2xhc2ggJiYgcHJldlR5cGUgPT09IF9qc3hUYWdTdGFydCkge1xuICAgICAgdG9rQ29udGV4dC5sZW5ndGggLT0gMjsgLy8gZG8gbm90IGNvbnNpZGVyIEpTWCBleHByIC0+IEpTWCBvcGVuIHRhZyAtPiAuLi4gYW55bW9yZVxuICAgICAgdG9rQ29udGV4dC5wdXNoKGpfY1RhZyk7IC8vIHJlY29uc2lkZXIgYXMgY2xvc2luZyB0YWcgY29udGV4dFxuICAgICAgdG9rRXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rRXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7XG4gICAgfVxuXG4gICAgaWYgKCFwcmVzZXJ2ZVNwYWNlKSBza2lwU3BhY2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBCbG9ja0NvbW1lbnQoKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0b2tQb3MsIGVuZCA9IGlucHV0LmluZGV4T2YoXCIqL1wiLCB0b2tQb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHJhaXNlKHRva1BvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7XG4gICAgdG9rUG9zID0gZW5kICsgMjtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdG9rUG9zKSB7XG4gICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9uQ29tbWVudClcbiAgICAgIG9wdGlvbnMub25Db21tZW50KHRydWUsIGlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRva1BvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBjdXJQb3NpdGlvbigpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBMaW5lQ29tbWVudChzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0b2tQb3M7XG4gICAgdmFyIHN0YXJ0TG9jID0gb3B0aW9ucy5vbkNvbW1lbnQgJiYgb3B0aW9ucy5sb2NhdGlvbnMgJiYgY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcys9c3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4gJiYgY2ggIT09IDEwICYmIGNoICE9PSAxMyAmJiBjaCAhPT0gODIzMiAmJiBjaCAhPT0gODIzMykge1xuICAgICAgKyt0b2tQb3M7XG4gICAgICBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub25Db21tZW50KVxuICAgICAgb3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIGlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0b2tQb3MpLCBzdGFydCwgdG9rUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIGN1clBvc2l0aW9uKCkpO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuICAvLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG4gIGZ1bmN0aW9uIHNraXBTcGFjZSgpIHtcbiAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4pIHtcbiAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAgIGlmIChjaCA9PT0gMzIpIHsgLy8gJyAnXG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTMpIHtcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgICBpZiAobmV4dCA9PT0gMTApIHtcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgICArK3Rva1BvcztcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgIHRva0xpbmVTdGFydCA9IHRva1BvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA+IDggJiYgY2ggPCAxNCkge1xuICAgICAgICArK3Rva1BvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ3KSB7IC8vICcvJ1xuICAgICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICAgIGlmIChuZXh0ID09PSA0MikgeyAvLyAnKidcbiAgICAgICAgICBza2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDcpIHsgLy8gJy8nXG4gICAgICAgICAgc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAxNjApIHsgLy8gJ1xceGEwJ1xuICAgICAgICArK3Rva1BvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuICBmdW5jdGlvbiByZWFkVG9rZW5fZG90KCkge1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSByZXR1cm4gcmVhZE51bWJlcih0cnVlKTtcbiAgICB2YXIgbmV4dDIgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpO1xuICAgIGlmIChvcHRpb25zLnBsYXlncm91bmQgJiYgbmV4dCA9PT0gNjMpIHsgLy8gNjNcbiAgICAgIHRva1BvcyArPSAyO1xuICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9kb3RRdWVzdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7IC8vIDQ2ID0gZG90ICcuJ1xuICAgICAgdG9rUG9zICs9IDM7XG4gICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2VsbGlwc2lzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0b2tQb3M7XG4gICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2RvdCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3NsYXNoKCkgeyAvLyAnLydcbiAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgaWYgKHRva0V4cHJBbGxvd2VkKSB7Kyt0b2tQb3M7IHJldHVybiByZWFkUmVnZXhwKCk7fVxuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgIHJldHVybiBmaW5pc2hPcChfc2xhc2gsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX21vZHVsbygpIHsgLy8gJyUnXG4gICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgIHJldHVybiBmaW5pc2hPcChfbW9kdWxvLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9tdWx0KCkgeyAvLyAnKidcbiAgICB2YXIgdHlwZSA9IF9zdGFyO1xuICAgIHZhciB3aWR0aCA9IDE7XG4gICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBuZXh0ID09PSA0MikgeyAvLyAnKidcbiAgICAgIHdpZHRoKys7XG4gICAgICBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKTtcbiAgICAgIHR5cGUgPSBfZXhwb25lbnQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IC8vICc9J1xuICAgICAgd2lkdGgrKztcbiAgICAgIHR5cGUgPSBfYXNzaWduO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmluaXNoT3AodHlwZSwgd2lkdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHsgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG9wdGlvbnMucGxheWdyb3VuZCAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDMpO1xuICAgICAgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9sb2dpY2FsT1IgOiBfbG9naWNhbEFORCwgMik7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgIHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfYml0d2lzZU9SIDogX2JpdHdpc2VBTkQsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2NhcmV0KCkgeyAvLyAnXidcbiAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgcmV0dXJuIGZpbmlzaE9wKF9iaXR3aXNlWE9SLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7IC8vICcrLSdcbiAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09IDQ1ICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT0gNjIgJiZcbiAgICAgICAgICBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rUG9zKSkpIHtcbiAgICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgICAgc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICBza2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRUb2tlbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmlzaE9wKF9pbmNEZWMsIDIpO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICByZXR1cm4gZmluaXNoT3AoX3BsdXNNaW4sIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHsgLy8gJzw+J1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKCFpblR5cGUgJiYgbmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyBzaXplKSA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCBzaXplICsgMSk7XG4gICAgICByZXR1cm4gZmluaXNoT3AoX2JpdFNoaWZ0LCBzaXplKTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT0gMzMgJiYgY29kZSA9PSA2MCAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDQ1ICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMykgPT0gNDUpIHtcbiAgICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICAgIHNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgIHNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHJlYWRUb2tlbigpO1xuICAgIH1cbiAgICBpZiAoIWluVHlwZSkge1xuICAgICAgaWYgKHRva0V4cHJBbGxvd2VkICYmIGNvZGUgPT09IDYwKSB7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2pzeFRhZ1N0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICB2YXIgY29udGV4dCA9IGN1clRva0NvbnRleHQoKTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IGpfb1RhZyB8fCBjb250ZXh0ID09PSBqX2NUYWcpIHtcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2pzeFRhZ0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKVxuICAgICAgc2l6ZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDI7XG4gICAgcmV0dXJuIGZpbmlzaE9wKF9yZWxhdGlvbmFsLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHsgLy8gJz0hJywgJz0+J1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfZXF1YWxpdHksIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDIpO1xuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiBvcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgICAgdG9rUG9zICs9IDI7XG4gICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2Fycm93KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDYxID8gX2VxIDogX3ByZWZpeCwgMSk7XG4gIH1cblxuICAvLyBHZXQgdG9rZW4gaW5zaWRlIEVTNiB0ZW1wbGF0ZSAoc3BlY2lhbCBydWxlcyB3b3JrIHRoZXJlKS5cblxuICBmdW5jdGlvbiBnZXRUZW1wbGF0ZVRva2VuKGNvZGUpIHtcbiAgICAvLyAnYCcgYW5kICckeycgaGF2ZSBzcGVjaWFsIG1lYW5pbmdzLCBidXQgdGhleSBzaG91bGQgZm9sbG93XG4gICAgLy8gc3RyaW5nIChjYW4gYmUgZW1wdHkpXG4gICAgaWYgKHRva1R5cGUgPT09IF9zdHJpbmcpIHtcbiAgICAgIGlmIChjb2RlID09PSA5NikgeyAvLyAnYCdcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfYnF1b3RlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMzYgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKSA9PT0gMTIzKSB7IC8vICckeydcbiAgICAgICAgdG9rUG9zICs9IDI7XG4gICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfZG9sbGFyQnJhY2VMKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIHN0cmluZyBsaXRlcmFsXG4gICAgcmV0dXJuIHJlYWRUbXBsU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBzd2l0Y2goY29kZSkge1xuICAgICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6IC8vICcuJ1xuICAgICAgcmV0dXJuIHJlYWRUb2tlbl9kb3QoKTtcblxuICAgICAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICAgIGNhc2UgNDA6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuTCk7XG4gICAgY2FzZSA0MTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5SKTtcbiAgICBjYXNlIDU5OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9zZW1pKTtcbiAgICBjYXNlIDQ0OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9jb21tYSk7XG4gICAgY2FzZSA5MTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldEwpO1xuICAgIGNhc2UgOTM6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRSKTtcbiAgICBjYXNlIDEyMzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VMKTtcbiAgICBjYXNlIDEyNTogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VSKTtcbiAgICBjYXNlIDYzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9xdWVzdGlvbik7XG5cbiAgICBjYXNlIDM1OlxuICAgICAgaWYgKG9wdGlvbnMucGxheWdyb3VuZCkge1xuICAgICAgICArK3Rva1BvcztcbiAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9oYXNoKTtcbiAgICAgIH1cblxuICAgIGNhc2UgNTg6XG4gICAgICArK3Rva1BvcztcbiAgICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcpIHtcbiAgICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgICAgIGlmIChuZXh0ID09PSA1OCkge1xuICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfcGFhbWF5aW1OZWt1ZG90YXlpbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfY29sb24pO1xuXG4gICAgY2FzZSA5NjogLy8gJ2AnXG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2JhY2tRdW90ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIDQ4OiAvLyAnMCdcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHJldHVybiByZWFkUmFkaXhOdW1iZXIoMTYpOyAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSByZXR1cm4gcmVhZFJhZGl4TnVtYmVyKDgpOyAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgcmV0dXJuIHJlYWRSYWRpeE51bWJlcigyKTsgLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICAgIH1cbiAgICAgIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAgICAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICAgIHJldHVybiByZWFkTnVtYmVyKGZhbHNlKTtcblxuICAgICAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgICAgcmV0dXJuIGluWEpTVGFnID8gcmVhZFhKU1N0cmluZ0xpdGVyYWwoKSA6IHJlYWRTdHJpbmcoY29kZSk7XG5cbiAgICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICByZXR1cm4gcmVhZFRva2VuX3NsYXNoKCk7XG5cbiAgICBjYXNlIDM3OiAvLyAnJSdcbiAgICAgIHJldHVybiByZWFkVG9rZW5fbW9kdWxvKCk7XG5cbiAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgIHJldHVybiByZWFkVG9rZW5fbXVsdCgpO1xuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICAgIHJldHVybiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG5cbiAgICBjYXNlIDk0OiAvLyAnXidcbiAgICAgIHJldHVybiByZWFkVG9rZW5fY2FyZXQoKTtcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICAgIHJldHVybiByZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgICByZXR1cm4gcmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgICAgcmV0dXJuIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuXG4gICAgY2FzZSAxMjY6IC8vICd+J1xuICAgICAgcmV0dXJuIGZpbmlzaE9wKF9wcmVmaXgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbigpIHtcbiAgICB0b2tTdGFydCA9IHRva1BvcztcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva1N0YXJ0TG9jID0gY3VyUG9zaXRpb24oKTtcbiAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByZXR1cm4gZmluaXNoVG9rZW4oX2VvZik7XG5cbiAgICB2YXIgY29udGV4dCA9IGN1clRva0NvbnRleHQoKTtcblxuICAgIGlmIChjb250ZXh0ID09PSBxX3RtcGwpIHtcbiAgICAgIHJldHVybiByZWFkVG1wbFRva2VuKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgPT09IGpfZXhwcikge1xuICAgICAgcmV0dXJuIHJlYWRKU1hUb2tlbigpO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgIGlmIChjb250ZXh0ID09PSBqX29UYWcgfHwgY29udGV4dCA9PT0gal9jVGFnKSB7XG4gICAgICAvLyBKU1ggaWRlbnRpZmllclxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSByZXR1cm4gcmVhZEpTWFdvcmQoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGpfZXhwcikge1xuICAgICAgcmV0dXJuIHJlYWRKU1hUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAgIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pIHJldHVybiByZWFkV29yZCgpO1xuICAgIH1cblxuICAgIHZhciB0b2sgPSBnZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuXG4gICAgaWYgKHRvayA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBoZXJlLCB3ZSBlaXRoZXIgZm91bmQgYSBub24tQVNDSUkgaWRlbnRpZmllclxuICAgICAgLy8gY2hhcmFjdGVyLCBvciBzb21ldGhpbmcgdGhhdCdzIGVudGlyZWx5IGRpc2FsbG93ZWQuXG4gICAgICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgaWYgKGNoID09PSBcIlxcXFxcIiB8fCBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSkgcmV0dXJuIHJlYWRXb3JkKCk7XG4gICAgICByYWlzZSh0b2tQb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiB0b2s7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplLCBzaG91bGRTa2lwU3BhY2UpIHtcbiAgICB2YXIgc3RyID0gaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyBzaXplKTtcbiAgICB0b2tQb3MgKz0gc2l6ZTtcbiAgICBmaW5pc2hUb2tlbih0eXBlLCBzdHIsIHNob3VsZFNraXBTcGFjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwVW5pY29kZVN1cHBvcnQgPSBmYWxzZTtcbiAgdHJ5IHsgbmV3IFJlZ0V4cChcIlxcdWZmZmZcIiwgXCJ1XCIpOyByZWdleHBVbmljb2RlU3VwcG9ydCA9IHRydWU7IH1cbiAgY2F0Y2goZSkge31cblxuICAvLyBQYXJzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbi4gU29tZSBjb250ZXh0LWF3YXJlbmVzcyBpcyBuZWNlc3NhcnksXG4gIC8vIHNpbmNlIGEgJy8nIGluc2lkZSBhICdbXScgc2V0IGRvZXMgbm90IGVuZCB0aGUgZXhwcmVzc2lvbi5cblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKCkge1xuICAgIHZhciBjb250ZW50ID0gXCJcIiwgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0b2tQb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICAgIHZhciBjaCA9IG5leHRDaGFyKCk7XG4gICAgICBpZiAobmV3bGluZS50ZXN0KGNoKSkgcmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICBpZiAoY2ggPT09IFwiW1wiKSBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2U7XG4gICAgICArK3Rva1BvcztcbiAgICB9XG4gICAgdmFyIGNvbnRlbnQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcbiAgICArK3Rva1BvcztcbiAgICAvLyBOZWVkIHRvIHVzZSBgcmVhZFdvcmQxYCBiZWNhdXNlICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWRcbiAgICAvLyBoZXJlIChkb24ndCBhc2spLlxuICAgIHZhciBtb2RzID0gcmVhZFdvcmQxKCk7XG4gICAgLy8gRGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICB2YXIgdG1wID0gY29udGVudDtcbiAgICBpZiAobW9kcykge1xuICAgICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnbXNpeV0qJC87XG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB2YWxpZEZsYWdzID0gL15bZ21zaXl1XSokLztcbiAgICAgIGlmICghdmFsaWRGbGFncy50ZXN0KG1vZHMpKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgaWYgKG1vZHMuaW5kZXhPZigndScpID49IDAgJiYgIXJlZ2V4cFVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50cyBzdWNoIGEgc3ltYm9sIHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdFxuICAgICAgICAvLyBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgL3VgIGZsYWcuXG4gICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXXs1LDZ9KVxcfS9nLCBcInhcIilcbiAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBcInhcIik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAodG1wKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSByYWlzZShzdGFydCwgXCJFcnJvciBwYXJzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbjogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgcmFpc2UoZSk7XG4gICAgfVxuICAgIC8vIEdldCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yIGBudWxsYCBpblxuICAgIC8vIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdCB1c2VzLlxuICAgIHRyeSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgUmVnRXhwKGNvbnRlbnQsIG1vZHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdmFsdWUgPSBudWxsO1xuICB9XG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKF9yZWdleHAsIHtwYXR0ZXJuOiBjb250ZW50LCBmbGFnczogbW9kcywgdmFsdWU6IHZhbHVlfSk7XG4gIH1cblxuICAvLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuICAvLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuICAvLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxuICBmdW5jdGlvbiByZWFkSW50KHJhZGl4LCBsZW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0b2tQb3MsIHRvdGFsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpLCB2YWw7XG4gICAgICBpZiAoY29kZSA+PSA5NykgdmFsID0gY29kZSAtIDk3ICsgMTA7IC8vIGFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHZhbCA9IGNvZGUgLSA2NSArIDEwOyAvLyBBXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHZhbCA9IGNvZGUgLSA0ODsgLy8gMC05XG4gICAgICBlbHNlIHZhbCA9IEluZmluaXR5O1xuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG4gICAgICArK3Rva1BvcztcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG4gICAgaWYgKHRva1BvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdG9rUG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUmFkaXhOdW1iZXIocmFkaXgpIHtcbiAgICB0b2tQb3MgKz0gMjsgLy8gMHhcbiAgICB2YXIgdmFsID0gcmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSByYWlzZSh0b2tTdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpO1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKF9udW0sIHZhbCk7XG4gIH1cblxuICAvLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxuICBmdW5jdGlvbiByZWFkTnVtYmVyKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0b2tQb3MsIGlzRmxvYXQgPSBmYWxzZSwgb2N0YWwgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ4O1xuICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiByZWFkSW50KDEwKSA9PT0gbnVsbCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gNDYpIHtcbiAgICAgICsrdG9rUG9zO1xuICAgICAgcmVhZEludCgxMCk7XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgaWYgKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgeyAvLyAnZUUnXG4gICAgICBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCgrK3Rva1Bvcyk7XG4gICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpICsrdG9rUG9zOyAvLyAnKy0nXG4gICAgICBpZiAocmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykpKSByYWlzZSh0b2tQb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG5cbiAgICB2YXIgc3RyID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1BvcyksIHZhbDtcbiAgICBpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIGVsc2UgaWYgKCFvY3RhbCB8fCBzdHIubGVuZ3RoID09PSAxKSB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICBlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHN0cmljdCkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgZWxzZSB2YWwgPSBwYXJzZUludChzdHIsIDgpO1xuICAgIHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICB9XG5cbiAgLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG4gIGZ1bmN0aW9uIHJlYWRDb2RlUG9pbnQoKSB7XG4gICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpLCBjb2RlO1xuICAgIFxuICAgIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICsrdG9rUG9zO1xuICAgICAgY29kZSA9IHJlYWRIZXhDaGFyKGlucHV0LmluZGV4T2YoJ30nLCB0b2tQb3MpIC0gdG9rUG9zKTtcbiAgICAgICsrdG9rUG9zO1xuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikgdW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gcmVhZEhleENoYXIoNCk7XG4gICAgfVxuXG4gICAgLy8gVVRGLTE2IEVuY29kaW5nXG4gICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gICAgdmFyIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICB2YXIgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgdmFyIGlzSlNYID0gY3VyVG9rQ29udGV4dCgpID09PSBqX29UYWc7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3Rva1BvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkgYnJlYWs7XG4gICAgICBpZiAoY2ggPT09IDkyICYmICFpc0pTWCkgeyAvLyAnXFwnXG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0b2tQb3MpO1xuICAgICAgICBvdXQgKz0gcmVhZEVzY2FwZWRDaGFyKCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0b2tQb3M7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAzOCAmJiBpc0pTWCkgeyAvLyAnJidcbiAgICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRva1Bvcyk7XG4gICAgICAgIG91dCArPSByZWFkSlNYRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0b2tQb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSAmJiAhaXNKU1gpIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdG9rUG9zKyspO1xuICAgIHJldHVybiBmaW5pc2hUb2tlbihfc3RyaW5nLCBvdXQpO1xuICB9XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICBmdW5jdGlvbiByZWFkVG1wbFRva2VuKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdG9rUG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHRva1N0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgICAgaWYgKHRva1BvcyA9PT0gdG9rU3RhcnQgJiYgdG9rVHlwZSA9PT0gX3RlbXBsYXRlKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgICAgdG9rUG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoVG9rZW4oX2RvbGxhckJyYWNlTCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9iYWNrUXVvdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdG9rUG9zKTtcbiAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF90ZW1wbGF0ZSwgb3V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdG9rUG9zKTtcbiAgICAgICAgb3V0ICs9IHJlYWRFc2NhcGVkQ2hhcigpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdG9rUG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0b2tQb3MpO1xuICAgICAgICArK3Rva1BvcztcbiAgICAgICAgaWYgKGNoID09PSAxMyAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDEwKSB7XG4gICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRva1BvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBYSFRNTEVudGl0aWVzID0ge1xuICAgIHF1b3Q6ICdcXHUwMDIyJyxcbiAgICBhbXA6ICcmJyxcbiAgICBhcG9zOiAnXFx1MDAyNycsXG4gICAgbHQ6ICc8JyxcbiAgICBndDogJz4nLFxuICAgIG5ic3A6ICdcXHUwMEEwJyxcbiAgICBpZXhjbDogJ1xcdTAwQTEnLFxuICAgIGNlbnQ6ICdcXHUwMEEyJyxcbiAgICBwb3VuZDogJ1xcdTAwQTMnLFxuICAgIGN1cnJlbjogJ1xcdTAwQTQnLFxuICAgIHllbjogJ1xcdTAwQTUnLFxuICAgIGJydmJhcjogJ1xcdTAwQTYnLFxuICAgIHNlY3Q6ICdcXHUwMEE3JyxcbiAgICB1bWw6ICdcXHUwMEE4JyxcbiAgICBjb3B5OiAnXFx1MDBBOScsXG4gICAgb3JkZjogJ1xcdTAwQUEnLFxuICAgIGxhcXVvOiAnXFx1MDBBQicsXG4gICAgbm90OiAnXFx1MDBBQycsXG4gICAgc2h5OiAnXFx1MDBBRCcsXG4gICAgcmVnOiAnXFx1MDBBRScsXG4gICAgbWFjcjogJ1xcdTAwQUYnLFxuICAgIGRlZzogJ1xcdTAwQjAnLFxuICAgIHBsdXNtbjogJ1xcdTAwQjEnLFxuICAgIHN1cDI6ICdcXHUwMEIyJyxcbiAgICBzdXAzOiAnXFx1MDBCMycsXG4gICAgYWN1dGU6ICdcXHUwMEI0JyxcbiAgICBtaWNybzogJ1xcdTAwQjUnLFxuICAgIHBhcmE6ICdcXHUwMEI2JyxcbiAgICBtaWRkb3Q6ICdcXHUwMEI3JyxcbiAgICBjZWRpbDogJ1xcdTAwQjgnLFxuICAgIHN1cDE6ICdcXHUwMEI5JyxcbiAgICBvcmRtOiAnXFx1MDBCQScsXG4gICAgcmFxdW86ICdcXHUwMEJCJyxcbiAgICBmcmFjMTQ6ICdcXHUwMEJDJyxcbiAgICBmcmFjMTI6ICdcXHUwMEJEJyxcbiAgICBmcmFjMzQ6ICdcXHUwMEJFJyxcbiAgICBpcXVlc3Q6ICdcXHUwMEJGJyxcbiAgICBBZ3JhdmU6ICdcXHUwMEMwJyxcbiAgICBBYWN1dGU6ICdcXHUwMEMxJyxcbiAgICBBY2lyYzogJ1xcdTAwQzInLFxuICAgIEF0aWxkZTogJ1xcdTAwQzMnLFxuICAgIEF1bWw6ICdcXHUwMEM0JyxcbiAgICBBcmluZzogJ1xcdTAwQzUnLFxuICAgIEFFbGlnOiAnXFx1MDBDNicsXG4gICAgQ2NlZGlsOiAnXFx1MDBDNycsXG4gICAgRWdyYXZlOiAnXFx1MDBDOCcsXG4gICAgRWFjdXRlOiAnXFx1MDBDOScsXG4gICAgRWNpcmM6ICdcXHUwMENBJyxcbiAgICBFdW1sOiAnXFx1MDBDQicsXG4gICAgSWdyYXZlOiAnXFx1MDBDQycsXG4gICAgSWFjdXRlOiAnXFx1MDBDRCcsXG4gICAgSWNpcmM6ICdcXHUwMENFJyxcbiAgICBJdW1sOiAnXFx1MDBDRicsXG4gICAgRVRIOiAnXFx1MDBEMCcsXG4gICAgTnRpbGRlOiAnXFx1MDBEMScsXG4gICAgT2dyYXZlOiAnXFx1MDBEMicsXG4gICAgT2FjdXRlOiAnXFx1MDBEMycsXG4gICAgT2NpcmM6ICdcXHUwMEQ0JyxcbiAgICBPdGlsZGU6ICdcXHUwMEQ1JyxcbiAgICBPdW1sOiAnXFx1MDBENicsXG4gICAgdGltZXM6ICdcXHUwMEQ3JyxcbiAgICBPc2xhc2g6ICdcXHUwMEQ4JyxcbiAgICBVZ3JhdmU6ICdcXHUwMEQ5JyxcbiAgICBVYWN1dGU6ICdcXHUwMERBJyxcbiAgICBVY2lyYzogJ1xcdTAwREInLFxuICAgIFV1bWw6ICdcXHUwMERDJyxcbiAgICBZYWN1dGU6ICdcXHUwMEREJyxcbiAgICBUSE9STjogJ1xcdTAwREUnLFxuICAgIHN6bGlnOiAnXFx1MDBERicsXG4gICAgYWdyYXZlOiAnXFx1MDBFMCcsXG4gICAgYWFjdXRlOiAnXFx1MDBFMScsXG4gICAgYWNpcmM6ICdcXHUwMEUyJyxcbiAgICBhdGlsZGU6ICdcXHUwMEUzJyxcbiAgICBhdW1sOiAnXFx1MDBFNCcsXG4gICAgYXJpbmc6ICdcXHUwMEU1JyxcbiAgICBhZWxpZzogJ1xcdTAwRTYnLFxuICAgIGNjZWRpbDogJ1xcdTAwRTcnLFxuICAgIGVncmF2ZTogJ1xcdTAwRTgnLFxuICAgIGVhY3V0ZTogJ1xcdTAwRTknLFxuICAgIGVjaXJjOiAnXFx1MDBFQScsXG4gICAgZXVtbDogJ1xcdTAwRUInLFxuICAgIGlncmF2ZTogJ1xcdTAwRUMnLFxuICAgIGlhY3V0ZTogJ1xcdTAwRUQnLFxuICAgIGljaXJjOiAnXFx1MDBFRScsXG4gICAgaXVtbDogJ1xcdTAwRUYnLFxuICAgIGV0aDogJ1xcdTAwRjAnLFxuICAgIG50aWxkZTogJ1xcdTAwRjEnLFxuICAgIG9ncmF2ZTogJ1xcdTAwRjInLFxuICAgIG9hY3V0ZTogJ1xcdTAwRjMnLFxuICAgIG9jaXJjOiAnXFx1MDBGNCcsXG4gICAgb3RpbGRlOiAnXFx1MDBGNScsXG4gICAgb3VtbDogJ1xcdTAwRjYnLFxuICAgIGRpdmlkZTogJ1xcdTAwRjcnLFxuICAgIG9zbGFzaDogJ1xcdTAwRjgnLFxuICAgIHVncmF2ZTogJ1xcdTAwRjknLFxuICAgIHVhY3V0ZTogJ1xcdTAwRkEnLFxuICAgIHVjaXJjOiAnXFx1MDBGQicsXG4gICAgdXVtbDogJ1xcdTAwRkMnLFxuICAgIHlhY3V0ZTogJ1xcdTAwRkQnLFxuICAgIHRob3JuOiAnXFx1MDBGRScsXG4gICAgeXVtbDogJ1xcdTAwRkYnLFxuICAgIE9FbGlnOiAnXFx1MDE1MicsXG4gICAgb2VsaWc6ICdcXHUwMTUzJyxcbiAgICBTY2Fyb246ICdcXHUwMTYwJyxcbiAgICBzY2Fyb246ICdcXHUwMTYxJyxcbiAgICBZdW1sOiAnXFx1MDE3OCcsXG4gICAgZm5vZjogJ1xcdTAxOTInLFxuICAgIGNpcmM6ICdcXHUwMkM2JyxcbiAgICB0aWxkZTogJ1xcdTAyREMnLFxuICAgIEFscGhhOiAnXFx1MDM5MScsXG4gICAgQmV0YTogJ1xcdTAzOTInLFxuICAgIEdhbW1hOiAnXFx1MDM5MycsXG4gICAgRGVsdGE6ICdcXHUwMzk0JyxcbiAgICBFcHNpbG9uOiAnXFx1MDM5NScsXG4gICAgWmV0YTogJ1xcdTAzOTYnLFxuICAgIEV0YTogJ1xcdTAzOTcnLFxuICAgIFRoZXRhOiAnXFx1MDM5OCcsXG4gICAgSW90YTogJ1xcdTAzOTknLFxuICAgIEthcHBhOiAnXFx1MDM5QScsXG4gICAgTGFtYmRhOiAnXFx1MDM5QicsXG4gICAgTXU6ICdcXHUwMzlDJyxcbiAgICBOdTogJ1xcdTAzOUQnLFxuICAgIFhpOiAnXFx1MDM5RScsXG4gICAgT21pY3JvbjogJ1xcdTAzOUYnLFxuICAgIFBpOiAnXFx1MDNBMCcsXG4gICAgUmhvOiAnXFx1MDNBMScsXG4gICAgU2lnbWE6ICdcXHUwM0EzJyxcbiAgICBUYXU6ICdcXHUwM0E0JyxcbiAgICBVcHNpbG9uOiAnXFx1MDNBNScsXG4gICAgUGhpOiAnXFx1MDNBNicsXG4gICAgQ2hpOiAnXFx1MDNBNycsXG4gICAgUHNpOiAnXFx1MDNBOCcsXG4gICAgT21lZ2E6ICdcXHUwM0E5JyxcbiAgICBhbHBoYTogJ1xcdTAzQjEnLFxuICAgIGJldGE6ICdcXHUwM0IyJyxcbiAgICBnYW1tYTogJ1xcdTAzQjMnLFxuICAgIGRlbHRhOiAnXFx1MDNCNCcsXG4gICAgZXBzaWxvbjogJ1xcdTAzQjUnLFxuICAgIHpldGE6ICdcXHUwM0I2JyxcbiAgICBldGE6ICdcXHUwM0I3JyxcbiAgICB0aGV0YTogJ1xcdTAzQjgnLFxuICAgIGlvdGE6ICdcXHUwM0I5JyxcbiAgICBrYXBwYTogJ1xcdTAzQkEnLFxuICAgIGxhbWJkYTogJ1xcdTAzQkInLFxuICAgIG11OiAnXFx1MDNCQycsXG4gICAgbnU6ICdcXHUwM0JEJyxcbiAgICB4aTogJ1xcdTAzQkUnLFxuICAgIG9taWNyb246ICdcXHUwM0JGJyxcbiAgICBwaTogJ1xcdTAzQzAnLFxuICAgIHJobzogJ1xcdTAzQzEnLFxuICAgIHNpZ21hZjogJ1xcdTAzQzInLFxuICAgIHNpZ21hOiAnXFx1MDNDMycsXG4gICAgdGF1OiAnXFx1MDNDNCcsXG4gICAgdXBzaWxvbjogJ1xcdTAzQzUnLFxuICAgIHBoaTogJ1xcdTAzQzYnLFxuICAgIGNoaTogJ1xcdTAzQzcnLFxuICAgIHBzaTogJ1xcdTAzQzgnLFxuICAgIG9tZWdhOiAnXFx1MDNDOScsXG4gICAgdGhldGFzeW06ICdcXHUwM0QxJyxcbiAgICB1cHNpaDogJ1xcdTAzRDInLFxuICAgIHBpdjogJ1xcdTAzRDYnLFxuICAgIGVuc3A6ICdcXHUyMDAyJyxcbiAgICBlbXNwOiAnXFx1MjAwMycsXG4gICAgdGhpbnNwOiAnXFx1MjAwOScsXG4gICAgenduajogJ1xcdTIwMEMnLFxuICAgIHp3ajogJ1xcdTIwMEQnLFxuICAgIGxybTogJ1xcdTIwMEUnLFxuICAgIHJsbTogJ1xcdTIwMEYnLFxuICAgIG5kYXNoOiAnXFx1MjAxMycsXG4gICAgbWRhc2g6ICdcXHUyMDE0JyxcbiAgICBsc3F1bzogJ1xcdTIwMTgnLFxuICAgIHJzcXVvOiAnXFx1MjAxOScsXG4gICAgc2JxdW86ICdcXHUyMDFBJyxcbiAgICBsZHF1bzogJ1xcdTIwMUMnLFxuICAgIHJkcXVvOiAnXFx1MjAxRCcsXG4gICAgYmRxdW86ICdcXHUyMDFFJyxcbiAgICBkYWdnZXI6ICdcXHUyMDIwJyxcbiAgICBEYWdnZXI6ICdcXHUyMDIxJyxcbiAgICBidWxsOiAnXFx1MjAyMicsXG4gICAgaGVsbGlwOiAnXFx1MjAyNicsXG4gICAgcGVybWlsOiAnXFx1MjAzMCcsXG4gICAgcHJpbWU6ICdcXHUyMDMyJyxcbiAgICBQcmltZTogJ1xcdTIwMzMnLFxuICAgIGxzYXF1bzogJ1xcdTIwMzknLFxuICAgIHJzYXF1bzogJ1xcdTIwM0EnLFxuICAgIG9saW5lOiAnXFx1MjAzRScsXG4gICAgZnJhc2w6ICdcXHUyMDQ0JyxcbiAgICBldXJvOiAnXFx1MjBBQycsXG4gICAgaW1hZ2U6ICdcXHUyMTExJyxcbiAgICB3ZWllcnA6ICdcXHUyMTE4JyxcbiAgICByZWFsOiAnXFx1MjExQycsXG4gICAgdHJhZGU6ICdcXHUyMTIyJyxcbiAgICBhbGVmc3ltOiAnXFx1MjEzNScsXG4gICAgbGFycjogJ1xcdTIxOTAnLFxuICAgIHVhcnI6ICdcXHUyMTkxJyxcbiAgICByYXJyOiAnXFx1MjE5MicsXG4gICAgZGFycjogJ1xcdTIxOTMnLFxuICAgIGhhcnI6ICdcXHUyMTk0JyxcbiAgICBjcmFycjogJ1xcdTIxQjUnLFxuICAgIGxBcnI6ICdcXHUyMUQwJyxcbiAgICB1QXJyOiAnXFx1MjFEMScsXG4gICAgckFycjogJ1xcdTIxRDInLFxuICAgIGRBcnI6ICdcXHUyMUQzJyxcbiAgICBoQXJyOiAnXFx1MjFENCcsXG4gICAgZm9yYWxsOiAnXFx1MjIwMCcsXG4gICAgcGFydDogJ1xcdTIyMDInLFxuICAgIGV4aXN0OiAnXFx1MjIwMycsXG4gICAgZW1wdHk6ICdcXHUyMjA1JyxcbiAgICBuYWJsYTogJ1xcdTIyMDcnLFxuICAgIGlzaW46ICdcXHUyMjA4JyxcbiAgICBub3RpbjogJ1xcdTIyMDknLFxuICAgIG5pOiAnXFx1MjIwQicsXG4gICAgcHJvZDogJ1xcdTIyMEYnLFxuICAgIHN1bTogJ1xcdTIyMTEnLFxuICAgIG1pbnVzOiAnXFx1MjIxMicsXG4gICAgbG93YXN0OiAnXFx1MjIxNycsXG4gICAgcmFkaWM6ICdcXHUyMjFBJyxcbiAgICBwcm9wOiAnXFx1MjIxRCcsXG4gICAgaW5maW46ICdcXHUyMjFFJyxcbiAgICBhbmc6ICdcXHUyMjIwJyxcbiAgICBhbmQ6ICdcXHUyMjI3JyxcbiAgICBvcjogJ1xcdTIyMjgnLFxuICAgIGNhcDogJ1xcdTIyMjknLFxuICAgIGN1cDogJ1xcdTIyMkEnLFxuICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgdGhlcmU0OiAnXFx1MjIzNCcsXG4gICAgc2ltOiAnXFx1MjIzQycsXG4gICAgY29uZzogJ1xcdTIyNDUnLFxuICAgIGFzeW1wOiAnXFx1MjI0OCcsXG4gICAgbmU6ICdcXHUyMjYwJyxcbiAgICBlcXVpdjogJ1xcdTIyNjEnLFxuICAgIGxlOiAnXFx1MjI2NCcsXG4gICAgZ2U6ICdcXHUyMjY1JyxcbiAgICBzdWI6ICdcXHUyMjgyJyxcbiAgICBzdXA6ICdcXHUyMjgzJyxcbiAgICBuc3ViOiAnXFx1MjI4NCcsXG4gICAgc3ViZTogJ1xcdTIyODYnLFxuICAgIHN1cGU6ICdcXHUyMjg3JyxcbiAgICBvcGx1czogJ1xcdTIyOTUnLFxuICAgIG90aW1lczogJ1xcdTIyOTcnLFxuICAgIHBlcnA6ICdcXHUyMkE1JyxcbiAgICBzZG90OiAnXFx1MjJDNScsXG4gICAgbGNlaWw6ICdcXHUyMzA4JyxcbiAgICByY2VpbDogJ1xcdTIzMDknLFxuICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxuICAgIHJmbG9vcjogJ1xcdTIzMEInLFxuICAgIGxhbmc6ICdcXHUyMzI5JyxcbiAgICByYW5nOiAnXFx1MjMyQScsXG4gICAgbG96OiAnXFx1MjVDQScsXG4gICAgc3BhZGVzOiAnXFx1MjY2MCcsXG4gICAgY2x1YnM6ICdcXHUyNjYzJyxcbiAgICBoZWFydHM6ICdcXHUyNjY1JyxcbiAgICBkaWFtczogJ1xcdTI2NjYnXG4gIH07XG5cbiAgZnVuY3Rpb24gcmVhZEpTWEVudGl0eSgpIHtcbiAgICB2YXIgc3RyID0gJycsIGNvdW50ID0gMCwgZW50aXR5O1xuICAgIHZhciBjaCA9IGlucHV0W3Rva1Bvc107XG4gICAgaWYgKGNoICE9PSAnJicpIHJhaXNlKHRva1BvcywgXCJFbnRpdHkgbXVzdCBzdGFydCB3aXRoIGFuIGFtcGVyc2FuZFwiKTtcbiAgICB2YXIgc3RhcnRQb3MgPSArK3Rva1BvcztcbiAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4gJiYgY291bnQrKyA8IDEwKSB7XG4gICAgICBjaCA9IGlucHV0W3Rva1BvcysrXTtcbiAgICAgIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgICAgICAgIGlmIChzdHJbMV0gPT09ICd4Jykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigyKTtcbiAgICAgICAgICAgIGlmIChoZXhOdW1iZXIudGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgIGVudGl0eSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLCAxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxOdW1iZXIudGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgIGVudGl0eSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRpdHkgPSBYSFRNTEVudGl0aWVzW3N0cl07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHIgKz0gY2g7XG4gICAgfVxuICAgIGlmICghZW50aXR5KSB7XG4gICAgICB0b2tQb3MgPSBzdGFydFBvcztcbiAgICAgIHJldHVybiAnJic7XG4gICAgfVxuICAgIHJldHVybiBlbnRpdHk7XG4gIH1cblxuICAvLyBSZWFkcyBpbmxpbmUgSlNYIGNvbnRlbnRzIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHJlYWRKU1hUb2tlbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRva1BvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgSlNYIGNvbnRlbnRzXCIpO1xuICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEyMzogLy8gJ3snXG4gICAgICAgIGNhc2UgNjA6IC8vICc8J1xuICAgICAgICAgIGlmICh0b2tQb3MgPT09IHRva1N0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VG9rZW5Gcm9tQ29kZShjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0b2tQb3MpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfanN4VGV4dCwgb3V0KTtcblxuICAgICAgICBjYXNlIDM4OiAvLyAnJidcbiAgICAgICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdG9rUG9zKTtcbiAgICAgICAgICBvdXQgKz0gcmVhZEpTWEVudGl0eSgpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRva1Bvcyk7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSAxMCkge1xuICAgICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gdG9rUG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gIGZ1bmN0aW9uIHJlYWRFc2NhcGVkQ2hhcigpIHtcbiAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcbiAgICB2YXIgb2N0YWwgPSAvXlswLTddKy8uZXhlYyhpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIDMpKTtcbiAgICBpZiAob2N0YWwpIG9jdGFsID0gb2N0YWxbMF07XG4gICAgd2hpbGUgKG9jdGFsICYmIHBhcnNlSW50KG9jdGFsLCA4KSA+IDI1NSkgb2N0YWwgPSBvY3RhbC5zbGljZSgwLCAtMSk7XG4gICAgaWYgKG9jdGFsID09PSBcIjBcIikgb2N0YWwgPSBudWxsO1xuICAgICsrdG9rUG9zO1xuICAgIGlmIChvY3RhbCkge1xuICAgICAgaWYgKHN0cmljdCkgcmFpc2UodG9rUG9zIC0gMiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgdG9rUG9zICs9IG9jdGFsLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChvY3RhbCwgOCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIjsgLy8gJ24nIC0+ICdcXG4nXG4gICAgICAgIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIjsgLy8gJ3InIC0+ICdcXHInXG4gICAgICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcigyKSk7IC8vICd4J1xuICAgICAgICBjYXNlIDExNzogcmV0dXJuIHJlYWRDb2RlUG9pbnQoKTsgLy8gJ3UnXG4gICAgICAgIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIjsgLy8gJ3QnIC0+ICdcXHQnXG4gICAgICAgIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiOyAvLyAnYicgLT4gJ1xcYidcbiAgICAgICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIjsgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICAgICAgICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCI7IC8vICdmJyAtPiAnXFxmJ1xuICAgICAgICBjYXNlIDQ4OiByZXR1cm4gXCJcXDBcIjsgLy8gMCAtPiAnXFwwJ1xuICAgICAgICBjYXNlIDEzOiBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSAxMCkgKyt0b2tQb3M7IC8vICdcXHJcXG4nXG4gICAgICAgIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgeyB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7ICsrdG9rQ3VyTGluZTsgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIFhIVE1MRW50aXRpZXMgPSB7XG4gICAgcXVvdDogJ1xcdTAwMjInLFxuICAgIGFtcDogJyYnLFxuICAgIGFwb3M6ICdcXHUwMDI3JyxcbiAgICBsdDogJzwnLFxuICAgIGd0OiAnPicsXG4gICAgbmJzcDogJ1xcdTAwQTAnLFxuICAgIGlleGNsOiAnXFx1MDBBMScsXG4gICAgY2VudDogJ1xcdTAwQTInLFxuICAgIHBvdW5kOiAnXFx1MDBBMycsXG4gICAgY3VycmVuOiAnXFx1MDBBNCcsXG4gICAgeWVuOiAnXFx1MDBBNScsXG4gICAgYnJ2YmFyOiAnXFx1MDBBNicsXG4gICAgc2VjdDogJ1xcdTAwQTcnLFxuICAgIHVtbDogJ1xcdTAwQTgnLFxuICAgIGNvcHk6ICdcXHUwMEE5JyxcbiAgICBvcmRmOiAnXFx1MDBBQScsXG4gICAgbGFxdW86ICdcXHUwMEFCJyxcbiAgICBub3Q6ICdcXHUwMEFDJyxcbiAgICBzaHk6ICdcXHUwMEFEJyxcbiAgICByZWc6ICdcXHUwMEFFJyxcbiAgICBtYWNyOiAnXFx1MDBBRicsXG4gICAgZGVnOiAnXFx1MDBCMCcsXG4gICAgcGx1c21uOiAnXFx1MDBCMScsXG4gICAgc3VwMjogJ1xcdTAwQjInLFxuICAgIHN1cDM6ICdcXHUwMEIzJyxcbiAgICBhY3V0ZTogJ1xcdTAwQjQnLFxuICAgIG1pY3JvOiAnXFx1MDBCNScsXG4gICAgcGFyYTogJ1xcdTAwQjYnLFxuICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxuICAgIGNlZGlsOiAnXFx1MDBCOCcsXG4gICAgc3VwMTogJ1xcdTAwQjknLFxuICAgIG9yZG06ICdcXHUwMEJBJyxcbiAgICByYXF1bzogJ1xcdTAwQkInLFxuICAgIGZyYWMxNDogJ1xcdTAwQkMnLFxuICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxuICAgIGZyYWMzNDogJ1xcdTAwQkUnLFxuICAgIGlxdWVzdDogJ1xcdTAwQkYnLFxuICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxuICAgIEFhY3V0ZTogJ1xcdTAwQzEnLFxuICAgIEFjaXJjOiAnXFx1MDBDMicsXG4gICAgQXRpbGRlOiAnXFx1MDBDMycsXG4gICAgQXVtbDogJ1xcdTAwQzQnLFxuICAgIEFyaW5nOiAnXFx1MDBDNScsXG4gICAgQUVsaWc6ICdcXHUwMEM2JyxcbiAgICBDY2VkaWw6ICdcXHUwMEM3JyxcbiAgICBFZ3JhdmU6ICdcXHUwMEM4JyxcbiAgICBFYWN1dGU6ICdcXHUwMEM5JyxcbiAgICBFY2lyYzogJ1xcdTAwQ0EnLFxuICAgIEV1bWw6ICdcXHUwMENCJyxcbiAgICBJZ3JhdmU6ICdcXHUwMENDJyxcbiAgICBJYWN1dGU6ICdcXHUwMENEJyxcbiAgICBJY2lyYzogJ1xcdTAwQ0UnLFxuICAgIEl1bWw6ICdcXHUwMENGJyxcbiAgICBFVEg6ICdcXHUwMEQwJyxcbiAgICBOdGlsZGU6ICdcXHUwMEQxJyxcbiAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcbiAgICBPYWN1dGU6ICdcXHUwMEQzJyxcbiAgICBPY2lyYzogJ1xcdTAwRDQnLFxuICAgIE90aWxkZTogJ1xcdTAwRDUnLFxuICAgIE91bWw6ICdcXHUwMEQ2JyxcbiAgICB0aW1lczogJ1xcdTAwRDcnLFxuICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxuICAgIFVncmF2ZTogJ1xcdTAwRDknLFxuICAgIFVhY3V0ZTogJ1xcdTAwREEnLFxuICAgIFVjaXJjOiAnXFx1MDBEQicsXG4gICAgVXVtbDogJ1xcdTAwREMnLFxuICAgIFlhY3V0ZTogJ1xcdTAwREQnLFxuICAgIFRIT1JOOiAnXFx1MDBERScsXG4gICAgc3psaWc6ICdcXHUwMERGJyxcbiAgICBhZ3JhdmU6ICdcXHUwMEUwJyxcbiAgICBhYWN1dGU6ICdcXHUwMEUxJyxcbiAgICBhY2lyYzogJ1xcdTAwRTInLFxuICAgIGF0aWxkZTogJ1xcdTAwRTMnLFxuICAgIGF1bWw6ICdcXHUwMEU0JyxcbiAgICBhcmluZzogJ1xcdTAwRTUnLFxuICAgIGFlbGlnOiAnXFx1MDBFNicsXG4gICAgY2NlZGlsOiAnXFx1MDBFNycsXG4gICAgZWdyYXZlOiAnXFx1MDBFOCcsXG4gICAgZWFjdXRlOiAnXFx1MDBFOScsXG4gICAgZWNpcmM6ICdcXHUwMEVBJyxcbiAgICBldW1sOiAnXFx1MDBFQicsXG4gICAgaWdyYXZlOiAnXFx1MDBFQycsXG4gICAgaWFjdXRlOiAnXFx1MDBFRCcsXG4gICAgaWNpcmM6ICdcXHUwMEVFJyxcbiAgICBpdW1sOiAnXFx1MDBFRicsXG4gICAgZXRoOiAnXFx1MDBGMCcsXG4gICAgbnRpbGRlOiAnXFx1MDBGMScsXG4gICAgb2dyYXZlOiAnXFx1MDBGMicsXG4gICAgb2FjdXRlOiAnXFx1MDBGMycsXG4gICAgb2NpcmM6ICdcXHUwMEY0JyxcbiAgICBvdGlsZGU6ICdcXHUwMEY1JyxcbiAgICBvdW1sOiAnXFx1MDBGNicsXG4gICAgZGl2aWRlOiAnXFx1MDBGNycsXG4gICAgb3NsYXNoOiAnXFx1MDBGOCcsXG4gICAgdWdyYXZlOiAnXFx1MDBGOScsXG4gICAgdWFjdXRlOiAnXFx1MDBGQScsXG4gICAgdWNpcmM6ICdcXHUwMEZCJyxcbiAgICB1dW1sOiAnXFx1MDBGQycsXG4gICAgeWFjdXRlOiAnXFx1MDBGRCcsXG4gICAgdGhvcm46ICdcXHUwMEZFJyxcbiAgICB5dW1sOiAnXFx1MDBGRicsXG4gICAgT0VsaWc6ICdcXHUwMTUyJyxcbiAgICBvZWxpZzogJ1xcdTAxNTMnLFxuICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxuICAgIHNjYXJvbjogJ1xcdTAxNjEnLFxuICAgIFl1bWw6ICdcXHUwMTc4JyxcbiAgICBmbm9mOiAnXFx1MDE5MicsXG4gICAgY2lyYzogJ1xcdTAyQzYnLFxuICAgIHRpbGRlOiAnXFx1MDJEQycsXG4gICAgQWxwaGE6ICdcXHUwMzkxJyxcbiAgICBCZXRhOiAnXFx1MDM5MicsXG4gICAgR2FtbWE6ICdcXHUwMzkzJyxcbiAgICBEZWx0YTogJ1xcdTAzOTQnLFxuICAgIEVwc2lsb246ICdcXHUwMzk1JyxcbiAgICBaZXRhOiAnXFx1MDM5NicsXG4gICAgRXRhOiAnXFx1MDM5NycsXG4gICAgVGhldGE6ICdcXHUwMzk4JyxcbiAgICBJb3RhOiAnXFx1MDM5OScsXG4gICAgS2FwcGE6ICdcXHUwMzlBJyxcbiAgICBMYW1iZGE6ICdcXHUwMzlCJyxcbiAgICBNdTogJ1xcdTAzOUMnLFxuICAgIE51OiAnXFx1MDM5RCcsXG4gICAgWGk6ICdcXHUwMzlFJyxcbiAgICBPbWljcm9uOiAnXFx1MDM5RicsXG4gICAgUGk6ICdcXHUwM0EwJyxcbiAgICBSaG86ICdcXHUwM0ExJyxcbiAgICBTaWdtYTogJ1xcdTAzQTMnLFxuICAgIFRhdTogJ1xcdTAzQTQnLFxuICAgIFVwc2lsb246ICdcXHUwM0E1JyxcbiAgICBQaGk6ICdcXHUwM0E2JyxcbiAgICBDaGk6ICdcXHUwM0E3JyxcbiAgICBQc2k6ICdcXHUwM0E4JyxcbiAgICBPbWVnYTogJ1xcdTAzQTknLFxuICAgIGFscGhhOiAnXFx1MDNCMScsXG4gICAgYmV0YTogJ1xcdTAzQjInLFxuICAgIGdhbW1hOiAnXFx1MDNCMycsXG4gICAgZGVsdGE6ICdcXHUwM0I0JyxcbiAgICBlcHNpbG9uOiAnXFx1MDNCNScsXG4gICAgemV0YTogJ1xcdTAzQjYnLFxuICAgIGV0YTogJ1xcdTAzQjcnLFxuICAgIHRoZXRhOiAnXFx1MDNCOCcsXG4gICAgaW90YTogJ1xcdTAzQjknLFxuICAgIGthcHBhOiAnXFx1MDNCQScsXG4gICAgbGFtYmRhOiAnXFx1MDNCQicsXG4gICAgbXU6ICdcXHUwM0JDJyxcbiAgICBudTogJ1xcdTAzQkQnLFxuICAgIHhpOiAnXFx1MDNCRScsXG4gICAgb21pY3JvbjogJ1xcdTAzQkYnLFxuICAgIHBpOiAnXFx1MDNDMCcsXG4gICAgcmhvOiAnXFx1MDNDMScsXG4gICAgc2lnbWFmOiAnXFx1MDNDMicsXG4gICAgc2lnbWE6ICdcXHUwM0MzJyxcbiAgICB0YXU6ICdcXHUwM0M0JyxcbiAgICB1cHNpbG9uOiAnXFx1MDNDNScsXG4gICAgcGhpOiAnXFx1MDNDNicsXG4gICAgY2hpOiAnXFx1MDNDNycsXG4gICAgcHNpOiAnXFx1MDNDOCcsXG4gICAgb21lZ2E6ICdcXHUwM0M5JyxcbiAgICB0aGV0YXN5bTogJ1xcdTAzRDEnLFxuICAgIHVwc2loOiAnXFx1MDNEMicsXG4gICAgcGl2OiAnXFx1MDNENicsXG4gICAgZW5zcDogJ1xcdTIwMDInLFxuICAgIGVtc3A6ICdcXHUyMDAzJyxcbiAgICB0aGluc3A6ICdcXHUyMDA5JyxcbiAgICB6d25qOiAnXFx1MjAwQycsXG4gICAgendqOiAnXFx1MjAwRCcsXG4gICAgbHJtOiAnXFx1MjAwRScsXG4gICAgcmxtOiAnXFx1MjAwRicsXG4gICAgbmRhc2g6ICdcXHUyMDEzJyxcbiAgICBtZGFzaDogJ1xcdTIwMTQnLFxuICAgIGxzcXVvOiAnXFx1MjAxOCcsXG4gICAgcnNxdW86ICdcXHUyMDE5JyxcbiAgICBzYnF1bzogJ1xcdTIwMUEnLFxuICAgIGxkcXVvOiAnXFx1MjAxQycsXG4gICAgcmRxdW86ICdcXHUyMDFEJyxcbiAgICBiZHF1bzogJ1xcdTIwMUUnLFxuICAgIGRhZ2dlcjogJ1xcdTIwMjAnLFxuICAgIERhZ2dlcjogJ1xcdTIwMjEnLFxuICAgIGJ1bGw6ICdcXHUyMDIyJyxcbiAgICBoZWxsaXA6ICdcXHUyMDI2JyxcbiAgICBwZXJtaWw6ICdcXHUyMDMwJyxcbiAgICBwcmltZTogJ1xcdTIwMzInLFxuICAgIFByaW1lOiAnXFx1MjAzMycsXG4gICAgbHNhcXVvOiAnXFx1MjAzOScsXG4gICAgcnNhcXVvOiAnXFx1MjAzQScsXG4gICAgb2xpbmU6ICdcXHUyMDNFJyxcbiAgICBmcmFzbDogJ1xcdTIwNDQnLFxuICAgIGV1cm86ICdcXHUyMEFDJyxcbiAgICBpbWFnZTogJ1xcdTIxMTEnLFxuICAgIHdlaWVycDogJ1xcdTIxMTgnLFxuICAgIHJlYWw6ICdcXHUyMTFDJyxcbiAgICB0cmFkZTogJ1xcdTIxMjInLFxuICAgIGFsZWZzeW06ICdcXHUyMTM1JyxcbiAgICBsYXJyOiAnXFx1MjE5MCcsXG4gICAgdWFycjogJ1xcdTIxOTEnLFxuICAgIHJhcnI6ICdcXHUyMTkyJyxcbiAgICBkYXJyOiAnXFx1MjE5MycsXG4gICAgaGFycjogJ1xcdTIxOTQnLFxuICAgIGNyYXJyOiAnXFx1MjFCNScsXG4gICAgbEFycjogJ1xcdTIxRDAnLFxuICAgIHVBcnI6ICdcXHUyMUQxJyxcbiAgICByQXJyOiAnXFx1MjFEMicsXG4gICAgZEFycjogJ1xcdTIxRDMnLFxuICAgIGhBcnI6ICdcXHUyMUQ0JyxcbiAgICBmb3JhbGw6ICdcXHUyMjAwJyxcbiAgICBwYXJ0OiAnXFx1MjIwMicsXG4gICAgZXhpc3Q6ICdcXHUyMjAzJyxcbiAgICBlbXB0eTogJ1xcdTIyMDUnLFxuICAgIG5hYmxhOiAnXFx1MjIwNycsXG4gICAgaXNpbjogJ1xcdTIyMDgnLFxuICAgIG5vdGluOiAnXFx1MjIwOScsXG4gICAgbmk6ICdcXHUyMjBCJyxcbiAgICBwcm9kOiAnXFx1MjIwRicsXG4gICAgc3VtOiAnXFx1MjIxMScsXG4gICAgbWludXM6ICdcXHUyMjEyJyxcbiAgICBsb3dhc3Q6ICdcXHUyMjE3JyxcbiAgICByYWRpYzogJ1xcdTIyMUEnLFxuICAgIHByb3A6ICdcXHUyMjFEJyxcbiAgICBpbmZpbjogJ1xcdTIyMUUnLFxuICAgIGFuZzogJ1xcdTIyMjAnLFxuICAgIGFuZDogJ1xcdTIyMjcnLFxuICAgIG9yOiAnXFx1MjIyOCcsXG4gICAgY2FwOiAnXFx1MjIyOScsXG4gICAgY3VwOiAnXFx1MjIyQScsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICB0aGVyZTQ6ICdcXHUyMjM0JyxcbiAgICBzaW06ICdcXHUyMjNDJyxcbiAgICBjb25nOiAnXFx1MjI0NScsXG4gICAgYXN5bXA6ICdcXHUyMjQ4JyxcbiAgICBuZTogJ1xcdTIyNjAnLFxuICAgIGVxdWl2OiAnXFx1MjI2MScsXG4gICAgbGU6ICdcXHUyMjY0JyxcbiAgICBnZTogJ1xcdTIyNjUnLFxuICAgIHN1YjogJ1xcdTIyODInLFxuICAgIHN1cDogJ1xcdTIyODMnLFxuICAgIG5zdWI6ICdcXHUyMjg0JyxcbiAgICBzdWJlOiAnXFx1MjI4NicsXG4gICAgc3VwZTogJ1xcdTIyODcnLFxuICAgIG9wbHVzOiAnXFx1MjI5NScsXG4gICAgb3RpbWVzOiAnXFx1MjI5NycsXG4gICAgcGVycDogJ1xcdTIyQTUnLFxuICAgIHNkb3Q6ICdcXHUyMkM1JyxcbiAgICBsY2VpbDogJ1xcdTIzMDgnLFxuICAgIHJjZWlsOiAnXFx1MjMwOScsXG4gICAgbGZsb29yOiAnXFx1MjMwQScsXG4gICAgcmZsb29yOiAnXFx1MjMwQicsXG4gICAgbGFuZzogJ1xcdTIzMjknLFxuICAgIHJhbmc6ICdcXHUyMzJBJyxcbiAgICBsb3o6ICdcXHUyNUNBJyxcbiAgICBzcGFkZXM6ICdcXHUyNjYwJyxcbiAgICBjbHViczogJ1xcdTI2NjMnLFxuICAgIGhlYXJ0czogJ1xcdTI2NjUnLFxuICAgIGRpYW1zOiAnXFx1MjY2NidcbiAgfTtcblxuICBmdW5jdGlvbiByZWFkWEpTRW50aXR5KCkge1xuICAgIHZhciBzdHIgPSAnJywgY291bnQgPSAwLCBlbnRpdHk7XG4gICAgdmFyIGNoID0gbmV4dENoYXIoKTtcbiAgICBpZiAoY2ggIT09ICcmJykgcmFpc2UodG9rUG9zLCBcIkVudGl0eSBtdXN0IHN0YXJ0IHdpdGggYW4gYW1wZXJzYW5kXCIpO1xuICAgIHZhciBzdGFydFBvcyA9ICsrdG9rUG9zO1xuICAgIHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbiAmJiBjb3VudCsrIDwgMTApIHtcbiAgICAgIGNoID0gbmV4dENoYXIoKTtcbiAgICAgIHRva1BvcysrO1xuICAgICAgaWYgKGNoID09PSAnOycpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgaWYgKHN0clsxXSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDIpO1xuICAgICAgICAgICAgaWYgKGhleE51bWJlci50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgZW50aXR5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIsIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbE51bWJlci50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgZW50aXR5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIsIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudGl0eSA9IFhIVE1MRW50aXRpZXNbc3RyXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBjaDtcbiAgICB9XG4gICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgIHRva1BvcyA9IHN0YXJ0UG9zO1xuICAgICAgcmV0dXJuICcmJztcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRYSlNUZXh0KHN0b3BDaGFycykge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4pIHtcbiAgICAgIHZhciBjaCA9IG5leHRDaGFyKCk7XG4gICAgICBpZiAoc3RvcENoYXJzLmluZGV4T2YoY2gpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gJyYnKSB7XG4gICAgICAgIHN0ciArPSByZWFkWEpTRW50aXR5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3Rva1BvcztcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBuZXh0Q2hhcigpID09PSAnXFxuJykge1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgb3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7XG4gICAgICAgICAgKyt0b2tDdXJMaW5lO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKF94anNUZXh0LCBzdHIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFhKU1N0cmluZ0xpdGVyYWwoKSB7XG4gICAgdmFyIHF1b3RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXG4gICAgaWYgKHF1b3RlICE9PSAzNCAmJiBxdW90ZSAhPT0gMzkpIHtcbiAgICAgIHJhaXNlKFwiU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlXCIpO1xuICAgIH1cblxuICAgICsrdG9rUG9zO1xuXG4gICAgcmVhZFhKU1RleHQoW1N0cmluZy5mcm9tQ2hhckNvZGUocXVvdGUpXSk7XG5cbiAgICBpZiAocXVvdGUgIT09IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkge1xuICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgICsrdG9rUG9zO1xuXG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKHRva1R5cGUsIHRva1ZhbCk7XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG4gIGZ1bmN0aW9uIHJlYWRIZXhDaGFyKGxlbikge1xuICAgIHZhciBuID0gcmVhZEludCgxNiwgbGVuKTtcbiAgICBpZiAobiA9PT0gbnVsbCkgcmFpc2UodG9rU3RhcnQsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cblxuICB2YXIgY29udGFpbnNFc2M7XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGBjb250YWluc0VzY2BcbiAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gIC8vXG4gIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgZnVuY3Rpb24gcmVhZFdvcmQxKCkge1xuICAgIGNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0b2tQb3M7XG4gICAgd2hpbGUgKHRva1BvcyA8IGlucHV0TGVuKSB7XG4gICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgICAgY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICB3b3JkICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRva1Bvcyk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKSAhPSAxMTcpIC8vIFwidVwiXG4gICAgICAgICAgcmFpc2UodG9rUG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgICB2YXIgZXNjID0gcmVhZEhleENoYXIoNCk7XG4gICAgICAgIHZhciBlc2NTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzYyk7XG4gICAgICAgIGlmICghZXNjU3RyKSByYWlzZSh0b2tQb3MgLSAxLCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQoZXNjKSA6IGlzSWRlbnRpZmllckNoYXIoZXNjKSkpXG4gICAgICAgICAgcmFpc2UodG9rUG9zIC0gNCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgICB3b3JkICs9IGVzY1N0cjtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRva1BvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmQgKyBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0b2tQb3MpO1xuICB9XG5cbiAgLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4gIC8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG4gIGZ1bmN0aW9uIHJlYWRXb3JkKCkge1xuICAgIHZhciB3b3JkID0gcmVhZFdvcmQxKCk7XG4gICAgdmFyIHR5cGUgPSBpblhKU1RhZyA/IF94anNOYW1lIDogX25hbWU7XG4gICAgaWYgKCFjb250YWluc0VzYyAmJiBpc0tleXdvcmQod29yZCkpXG4gICAgICB0eXBlID0ga2V5d29yZFR5cGVzW3dvcmRdO1xuICAgIHJldHVybiBmaW5pc2hUb2tlbih0eXBlLCB3b3JkKTtcbiAgfVxuXG4gIC8vIFJlYWQgYSBKU1ggaWRlbnRpZmllciAodmFsaWQgdGFnIG9yIGF0dHJpYnV0ZSBuYW1lKS5cbiAgLy9cbiAgLy8gT3B0aW1pemVkIHZlcnNpb24gc2luY2UgSlNYIGlkZW50aWZpZXJzIGNhbid0IGNvbnRhaW5cbiAgLy8gZXNjYXBlIGNoYXJhY3RlcnMgYW5kIHNvIGNhbiBiZSByZWFkIGFzIHNpbmdsZSBzbGljZS5cbiAgLy8gQWxzbyBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIHdhcyBhbHJlYWR5IGNoZWNrZWRcbiAgLy8gYnkgaXNJZGVudGlmaWVyU3RhcnQgaW4gcmVhZFRva2VuLlxuXG4gIGZ1bmN0aW9uIHJlYWRKU1hXb3JkKCkge1xuICAgIHZhciBjaCwgc3RhcnQgPSB0b2tQb3M7XG4gICAgZG8ge1xuICAgICAgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcbiAgICB9IHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKGNoKSB8fCBjaCA9PT0gNDUpOyAvLyAnLSdcbiAgICByZXR1cm4gZmluaXNoVG9rZW4oX2pzeE5hbWUsIGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpKTtcbiAgfVxuXG4gIC8vICMjIFBhcnNlclxuXG4gIC8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4gIC8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbiAgLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuICAvLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuICAvLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuICAvLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4gIC8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuICAvLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4gIC8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbiAgLy9cbiAgLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuICAvLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbiAgLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3RpbmdcbiAgLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuICAvLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbiAgLy9cbiAgLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuICAvLyAjIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4gIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKG9wdGlvbnMub25Ub2tlbilcbiAgICAgIG9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4oKSk7XG5cbiAgICBsYXN0U3RhcnQgPSB0b2tTdGFydDtcbiAgICBsYXN0RW5kID0gdG9rRW5kO1xuICAgIGxhc3RFbmRMb2MgPSB0b2tFbmRMb2M7XG4gICAgcmVhZFRva2VuKCk7XG4gIH1cblxuICAvLyBFbnRlciBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0b1xuICAvLyBwbGVhc2UgcGVkYW50aWMgdGVzdHMgKFwidXNlIHN0cmljdFwiOyAwMTA7IC0tIHNob3VsZCBmYWlsKS5cblxuICBmdW5jdGlvbiBzZXRTdHJpY3Qoc3RyY3QpIHtcbiAgICBzdHJpY3QgPSBzdHJjdDtcbiAgICBpZiAodG9rVHlwZSAhPT0gX251bSAmJiB0b2tUeXBlICE9PSBfc3RyaW5nKSByZXR1cm47XG4gICAgdG9rUG9zID0gdG9rU3RhcnQ7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB3aGlsZSAodG9rUG9zIDwgdG9rTGluZVN0YXJ0KSB7XG4gICAgICAgIHRva0xpbmVTdGFydCA9IGlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRva0xpbmVTdGFydCAtIDIpICsgMTtcbiAgICAgICAgLS10b2tDdXJMaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBza2lwU3BhY2UoKTtcbiAgICByZWFkVG9rZW4oKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSB0b2tTdGFydDtcbiAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cbiAgXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG5cbiAgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oKSB7XG4gICAgdGhpcy5zdGFydCA9IHRva1N0YXJ0TG9jO1xuICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICBpZiAoc291cmNlRmlsZSAhPT0gbnVsbCkgdGhpcy5zb3VyY2UgPSBzb3VyY2VGaWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnROb2RlKCkge1xuICAgIHZhciBub2RlID0gbmV3IGV4cG9ydHMuTm9kZSgpO1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIG5vZGUubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIG5vZGUuc291cmNlRmlsZSA9IG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICBub2RlLnJhbmdlID0gW3Rva1N0YXJ0LCAwXTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFNvbWV0aW1lcywgYSBub2RlIGlzIG9ubHkgc3RhcnRlZCAqYWZ0ZXIqIHRoZSB0b2tlbiBzdHJlYW0gcGFzc2VkXG4gIC8vIGl0cyBzdGFydCBwb3NpdGlvbi4gVGhlIGZ1bmN0aW9ucyBiZWxvdyBoZWxwIHN0b3JpbmcgYSBwb3NpdGlvblxuICAvLyBhbmQgY3JlYXRpbmcgYSBub2RlIGZyb20gYSBwcmV2aW91cyBwb3NpdGlvbi5cblxuICBmdW5jdGlvbiBzdG9yZUN1cnJlbnRQb3MoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jYXRpb25zID8gW3Rva1N0YXJ0LCB0b2tTdGFydExvY10gOiB0b2tTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Tm9kZUF0KHBvcykge1xuICAgIHZhciBub2RlID0gbmV3IGV4cG9ydHMuTm9kZSgpLCBzdGFydCA9IHBvcztcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIG5vZGUubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgICBub2RlLmxvYy5zdGFydCA9IHN0YXJ0WzFdO1xuICAgICAgc3RhcnQgPSBwb3NbMF07XG4gICAgfVxuICAgIG5vZGUuc3RhcnQgPSBzdGFydDtcbiAgICBpZiAob3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgICAgbm9kZS5zb3VyY2VGaWxlID0gb3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlO1xuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIG5vZGUucmFuZ2UgPSBbc3RhcnQsIDBdO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBGaW5pc2ggYW4gQVNUIG5vZGUsIGFkZGluZyBgdHlwZWAgYW5kIGBlbmRgIHByb3BlcnRpZXMuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZShub2RlLCB0eXBlKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IGxhc3RFbmQ7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgbm9kZS5sb2MuZW5kID0gbGFzdEVuZExvYztcbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICBub2RlLnJhbmdlWzFdID0gbGFzdEVuZDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcykge1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgeyBub2RlLmxvYy5lbmQgPSBwb3NbMV07IHBvcyA9IHBvc1swXTsgfVxuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBwb3M7XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgbm9kZS5yYW5nZVsxXSA9IHBvcztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIHN0YXRlbWVudCBub2RlIGlzIHRoZSBzdHJpbmcgbGl0ZXJhbCBgXCJ1c2Ugc3RyaWN0XCJgLlxuXG4gIGZ1bmN0aW9uIGlzVXNlU3RyaWN0KHN0bXQpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiO1xuICB9XG5cbiAgLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbiAgLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxuICBmdW5jdGlvbiBlYXQodHlwZSkge1xuICAgIGlmICh0b2tUeXBlID09PSB0eXBlKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIGZ1bmN0aW9uIGlzQ29udGV4dHVhbChuYW1lKSB7XG4gICAgcmV0dXJuIHRva1R5cGUgPT09IF9uYW1lICYmIHRva1ZhbCA9PT0gbmFtZTtcbiAgfVxuXG4gIC8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxuICBmdW5jdGlvbiBlYXRDb250ZXh0dWFsKG5hbWUpIHtcbiAgICByZXR1cm4gdG9rVmFsID09PSBuYW1lICYmIGVhdChfbmFtZSk7XG4gIH1cblxuICAvLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBmdW5jdGlvbiBleHBlY3RDb250ZXh0dWFsKG5hbWUpIHtcbiAgICBpZiAoIWVhdENvbnRleHR1YWwobmFtZSkpIHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbiAgZnVuY3Rpb24gY2FuSW5zZXJ0U2VtaWNvbG9uKCkge1xuICAgIHJldHVybiAhb3B0aW9ucy5zdHJpY3RTZW1pY29sb25zICYmXG4gICAgICAodG9rVHlwZSA9PT0gX2VvZiB8fCB0b2tUeXBlID09PSBfYnJhY2VSIHx8IG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKTtcbiAgfVxuXG4gIC8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuICAvLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxuICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG4gICAgaWYgKCFlYXQoX3NlbWkpICYmICFjYW5JbnNlcnRTZW1pY29sb24oKSkgdW5leHBlY3RlZCgpO1xuICB9XG5cbiAgLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuICAvLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh0eXBlKSB7XG4gICAgZWF0KHR5cGUpIHx8IHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIC8vIEdldCBmb2xsb3dpbmcgY2hhci5cblxuICBmdW5jdGlvbiBuZXh0Q2hhcigpIHtcbiAgICByZXR1cm4gaW5wdXQuY2hhckF0KHRva1Bvcyk7XG4gIH1cblxuICAvLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIGZ1bmN0aW9uIHVuZXhwZWN0ZWQocG9zKSB7XG4gICAgcmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0b2tTdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGhhc2ggb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuICAvLyBpZiBwb3NzaWJsZS5cblxuICBmdW5jdGlvbiB0b0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBjYXNlIFwiVmlydHVhbFByb3BlcnR5RXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgaWYgKHByb3Aua2luZCAhPT0gXCJpbml0XCIpIHJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTtcbiAgICAgICAgICAgIHRvQXNzaWduYWJsZShwcm9wLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgICB0b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgaWYgKCFpc0JpbmRpbmcpIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBmdW5jdGlvbiB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB0b0Fzc2lnbmFibGUoZXhwckxpc3RbaV0sIGlzQmluZGluZyk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2V4cHJMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgc3dpdGNoIChsYXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgICAgbGFzdC50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgICAgIHZhciBhcmcgPSBsYXN0LmFyZ3VtZW50O1xuICAgICAgICAgIHRvQXNzaWduYWJsZShhcmcsIGlzQmluZGluZyk7XG4gICAgICAgICAgaWYgKGFyZy50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBhcmcudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgYXJnLnR5cGUgIT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgICAgICAgICB1bmV4cGVjdGVkKGFyZy5zdGFydCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdG9Bc3NpZ25hYmxlKGxhc3QsIGlzQmluZGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuXG4gIC8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxuICBmdW5jdGlvbiBwYXJzZVNwcmVhZChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBuZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlTWF5YmVBc3NpZ24ocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSZXN0KCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgbmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0b2tUeXBlID09PSBfbmFtZSB8fCB0b2tUeXBlID09PSBfYnJhY2tldEwgPyBwYXJzZUJpbmRpbmdBdG9tKCkgOiB1bmV4cGVjdGVkKCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgZnVuY3Rpb24gcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHJldHVybiBwYXJzZUlkZW50KCk7XG4gICAgc3dpdGNoICh0b2tUeXBlKSB7XG4gICAgICBjYXNlIF9uYW1lOlxuICAgICAgICByZXR1cm4gcGFyc2VJZGVudCgpO1xuXG4gICAgICBjYXNlIF9icmFja2V0TDpcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gcGFyc2VCaW5kaW5nTGlzdChfYnJhY2tldFIsIHRydWUpO1xuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKTtcblxuICAgICAgY2FzZSBfYnJhY2VMOlxuICAgICAgICByZXR1cm4gcGFyc2VPYmoodHJ1ZSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUJpbmRpbmdMaXN0KGNsb3NlLCBhbGxvd0VtcHR5KSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghZWF0KGNsb3NlKSkge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogZXhwZWN0KF9jb21tYSk7XG4gICAgICBpZiAodG9rVHlwZSA9PT0gX2VsbGlwc2lzKSB7XG4gICAgICAgIGVsdHMucHVzaChwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcnNlUmVzdCgpKSk7XG4gICAgICAgIGV4cGVjdChjbG9zZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW07XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0b2tUeXBlID09PSBfY29tbWEpIHtcbiAgICAgICAgZWxlbSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHBhcnNlTWF5YmVEZWZhdWx0KCk7XG4gICAgICAgIHBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXMobGVmdCk7XG4gICAgICAgIGVsZW0gPSBwYXJzZU1heWJlRGVmYXVsdChudWxsLCBsZWZ0KTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcmFtKSB7XG4gICAgaWYgKGVhdChfcXVlc3Rpb24pKSB7XG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0b2tUeXBlID09PSBfY29sb24pIHtcbiAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICBmaW5pc2hOb2RlKHBhcmFtLCBwYXJhbS50eXBlKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBsZWZ0KSB7XG4gICAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICBsZWZ0ID0gbGVmdCB8fCBwYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKCFlYXQoX2VxKSkgcmV0dXJuIGxlZnQ7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydFBvcyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IFwiPVwiO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXMgYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90XG4gIC8vIHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGAgb3IgYGFyZ3VtZW50c2AuXG5cbiAgZnVuY3Rpb24gY2hlY2tGdW5jdGlvblBhcmFtKHBhcmFtLCBuYW1lSGFzaCkge1xuICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWYgKGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHBhcmFtLm5hbWUpIHx8IGlzU3RyaWN0QmFkSWRXb3JkKHBhcmFtLm5hbWUpKVxuICAgICAgICAgIHJhaXNlKHBhcmFtLnN0YXJ0LCBcIkRlZmluaW5nICdcIiArIHBhcmFtLm5hbWUgKyBcIicgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIGlmIChoYXMobmFtZUhhc2gsIHBhcmFtLm5hbWUpKVxuICAgICAgICAgIHJhaXNlKHBhcmFtLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIG5hbWVIYXNoW3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJhbTIgPSBwYXJhbS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIGlmIChwYXJhbTIudHlwZSA9PT0gXCJTcHJlYWRQcm9wZXJ0eVwiKSB7XG4gICAgICAgICAgICBjaGVja0Z1bmN0aW9uUGFyYW0ocGFyYW0yLmFyZ3VtZW50LCBuYW1lSGFzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbShwYXJhbTIudmFsdWUsIG5hbWVIYXNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtID0gcGFyYW0uZWxlbWVudHNbaV07XG4gICAgICAgICAgaWYgKGVsZW0pIGNoZWNrRnVuY3Rpb25QYXJhbShlbGVtLCBuYW1lSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gY2hlY2tGdW5jdGlvblBhcmFtKHBhcmFtLmFyZ3VtZW50LCBuYW1lSGFzaCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbiAgLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuICAvLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4gIC8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbiAgZnVuY3Rpb24gY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gpIHtcbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSByZXR1cm47XG4gICAgdmFyIGtleSA9IHByb3Aua2V5LCBuYW1lO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2luZCA9IHByb3Aua2luZCB8fCBcImluaXRcIiwgb3RoZXI7XG4gICAgaWYgKGhhcyhwcm9wSGFzaCwgbmFtZSkpIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgICB2YXIgaXNHZXRTZXQgPSBraW5kICE9PSBcImluaXRcIjtcbiAgICAgIGlmICgoc3RyaWN0IHx8IGlzR2V0U2V0KSAmJiBvdGhlcltraW5kXSB8fCAhKGlzR2V0U2V0IF4gb3RoZXIuaW5pdCkpXG4gICAgICAgIHJhaXNlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4gIC8vIHRvLlxuXG4gIGZ1bmN0aW9uIGNoZWNrTFZhbChleHByLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWYgKHN0cmljdCAmJiAoaXNTdHJpY3RCYWRJZFdvcmQoZXhwci5uYW1lKSB8fCBpc1N0cmljdFJlc2VydmVkV29yZChleHByLm5hbWUpKSlcbiAgICAgICAgICByYWlzZShleHByLnN0YXJ0LCAoaXNCaW5kaW5nID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoaXNCaW5kaW5nKSByYWlzZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgdG8gbWVtYmVyIGV4cHJlc3Npb25cIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wID0gZXhwci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiUHJvcGVydHlcIikgcHJvcCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgY2hlY2tMVmFsKHByb3AsIGlzQmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBleHByLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGlmIChlbGVtKSBjaGVja0xWYWwoZWxlbSwgaXNCaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIGNoZWNrTFZhbChleHByLmxlZnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICBjYXNlIFwiVmlydHVhbFByb3BlcnR5RXhwcmVzc2lvblwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIGNoZWNrTFZhbChleHByLmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gIH1cbiAgfVxuXG4gIC8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4gIC8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuICAvLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuICAvLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4gIC8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgZXhwb3J0cy5Ob2RlLlxuXG4gIGZ1bmN0aW9uIHBhcnNlVG9wTGV2ZWwobm9kZSkge1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgaWYgKCFub2RlLmJvZHkpIG5vZGUuYm9keSA9IFtdO1xuICAgIHdoaWxlICh0b2tUeXBlICE9PSBfZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KHRydWUsIHRydWUpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgICBpZiAoZmlyc3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHNldFN0cmljdCh0cnVlKTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgfVxuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICAvLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gIC8vXG4gIC8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4gIC8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pO2AsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoZGVjbGFyYXRpb24sIHRvcExldmVsKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRva1R5cGUsIG5vZGUgPSBzdGFydE5vZGUoKTtcblxuICAgIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gICAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gICAgLy8gY29tcGxleGl0eS5cblxuICAgIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gICAgY2FzZSBfYnJlYWs6IGNhc2UgX2NvbnRpbnVlOiByZXR1cm4gcGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKTtcbiAgICBjYXNlIF9kZWJ1Z2dlcjogcmV0dXJuIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfZG86IHJldHVybiBwYXJzZURvU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX2ZvcjogcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX2Z1bmN0aW9uOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbiAmJiBvcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHVuZXhwZWN0ZWQoKTtcbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX2NsYXNzOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbikgdW5leHBlY3RlZCgpO1xuICAgICAgcmV0dXJuIHBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSk7XG4gICAgY2FzZSBfaWY6IHJldHVybiBwYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3JldHVybjogcmV0dXJuIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3N3aXRjaDogcmV0dXJuIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rocm93OiByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF90cnk6IHJldHVybiBwYXJzZVRyeVN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF9sZXQ6IGNhc2UgX2NvbnN0OiBpZiAoIWRlY2xhcmF0aW9uKSB1bmV4cGVjdGVkKCk7IC8vIE5PVEU6IGZhbGxzIHRocm91Z2ggdG8gX3ZhclxuICAgIGNhc2UgX3ZhcjogcmV0dXJuIHBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKTtcbiAgICBjYXNlIF93aGlsZTogcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfd2l0aDogcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF9icmFjZUw6IHJldHVybiBwYXJzZUJsb2NrKCk7IC8vIG5vIHBvaW50IGNyZWF0aW5nIGEgZnVuY3Rpb24gZm9yIHRoaXNcbiAgICBjYXNlIF9zZW1pOiByZXR1cm4gcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF9leHBvcnQ6XG4gICAgY2FzZSBfaW1wb3J0OlxuICAgICAgaWYgKCF0b3BMZXZlbCAmJiAhb3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUpXG4gICAgICAgIHJhaXNlKHRva1N0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTtcbiAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IF9pbXBvcnQgPyBwYXJzZUltcG9ydChub2RlKSA6IHBhcnNlRXhwb3J0KG5vZGUpO1xuXG4gICAgY2FzZSBfbmFtZTpcbiAgICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgdG9rVmFsID09PSBcInByaXZhdGVcIikge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBwYXJzZVByaXZhdGUobm9kZSk7XG4gICAgICB9IFxuXG4gICAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBtYXliZU5hbWUgPSB0b2tWYWwsIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBzdGFydHR5cGUgPT09IF9uYW1lICYmIG1heWJlTmFtZSA9PT0gXCJhc3luY1wiICYmIHRva1R5cGUgPT09IF9mdW5jdGlvbiAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICB2YXIgZnVuYyA9IHBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgIGZ1bmMuYXN5bmMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gX25hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICBpZiAoZWF0KF9jb2xvbikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcImRlY2xhcmVcIikge1xuICAgICAgICAgIGlmICh0b2tUeXBlID09PSBfY2xhc3MgfHwgdG9rVHlwZSA9PT0gX25hbWUgfHwgdG9rVHlwZSA9PT0gX2Z1bmN0aW9uIHx8IHRva1R5cGUgPT09IF92YXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURlY2xhcmUobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRva1R5cGUgPT09IF9uYW1lKSB7XG4gICAgICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZUFsaWFzKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXhwci50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiICYmIGV4cHIuYXN5bmMpIHtcbiAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICBleHByLnR5cGUgPSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjtcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmV4cGVjdGVkKGV4cHIuc3RhcnQgKyBcImFzeW5jIGZ1bmN0aW9uIFwiLmxlbmd0aCk7IC8vIHRoaXMgaXMgc3VjaCBhIGhhY2tcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICAgIH1cbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGtleXdvcmQpIHtcbiAgICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT0gXCJicmVha1wiO1xuICAgIG5leHQoKTtcbiAgICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgZWxzZSBpZiAodG9rVHlwZSAhPT0gX25hbWUpIHVuZXhwZWN0ZWQoKTtcbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSBwYXJzZUlkZW50KCk7XG4gICAgICBzZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IGxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSBicmVhaztcbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBsYWJlbHMubGVuZ3RoKSByYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSkge1xuICAgIG5leHQoKTtcbiAgICBzZW1pY29sb24oKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBwYXJzZURvU3RhdGVtZW50KG5vZGUpIHtcbiAgICBuZXh0KCk7XG4gICAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgbGFiZWxzLnBvcCgpO1xuICAgIGV4cGVjdChfd2hpbGUpO1xuICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIGVhdChfc2VtaSk7XG4gICAgZWxzZVxuICAgICAgc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuICB9XG4gIFxuICAvLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4gIC8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuICAvLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuICAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4gIC8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbiAgLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbiAgLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG4gIFxuICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIGxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgZXhwZWN0KF9wYXJlbkwpO1xuICAgIGlmICh0b2tUeXBlID09PSBfc2VtaSkgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIG51bGwpO1xuICAgIGlmICh0b2tUeXBlID09PSBfdmFyIHx8IHRva1R5cGUgPT09IF9sZXQpIHtcbiAgICAgIHZhciBpbml0ID0gc3RhcnROb2RlKCksIHZhcktpbmQgPSB0b2tUeXBlLmtleXdvcmQsIGlzTGV0ID0gdG9rVHlwZSA9PT0gX2xldDtcbiAgICAgIG5leHQoKTtcbiAgICAgIHBhcnNlVmFyKGluaXQsIHRydWUsIHZhcktpbmQpO1xuICAgICAgZmluaXNoTm9kZShpbml0LCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRva1R5cGUgPT09IF9pbiB8fCAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIGlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgIShpc0xldCAmJiBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0KSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG4gICAgICByZXR1cm4gcGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgfVxuICAgIHZhciByZWZTaG9ydGhhbmREZWZhdWx0UG9zID0ge3N0YXJ0OiAwfTtcbiAgICB2YXIgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgICBpZiAodG9rVHlwZSA9PT0gX2luIHx8IChvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICB0b0Fzc2lnbmFibGUoaW5pdCk7XG4gICAgICBjaGVja0xWYWwoaW5pdCk7XG4gICAgICByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTtcbiAgICB9IGVsc2UgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICAgIHVuZXhwZWN0ZWQocmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZvcihub2RlLCBpbml0KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUsIGZhbHNlKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gZWF0KF9lbHNlKSA/IHBhcnNlU3RhdGVtZW50KGZhbHNlKSA6IG51bGw7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICghaW5GdW5jdGlvbiAmJiAhb3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgIHJhaXNlKHRva1N0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gICAgbmV4dCgpO1xuXG4gICAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gICAgaWYgKGVhdChfc2VtaSkgfHwgY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7IHNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICBuZXh0KCk7XG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICBleHBlY3QoX2JyYWNlTCk7XG4gICAgbGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuXG4gICAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gICAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICAgIGZvciAodmFyIGN1ciwgc2F3RGVmYXVsdDsgdG9rVHlwZSAhPSBfYnJhY2VSOykge1xuICAgICAgaWYgKHRva1R5cGUgPT09IF9jYXNlIHx8IHRva1R5cGUgPT09IF9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0b2tUeXBlID09PSBfY2FzZTtcbiAgICAgICAgaWYgKGN1cikgZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSBjdXIudGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgcmFpc2UobGFzdFN0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChfY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaChwYXJzZVN0YXRlbWVudCh0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXIpIGZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgbmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gICAgbGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpIHtcbiAgICBuZXh0KCk7XG4gICAgaWYgKG5ld2xpbmUudGVzdChpbnB1dC5zbGljZShsYXN0RW5kLCB0b2tTdGFydCkpKVxuICAgICAgcmFpc2UobGFzdEVuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHNlbWljb2xvbigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhyb3dTdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICBuZXh0KCk7XG4gICAgbm9kZS5ibG9jayA9IHBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0b2tUeXBlID09PSBfY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgIGNsYXVzZS5wYXJhbSA9IHBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgIGNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHRydWUpO1xuICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgY2xhdXNlLmd1YXJkID0gbnVsbDtcbiAgICAgIGNsYXVzZS5ib2R5ID0gcGFyc2VCbG9jaygpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZ3VhcmRlZEhhbmRsZXJzID0gZW1wdHk7XG4gICAgbm9kZS5maW5hbGl6ZXIgPSBlYXQoX2ZpbmFsbHkpID8gcGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICByYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpIHtcbiAgICBuZXh0KCk7XG4gICAgcGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICAgIHNlbWljb2xvbigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgbGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudChub2RlKSB7XG4gICAgaWYgKHN0cmljdCkgcmFpc2UodG9rU3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpO1xuICAgIG5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSlcbiAgICAgIGlmIChsYWJlbHNbaV0ubmFtZSA9PT0gbWF5YmVOYW1lKSByYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgIHZhciBraW5kID0gdG9rVHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRva1R5cGUgPT09IF9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgICBsYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kfSk7XG4gICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgbGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHNlbWljb2xvbigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIGNvbnN0cnVjdHMgbGlrZSBgc3dpdGNoYCBhbmQgYGlmYCB0aGF0IGluc2lzdCBvblxuICAvLyBwYXJlbnRoZXNlcyBhcm91bmQgdGhlaXIgZXhwcmVzc2lvbi5cblxuICBmdW5jdGlvbiBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIHtcbiAgICBleHBlY3QoX3BhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgZnVuY3Rpb24gcGFyc2VCbG9jayhhbGxvd1N0cmljdCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgb2xkU3RyaWN0O1xuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIGV4cGVjdChfYnJhY2VMKTtcbiAgICB3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuICAgICAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgICAgaWYgKGZpcnN0ICYmIGFsbG93U3RyaWN0ICYmIGlzVXNlU3RyaWN0KHN0bXQpKSB7XG4gICAgICAgIG9sZFN0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc2V0U3RyaWN0KHN0cmljdCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9sZFN0cmljdCA9PT0gZmFsc2UpIHNldFN0cmljdChmYWxzZSk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuICAvLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3JcbiAgLy8gZXhwcmVzc2lvbi5cblxuICBmdW5jdGlvbiBwYXJzZUZvcihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICBleHBlY3QoX3NlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRva1R5cGUgPT09IF9zZW1pID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChfc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0b2tUeXBlID09PSBfcGFyZW5SID8gbnVsbCA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgbGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9ySW4obm9kZSwgaW5pdCkge1xuICAgIHZhciB0eXBlID0gdG9rVHlwZSA9PT0gX2luID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiO1xuICAgIG5leHQoKTtcbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgIGxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbiAgZnVuY3Rpb24gcGFyc2VWYXIobm9kZSwgbm9Jbiwga2luZCkge1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgZGVjbC5pZCA9IHBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgIGNoZWNrTFZhbChkZWNsLmlkLCB0cnVlKTtcblxuICAgICAgaWYgKHRva1R5cGUgPT09IF9jb2xvbikge1xuICAgICAgICBkZWNsLmlkLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgICBmaW5pc2hOb2RlKGRlY2wuaWQsIGRlY2wuaWQudHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGRlY2wuaW5pdCA9IGVhdChfZXEpID8gcGFyc2VNYXliZUFzc2lnbihub0luKSA6IChraW5kID09PSBfY29uc3Qua2V5d29yZCA/IHVuZXhwZWN0ZWQoKSA6IG51bGwpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaChmaW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghZWF0KF9jb21tYSkpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuICAvLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbiAgLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2ZcbiAgLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4gIC8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4gIC8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuICAvLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuICAvLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuICAvLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbiAgLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4gIC8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2VcbiAgLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gICAgaWYgKHRva1R5cGUgPT09IF9jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKGVhdChfY29tbWEpKSBub2RlLmV4cHJlc3Npb25zLnB1c2gocGFyc2VNYXliZUFzc2lnbihub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSk7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4gIC8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZUFzc2lnbihub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHZhciBmYWlsT25TaG9ydGhhbmRBc3NpZ247XG4gICAgaWYgKCFyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gICAgICByZWZTaG9ydGhhbmREZWZhdWx0UG9zID0ge3N0YXJ0OiAwfTtcbiAgICAgIGZhaWxPblNob3J0aGFuZEFzc2lnbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhaWxPblNob3J0aGFuZEFzc2lnbiA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgbGVmdCA9IHBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIGxlZnQgPSBhZnRlckxlZnRQYXJzZShsZWZ0LCBzdGFydCk7XG4gICAgaWYgKHRva1R5cGUuaXNBc3NpZ24pIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgIG5vZGUubGVmdCA9IHRva1R5cGUgPT09IF9lcSA/IHRvQXNzaWduYWJsZShsZWZ0KSA6IGxlZnQ7XG4gICAgICByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0ID0gMDsgLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICAgIGNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGZhaWxPblNob3J0aGFuZEFzc2lnbiAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB7XG4gICAgICB1bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuXG4gIC8vIFBhcnNlIGEgdGVybmFyeSBjb25kaXRpb25hbCAoYD86YCkgb3BlcmF0b3IuXG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwck9wcyhub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSByZXR1cm4gZXhwcjtcbiAgICBpZiAoZWF0KF9xdWVzdGlvbikpIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgaWYgKG9wdGlvbnMucGxheWdyb3VuZCAmJiBlYXQoX2VxKSkge1xuICAgICAgICB2YXIgbGVmdCA9IG5vZGUubGVmdCA9IHRvQXNzaWduYWJsZShleHByKTtcbiAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJhaXNlKGxlZnQuc3RhcnQsIFwiWW91IGNhbiBvbmx5IHVzZSBtZW1iZXIgZXhwcmVzc2lvbnMgaW4gbWVtb2l6YXRpb24gYXNzaWdubWVudFwiKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSBcIj89XCI7XG4gICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgZXhwZWN0KF9jb2xvbik7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByT3BzKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHBhcnNlTWF5YmVVbmFyeShyZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gcGFyc2VFeHByT3AoZXhwciwgc3RhcnQsIC0xLCBub0luKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzaW5nXG4gIC8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4gIC8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuICAvLyBkZWZlciBmdXJ0aGVyIHBhcnNlciB0byBvbmUgb2YgaXRzIGNhbGxlcnMgd2hlbiBpdCBlbmNvdW50ZXJzIGFuXG4gIC8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnQsIG1pblByZWMsIG5vSW4pIHtcbiAgICB2YXIgcHJlYyA9IHRva1R5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdG9rVHlwZSAhPT0gX2luKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQobGVmdFN0YXJ0KTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgICAgdmFyIG9wID0gdG9rVHlwZTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCBzdGFydCwgb3AucmlnaHRBc3NvY2lhdGl2ZSA/IChwcmVjIC0gMSkgOiBwcmVjLCBub0luKTtcbiAgICAgICAgZmluaXNoTm9kZShub2RlLCAob3AgPT09IF9sb2dpY2FsT1IgfHwgb3AgPT09IF9sb2dpY2FsQU5EKSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydCwgbWluUHJlYywgbm9Jbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlVW5hcnkocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICAgIGlmICh0b2tUeXBlLnByZWZpeCkge1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgdXBkYXRlID0gdG9rVHlwZS5pc1VwZGF0ZTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG4gICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICBuZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB1bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICAgICAgaWYgKHVwZGF0ZSkgY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpO1xuICAgICAgZWxzZSBpZiAoc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHJhaXNlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwclN1YnNjcmlwdHMocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gICAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkgcmV0dXJuIGV4cHI7XG4gICAgd2hpbGUgKHRva1R5cGUucG9zdGZpeCAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcbiAgICAgIG5vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIGNoZWNrTFZhbChleHByKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHRzKHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwckF0b20ocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gICAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnQsIG5vQ2FsbHMpIHtcbiAgICBpZiAob3B0aW9ucy5wbGF5Z3JvdW5kICYmIGVhdChfaGFzaCkpIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAoZWF0KF9wYXJlbkwpKSB7XG4gICAgICAgIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiQmluZE1lbWJlckV4cHJlc3Npb25cIiksIHN0YXJ0LCBub0NhbGxzKTtcbiAgICB9IGVsc2UgaWYgKGVhdChfcGFhbWF5aW1OZWt1ZG90YXlpbSkpIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJWaXJ0dWFsUHJvcGVydHlFeHByZXNzaW9uXCIpLCBzdGFydCwgbm9DYWxscyk7XG4gICAgfSBlbHNlIGlmIChlYXQoX2RvdCkpIHtcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBzdGFydCwgbm9DYWxscyk7XG4gICAgfSBlbHNlIGlmIChlYXQoX2JyYWNrZXRMKSkge1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBub2RlLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIGV4cGVjdChfYnJhY2tldFIpO1xuICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgc3RhcnQsIG5vQ2FsbHMpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgZWF0KF9wYXJlbkwpKSB7XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKSwgc3RhcnQsIG5vQ2FsbHMpO1xuICAgIH0gZWxzZSBpZiAodG9rVHlwZSA9PT0gX2JhY2tRdW90ZSkge1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlLnRhZyA9IGJhc2U7XG4gICAgICBub2RlLnF1YXNpID0gcGFyc2VUZW1wbGF0ZSgpO1xuICAgICAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpLCBzdGFydCwgbm9DYWxscyk7XG4gICAgfSByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgLy8gb3IgYHt9YC5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICBzd2l0Y2ggKHRva1R5cGUpIHtcbiAgICBjYXNlIF90aGlzOlxuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgXG4gICAgY2FzZSBfeWllbGQ6XG4gICAgICBpZiAoaW5HZW5lcmF0b3IpIHJldHVybiBwYXJzZVlpZWxkKCk7XG5cbiAgICBjYXNlIF9uYW1lOlxuICAgICAgdmFyIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgdmFyIGlkID0gcGFyc2VJZGVudCh0b2tUeXBlICE9PSBfbmFtZSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcpIHtcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIVxuICAgICAgICBpZiAoaWQubmFtZSA9PT0gXCJhc3luY1wiKSB7XG4gICAgICAgICAgLy8gYXJyb3cgZnVuY3Rpb25zXG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9wYXJlbkwpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBleHByTGlzdDtcbiAgICAgICAgICAgIGlmICh0b2tUeXBlICE9PSBfcGFyZW5SKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgZXhwckxpc3QgPSB2YWwudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiA/IHZhbC5leHByZXNzaW9ucyA6IFt2YWxdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwckxpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgICAgIC8vIGlmICc9PicgZm9sbG93cyAnKC4uLiknLCBjb252ZXJ0IGNvbnRlbnRzIHRvIGFyZ3VtZW50c1xuICAgICAgICAgICAgaWYgKGVhdChfYXJyb3cpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBleHByTGlzdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLmNhbGxlZSA9IGlkO1xuICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKSwgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgaWYgKGVhdChfYXJyb3cpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBbaWRdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBub3JtYWwgZnVuY3Rpb25zXG4gICAgICAgICAgaWYgKHRva1R5cGUgPT09IF9mdW5jdGlvbiAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaWQubmFtZSA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICAgICAgaWYgKGluQXN5bmMpIHJldHVybiBwYXJzZUF3YWl0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgZWF0KF9hcnJvdykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJyb3dFeHByZXNzaW9uKHN0YXJ0Tm9kZUF0KHN0YXJ0KSwgW2lkXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgICBcbiAgICBjYXNlIF9yZWdleHA6XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB0b2tWYWwucGF0dGVybiwgZmxhZ3M6IHRva1ZhbC5mbGFnc307XG4gICAgICBub2RlLnZhbHVlID0gdG9rVmFsLnZhbHVlO1xuICAgICAgbm9kZS5yYXcgPSBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgX251bTogY2FzZSBfc3RyaW5nOiBjYXNlIF9qc3hUZXh0OlxuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0b2tWYWw7XG4gICAgICBub2RlLnJhdyA9IGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG4gICAgY2FzZSBfbnVsbDogY2FzZSBfdHJ1ZTogY2FzZSBfZmFsc2U6XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRva1R5cGUuYXRvbVZhbHVlO1xuICAgICAgbm9kZS5yYXcgPSB0b2tUeXBlLmtleXdvcmQ7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cbiAgICBjYXNlIF9wYXJlbkw6XG4gICAgICByZXR1cm4gcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbigpO1xuXG4gICAgY2FzZSBfYnJhY2tldEw6XG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgbmV4dCgpO1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlzIGFycmF5IGNvbXByZWhlbnNpb24gb3IgcmVndWxhciBhcnJheVxuICAgICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiB0b2tUeXBlID09PSBfZm9yKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbXByZWhlbnNpb24obm9kZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgbm9kZS5lbGVtZW50cyA9IHBhcnNlRXhwckxpc3QoX2JyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuXG4gICAgY2FzZSBfYnJhY2VMOlxuICAgICAgcmV0dXJuIHBhcnNlT2JqKGZhbHNlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcblxuICAgIGNhc2UgX2Z1bmN0aW9uOlxuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBjYXNlIF9jbGFzczpcbiAgICAgIHJldHVybiBwYXJzZUNsYXNzKHN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG5cbiAgICBjYXNlIF9uZXc6XG4gICAgICByZXR1cm4gcGFyc2VOZXcoKTtcblxuICAgIGNhc2UgX2JhY2tRdW90ZTpcbiAgICAgIHJldHVybiBwYXJzZVRlbXBsYXRlKCk7XG5cbiAgICBjYXNlIF9oYXNoOlxuICAgICAgcmV0dXJuIHBhcnNlQmluZEZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuXG4gICAgY2FzZSBfanN4VGFnU3RhcnQ6XG4gICAgICByZXR1cm4gcGFyc2VKU1hFbGVtZW50KCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQmluZEZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5leHQoKTtcblxuICAgIHZhciBzdGFydCA9IHN0b3JlQ3VycmVudFBvcygpO1xuICAgIG5vZGUuY2FsbGVlID0gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSwgc3RhcnQsIHRydWUpO1xuXG4gICAgaWYgKGVhdChfcGFyZW5MKSkge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBwYXJzZUV4cHJMaXN0KF9wYXJlblIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkJpbmRGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKCkge1xuICAgIHZhciBzdGFydCA9IHN0b3JlQ3VycmVudFBvcygpLCB2YWw7XG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgbmV4dCgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIHRva1R5cGUgPT09IF9mb3IpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29tcHJlaGVuc2lvbihzdGFydE5vZGVBdChzdGFydCksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5uZXJTdGFydCA9IHN0b3JlQ3VycmVudFBvcygpLCBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgICB2YXIgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyA9IHtzdGFydDogMH0sIHNwcmVhZFN0YXJ0LCBpbm5lclBhcmVuU3RhcnQsIHR5cGVTdGFydDtcblxuICAgICAgdmFyIHBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24gKG5vZGUsIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0b2tUeXBlID09PSBfY29sb24pIHtcbiAgICAgICAgICB2YXIgdHlwZUNhc3ROb2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgICAgIHR5cGVDYXN0Tm9kZS5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRva1R5cGUgIT09IF9wYXJlblIpIHtcbiAgICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogZXhwZWN0KF9jb21tYSk7XG4gICAgICAgIGlmICh0b2tUeXBlID09PSBfZWxsaXBzaXMpIHtcbiAgICAgICAgICB2YXIgc3ByZWFkTm9kZVN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICAgICAgc3ByZWFkU3RhcnQgPSB0b2tTdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHBhcnNlUGFyZW5JdGVtKHBhcnNlUmVzdCgpLCBzcHJlYWROb2RlU3RhcnQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX3BhcmVuTCAmJiAhaW5uZXJQYXJlblN0YXJ0KSB7XG4gICAgICAgICAgICBpbm5lclBhcmVuU3RhcnQgPSB0b2tTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwckxpc3QucHVzaChwYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zLCBwYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJFbmQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICAgIGV4cGVjdChfcGFyZW5SKTtcblxuICAgICAgaWYgKCFjYW5JbnNlcnRTZW1pY29sb24oKSAmJiBlYXQoX2Fycm93KSkge1xuICAgICAgICBpZiAoaW5uZXJQYXJlblN0YXJ0KSB1bmV4cGVjdGVkKGlubmVyUGFyZW5TdGFydCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsaXN0SXRlbSA9IGV4cHJMaXN0W2ldO1xuICAgICAgICAgIGlmIChsaXN0SXRlbS50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IGxpc3RJdGVtLmV4cHJlc3Npb247XG4gICAgICAgICAgICBleHByLnJldHVyblR5cGUgPSBsaXN0SXRlbS50eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGV4cHJMaXN0W2ldID0gZXhwcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0V4cHJlc3Npb24oc3RhcnROb2RlQXQoc3RhcnQpLCBleHByTGlzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhwckxpc3QubGVuZ3RoKSB1bmV4cGVjdGVkKGxhc3RTdGFydCk7XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpO1xuICAgICAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHVuZXhwZWN0ZWQocmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9IHN0YXJ0Tm9kZUF0KGlubmVyU3RhcnQpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJlc2VydmVQYXJlbnMpIHtcbiAgICAgIHZhciBwYXIgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnRcbiAgLy8gdG8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0XG4gIC8vIGxlYXN0LCBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGVcblxuICBmdW5jdGlvbiBwYXJzZU5ldygpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5leHQoKTtcbiAgICB2YXIgc3RhcnQgPSBzdG9yZUN1cnJlbnRQb3MoKTtcbiAgICBub2RlLmNhbGxlZSA9IHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCksIHN0YXJ0LCB0cnVlKTtcbiAgICBpZiAoZWF0KF9wYXJlbkwpKSBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO1xuICAgIGVsc2Ugbm9kZS5hcmd1bWVudHMgPSBlbXB0eTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cblxuICAvLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVFbGVtZW50KCkge1xuICAgIHZhciBlbGVtID0gc3RhcnROb2RlKCk7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCksXG4gICAgICBjb29rZWQ6IHRva1ZhbFxuICAgIH07XG4gICAgbmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRva1R5cGUgPT09IF9iYWNrUXVvdGU7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgbmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIGV4cGVjdChfZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICBleHBlY3QoX2JyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHBhcnNlVGVtcGxhdGVFbGVtZW50KCkpO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIik7XG4gIH1cblxuICAvLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbiAgZnVuY3Rpb24gcGFyc2VPYmooaXNQYXR0ZXJuLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIG5leHQoKTtcbiAgICB3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBleHBlY3QoX2NvbW1hKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoX2JyYWNlUikpIGJyZWFrO1xuICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgIHZhciBwcm9wID0gc3RhcnROb2RlKCksIHN0YXJ0LCBpc0dlbmVyYXRvciA9IGZhbHNlLCBpc0FzeW5jID0gZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIHRva1R5cGUgPT09IF9lbGxpcHNpcykge1xuICAgICAgICBwcm9wID0gcGFyc2VTcHJlYWQoKTtcbiAgICAgICAgcHJvcC50eXBlID0gXCJTcHJlYWRQcm9wZXJ0eVwiO1xuICAgICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICAgICAgICAgIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BhdHRlcm4pIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IGVhdChfc3Rhcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICAgICAgdmFyIGFzeW5jSWQgPSBwYXJzZUlkZW50KCk7XG4gICAgICAgIGlmICh0b2tUeXBlID09PSBfY29sb24gfHwgdG9rVHlwZSA9PT0gX3BhcmVuTCkge1xuICAgICAgICAgIHByb3Aua2V5ID0gYXN5bmNJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICBwYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZVBhcmFtZXRlcnNcbiAgICAgIGlmIChpc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgaWYgKHRva1R5cGUgIT09IF9wYXJlbkwpIHVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlYXQoX2NvbG9uKSkge1xuICAgICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gcGFyc2VNYXliZURlZmF1bHQoKSA6IHBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICAgICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRva1R5cGUgPT09IF9wYXJlbkwpIHtcbiAgICAgICAgaWYgKGlzUGF0dGVybikgdW5leHBlY3RlZCgpO1xuICAgICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgICBwcm9wLnZhbHVlID0gcGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIiB8fCAob3B0aW9ucy5wbGF5Z3JvdW5kICYmIHByb3Aua2V5Lm5hbWUgPT09IFwibWVtb1wiKSkgJiZcbiAgICAgICAgICAgICAgICAgKHRva1R5cGUgIT0gX2NvbW1hICYmIHRva1R5cGUgIT0gX2JyYWNlUikpIHtcbiAgICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMgfHwgaXNQYXR0ZXJuKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICAgIHBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgICBwcm9wLnZhbHVlID0gcGFyc2VNZXRob2QoZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgICAgcHJvcC52YWx1ZSA9IHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0LCBwcm9wLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rVHlwZSA9PT0gX2VxICYmIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICAgICAgICBpZiAoIXJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpXG4gICAgICAgICAgICByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0ID0gdG9rU3RhcnQ7XG4gICAgICAgICAgcHJvcC52YWx1ZSA9IHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0LCBwcm9wLmtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgICAgICB9XG4gICAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB1bmV4cGVjdGVkKCk7XG5cbiAgICAgIHByb3AudmFsdWUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIGNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoKTtcbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKGZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU5hbWUocHJvcCkge1xuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChlYXQoX2JyYWNrZXRMKSkge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5rZXkgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgZXhwZWN0KF9icmFja2V0Uik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcC5rZXkgPSAodG9rVHlwZSA9PT0gX251bSB8fCB0b2tUeXBlID09PSBfc3RyaW5nKSA/IHBhcnNlRXhwckF0b20oKSA6IHBhcnNlSWRlbnQodHJ1ZSk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbiAgZnVuY3Rpb24gaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcpIHtcbiAgICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCwgaXNBc3luYywgYWxsb3dFeHByZXNzaW9uQm9keSkge1xuICAgIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLmdlbmVyYXRvciA9IGVhdChfc3Rhcik7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlbWVudCB8fCB0b2tUeXBlID09PSBfbmFtZSkge1xuICAgICAgbm9kZS5pZCA9IHBhcnNlSWRlbnQoKTtcbiAgICB9XG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHkpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbiAgZnVuY3Rpb24gcGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIHZhciBhbGxvd0V4cHJlc3Npb25Cb2R5O1xuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7XG4gICAgICBhbGxvd0V4cHJlc3Npb25Cb2R5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dFeHByZXNzaW9uQm9keSA9IGZhbHNlO1xuICAgIH1cbiAgICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5KTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSkge1xuICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHBhcnNlQmluZGluZ0xpc3QoX3BhcmVuUiwgZmFsc2UpO1xuICAgIGlmICh0b2tUeXBlID09PSBfY29sb24pIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxuICBmdW5jdGlvbiBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMpIHtcbiAgICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5wYXJhbXMgPSB0b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uKSB7XG4gICAgdmFyIGlzRXhwcmVzc2lvbiA9IGFsbG93RXhwcmVzc2lvbiAmJiB0b2tUeXBlICE9PSBfYnJhY2VMO1xuXG4gICAgdmFyIG9sZEluQXN5bmMgPSBpbkFzeW5jO1xuICAgIGluQXN5bmMgPSBub2RlLmFzeW5jO1xuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgICAgdmFyIG9sZEluRnVuYyA9IGluRnVuY3Rpb24sIG9sZEluR2VuID0gaW5HZW5lcmF0b3IsIG9sZExhYmVscyA9IGxhYmVscztcbiAgICAgIGluRnVuY3Rpb24gPSB0cnVlOyBpbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yOyBsYWJlbHMgPSBbXTtcbiAgICAgIG5vZGUuYm9keSA9IHBhcnNlQmxvY2sodHJ1ZSk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIGluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7IGluR2VuZXJhdG9yID0gb2xkSW5HZW47IGxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgaW5Bc3luYyA9IG9sZEluQXN5bmM7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICBpZiAoc3RyaWN0IHx8ICFpc0V4cHJlc3Npb24gJiYgbm9kZS5ib2R5LmJvZHkubGVuZ3RoICYmIGlzVXNlU3RyaWN0KG5vZGUuYm9keS5ib2R5WzBdKSkge1xuICAgICAgdmFyIG5hbWVIYXNoID0ge307XG4gICAgICBpZiAobm9kZS5pZClcbiAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtKG5vZGUuaWQsIHt9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGNoZWNrRnVuY3Rpb25QYXJhbShub2RlLnBhcmFtc1tpXSwgbmFtZUhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpdmF0ZShub2RlKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHBhcnNlSWRlbnQoKSk7XG4gICAgfSB3aGlsZSAoZWF0KF9jb21tYSkpO1xuICAgIHNlbWljb2xvbigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZURlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICBuZXh0KCk7XG4gICAgbm9kZS5pZCA9IHRva1R5cGUgPT09IF9uYW1lID8gcGFyc2VJZGVudCgpIDogaXNTdGF0ZW1lbnQgPyB1bmV4cGVjdGVkKCkgOiBudWxsO1xuICAgIGlmIChpc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgbm9kZS5zdXBlckNsYXNzID0gZWF0KF9leHRlbmRzKSA/IHBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiBpc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuICAgIGlmIChpc0NvbnRleHR1YWwoXCJpbXBsZW1lbnRzXCIpKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICBub2RlLmltcGxlbWVudHMgPSBwYXJzZUNsYXNzSW1wbGVtZW50cygpO1xuICAgIH1cbiAgICB2YXIgY2xhc3NCb2R5ID0gc3RhcnROb2RlKCk7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICBleHBlY3QoX2JyYWNlTCk7XG4gICAgd2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcbiAgICAgIGlmIChlYXQoX3NlbWkpKSBjb250aW51ZTtcbiAgICAgIHZhciBtZXRob2QgPSBzdGFydE5vZGUoKTtcbiAgICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgaXNDb250ZXh0dWFsKFwicHJpdmF0ZVwiKSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2gocGFyc2VQcml2YXRlKG1ldGhvZCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0dlbmVyYXRvciA9IGVhdChfc3Rhcik7XG4gICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgICAgcGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgIGlmICh0b2tUeXBlICE9PSBfcGFyZW5MICYmICFtZXRob2QuY29tcHV0ZWQgJiYgbWV0aG9kLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgIG1ldGhvZC5rZXkubmFtZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgdW5leHBlY3RlZCgpO1xuICAgICAgICBtZXRob2RbJ3N0YXRpYyddID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSBlYXQoX3N0YXIpO1xuICAgICAgICBwYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kWydzdGF0aWMnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRva1R5cGUgIT09IF9wYXJlbkwgJiYgIW1ldGhvZC5jb21wdXRlZCAmJiBtZXRob2Qua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgbWV0aG9kLmtleS5uYW1lID09PSBcImFzeW5jXCIpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICB9XG4gICAgICBpZiAodG9rVHlwZSAhPT0gX3BhcmVuTCAmJiAhbWV0aG9kLmNvbXB1dGVkICYmIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAobWV0aG9kLmtleS5uYW1lID09PSBcImdldFwiIHx8IG1ldGhvZC5rZXkubmFtZSA9PT0gXCJzZXRcIikgfHwgKG9wdGlvbnMucGxheWdyb3VuZCAmJiBtZXRob2Qua2V5Lm5hbWUgPT09IFwibWVtb1wiKSkge1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgdW5leHBlY3RlZCgpO1xuICAgICAgICBtZXRob2Qua2luZCA9IG1ldGhvZC5rZXkubmFtZTtcbiAgICAgICAgcGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsYXNzUHJvcGVydHkgPSBmYWxzZTtcblxuICAgICAgaWYgKHRva1R5cGUgPT09IF9jb2xvbikge1xuICAgICAgICBtZXRob2QudHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIGNsYXNzUHJvcGVydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wbGF5Z3JvdW5kICYmIGVhdChfZXEpKSB7XG4gICAgICAgIG1ldGhvZC52YWx1ZSA9IHBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgY2xhc3NQcm9wZXJ0eSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc1Byb3BlcnR5KSB7XG4gICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGZpbmlzaE5vZGUobWV0aG9kLCBcIkNsYXNzUHJvcGVydHlcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QudmFsdWUgPSBwYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgICAgIG1ldGhvZC52YWx1ZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpO1xuICAgICAgICBlYXQoX3NlbWkpO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLmJvZHkgPSBmaW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDbGFzc0ltcGxlbWVudHMoKSB7XG4gICAgICB2YXIgaW1wbGVtZW50ZWQgPSBbXTtcblxuICAgICAgZG8ge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgICBpZiAoaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHBhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGltcGxlbWVudGVkLnB1c2goZmluaXNoTm9kZShub2RlLCBcIkNsYXNzSW1wbGVtZW50c1wiKSk7XG4gICAgICB9IHdoaWxlKGVhdChfY29tbWEpKTtcblxuICAgICAgcmV0dXJuIGltcGxlbWVudGVkO1xuICB9XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbiAgLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbiAgLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuICAvLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbiAgLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCFlYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoY2xvc2UpKSBicmVhaztcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0b2tUeXBlID09PSBfY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva1R5cGUgPT09IF9lbGxpcHNpcylcbiAgICAgICAgICBlbHRzLnB1c2gocGFyc2VTcHJlYWQocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZWx0cy5wdXNoKHBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cblxuICAvLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuICAvLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbiAgLy8gaWRlbnRpZmllcnMuXG5cbiAgZnVuY3Rpb24gcGFyc2VJZGVudChsaWJlcmFsKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBpZiAobGliZXJhbCAmJiBvcHRpb25zLmZvcmJpZFJlc2VydmVkID09IFwiZXZlcnl3aGVyZVwiKSBsaWJlcmFsID0gZmFsc2U7XG4gICAgaWYgKHRva1R5cGUgPT09IF9uYW1lKSB7XG4gICAgICBpZiAoIWxpYmVyYWwgJiZcbiAgICAgICAgICAob3B0aW9ucy5mb3JiaWRSZXNlcnZlZCAmJlxuICAgICAgICAgICAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gMyA/IGlzUmVzZXJ2ZWRXb3JkMyA6IGlzUmVzZXJ2ZWRXb3JkNSkodG9rVmFsKSB8fFxuICAgICAgICAgICBzdHJpY3QgJiYgaXNTdHJpY3RSZXNlcnZlZFdvcmQodG9rVmFsKSkgJiZcbiAgICAgICAgICBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKS5pbmRleE9mKFwiXFxcXFwiKSA9PSAtMSlcbiAgICAgICAgcmFpc2UodG9rU3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgdG9rVmFsICsgXCInIGlzIHJlc2VydmVkXCIpO1xuICAgICAgbm9kZS5uYW1lID0gdG9rVmFsO1xuICAgIH0gZWxzZSBpZiAobGliZXJhbCAmJiB0b2tUeXBlLmtleXdvcmQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRva1R5cGUua2V5d29yZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG5cbiAgLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIG5leHQoKTtcbiAgICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi47XG4gICAgaWYgKHRva1R5cGUgPT09IF92YXIgfHwgdG9rVHlwZSA9PT0gX2NvbnN0IHx8IHRva1R5cGUgPT09IF9sZXQgfHwgdG9rVHlwZSA9PT0gX2Z1bmN0aW9uIHx8IHRva1R5cGUgPT09IF9jbGFzcyB8fCBpc0NvbnRleHR1YWwoXCJhc3luY1wiKSB8fCBpc0NvbnRleHR1YWwoXCJ0eXBlXCIpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gcGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgICBub2RlWydkZWZhdWx0J10gPSBmYWxzZTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IG51bGw7XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlXG4gICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uO1xuICAgIGlmIChlYXQoX2RlZmF1bHQpKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOiBleHByLnR5cGUgPSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOiBleHByLnR5cGUgPSBcIkNsYXNzRGVjbGFyYXRpb25cIjsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBleHByO1xuICAgICAgbm9kZVsnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IG51bGw7XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBzZW1pY29sb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJztcbiAgICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXTtcbiAgICAgIHZhciBpc0JhdGNoID0gdG9rVHlwZSA9PT0gX3N0YXI7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGVbJ2RlZmF1bHQnXSA9IGZhbHNlO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gcGFyc2VFeHBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICBpZiAoZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0b2tUeXBlID09PSBfc3RyaW5nID8gcGFyc2VFeHByQXRvbSgpIDogdW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQmF0Y2gpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxuICBmdW5jdGlvbiBwYXJzZUV4cG9ydFNwZWNpZmllcnMoKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICBpZiAodG9rVHlwZSA9PT0gX3N0YXIpIHtcbiAgICAgIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICBuZXh0KCk7XG4gICAgICBub2Rlcy5wdXNoKGZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRCYXRjaFNwZWNpZmllclwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgICAgZXhwZWN0KF9icmFjZUwpO1xuICAgICAgd2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KF9icmFjZVIpKSBicmVhaztcbiAgICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5pZCA9IHBhcnNlSWRlbnQodG9rVHlwZSA9PT0gX2RlZmF1bHQpO1xuICAgICAgICBub2RlLm5hbWUgPSBlYXRDb250ZXh0dWFsKFwiYXNcIikgPyBwYXJzZUlkZW50KHRydWUpIDogbnVsbDtcbiAgICAgICAgbm9kZXMucHVzaChmaW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxuICBmdW5jdGlvbiBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIFxuICAgIG5vZGUuaXNUeXBlID0gZmFsc2U7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG5cbiAgICB2YXIgdHlwZUlkO1xuICAgIGlmIChpc0NvbnRleHR1YWwoJ3R5cGUnKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICB0eXBlSWQgPSBwYXJzZUlkZW50KCk7XG4gICAgICBpZiAoKHRva1R5cGUgPT09IF9uYW1lICYmIHRva1ZhbCAhPT0gXCJmcm9tXCIpIHx8IHRva1R5cGUgPT09IF9icmFjZUwgfHwgdG9rVHlwZSA9PT0gX3N0YXIpIHtcbiAgICAgICAgbm9kZS5pc1R5cGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnRTcGVjaWZpZXJEZWZhdWx0KHR5cGVJZCwgc3RhcnQpKTtcbiAgICAgICAgZWF0KF9jb21tYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgXG4gICAgLy8gaW1wb3J0ICcuLi4nO1xuICAgIGlmICh0b2tUeXBlID09PSBfc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZUlkKSB1bmV4cGVjdGVkKHR5cGVJZC5zdGFydCk7XG4gICAgICBub2RlLnNvdXJjZSA9IHBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc0NvbnRleHR1YWwoXCJmcm9tXCIpKSBwYXJzZUltcG9ydFNwZWNpZmllcnMobm9kZS5zcGVjaWZpZXJzKTtcbiAgICAgIGV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgbm9kZS5zb3VyY2UgPSB0b2tUeXBlID09PSBfc3RyaW5nID8gcGFyc2VFeHByQXRvbSgpIDogdW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBzZW1pY29sb24oKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRTcGVjaWZpZXJzKG5vZGVzKSB7XG4gICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICBpZiAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgICAgIHZhciBzdGFydCA9IHN0b3JlQ3VycmVudFBvcygpO1xuICAgICAgdmFyIGlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgbm9kZXMucHVzaChwYXJzZUltcG9ydFNwZWNpZmllckRlZmF1bHQoaWQsIHN0YXJ0KSk7XG4gICAgICBpZiAoIWVhdChfY29tbWEpKSByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGlmICh0b2tUeXBlID09PSBfc3Rhcikge1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICAgIG5vZGUubmFtZSA9IHBhcnNlSWRlbnQoKTtcbiAgICAgIGNoZWNrTFZhbChub2RlLm5hbWUsIHRydWUpO1xuICAgICAgbm9kZXMucHVzaChmaW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0QmF0Y2hTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBleHBlY3QoX2JyYWNlTCk7XG4gICAgd2hpbGUgKCFlYXQoX2JyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgZXhwZWN0KF9jb21tYSk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KF9icmFjZVIpKSBicmVhaztcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5pZCA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLm5hbWUgPSBlYXRDb250ZXh0dWFsKFwiYXNcIikgPyBwYXJzZUlkZW50KCkgOiBudWxsO1xuICAgICAgY2hlY2tMVmFsKG5vZGUubmFtZSB8fCBub2RlLmlkLCB0cnVlKTtcbiAgICAgIG5vZGVbJ2RlZmF1bHQnXSA9IGZhbHNlO1xuICAgICAgbm9kZXMucHVzaChmaW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRTcGVjaWZpZXJEZWZhdWx0KGlkLCBzdGFydCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgIG5vZGUuaWQgPSBpZDtcbiAgICBjaGVja0xWYWwobm9kZS5pZCwgdHJ1ZSk7XG4gICAgbm9kZS5uYW1lID0gbnVsbDtcbiAgICBub2RlWydkZWZhdWx0J10gPSB0cnVlO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICB9XG5cbiAgLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxuICBmdW5jdGlvbiBwYXJzZVlpZWxkKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgbmV4dCgpO1xuICAgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGVhdChfc3Rhcik7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZUFzc2lnbigpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlcyBhd2FpdCBleHByZXNzaW9uIGluc2lkZSBhc3luYyBmdW5jdGlvbi5cblxuICBmdW5jdGlvbiBwYXJzZUF3YWl0KG5vZGUpIHtcbiAgICBpZiAoZWF0KF9zZW1pKSB8fCBjYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBub2RlLmFsbCA9IGVhdChfc3Rhcik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlTWF5YmVBc3NpZ24odHJ1ZSk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG4gIH1cblxuICAvLyBQYXJzZXMgYXJyYXkgYW5kIGdlbmVyYXRvciBjb21wcmVoZW5zaW9ucy5cblxuICBmdW5jdGlvbiBwYXJzZUNvbXByZWhlbnNpb24obm9kZSwgaXNHZW5lcmF0b3IpIHtcbiAgICBub2RlLmJsb2NrcyA9IFtdO1xuICAgIHdoaWxlICh0b2tUeXBlID09PSBfZm9yKSB7XG4gICAgICB2YXIgYmxvY2sgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgIGJsb2NrLmxlZnQgPSBwYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICBjaGVja0xWYWwoYmxvY2subGVmdCwgdHJ1ZSk7XG4gICAgICBleHBlY3RDb250ZXh0dWFsKFwib2ZcIik7XG4gICAgICBibG9jay5yaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgbm9kZS5ibG9ja3MucHVzaChmaW5pc2hOb2RlKGJsb2NrLCBcIkNvbXByZWhlbnNpb25CbG9ja1wiKSk7XG4gICAgfVxuICAgIG5vZGUuZmlsdGVyID0gZWF0KF9pZikgPyBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIDogbnVsbDtcbiAgICBub2RlLmJvZHkgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoaXNHZW5lcmF0b3IgPyBfcGFyZW5SIDogX2JyYWNrZXRSKTtcbiAgICBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQ29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIik7XG4gIH1cblxuICAvLyBUcmFuc2Zvcm1zIEpTWCBlbGVtZW50IG5hbWUgdG8gc3RyaW5nLlxuXG4gIGZ1bmN0aW9uIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWElkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikge1xuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lc3BhY2UubmFtZSArICc6JyArIG9iamVjdC5uYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChvYmplY3QudHlwZSA9PT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0Lm9iamVjdCkgKyAnLicgK1xuICAgICAgICBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgbmV4dCB0b2tlbiBhcyBKU1ggaWRlbnRpZmllclxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNYSWRlbnRpZmllcigpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0b2tUeXBlID09PSBfanN4TmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdG9rVmFsO1xuICAgIH0gZWxzZSBpZiAodG9rVHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0b2tUeXBlLmtleXdvcmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSlNYSWRlbnRpZmllclwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIG5hbWVzcGFjZWQgaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBwYXJzZUpTWE5hbWVzcGFjZWROYW1lKCkge1xuICAgIHZhciBzdGFydCA9IHN0b3JlQ3VycmVudFBvcygpO1xuICAgIHZhciBuYW1lID0gcGFyc2VKU1hJZGVudGlmaWVyKCk7XG4gICAgaWYgKCFlYXQoX2NvbG9uKSkgcmV0dXJuIG5hbWU7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgIG5vZGUubmFtZSA9IHBhcnNlSlNYSWRlbnRpZmllcigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIik7XG4gIH1cblxuICAvLyBQYXJzZXMgZWxlbWVudCBuYW1lIGluIGFueSBmb3JtIC0gbmFtZXNwYWNlZCwgbWVtYmVyXG4gIC8vIG9yIHNpbmdsZSBpZGVudGlmaWVyLlxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNYRWxlbWVudE5hbWUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgdmFyIG5vZGUgPSBwYXJzZUpTWE5hbWVzcGFjZWROYW1lKCk7XG4gICAgd2hpbGUgKGVhdChfZG90KSkge1xuICAgICAgdmFyIG5ld05vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgICBuZXdOb2RlLnByb3BlcnR5ID0gcGFyc2VKU1hJZGVudGlmaWVyKCk7XG4gICAgICBub2RlID0gZmluaXNoTm9kZShuZXdOb2RlLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gUGFyc2VzIGFueSB0eXBlIG9mIEpTWCBhdHRyaWJ1dGUgdmFsdWUuXG5cbiAgZnVuY3Rpb24gcGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICBzd2l0Y2ggKHRva1R5cGUpIHtcbiAgICAgIGNhc2UgX2JyYWNlTDpcbiAgICAgICAgdmFyIG5vZGUgPSBwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmFpc2UoXG4gICAgICAgICAgICBub2RlLnN0YXJ0LFxuICAgICAgICAgICAgICAnSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5ICcgK1xuICAgICAgICAgICAgICAnZXhwcmVzc2lvbidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBjYXNlIF9qc3hUYWdTdGFydDpcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNYRWxlbWVudCgpO1xuXG4gICAgICBjYXNlIF9qc3hUZXh0OlxuICAgICAgY2FzZSBfc3RyaW5nOlxuICAgICAgICByZXR1cm4gcGFyc2VFeHByQXRvbSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByYWlzZSh0b2tTdGFydCwgXCJKU1ggdmFsdWUgc2hvdWxkIGJlIGVpdGhlciBhbiBleHByZXNzaW9uIG9yIGEgcXVvdGVkIEpTWCB0ZXh0XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEpTWEVtcHR5RXhwcmVzc2lvbiBpcyB1bmlxdWUgdHlwZSBzaW5jZSBpdCBkb2Vzbid0IGFjdHVhbGx5IHBhcnNlIGFueXRoaW5nLFxuICAvLyBhbmQgc28gaXQgc2hvdWxkIHN0YXJ0IGF0IHRoZSBlbmQgb2YgbGFzdCByZWFkIHRva2VuIChsZWZ0IGJyYWNlKSBhbmQgZmluaXNoXG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgb25lIChyaWdodCBicmFjZSkuXG5cbiAgZnVuY3Rpb24gcGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRva1R5cGUgIT09IF9icmFjZVIpIHtcbiAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wO1xuXG4gICAgdG1wID0gdG9rU3RhcnQ7XG4gICAgdG9rU3RhcnQgPSBsYXN0RW5kO1xuICAgIGxhc3RFbmQgPSB0bXA7XG5cbiAgICB0bXAgPSB0b2tTdGFydExvYztcbiAgICB0b2tTdGFydExvYyA9IGxhc3RFbmRMb2M7XG4gICAgbGFzdEVuZExvYyA9IHRtcDtcblxuICAgIHJldHVybiBmaW5pc2hOb2RlKHN0YXJ0Tm9kZSgpLCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlcyBKU1ggZXhwcmVzc2lvbiBlbmNsb3NlZCBpbnRvIGN1cmx5IGJyYWNrZXRzLlxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcigpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0b2tUeXBlID09PSBfYnJhY2VSID8gcGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKSA6IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChfYnJhY2VSKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gIH1cblxuICAvLyBQYXJzZXMgZm9sbG93aW5nIEpTWCBhdHRyaWJ1dGUgbmFtZS12YWx1ZSBwYWlyLlxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNYQXR0cmlidXRlKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgaWYgKGVhdChfYnJhY2VMKSkge1xuICAgICAgZXhwZWN0KF9lbGxpcHNpcyk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgZXhwZWN0KF9icmFjZVIpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHBhcnNlSlNYTmFtZXNwYWNlZE5hbWUoKTtcbiAgICBub2RlLnZhbHVlID0gZWF0KF9lcSkgPyBwYXJzZUpTWEF0dHJpYnV0ZVZhbHVlKCkgOiBudWxsO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSlNYQXR0cmlidXRlXCIpO1xuICB9XG5cbiAgLy8gUGFyc2VzIEpTWCBvcGVuaW5nIHRhZyBzdGFydGluZyBhZnRlciAnPCcuXG5cbiAgZnVuY3Rpb24gcGFyc2VKU1hPcGVuaW5nRWxlbWVudEF0KHN0YXJ0KSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgbm9kZS5hdHRyaWJ1dGVzID0gW107XG4gICAgbm9kZS5uYW1lID0gcGFyc2VKU1hFbGVtZW50TmFtZSgpO1xuICAgIHdoaWxlICh0b2tUeXBlICE9PSBfc2xhc2ggJiYgdG9rVHlwZSAhPT0gX2pzeFRhZ0VuZCkge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLnB1c2gocGFyc2VKU1hBdHRyaWJ1dGUoKSk7XG4gICAgfVxuICAgIG5vZGUuc2VsZkNsb3NpbmcgPSBlYXQoX3NsYXNoKTtcbiAgICBleHBlY3QoX2pzeFRhZ0VuZCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRWxlbWVudFwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlcyBKU1ggY2xvc2luZyB0YWcgc3RhcnRpbmcgYWZ0ZXIgJzwvJy5cblxuICBmdW5jdGlvbiBwYXJzZUpTWENsb3NpbmdFbGVtZW50QXQoc3RhcnQpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICBub2RlLm5hbWUgPSBwYXJzZUpTWEVsZW1lbnROYW1lKCk7XG4gICAgZXhwZWN0KF9qc3hUYWdFbmQpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0VsZW1lbnRcIik7XG4gIH1cblxuICAvLyBQYXJzZXMgZW50aXJlIEpTWCBlbGVtZW50LCBpbmNsdWRpbmcgaXQncyBvcGVuaW5nIHRhZ1xuICAvLyAoc3RhcnRpbmcgYWZ0ZXIgJzwnKSwgYXR0cmlidXRlcywgY29udGVudHMgYW5kIGNsb3NpbmcgdGFnLlxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNYRWxlbWVudEF0KHN0YXJ0KSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgdmFyIG9wZW5pbmdFbGVtZW50ID0gcGFyc2VKU1hPcGVuaW5nRWxlbWVudEF0KHN0YXJ0KTtcbiAgICB2YXIgY2xvc2luZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKCFvcGVuaW5nRWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgY29udGVudHM6Zm9yICg7Oykge1xuICAgICAgICBzd2l0Y2ggKHRva1R5cGUpIHtcbiAgICAgICAgICBjYXNlIF9qc3hUYWdTdGFydDpcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoZWF0KF9zbGFzaCkpIHtcbiAgICAgICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSBwYXJzZUpTWENsb3NpbmdFbGVtZW50QXQoc3RhcnQpO1xuICAgICAgICAgICAgICBicmVhayBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocGFyc2VKU1hFbGVtZW50QXQoc3RhcnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfanN4VGV4dDpcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gocGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfYnJhY2VMOlxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChnZXRRdWFsaWZpZWRKU1hOYW1lKGNsb3NpbmdFbGVtZW50Lm5hbWUpICE9PSBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpKSB7XG4gICAgICAgIHJhaXNlKFxuICAgICAgICAgIGNsb3NpbmdFbGVtZW50LnN0YXJ0LFxuICAgICAgICAgIFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDxcIiArIGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkgKyBcIj5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcbiAgICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSlNYRWxlbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVsYXRpb25hbChvcCkge1xuICAgIHJldHVybiB0b2tUeXBlID09PSBfcmVsYXRpb25hbCAmJiB0b2tWYWwgPT09IG9wO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0UmVsYXRpb25hbChvcCkge1xuICAgIGlmIChpc1JlbGF0aW9uYWwob3ApKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgZW50aXJlIEpTWCBlbGVtZW50IGZyb20gY3VycmVudCBwb3NpdGlvbi5cblxuICBmdW5jdGlvbiBwYXJzZUpTWEVsZW1lbnQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBwYXJzZUpTWEVsZW1lbnRBdChzdGFydCk7XG4gIH1cblxuICAvLyBEZWNsYXJlXG4gIFxuICBmdW5jdGlvbiBwYXJzZURlY2xhcmVDbGFzcyhub2RlKSB7XG4gICAgbmV4dCgpO1xuICAgIHBhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIHRydWUpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNsYXJlRnVuY3Rpb24obm9kZSkge1xuICAgIG5leHQoKTtcblxuICAgIHZhciBpZCA9IG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG5cbiAgICB2YXIgdHlwZU5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICB2YXIgdHlwZUNvbnRhaW5lciA9IHN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gcGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICB2YXIgdG1wID0gcGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICB0eXBlTm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgIHR5cGVOb2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICBleHBlY3QoX3BhcmVuUik7XG5cbiAgICBleHBlY3QoX2NvbG9uKTtcbiAgICB0eXBlTm9kZS5yZXR1cm5UeXBlID0gcGFyc2VUeXBlKCk7XG5cbiAgICB0eXBlQ29udGFpbmVyLnR5cGVBbm5vdGF0aW9uID0gZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gZmluaXNoTm9kZSh0eXBlQ29udGFpbmVyLCBcIlR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgZmluaXNoTm9kZShpZCwgaWQudHlwZSk7XG5cbiAgICBzZW1pY29sb24oKTtcblxuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNsYXJlKG5vZGUpIHtcbiAgICBpZiAodG9rVHlwZSA9PT0gX2NsYXNzKSB7XG4gICAgICByZXR1cm4gcGFyc2VEZWNsYXJlQ2xhc3Mobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0b2tUeXBlID09PSBfZnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRva1R5cGUgPT09IF92YXIpIHtcbiAgICAgIHJldHVybiBwYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ29udGV4dHVhbChcIm1vZHVsZVwiKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRGVjbGFyZU1vZHVsZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGVjbGFyZVZhcmlhYmxlKG5vZGUpIHtcbiAgICBuZXh0KCk7XG4gICAgbm9kZS5pZCA9IHBhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO1xuICAgIHNlbWljb2xvbigpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZVZhcmlhYmxlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpIHtcbiAgICBuZXh0KCk7XG5cbiAgICBpZiAodG9rVHlwZSA9PT0gX3N0cmluZykge1xuICAgICAgbm9kZS5pZCA9IHBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IHBhcnNlSWRlbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgYm9keU5vZGUgPSBub2RlLmJvZHkgPSBzdGFydE5vZGUoKTtcbiAgICB2YXIgYm9keSA9IGJvZHlOb2RlLmJvZHkgPSBbXTtcbiAgICBleHBlY3QoX2JyYWNlTCk7XG4gICAgd2hpbGUgKHRva1R5cGUgIT09IF9icmFjZVIpIHtcbiAgICAgIHZhciBub2RlMiA9IHN0YXJ0Tm9kZSgpO1xuXG4gICAgICAvLyB0b2RvOiBkZWNsYXJlIGNoZWNrXG4gICAgICBuZXh0KCk7XG5cbiAgICAgIGJvZHkucHVzaChwYXJzZURlY2xhcmUobm9kZTIpKTtcbiAgICB9XG4gICAgZXhwZWN0KF9icmFjZVIpO1xuXG4gICAgZmluaXNoTm9kZShib2R5Tm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG4gIH1cblxuXG4gIC8vIEludGVyZmFjZXNcblxuICBmdW5jdGlvbiBwYXJzZUludGVyZmFjZWlzaChub2RlLCBhbGxvd1N0YXRpYykge1xuICAgIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG4gICAgXG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG5cbiAgICBub2RlLmV4dGVuZHMgPSBbXTtcblxuICAgIGlmIChlYXQoX2V4dGVuZHMpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUuZXh0ZW5kcy5wdXNoKHBhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgIH0gd2hpbGUoZWF0KF9jb21tYSkpO1xuICAgIH1cblxuICAgIG5vZGUuYm9keSA9IHBhcnNlT2JqZWN0VHlwZShhbGxvd1N0YXRpYyk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUludGVyZmFjZUV4dGVuZHMoKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblxuICAgIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRXh0ZW5kc1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICBwYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIC8vIFR5cGUgYWxpYXNlc1xuICBcbiAgZnVuY3Rpb24gcGFyc2VUeXBlQWxpYXMobm9kZSkge1xuICAgIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG5cbiAgICBpZiAoaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHBhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIGV4cGVjdChfZXEpO1xuXG4gICAgbm9kZS5yaWdodCA9IHBhcnNlVHlwZSgpO1xuXG4gICAgc2VtaWNvbG9uKCk7XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbGlhc1wiKTtcbiAgfVxuXG4gIC8vIFR5cGUgYW5ub3RhdGlvbnNcblxuICBmdW5jdGlvbiBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gW107XG5cbiAgICBleHBlY3RSZWxhdGlvbmFsKFwiPFwiKTtcbiAgICB3aGlsZSAoIWlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2gocGFyc2VJZGVudCgpKTtcbiAgICAgIGlmICghaXNSZWxhdGlvbmFsKFwiPlwiKSkge1xuICAgICAgICBleHBlY3QoX2NvbW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwZWN0UmVsYXRpb25hbChcIj5cIik7XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgb2xkSW5UeXBlID0gaW5UeXBlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG5cbiAgICBpblR5cGUgPSB0cnVlO1xuXG4gICAgZXhwZWN0UmVsYXRpb25hbChcIjxcIik7XG4gICAgd2hpbGUgKCFpc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHBhcnNlVHlwZSgpKTtcbiAgICAgIGlmICghaXNSZWxhdGlvbmFsKFwiPlwiKSkge1xuICAgICAgICBleHBlY3QoX2NvbW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwZWN0UmVsYXRpb25hbChcIj5cIik7XG5cbiAgICBpblR5cGUgPSBvbGRJblR5cGU7XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICByZXR1cm4gKHRva1R5cGUgPT09IF9udW0gfHwgdG9rVHlwZSA9PT0gX3N0cmluZykgPyBwYXJzZUV4cHJBdG9tKCkgOiBwYXJzZUlkZW50KHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RUeXBlSW5kZXhlcihub2RlLCBpc1N0YXRpYykge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG5cbiAgICBleHBlY3QoX2JyYWNrZXRMKTtcbiAgICBub2RlLmlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdChfY29sb24pO1xuICAgIG5vZGUua2V5ID0gcGFyc2VUeXBlKCk7XG4gICAgZXhwZWN0KF9icmFja2V0Uik7XG4gICAgZXhwZWN0KF9jb2xvbik7XG4gICAgbm9kZS52YWx1ZSA9IHBhcnNlVHlwZSgpO1xuXG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW5kZXhlclwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaChub2RlKSB7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuXG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cblxuICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICB3aGlsZSAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2gocGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKTtcbiAgICAgIGlmICh0b2tUeXBlICE9PSBfcGFyZW5SKSB7XG4gICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlYXQoX2VsbGlwc2lzKSkge1xuICAgICAgbm9kZS5yZXN0ID0gcGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpO1xuICAgIH1cbiAgICBleHBlY3QoX3BhcmVuUik7XG4gICAgZXhwZWN0KF9jb2xvbik7XG4gICAgbm9kZS5yZXR1cm5UeXBlID0gcGFyc2VUeXBlKCk7XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVNZXRob2Qoc3RhcnQsIGlzU3RhdGljLCBrZXkpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICBub2RlLnZhbHVlID0gcGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHN0YXJ0Tm9kZUF0KHN0YXJ0KSk7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLmtleSA9IGtleTtcbiAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgdmFsdWVOb2RlID0gc3RhcnROb2RlKCk7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLnZhbHVlID0gcGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RUeXBlKGFsbG93U3RhdGljKSB7XG4gICAgdmFyIG5vZGVTdGFydCA9IHN0YXJ0Tm9kZSgpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBvcHRpb25hbCA9IGZhbHNlO1xuICAgIHZhciBwcm9wZXJ0eTtcbiAgICB2YXIgcHJvcGVydHlLZXk7XG4gICAgdmFyIHByb3BlcnR5VHlwZUFubm90YXRpb247XG4gICAgdmFyIHRva2VuO1xuICAgIHZhciBpc1N0YXRpYztcblxuICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcyA9IFtdO1xuICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG5cbiAgICBleHBlY3QoX2JyYWNlTCk7XG5cbiAgICB3aGlsZSAodG9rVHlwZSAhPT0gX2JyYWNlUikge1xuICAgICAgdmFyIHN0YXJ0ID0gc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICBpZiAoYWxsb3dTdGF0aWMgJiYgaXNDb250ZXh0dWFsKFwic3RhdGljXCIpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rVHlwZSA9PT0gX2JyYWNrZXRMKSB7XG4gICAgICAgIG5vZGVTdGFydC5pbmRleGVycy5wdXNoKHBhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMpKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rVHlwZSA9PT0gX3BhcmVuTCB8fCBpc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcy5wdXNoKHBhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBhbGxvd1N0YXRpYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RhdGljICYmIHRva1R5cGUgPT09IF9jb2xvbikge1xuICAgICAgICAgIHByb3BlcnR5S2V5ID0gcGFyc2VJZGVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnR5S2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlbGF0aW9uYWwoXCI8XCIpIHx8IHRva1R5cGUgPT09IF9wYXJlbkwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHByb3BlcnR5XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaChwYXJzZU9iamVjdFR5cGVNZXRob2Qoc3RhcnQsIGlzU3RhdGljLCBwcm9wZXJ0eUtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlYXQoX3F1ZXN0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgICAgICBub2RlLmtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBwYXJzZVR5cGUoKTtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgICBub2RlU3RhcnQucHJvcGVydGllcy5wdXNoKGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZWF0KF9zZW1pKSAmJiB0b2tUeXBlICE9PSBfYnJhY2VSKSB7XG4gICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBlY3QoX2JyYWNlUik7XG5cbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlU3RhcnQsIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlR2VuZXJpY1R5cGUoc3RhcnQsIGlkKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVBdChzdGFydCk7XG5cbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICBub2RlLmlkID0gaWQ7XG5cbiAgICB3aGlsZSAoZWF0KF9kb3QpKSB7XG4gICAgICB2YXIgbm9kZTIgPSBzdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlMi5xdWFsaWZpY2F0aW9uID0gbm9kZS5pZDtcbiAgICAgIG5vZGUyLmlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgbm9kZS5pZCA9IGZpbmlzaE5vZGUobm9kZTIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVZvaWRUeXBlKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgZXhwZWN0KGtleXdvcmRUeXBlc1tcInZvaWRcIl0pO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlb2ZUeXBlKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgZXhwZWN0KGtleXdvcmRUeXBlc1tcInR5cGVvZlwiXSk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHBhcnNlUHJpbWFyeVR5cGUoKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUdXBsZVR5cGUoKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVzID0gW107XG4gICAgZXhwZWN0KF9icmFja2V0TCk7XG4gICAgLy8gV2UgYWxsb3cgdHJhaWxpbmcgY29tbWFzXG4gICAgd2hpbGUgKHRva1BvcyA8IGlucHV0TGVuICYmIHRva1R5cGUgIT09IF9icmFja2V0Uikge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHBhcnNlVHlwZSgpKTtcbiAgICAgIGlmICh0b2tUeXBlID09PSBfYnJhY2tldFIpIGJyZWFrO1xuICAgICAgZXhwZWN0KF9jb21tYSk7XG4gICAgfVxuICAgIGV4cGVjdChfYnJhY2tldFIpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKSB7XG4gICAgdmFyIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBub2RlLm5hbWUgPSBwYXJzZUlkZW50KCk7XG4gICAgaWYgKGVhdChfcXVlc3Rpb24pKSB7XG4gICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGV4cGVjdChfY29sb24pO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlKCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVQYXJhbVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCkge1xuICAgIHZhciByZXQgPSB7IHBhcmFtczogW10sIHJlc3Q6IG51bGwgfTtcbiAgICB3aGlsZSAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgIHJldC5wYXJhbXMucHVzaChwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCkpO1xuICAgICAgaWYgKHRva1R5cGUgIT09IF9wYXJlblIpIHtcbiAgICAgICAgZXhwZWN0KF9jb21tYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVhdChfZWxsaXBzaXMpKSB7XG4gICAgICByZXQucmVzdCA9IHBhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydCwgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgJ2FueSc6XG4gICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQW55VHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gcGFyc2VHZW5lcmljVHlwZShzdGFydCwgaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBwYXJzaW5nIG9mIHR5cGVzIHJvdWdobHkgcGFyYWxsZWxzIHRoZSBwYXJzaW5nIG9mIGV4cHJlc3Npb25zLCBhbmRcbiAgLy8gcHJpbWFyeSB0eXBlcyBhcmUga2luZCBvZiBsaWtlIHByaW1hcnkgZXhwcmVzc2lvbnMuLi50aGV5J3JlIHRoZVxuICAvLyBwcmltaXRpdmVzIHdpdGggd2hpY2ggb3RoZXIgdHlwZXMgYXJlIGNvbnN0cnVjdGVkLlxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlUeXBlKCkge1xuICAgIHZhciB0eXBlSWRlbnRpZmllciA9IG51bGw7XG4gICAgdmFyIHBhcmFtcyA9IG51bGw7XG4gICAgdmFyIHJldHVyblR5cGUgPSBudWxsO1xuICAgIHZhciBzdGFydCA9IHN0b3JlQ3VycmVudFBvcygpO1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgdmFyIHJlc3QgPSBudWxsO1xuICAgIHZhciB0bXA7XG4gICAgdmFyIHR5cGVQYXJhbWV0ZXJzO1xuICAgIHZhciB0b2tlbjtcbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgaXNHcm91cGVkVHlwZSA9IGZhbHNlO1xuXG4gICAgc3dpdGNoICh0b2tUeXBlKSB7XG4gICAgICBjYXNlIF9uYW1lOlxuICAgICAgICByZXR1cm4gaWRlbnRUb1R5cGVBbm5vdGF0aW9uKHN0YXJ0LCBub2RlLCBwYXJzZUlkZW50KCkpO1xuXG4gICAgICBjYXNlIF9icmFjZUw6XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdFR5cGUoKTtcblxuICAgICAgY2FzZSBfYnJhY2tldEw6XG4gICAgICAgIHJldHVybiBwYXJzZVR1cGxlVHlwZSgpO1xuXG4gICAgICBjYXNlIF9yZWxhdGlvbmFsOlxuICAgICAgICBpZiAodG9rVmFsID09PSBcIjxcIikge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBwYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgICAgICB0bXAgPSBwYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBleHBlY3QoX3BhcmVuUik7XG5cbiAgICAgICAgICBleHBlY3QoX2Fycm93KTtcblxuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHBhcnNlVHlwZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX3BhcmVuTDpcbiAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgIHZhciB0bXBJZDtcblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhY3R1YWxseSBhIGdyb3VwZWQgdHlwZVxuICAgICAgICBpZiAodG9rVHlwZSAhPT0gX3BhcmVuUiAmJiB0b2tUeXBlICE9PSBfZWxsaXBzaXMpIHtcbiAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gX25hbWUpIHtcbiAgICAgICAgICAgIC8vcmFpc2UodG9rU3RhcnQsIFwiR3JvdXBlZCB0eXBlcyBhcmUgY3VycmVudGx5IHRoZSBvbmx5IGZsb3cgZmVhdHVyZSBub3Qgc3VwcG9ydGVkLCByZXF1ZXN0IGl0P1wiKTtcbiAgICAgICAgICAgIC8vdG1wSWQgPSBpZGVudFRvVHlwZUFubm90YXRpb24oc3RhcnQsIG5vZGUsIHBhcnNlSWRlbnQoKSk7XG4gICAgICAgICAgICAvL25leHQoKTtcbiAgICAgICAgICAgIC8vaXNHcm91cGVkVHlwZSA9IHRva1R5cGUgIT09IF9xdWVzdGlvbiAmJiB0b2tUeXBlICE9PSBfY29sb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzR3JvdXBlZFR5cGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0dyb3VwZWRUeXBlKSB7XG4gICAgICAgICAgaWYgKHRtcElkICYmIF9wYXJlblIpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0bXBJZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IHBhcnNlVHlwZSgpO1xuICAgICAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIHNlZSBhID0+IG5leHQgdGhlbiBzb21lb25lIHdhcyBwcm9iYWJseSBjb25mdXNlZCBhYm91dFxuICAgICAgICAgIC8vIGZ1bmN0aW9uIHR5cGVzLCBzbyB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgaWYgKGVhdChfYXJyb3cpKSB7XG4gICAgICAgICAgICByYWlzZShub2RlLFxuICAgICAgICAgICAgICAnVW5leHBlY3RlZCB0b2tlbiA9Pi4gSXQgbG9va3MgbGlrZSAnICtcbiAgICAgICAgICAgICAgJ3lvdSBhcmUgdHJ5aW5nIHRvIHdyaXRlIGEgZnVuY3Rpb24gdHlwZSwgYnV0IHlvdSBlbmRlZCB1cCAnICtcbiAgICAgICAgICAgICAgJ3dyaXRpbmcgYSBncm91cGVkIHR5cGUgZm9sbG93ZWQgYnkgYW4gPT4sIHdoaWNoIGlzIGEgc3ludGF4ICcgK1xuICAgICAgICAgICAgICAnZXJyb3IuIFJlbWVtYmVyLCBmdW5jdGlvbiB0eXBlIHBhcmFtZXRlcnMgYXJlIG5hbWVkIHNvIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgICAndHlwZXMgbG9vayBsaWtlIChuYW1lMTogdHlwZTEsIG5hbWUyOiB0eXBlMikgPT4gcmV0dXJuVHlwZS4gWW91ICcgK1xuICAgICAgICAgICAgICAncHJvYmFibHkgd3JvdGUgKHR5cGUxKSA9PiByZXR1cm5UeXBlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgbm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG5cbiAgICAgICAgZXhwZWN0KF9wYXJlblIpO1xuXG4gICAgICAgIGV4cGVjdChfYXJyb3cpO1xuXG4gICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHBhcnNlVHlwZSgpO1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgX3N0cmluZzpcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRva1ZhbDtcbiAgICAgICAgbm9kZS5yYXcgPSBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRva1R5cGUua2V5d29yZCkge1xuICAgICAgICAgIHN3aXRjaCAodG9rVHlwZS5rZXl3b3JkKSB7XG4gICAgICAgICAgICBjYXNlICd2b2lkJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVm9pZFR5cGUoKTtcblxuICAgICAgICAgICAgY2FzZSAndHlwZW9mJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZW9mVHlwZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeFR5cGUoKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICB2YXIgdHlwZSA9IG5vZGUuZWxlbWVudFR5cGUgPSBwYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgaWYgKHRva1R5cGUgPT09IF9icmFja2V0TCkge1xuICAgICAgZXhwZWN0KF9icmFja2V0TCk7XG4gICAgICBleHBlY3QoX2JyYWNrZXRSKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByZWZpeFR5cGUoKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBpZiAoZWF0KF9xdWVzdGlvbikpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBwYXJzZVByZWZpeFR5cGUoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlUG9zdGZpeFR5cGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSW50ZXJzZWN0aW9uVHlwZSgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIHZhciB0eXBlID0gcGFyc2VQcmVmaXhUeXBlKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgICB3aGlsZSAoZWF0KF9iaXR3aXNlQU5EKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHBhcnNlUHJlZml4VHlwZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IGZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVW5pb25UeXBlKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgdmFyIHR5cGUgPSBwYXJzZUludGVyc2VjdGlvblR5cGUoKTtcbiAgICBub2RlLnR5cGVzID0gW3R5cGVdO1xuICAgIHdoaWxlIChlYXQoX2JpdHdpc2VPUikpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaChwYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGVzLmxlbmd0aCA9PT0gMSA/IHR5cGUgOiBmaW5pc2hOb2RlKG5vZGUsIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZSgpIHtcbiAgICB2YXIgb2xkSW5UeXBlID0gaW5UeXBlO1xuICAgIGluVHlwZSA9IHRydWU7XG4gICAgdmFyIHR5cGUgPSBwYXJzZVVuaW9uVHlwZSgpO1xuICAgIGluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblxuICAgIHZhciBvbGRJblR5cGUgPSBpblR5cGU7XG4gICAgaW5UeXBlID0gdHJ1ZTtcbiAgICBleHBlY3QoX2NvbG9uKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gcGFyc2VUeXBlKCk7XG4gICAgaW5UeXBlID0gb2xkSW5UeXBlO1xuXG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcihyZXF1aXJlVHlwZUFubm90YXRpb24sIGNhbkJlT3B0aW9uYWxQYXJhbSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgdmFyIGlkZW50ID0gcGFyc2VJZGVudCgpO1xuICAgIHZhciBpc09wdGlvbmFsUGFyYW0gPSBmYWxzZTtcblxuICAgIGlmIChjYW5CZU9wdGlvbmFsUGFyYW0gJiYgZWF0KF9xdWVzdGlvbikpIHtcbiAgICAgIGV4cGVjdChfcXVlc3Rpb24pO1xuICAgICAgaXNPcHRpb25hbFBhcmFtID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZVR5cGVBbm5vdGF0aW9uIHx8IHRva1R5cGUgPT09IF9jb2xvbikge1xuICAgICAgaWRlbnQudHlwZUFubm90YXRpb24gPSBwYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICBmaW5pc2hOb2RlKGlkZW50LCBpZGVudC50eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPcHRpb25hbFBhcmFtKSB7XG4gICAgICBpZGVudC5vcHRpb25hbCA9IHRydWU7XG4gICAgICBmaW5pc2hOb2RlKGlkZW50LCBpZGVudC50eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnQ7XG4gIH1cbn0pO1xuIiwidmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL2xpYi90eXBlc1wiKTtcbnZhciBUeXBlID0gdHlwZXMuVHlwZTtcbnZhciBkZWYgPSBUeXBlLmRlZjtcbnZhciBvciA9IFR5cGUub3I7XG52YXIgYnVpbHRpbiA9IHR5cGVzLmJ1aWx0SW5UeXBlcztcbnZhciBpc1N0cmluZyA9IGJ1aWx0aW4uc3RyaW5nO1xudmFyIGlzTnVtYmVyID0gYnVpbHRpbi5udW1iZXI7XG52YXIgaXNCb29sZWFuID0gYnVpbHRpbi5ib29sZWFuO1xudmFyIGlzUmVnRXhwID0gYnVpbHRpbi5SZWdFeHA7XG52YXIgc2hhcmVkID0gcmVxdWlyZShcIi4uL2xpYi9zaGFyZWRcIik7XG52YXIgZGVmYXVsdHMgPSBzaGFyZWQuZGVmYXVsdHM7XG52YXIgZ2VxID0gc2hhcmVkLmdlcTtcblxuLy8gQWJzdHJhY3Qgc3VwZXJ0eXBlIG9mIGFsbCBzeW50YWN0aWMgZW50aXRpZXMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIGFcbi8vIC5sb2MgZmllbGQuXG5kZWYoXCJQcmludGFibGVcIilcbiAgICAuZmllbGQoXCJsb2NcIiwgb3IoXG4gICAgICAgIGRlZihcIlNvdXJjZUxvY2F0aW9uXCIpLFxuICAgICAgICBudWxsXG4gICAgKSwgZGVmYXVsdHNbXCJudWxsXCJdLCB0cnVlKTtcblxuZGVmKFwiTm9kZVwiKVxuICAgIC5iYXNlcyhcIlByaW50YWJsZVwiKVxuICAgIC5maWVsZChcInR5cGVcIiwgaXNTdHJpbmcpXG4gICAgLmZpZWxkKFwiY29tbWVudHNcIiwgb3IoXG4gICAgICAgIFtkZWYoXCJDb21tZW50XCIpXSxcbiAgICAgICAgbnVsbFxuICAgICksIGRlZmF1bHRzW1wibnVsbFwiXSwgdHJ1ZSk7XG5cbmRlZihcIlNvdXJjZUxvY2F0aW9uXCIpXG4gICAgLmJ1aWxkKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJzb3VyY2VcIilcbiAgICAuZmllbGQoXCJzdGFydFwiLCBkZWYoXCJQb3NpdGlvblwiKSlcbiAgICAuZmllbGQoXCJlbmRcIiwgZGVmKFwiUG9zaXRpb25cIikpXG4gICAgLmZpZWxkKFwic291cmNlXCIsIG9yKGlzU3RyaW5nLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcblxuZGVmKFwiUG9zaXRpb25cIilcbiAgICAuYnVpbGQoXCJsaW5lXCIsIFwiY29sdW1uXCIpXG4gICAgLmZpZWxkKFwibGluZVwiLCBnZXEoMSkpXG4gICAgLmZpZWxkKFwiY29sdW1uXCIsIGdlcSgwKSk7XG5cbmRlZihcIlByb2dyYW1cIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwiYm9keVwiKVxuICAgIC5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xuXG5kZWYoXCJGdW5jdGlvblwiKVxuICAgIC5iYXNlcyhcIk5vZGVcIilcbiAgICAuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKVxuICAgIC5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiUGF0dGVyblwiKV0pXG4gICAgLmZpZWxkKFwiYm9keVwiLCBvcihkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSwgZGVmKFwiRXhwcmVzc2lvblwiKSkpO1xuXG5kZWYoXCJTdGF0ZW1lbnRcIikuYmFzZXMoXCJOb2RlXCIpO1xuXG4vLyBUaGUgZW1wdHkgLmJ1aWxkKCkgaGVyZSBtZWFucyB0aGF0IGFuIEVtcHR5U3RhdGVtZW50IGNhbiBiZSBjb25zdHJ1Y3RlZFxuLy8gKGkuZS4gaXQncyBub3QgYWJzdHJhY3QpIGJ1dCB0aGF0IGl0IG5lZWRzIG5vIGFyZ3VtZW50cy5cbmRlZihcIkVtcHR5U3RhdGVtZW50XCIpLmJhc2VzKFwiU3RhdGVtZW50XCIpLmJ1aWxkKCk7XG5cbmRlZihcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiYm9keVwiKVxuICAgIC5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xuXG4vLyBUT0RPIEZpZ3VyZSBvdXQgaG93IHRvIHNpbGVudGx5IGNvZXJjZSBFeHByZXNzaW9ucyB0b1xuLy8gRXhwcmVzc2lvblN0YXRlbWVudHMgd2hlcmUgYSBTdGF0ZW1lbnQgd2FzIGV4cGVjdGVkLlxuZGVmKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxuICAgIC5iYXNlcyhcIlN0YXRlbWVudFwiKVxuICAgIC5idWlsZChcImV4cHJlc3Npb25cIilcbiAgICAuZmllbGQoXCJleHByZXNzaW9uXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuXG5kZWYoXCJJZlN0YXRlbWVudFwiKVxuICAgIC5iYXNlcyhcIlN0YXRlbWVudFwiKVxuICAgIC5idWlsZChcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCIpXG4gICAgLmZpZWxkKFwidGVzdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcImNvbnNlcXVlbnRcIiwgZGVmKFwiU3RhdGVtZW50XCIpKVxuICAgIC5maWVsZChcImFsdGVybmF0ZVwiLCBvcihkZWYoXCJTdGF0ZW1lbnRcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwibGFiZWxcIiwgXCJib2R5XCIpXG4gICAgLmZpZWxkKFwibGFiZWxcIiwgZGVmKFwiSWRlbnRpZmllclwiKSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIlN0YXRlbWVudFwiKSk7XG5cbmRlZihcIkJyZWFrU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwibGFiZWxcIilcbiAgICAuZmllbGQoXCJsYWJlbFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcblxuZGVmKFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgICAuYmFzZXMoXCJTdGF0ZW1lbnRcIilcbiAgICAuYnVpbGQoXCJsYWJlbFwiKVxuICAgIC5maWVsZChcImxhYmVsXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJXaXRoU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwib2JqZWN0XCIsIFwiYm9keVwiKVxuICAgIC5maWVsZChcIm9iamVjdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcblxuZGVmKFwiU3dpdGNoU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiZGlzY3JpbWluYW50XCIsIFwiY2FzZXNcIiwgXCJsZXhpY2FsXCIpXG4gICAgLmZpZWxkKFwiZGlzY3JpbWluYW50XCIsIGRlZihcIkV4cHJlc3Npb25cIikpXG4gICAgLmZpZWxkKFwiY2FzZXNcIiwgW2RlZihcIlN3aXRjaENhc2VcIildKVxuICAgIC5maWVsZChcImxleGljYWxcIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcblxuZGVmKFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIilcbiAgICAuZmllbGQoXCJhcmd1bWVudFwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSk7XG5cbmRlZihcIlRocm93U3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIilcbiAgICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxuZGVmKFwiVHJ5U3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiYmxvY2tcIiwgXCJoYW5kbGVyXCIsIFwiZmluYWxpemVyXCIpXG4gICAgLmZpZWxkKFwiYmxvY2tcIiwgZGVmKFwiQmxvY2tTdGF0ZW1lbnRcIikpXG4gICAgLmZpZWxkKFwiaGFuZGxlclwiLCBvcihkZWYoXCJDYXRjaENsYXVzZVwiKSwgbnVsbCksIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycyAmJiB0aGlzLmhhbmRsZXJzWzBdIHx8IG51bGw7XG4gICAgfSlcbiAgICAuZmllbGQoXCJoYW5kbGVyc1wiLCBbZGVmKFwiQ2F0Y2hDbGF1c2VcIildLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlciA/IFt0aGlzLmhhbmRsZXJdIDogW107XG4gICAgfSwgdHJ1ZSkgLy8gSW5kaWNhdGVzIHRoaXMgZmllbGQgaXMgaGlkZGVuIGZyb20gZWFjaEZpZWxkIGl0ZXJhdGlvbi5cbiAgICAuZmllbGQoXCJndWFyZGVkSGFuZGxlcnNcIiwgW2RlZihcIkNhdGNoQ2xhdXNlXCIpXSwgZGVmYXVsdHMuZW1wdHlBcnJheSlcbiAgICAuZmllbGQoXCJmaW5hbGl6ZXJcIiwgb3IoZGVmKFwiQmxvY2tTdGF0ZW1lbnRcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJDYXRjaENsYXVzZVwiKVxuICAgIC5iYXNlcyhcIk5vZGVcIilcbiAgICAuYnVpbGQoXCJwYXJhbVwiLCBcImd1YXJkXCIsIFwiYm9keVwiKVxuICAgIC5maWVsZChcInBhcmFtXCIsIGRlZihcIlBhdHRlcm5cIikpXG4gICAgLmZpZWxkKFwiZ3VhcmRcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIkJsb2NrU3RhdGVtZW50XCIpKTtcblxuZGVmKFwiV2hpbGVTdGF0ZW1lbnRcIilcbiAgICAuYmFzZXMoXCJTdGF0ZW1lbnRcIilcbiAgICAuYnVpbGQoXCJ0ZXN0XCIsIFwiYm9keVwiKVxuICAgIC5maWVsZChcInRlc3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIlN0YXRlbWVudFwiKSk7XG5cbmRlZihcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbiAgICAuYmFzZXMoXCJTdGF0ZW1lbnRcIilcbiAgICAuYnVpbGQoXCJib2R5XCIsIFwidGVzdFwiKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKVxuICAgIC5maWVsZChcInRlc3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbmRlZihcIkZvclN0YXRlbWVudFwiKVxuICAgIC5iYXNlcyhcIlN0YXRlbWVudFwiKVxuICAgIC5idWlsZChcImluaXRcIiwgXCJ0ZXN0XCIsIFwidXBkYXRlXCIsIFwiYm9keVwiKVxuICAgIC5maWVsZChcImluaXRcIiwgb3IoXG4gICAgICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksXG4gICAgICAgIGRlZihcIkV4cHJlc3Npb25cIiksXG4gICAgICAgIG51bGwpKVxuICAgIC5maWVsZChcInRlc3RcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCkpXG4gICAgLmZpZWxkKFwidXBkYXRlXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcblxuZGVmKFwiRm9ySW5TdGF0ZW1lbnRcIilcbiAgICAuYmFzZXMoXCJTdGF0ZW1lbnRcIilcbiAgICAuYnVpbGQoXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCIsIFwiZWFjaFwiKVxuICAgIC5maWVsZChcImxlZnRcIiwgb3IoXG4gICAgICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksXG4gICAgICAgIGRlZihcIkV4cHJlc3Npb25cIikpKVxuICAgIC5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpXG4gICAgLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJTdGF0ZW1lbnRcIikpXG4gICAgLmZpZWxkKFwiZWFjaFwiLCBpc0Jvb2xlYW4pO1xuXG5kZWYoXCJEZWJ1Z2dlclN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZCgpO1xuXG5kZWYoXCJEZWNsYXJhdGlvblwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKTtcblxuZGVmKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiKVxuICAgIC5iYXNlcyhcIkZ1bmN0aW9uXCIsIFwiRGVjbGFyYXRpb25cIilcbiAgICAuYnVpbGQoXCJpZFwiLCBcInBhcmFtc1wiLCBcImJvZHlcIilcbiAgICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcblxuZGVmKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRnVuY3Rpb25cIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIpO1xuXG5kZWYoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgLmJhc2VzKFwiRGVjbGFyYXRpb25cIilcbiAgICAuYnVpbGQoXCJraW5kXCIsIFwiZGVjbGFyYXRpb25zXCIpXG4gICAgLmZpZWxkKFwia2luZFwiLCBvcihcInZhclwiLCBcImxldFwiLCBcImNvbnN0XCIpKVxuICAgIC5maWVsZChcImRlY2xhcmF0aW9uc1wiLCBbb3IoXG4gICAgICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSxcbiAgICAgICAgZGVmKFwiSWRlbnRpZmllclwiKSAvLyBUT0RPIEVzcHJpbWEgZGV2aWF0aW9uLlxuICAgICldKTtcblxuZGVmKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcImlkXCIsIFwiaW5pdFwiKVxuICAgIC5maWVsZChcImlkXCIsIGRlZihcIlBhdHRlcm5cIikpXG4gICAgLmZpZWxkKFwiaW5pdFwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSk7XG5cbi8vIFRPRE8gQXJlIGFsbCBFeHByZXNzaW9ucyByZWFsbHkgUGF0dGVybnM/XG5kZWYoXCJFeHByZXNzaW9uXCIpLmJhc2VzKFwiTm9kZVwiLCBcIlBhdHRlcm5cIik7XG5cbmRlZihcIlRoaXNFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZCgpO1xuXG5kZWYoXCJBcnJheUV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiZWxlbWVudHNcIilcbiAgICAuZmllbGQoXCJlbGVtZW50c1wiLCBbb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCldKTtcblxuZGVmKFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJwcm9wZXJ0aWVzXCIpXG4gICAgLmZpZWxkKFwicHJvcGVydGllc1wiLCBbZGVmKFwiUHJvcGVydHlcIildKTtcblxuLy8gVE9ETyBOb3QgaW4gdGhlIE1vemlsbGEgUGFyc2VyIEFQSSwgYnV0IHVzZWQgYnkgRXNwcmltYS5cbmRlZihcIlByb3BlcnR5XCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKSAvLyBXYW50IHRvIGJlIGFibGUgdG8gdmlzaXQgUHJvcGVydHkgTm9kZXMuXG4gICAgLmJ1aWxkKFwia2luZFwiLCBcImtleVwiLCBcInZhbHVlXCIpXG4gICAgLmZpZWxkKFwia2luZFwiLCBvcihcImluaXRcIiwgXCJnZXRcIiwgXCJzZXRcIikpXG4gICAgLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIikpKVxuICAgIC8vIGVzcHJpbWEgYWxsb3dzIFBhdHRlcm5cbiAgICAuZmllbGQoXCJ2YWx1ZVwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBkZWYoXCJQYXR0ZXJuXCIpKSk7XG5cbmRlZihcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJleHByZXNzaW9uc1wiKVxuICAgIC5maWVsZChcImV4cHJlc3Npb25zXCIsIFtkZWYoXCJFeHByZXNzaW9uXCIpXSk7XG5cbnZhciBVbmFyeU9wZXJhdG9yID0gb3IoXG4gICAgXCItXCIsIFwiK1wiLCBcIiFcIiwgXCJ+XCIsXG4gICAgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCIpO1xuXG5kZWYoXCJVbmFyeUV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiKVxuICAgIC5maWVsZChcIm9wZXJhdG9yXCIsIFVuYXJ5T3BlcmF0b3IpXG4gICAgLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAvLyBUT0RPIEVzcHJpbWEgZG9lc24ndCBib3RoZXIgd2l0aCB0aGlzIGZpZWxkLCBwcmVzdW1hYmx5IGJlY2F1c2VcbiAgICAvLyBpdCdzIGFsd2F5cyB0cnVlIGZvciB1bmFyeSBvcGVyYXRvcnMuXG4gICAgLmZpZWxkKFwicHJlZml4XCIsIGlzQm9vbGVhbiwgZGVmYXVsdHNbXCJ0cnVlXCJdKTtcblxudmFyIEJpbmFyeU9wZXJhdG9yID0gb3IoXG4gICAgXCI9PVwiLCBcIiE9XCIsIFwiPT09XCIsIFwiIT09XCIsXG4gICAgXCI8XCIsIFwiPD1cIiwgXCI+XCIsIFwiPj1cIixcbiAgICBcIjw8XCIsIFwiPj5cIiwgXCI+Pj5cIixcbiAgICBcIitcIiwgXCItXCIsIFwiKlwiLCBcIi9cIiwgXCIlXCIsXG4gICAgXCImXCIsIC8vIFRPRE8gTWlzc2luZyBmcm9tIHRoZSBQYXJzZXIgQVBJLlxuICAgIFwifFwiLCBcIl5cIiwgXCJpblwiLFxuICAgIFwiaW5zdGFuY2VvZlwiLCBcIi4uXCIpO1xuXG5kZWYoXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5idWlsZChcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIpXG4gICAgLmZpZWxkKFwib3BlcmF0b3JcIiwgQmluYXJ5T3BlcmF0b3IpXG4gICAgLmZpZWxkKFwibGVmdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuXG52YXIgQXNzaWdubWVudE9wZXJhdG9yID0gb3IoXG4gICAgXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIio9XCIsIFwiLz1cIiwgXCIlPVwiLFxuICAgIFwiPDw9XCIsIFwiPj49XCIsIFwiPj4+PVwiLFxuICAgIFwifD1cIiwgXCJePVwiLCBcIiY9XCIpO1xuXG5kZWYoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiKVxuICAgIC5maWVsZChcIm9wZXJhdG9yXCIsIEFzc2lnbm1lbnRPcGVyYXRvcilcbiAgICAuZmllbGQoXCJsZWZ0XCIsIGRlZihcIlBhdHRlcm5cIikpXG4gICAgLmZpZWxkKFwicmlnaHRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbnZhciBVcGRhdGVPcGVyYXRvciA9IG9yKFwiKytcIiwgXCItLVwiKTtcblxuZGVmKFwiVXBkYXRlRXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJvcGVyYXRvclwiLCBcImFyZ3VtZW50XCIsIFwicHJlZml4XCIpXG4gICAgLmZpZWxkKFwib3BlcmF0b3JcIiwgVXBkYXRlT3BlcmF0b3IpXG4gICAgLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJwcmVmaXhcIiwgaXNCb29sZWFuKTtcblxudmFyIExvZ2ljYWxPcGVyYXRvciA9IG9yKFwifHxcIiwgXCImJlwiKTtcblxuZGVmKFwiTG9naWNhbEV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIilcbiAgICAuZmllbGQoXCJvcGVyYXRvclwiLCBMb2dpY2FsT3BlcmF0b3IpXG4gICAgLmZpZWxkKFwibGVmdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuXG5kZWYoXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwidGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIilcbiAgICAuZmllbGQoXCJ0ZXN0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpXG4gICAgLmZpZWxkKFwiY29uc2VxdWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcImFsdGVybmF0ZVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxuZGVmKFwiTmV3RXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIilcbiAgICAuZmllbGQoXCJjYWxsZWVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAvLyBUaGUgTW96aWxsYSBQYXJzZXIgQVBJIGdpdmVzIHRoaXMgdHlwZSBhcyBbb3IoZGVmKFwiRXhwcmVzc2lvblwiKSxcbiAgICAvLyBudWxsKV0sIGJ1dCBudWxsIHZhbHVlcyBkb24ndCByZWFsbHkgbWFrZSBzZW5zZSBhdCB0aGUgY2FsbCBzaXRlLlxuICAgIC8vIFRPRE8gUmVwb3J0IHRoaXMgbm9uc2Vuc2UuXG4gICAgLmZpZWxkKFwiYXJndW1lbnRzXCIsIFtkZWYoXCJFeHByZXNzaW9uXCIpXSk7XG5cbmRlZihcIkNhbGxFeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5idWlsZChcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiKVxuICAgIC5maWVsZChcImNhbGxlZVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC8vIFNlZSBjb21tZW50IGZvciBOZXdFeHByZXNzaW9uIGFib3ZlLlxuICAgIC5maWVsZChcImFyZ3VtZW50c1wiLCBbZGVmKFwiRXhwcmVzc2lvblwiKV0pO1xuXG5kZWYoXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5idWlsZChcIm9iamVjdFwiLCBcInByb3BlcnR5XCIsIFwiY29tcHV0ZWRcIilcbiAgICAuZmllbGQoXCJvYmplY3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJwcm9wZXJ0eVwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSlcbiAgICAuZmllbGQoXCJjb21wdXRlZFwiLCBpc0Jvb2xlYW4pO1xuXG5kZWYoXCJQYXR0ZXJuXCIpLmJhc2VzKFwiTm9kZVwiKTtcblxuZGVmKFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIC5iYXNlcyhcIlBhdHRlcm5cIilcbiAgICAuYnVpbGQoXCJwcm9wZXJ0aWVzXCIpXG4gICAgLy8gVE9ETyBGaWxlIGEgYnVnIHRvIGdldCBQcm9wZXJ0eVBhdHRlcm4gYWRkZWQgdG8gdGhlIGludGVyZmFjZXMgQVBJLlxuICAgIC8vIGVzcHJpbWEgdXNlcyBQcm9wZXJ0eVxuICAgIC5maWVsZChcInByb3BlcnRpZXNcIiwgW29yKGRlZihcIlByb3BlcnR5UGF0dGVyblwiKSwgZGVmKFwiUHJvcGVydHlcIikpXSk7XG5cbmRlZihcIlByb3BlcnR5UGF0dGVyblwiKVxuICAgIC5iYXNlcyhcIlBhdHRlcm5cIilcbiAgICAuYnVpbGQoXCJrZXlcIiwgXCJwYXR0ZXJuXCIpXG4gICAgLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIikpKVxuICAgIC5maWVsZChcInBhdHRlcm5cIiwgZGVmKFwiUGF0dGVyblwiKSk7XG5cbmRlZihcIkFycmF5UGF0dGVyblwiKVxuICAgIC5iYXNlcyhcIlBhdHRlcm5cIilcbiAgICAuYnVpbGQoXCJlbGVtZW50c1wiKVxuICAgIC5maWVsZChcImVsZW1lbnRzXCIsIFtvcihkZWYoXCJQYXR0ZXJuXCIpLCBudWxsKV0pO1xuXG5kZWYoXCJTd2l0Y2hDYXNlXCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIpXG4gICAgLmZpZWxkKFwidGVzdFwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSlcbiAgICAuZmllbGQoXCJjb25zZXF1ZW50XCIsIFtkZWYoXCJTdGF0ZW1lbnRcIildKTtcblxuZGVmKFwiSWRlbnRpZmllclwiKVxuICAgIC8vIEJ1dCBhcmVuJ3QgRXhwcmVzc2lvbnMgYW5kIFBhdHRlcm5zIGFscmVhZHkgTm9kZXM/IFRPRE8gUmVwb3J0IHRoaXMuXG4gICAgLmJhc2VzKFwiTm9kZVwiLCBcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuXCIpXG4gICAgLmJ1aWxkKFwibmFtZVwiKVxuICAgIC5maWVsZChcIm5hbWVcIiwgaXNTdHJpbmcpO1xuXG5kZWYoXCJMaXRlcmFsXCIpXG4gICAgLy8gQnV0IGFyZW4ndCBFeHByZXNzaW9ucyBhbHJlYWR5IE5vZGVzPyBUT0RPIFJlcG9ydCB0aGlzLlxuICAgIC5iYXNlcyhcIk5vZGVcIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwidmFsdWVcIilcbiAgICAuZmllbGQoXCJ2YWx1ZVwiLCBvcihcbiAgICAgICAgaXNTdHJpbmcsXG4gICAgICAgIGlzQm9vbGVhbixcbiAgICAgICAgbnVsbCwgLy8gaXNOdWxsIHdvdWxkIGFsc28gd29yayBoZXJlLlxuICAgICAgICBpc051bWJlcixcbiAgICAgICAgaXNSZWdFeHBcbiAgICApKTtcblxuLy8gQWJzdHJhY3QgKG5vbi1idWlsZGFibGUpIGNvbW1lbnQgc3VwZXJ0eXBlLiBOb3QgYSBOb2RlLlxuZGVmKFwiQ29tbWVudFwiKVxuICAgIC5iYXNlcyhcIlByaW50YWJsZVwiKVxuICAgIC5maWVsZChcInZhbHVlXCIsIGlzU3RyaW5nKVxuICAgIC8vIEEgLmxlYWRpbmcgY29tbWVudCBjb21lcyBiZWZvcmUgdGhlIG5vZGUsIHdoZXJlYXMgYSAudHJhaWxpbmdcbiAgICAvLyBjb21tZW50IGNvbWVzIGFmdGVyIGl0LiBUaGVzZSB0d28gZmllbGRzIHNob3VsZCBub3QgYm90aCBiZSB0cnVlLFxuICAgIC8vIGJ1dCB0aGV5IG1pZ2h0IGJvdGggYmUgZmFsc2Ugd2hlbiB0aGUgY29tbWVudCBmYWxscyBpbnNpZGUgYSBub2RlXG4gICAgLy8gYW5kIHRoZSBub2RlIGhhcyBubyBjaGlsZHJlbiBmb3IgdGhlIGNvbW1lbnQgdG8gbGVhZCBvciB0cmFpbCxcbiAgICAvLyBlLmcuIHsgLypkYW5nbGluZyovIH0uXG4gICAgLmZpZWxkKFwibGVhZGluZ1wiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzW1widHJ1ZVwiXSlcbiAgICAuZmllbGQoXCJ0cmFpbGluZ1wiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuXG4vLyBCbG9jayBjb21tZW50LiBUaGUgLnR5cGUgcmVhbGx5IHNob3VsZCBiZSBCbG9ja0NvbW1lbnQgcmF0aGVyIHRoYW5cbi8vIEJsb2NrLCBidXQgdGhhdCdzIHdoYXQgd2UncmUgc3R1Y2sgd2l0aCBmb3Igbm93LlxuZGVmKFwiQmxvY2tcIilcbiAgICAuYmFzZXMoXCJDb21tZW50XCIpXG4gICAgLmJ1aWxkKFwidmFsdWVcIiwgLypvcHRpb25hbDoqLyBcImxlYWRpbmdcIiwgXCJ0cmFpbGluZ1wiKTtcblxuLy8gU2luZ2xlIGxpbmUgY29tbWVudC4gVGhlIC50eXBlIHJlYWxseSBzaG91bGQgYmUgTGluZUNvbW1lbnQgcmF0aGVyIHRoYW5cbi8vIExpbmUsIGJ1dCB0aGF0J3Mgd2hhdCB3ZSdyZSBzdHVjayB3aXRoIGZvciBub3cuXG5kZWYoXCJMaW5lXCIpXG4gICAgLmJhc2VzKFwiQ29tbWVudFwiKVxuICAgIC5idWlsZChcInZhbHVlXCIsIC8qb3B0aW9uYWw6Ki8gXCJsZWFkaW5nXCIsIFwidHJhaWxpbmdcIik7XG4iLCJyZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL2xpYi90eXBlc1wiKTtcbnZhciBkZWYgPSB0eXBlcy5UeXBlLmRlZjtcbnZhciBvciA9IHR5cGVzLlR5cGUub3I7XG52YXIgYnVpbHRpbiA9IHR5cGVzLmJ1aWx0SW5UeXBlcztcbnZhciBpc1N0cmluZyA9IGJ1aWx0aW4uc3RyaW5nO1xudmFyIGlzQm9vbGVhbiA9IGJ1aWx0aW4uYm9vbGVhbjtcblxuLy8gTm90ZSB0aGF0IG5vbmUgb2YgdGhlc2UgdHlwZXMgYXJlIGJ1aWxkYWJsZSBiZWNhdXNlIHRoZSBNb3ppbGxhIFBhcnNlclxuLy8gQVBJIGRvZXNuJ3Qgc3BlY2lmeSBhbnkgYnVpbGRlciBmdW5jdGlvbnMsIGFuZCBub2JvZHkgdXNlcyBFNFggYW55bW9yZS5cblxuZGVmKFwiWE1MRGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gICAgLmJhc2VzKFwiRGVjbGFyYXRpb25cIilcbiAgICAuZmllbGQoXCJuYW1lc3BhY2VcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbmRlZihcIlhNTEFueU5hbWVcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpO1xuXG5kZWYoXCJYTUxRdWFsaWZpZWRJZGVudGlmaWVyXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImxlZnRcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiWE1MQW55TmFtZVwiKSkpXG4gICAgLmZpZWxkKFwicmlnaHRcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiRXhwcmVzc2lvblwiKSkpXG4gICAgLmZpZWxkKFwiY29tcHV0ZWRcIiwgaXNCb29sZWFuKTtcblxuZGVmKFwiWE1MRnVuY3Rpb25RdWFsaWZpZWRJZGVudGlmaWVyXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcInJpZ2h0XCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKVxuICAgIC5maWVsZChcImNvbXB1dGVkXCIsIGlzQm9vbGVhbik7XG5cbmRlZihcIlhNTEF0dHJpYnV0ZVNlbGVjdG9yXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImF0dHJpYnV0ZVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxuZGVmKFwiWE1MRmlsdGVyRXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuZmllbGQoXCJsZWZ0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpXG4gICAgLmZpZWxkKFwicmlnaHRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbmRlZihcIlhNTEVsZW1lbnRcIilcbiAgICAuYmFzZXMoXCJYTUxcIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgLmZpZWxkKFwiY29udGVudHNcIiwgW2RlZihcIlhNTFwiKV0pO1xuXG5kZWYoXCJYTUxMaXN0XCIpXG4gICAgLmJhc2VzKFwiWE1MXCIsIFwiRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImNvbnRlbnRzXCIsIFtkZWYoXCJYTUxcIildKTtcblxuZGVmKFwiWE1MXCIpLmJhc2VzKFwiTm9kZVwiKTtcblxuZGVmKFwiWE1MRXNjYXBlXCIpXG4gICAgLmJhc2VzKFwiWE1MXCIpXG4gICAgLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxuZGVmKFwiWE1MVGV4dFwiKVxuICAgIC5iYXNlcyhcIlhNTFwiKVxuICAgIC5maWVsZChcInRleHRcIiwgaXNTdHJpbmcpO1xuXG5kZWYoXCJYTUxTdGFydFRhZ1wiKVxuICAgIC5iYXNlcyhcIlhNTFwiKVxuICAgIC5maWVsZChcImNvbnRlbnRzXCIsIFtkZWYoXCJYTUxcIildKTtcblxuZGVmKFwiWE1MRW5kVGFnXCIpXG4gICAgLmJhc2VzKFwiWE1MXCIpXG4gICAgLmZpZWxkKFwiY29udGVudHNcIiwgW2RlZihcIlhNTFwiKV0pO1xuXG5kZWYoXCJYTUxQb2ludFRhZ1wiKVxuICAgIC5iYXNlcyhcIlhNTFwiKVxuICAgIC5maWVsZChcImNvbnRlbnRzXCIsIFtkZWYoXCJYTUxcIildKTtcblxuZGVmKFwiWE1MTmFtZVwiKVxuICAgIC5iYXNlcyhcIlhNTFwiKVxuICAgIC5maWVsZChcImNvbnRlbnRzXCIsIG9yKGlzU3RyaW5nLCBbZGVmKFwiWE1MXCIpXSkpO1xuXG5kZWYoXCJYTUxBdHRyaWJ1dGVcIilcbiAgICAuYmFzZXMoXCJYTUxcIilcbiAgICAuZmllbGQoXCJ2YWx1ZVwiLCBpc1N0cmluZyk7XG5cbmRlZihcIlhNTENkYXRhXCIpXG4gICAgLmJhc2VzKFwiWE1MXCIpXG4gICAgLmZpZWxkKFwiY29udGVudHNcIiwgaXNTdHJpbmcpO1xuXG5kZWYoXCJYTUxDb21tZW50XCIpXG4gICAgLmJhc2VzKFwiWE1MXCIpXG4gICAgLmZpZWxkKFwiY29udGVudHNcIiwgaXNTdHJpbmcpO1xuXG5kZWYoXCJYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIilcbiAgICAuYmFzZXMoXCJYTUxcIilcbiAgICAuZmllbGQoXCJ0YXJnZXRcIiwgaXNTdHJpbmcpXG4gICAgLmZpZWxkKFwiY29udGVudHNcIiwgb3IoaXNTdHJpbmcsIG51bGwpKTtcbiIsInJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi4vbGliL3R5cGVzXCIpO1xudmFyIGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xudmFyIG9yID0gdHlwZXMuVHlwZS5vcjtcbnZhciBidWlsdGluID0gdHlwZXMuYnVpbHRJblR5cGVzO1xudmFyIGlzQm9vbGVhbiA9IGJ1aWx0aW4uYm9vbGVhbjtcbnZhciBpc09iamVjdCA9IGJ1aWx0aW4ub2JqZWN0O1xudmFyIGlzU3RyaW5nID0gYnVpbHRpbi5zdHJpbmc7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKFwiLi4vbGliL3NoYXJlZFwiKS5kZWZhdWx0cztcblxuZGVmKFwiRnVuY3Rpb25cIilcbiAgICAuZmllbGQoXCJnZW5lcmF0b3JcIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKVxuICAgIC5maWVsZChcImV4cHJlc3Npb25cIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKVxuICAgIC5maWVsZChcImRlZmF1bHRzXCIsIFtvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpXG4gICAgLy8gVE9ETyBUaGlzIGNvdWxkIGJlIHJlcHJlc2VudGVkIGFzIGEgU3ByZWFkRWxlbWVudFBhdHRlcm4gaW4gLnBhcmFtcy5cbiAgICAuZmllbGQoXCJyZXN0XCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpXG4gICAgLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiZXhwcmVzc2lvblwiKTtcblxuZGVmKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiZXhwcmVzc2lvblwiKTtcblxuLy8gVE9ETyBUaGUgUGFyc2VyIEFQSSBjYWxscyB0aGlzIEFycm93RXhwcmVzc2lvbiwgYnV0IEVzcHJpbWEgdXNlc1xuLy8gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24uXG5kZWYoXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkZ1bmN0aW9uXCIsIFwiRXhwcmVzc2lvblwiKVxuICAgIC5idWlsZChcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJleHByZXNzaW9uXCIpXG4gICAgLy8gVGhlIGZvcmNlZCBudWxsIHZhbHVlIGhlcmUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBvdmVycmlkZGVuXG4gICAgLy8gZGVmaW5pdGlvbiBvZiB0aGUgXCJpZFwiIGZpZWxkIGluIHRoZSBGdW5jdGlvbiBpbnRlcmZhY2UuXG4gICAgLmZpZWxkKFwiaWRcIiwgbnVsbCwgZGVmYXVsdHNbXCJudWxsXCJdKVxuICAgIC8vIFRoZSBjdXJyZW50IHNwZWMgZm9yYmlkcyBhcnJvdyBnZW5lcmF0b3JzLCBzbyBJIGhhdmUgdGFrZW4gdGhlXG4gICAgLy8gbGliZXJ0eSBvZiBlbmZvcmNpbmcgdGhhdC4gVE9ETyBSZXBvcnQgdGhpcy5cbiAgICAuZmllbGQoXCJnZW5lcmF0b3JcIiwgZmFsc2UpO1xuXG5kZWYoXCJZaWVsZEV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIiwgXCJkZWxlZ2F0ZVwiKVxuICAgIC5maWVsZChcImFyZ3VtZW50XCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKVxuICAgIC5maWVsZChcImRlbGVnYXRlXCIsIGlzQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG5cbmRlZihcIkdlbmVyYXRvckV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiYm9keVwiLCBcImJsb2Nrc1wiLCBcImZpbHRlclwiKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJibG9ja3NcIiwgW2RlZihcIkNvbXByZWhlbnNpb25CbG9ja1wiKV0pXG4gICAgLmZpZWxkKFwiZmlsdGVyXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKTtcblxuZGVmKFwiQ29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiYm9keVwiLCBcImJsb2Nrc1wiLCBcImZpbHRlclwiKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJibG9ja3NcIiwgW2RlZihcIkNvbXByZWhlbnNpb25CbG9ja1wiKV0pXG4gICAgLmZpZWxkKFwiZmlsdGVyXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKTtcblxuZGVmKFwiQ29tcHJlaGVuc2lvbkJsb2NrXCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcImxlZnRcIiwgXCJyaWdodFwiLCBcImVhY2hcIilcbiAgICAuZmllbGQoXCJsZWZ0XCIsIGRlZihcIlBhdHRlcm5cIikpXG4gICAgLmZpZWxkKFwicmlnaHRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSlcbiAgICAuZmllbGQoXCJlYWNoXCIsIGlzQm9vbGVhbik7XG5cbmRlZihcIk1vZHVsZVNwZWNpZmllclwiKVxuICAgIC5iYXNlcyhcIkxpdGVyYWxcIilcbiAgICAuYnVpbGQoXCJ2YWx1ZVwiKVxuICAgIC5maWVsZChcInZhbHVlXCIsIGlzU3RyaW5nKTtcblxuZGVmKFwiUHJvcGVydHlcIilcbiAgICAvLyBFc3ByaW1hIGV4dGVuc2lvbnMgbm90IG1lbnRpb25lZCBpbiB0aGUgTW96aWxsYSBQYXJzZXIgQVBJOlxuICAgIC5maWVsZChcImtleVwiLCBvcihkZWYoXCJMaXRlcmFsXCIpLCBkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSlcbiAgICAuZmllbGQoXCJtZXRob2RcIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKVxuICAgIC5maWVsZChcInNob3J0aGFuZFwiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pXG4gICAgLmZpZWxkKFwiY29tcHV0ZWRcIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcblxuZGVmKFwiUHJvcGVydHlQYXR0ZXJuXCIpXG4gICAgLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKVxuICAgIC5maWVsZChcImNvbXB1dGVkXCIsIGlzQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG5cbmRlZihcIk1ldGhvZERlZmluaXRpb25cIilcbiAgICAuYmFzZXMoXCJEZWNsYXJhdGlvblwiKVxuICAgIC5idWlsZChcImtpbmRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiKVxuICAgIC5maWVsZChcImtpbmRcIiwgb3IoXCJpbml0XCIsIFwiZ2V0XCIsIFwic2V0XCIsIFwiXCIpKVxuICAgIC5maWVsZChcImtleVwiLCBvcihkZWYoXCJMaXRlcmFsXCIpLCBkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSlcbiAgICAuZmllbGQoXCJ2YWx1ZVwiLCBkZWYoXCJGdW5jdGlvblwiKSlcbiAgICAuZmllbGQoXCJjb21wdXRlZFwiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuXG5kZWYoXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcImFyZ3VtZW50XCIpXG4gICAgLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbmRlZihcIkFycmF5RXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImVsZW1lbnRzXCIsIFtvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBkZWYoXCJTcHJlYWRFbGVtZW50XCIpLCBudWxsKV0pO1xuXG5kZWYoXCJOZXdFeHByZXNzaW9uXCIpXG4gICAgLmZpZWxkKFwiYXJndW1lbnRzXCIsIFtvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBkZWYoXCJTcHJlYWRFbGVtZW50XCIpKV0pO1xuXG5kZWYoXCJDYWxsRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImFyZ3VtZW50c1wiLCBbb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgZGVmKFwiU3ByZWFkRWxlbWVudFwiKSldKTtcblxuZGVmKFwiU3ByZWFkRWxlbWVudFBhdHRlcm5cIilcbiAgICAuYmFzZXMoXCJQYXR0ZXJuXCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIilcbiAgICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJQYXR0ZXJuXCIpKTtcblxuZGVmKFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgLmZpZWxkKFwiZWxlbWVudHNcIiwgW29yKFxuICAgICAgICBkZWYoXCJQYXR0ZXJuXCIpLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyB1c2VkIGJ5IGVzcHJpbWFcbiAgICAgICAgZGVmKFwiU3ByZWFkRWxlbWVudFwiKVxuICAgICldKTtcblxudmFyIENsYXNzQm9keUVsZW1lbnQgPSBvcihcbiAgICBkZWYoXCJNZXRob2REZWZpbml0aW9uXCIpLFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5RGVmaW5pdGlvblwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5XCIpXG4pO1xuXG5kZWYoXCJDbGFzc1Byb3BlcnR5XCIpXG4gIC5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpXG4gIC5idWlsZChcImtleVwiKVxuICAuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiRXhwcmVzc2lvblwiKSkpXG4gIC5maWVsZChcImNvbXB1dGVkXCIsIGlzQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG5cbmRlZihcIkNsYXNzUHJvcGVydHlEZWZpbml0aW9uXCIpIC8vIHN0YXRpYyBwcm9wZXJ0eVxuICAgIC5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpXG4gICAgLmJ1aWxkKFwiZGVmaW5pdGlvblwiKVxuICAgIC8vIFllcywgVmlyZ2luaWEsIGNpcmN1bGFyIGRlZmluaXRpb25zIGFyZSBwZXJtaXR0ZWQuXG4gICAgLmZpZWxkKFwiZGVmaW5pdGlvblwiLCBDbGFzc0JvZHlFbGVtZW50KTtcblxuZGVmKFwiQ2xhc3NCb2R5XCIpXG4gICAgLmJhc2VzKFwiRGVjbGFyYXRpb25cIilcbiAgICAuYnVpbGQoXCJib2R5XCIpXG4gICAgLmZpZWxkKFwiYm9keVwiLCBbQ2xhc3NCb2R5RWxlbWVudF0pO1xuXG5kZWYoXCJDbGFzc0RlY2xhcmF0aW9uXCIpXG4gICAgLmJhc2VzKFwiRGVjbGFyYXRpb25cIilcbiAgICAuYnVpbGQoXCJpZFwiLCBcImJvZHlcIiwgXCJzdXBlckNsYXNzXCIpXG4gICAgLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIkNsYXNzQm9keVwiKSlcbiAgICAuZmllbGQoXCJzdXBlckNsYXNzXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiaWRcIiwgXCJib2R5XCIsIFwic3VwZXJDbGFzc1wiKVxuICAgIC5maWVsZChcImlkXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pXG4gICAgLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJDbGFzc0JvZHlcIikpXG4gICAgLmZpZWxkKFwic3VwZXJDbGFzc1wiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKVxuICAgIC5maWVsZChcImltcGxlbWVudHNcIiwgW2RlZihcIkNsYXNzSW1wbGVtZW50c1wiKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpO1xuXG5kZWYoXCJDbGFzc0ltcGxlbWVudHNcIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwiaWRcIilcbiAgICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKVxuICAgIC5maWVsZChcInN1cGVyQ2xhc3NcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG5cbi8vIFNwZWNpZmllciBhbmQgTmFtZWRTcGVjaWZpZXIgYXJlIGFic3RyYWN0IG5vbi1zdGFuZGFyZCB0eXBlcyB0aGF0IElcbi8vIGludHJvZHVjZWQgZm9yIGRlZmluaXRpb25hbCBjb252ZW5pZW5jZS5cbmRlZihcIlNwZWNpZmllclwiKS5iYXNlcyhcIk5vZGVcIik7XG5kZWYoXCJOYW1lZFNwZWNpZmllclwiKVxuICAgIC5iYXNlcyhcIlNwZWNpZmllclwiKVxuICAgIC8vIE5vdGU6IHRoaXMgYWJzdHJhY3QgdHlwZSBpcyBpbnRlbnRpb25hbGx5IG5vdCBidWlsZGFibGUuXG4gICAgLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSlcbiAgICAuZmllbGQoXCJuYW1lXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG4vLyBMaWtlIE5hbWVkU3BlY2lmaWVyLCBleGNlcHQgdHlwZTpcIkV4cG9ydFNwZWNpZmllclwiIGFuZCBidWlsZGFibGUuXG4vLyBleHBvcnQgezxpZCBbYXMgbmFtZV0+fSBbZnJvbSAuLi5dO1xuZGVmKFwiRXhwb3J0U3BlY2lmaWVyXCIpXG4gICAgLmJhc2VzKFwiTmFtZWRTcGVjaWZpZXJcIilcbiAgICAuYnVpbGQoXCJpZFwiLCBcIm5hbWVcIik7XG5cbi8vIGV4cG9ydCA8Kj4gZnJvbSAuLi47XG5kZWYoXCJFeHBvcnRCYXRjaFNwZWNpZmllclwiKVxuICAgIC5iYXNlcyhcIlNwZWNpZmllclwiKVxuICAgIC5idWlsZCgpO1xuXG4vLyBMaWtlIE5hbWVkU3BlY2lmaWVyLCBleGNlcHQgdHlwZTpcIkltcG9ydFNwZWNpZmllclwiIGFuZCBidWlsZGFibGUuXG4vLyBpbXBvcnQgezxpZCBbYXMgbmFtZV0+fSBmcm9tIC4uLjtcbmRlZihcIkltcG9ydFNwZWNpZmllclwiKVxuICAgIC5iYXNlcyhcIk5hbWVkU3BlY2lmaWVyXCIpXG4gICAgLmJ1aWxkKFwiaWRcIiwgXCJuYW1lXCIpO1xuXG4vLyBpbXBvcnQgPCogYXMgaWQ+IGZyb20gLi4uO1xuZGVmKFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXG4gICAgLmJhc2VzKFwiU3BlY2lmaWVyXCIpXG4gICAgLmJ1aWxkKFwiaWRcIilcbiAgICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcblxuLy8gaW1wb3J0IDxpZD4gZnJvbSAuLi47XG5kZWYoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gICAgLmJhc2VzKFwiU3BlY2lmaWVyXCIpXG4gICAgLmJ1aWxkKFwiaWRcIilcbiAgICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcblxuZGVmKFwiRXhwb3J0RGVjbGFyYXRpb25cIilcbiAgICAuYmFzZXMoXCJEZWNsYXJhdGlvblwiKVxuICAgIC5idWlsZChcImRlZmF1bHRcIiwgXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIilcbiAgICAuZmllbGQoXCJkZWZhdWx0XCIsIGlzQm9vbGVhbilcbiAgICAuZmllbGQoXCJkZWNsYXJhdGlvblwiLCBvcihcbiAgICAgICAgZGVmKFwiRGVjbGFyYXRpb25cIiksXG4gICAgICAgIGRlZihcIkV4cHJlc3Npb25cIiksIC8vIEltcGxpZXMgZGVmYXVsdC5cbiAgICAgICAgbnVsbFxuICAgICkpXG4gICAgLmZpZWxkKFwic3BlY2lmaWVyc1wiLCBbb3IoXG4gICAgICAgIGRlZihcIkV4cG9ydFNwZWNpZmllclwiKSxcbiAgICAgICAgZGVmKFwiRXhwb3J0QmF0Y2hTcGVjaWZpZXJcIilcbiAgICApXSwgZGVmYXVsdHMuZW1wdHlBcnJheSlcbiAgICAuZmllbGQoXCJzb3VyY2VcIiwgb3IoZGVmKFwiTW9kdWxlU3BlY2lmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcblxuZGVmKFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgICAuYmFzZXMoXCJEZWNsYXJhdGlvblwiKVxuICAgIC5idWlsZChcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIilcbiAgICAuZmllbGQoXCJzcGVjaWZpZXJzXCIsIFtvcihcbiAgICAgICAgZGVmKFwiSW1wb3J0U3BlY2lmaWVyXCIpLFxuICAgICAgICBkZWYoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiksXG4gICAgICAgIGRlZihcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIilcbiAgICApXSwgZGVmYXVsdHMuZW1wdHlBcnJheSlcbiAgICAuZmllbGQoXCJzb3VyY2VcIiwgZGVmKFwiTW9kdWxlU3BlY2lmaWVyXCIpKTtcblxuZGVmKFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcInRhZ1wiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcInF1YXNpXCIsIGRlZihcIlRlbXBsYXRlTGl0ZXJhbFwiKSk7XG5cbmRlZihcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJxdWFzaXNcIiwgXCJleHByZXNzaW9uc1wiKVxuICAgIC5maWVsZChcInF1YXNpc1wiLCBbZGVmKFwiVGVtcGxhdGVFbGVtZW50XCIpXSlcbiAgICAuZmllbGQoXCJleHByZXNzaW9uc1wiLCBbZGVmKFwiRXhwcmVzc2lvblwiKV0pO1xuXG5kZWYoXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwidmFsdWVcIiwgXCJ0YWlsXCIpXG4gICAgLmZpZWxkKFwidmFsdWVcIiwge1wiY29va2VkXCI6IGlzU3RyaW5nLCBcInJhd1wiOiBpc1N0cmluZ30pXG4gICAgLmZpZWxkKFwidGFpbFwiLCBpc0Jvb2xlYW4pO1xuIiwicmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi9saWIvdHlwZXNcIik7XG52YXIgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG52YXIgb3IgPSB0eXBlcy5UeXBlLm9yO1xudmFyIGJ1aWx0aW4gPSB0eXBlcy5idWlsdEluVHlwZXM7XG52YXIgaXNCb29sZWFuID0gYnVpbHRpbi5ib29sZWFuO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZShcIi4uL2xpYi9zaGFyZWRcIikuZGVmYXVsdHM7XG5cbmRlZihcIkZ1bmN0aW9uXCIpXG4gICAgLmZpZWxkKFwiYXN5bmNcIiwgaXNCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcblxuZGVmKFwiU3ByZWFkUHJvcGVydHlcIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIilcbiAgICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxuZGVmKFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcInByb3BlcnRpZXNcIiwgW29yKGRlZihcIlByb3BlcnR5XCIpLCBkZWYoXCJTcHJlYWRQcm9wZXJ0eVwiKSldKTtcblxuZGVmKFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCIpXG4gICAgLmJhc2VzKFwiUGF0dGVyblwiKVxuICAgIC5idWlsZChcImFyZ3VtZW50XCIpXG4gICAgLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiUGF0dGVyblwiKSk7XG5cbmRlZihcIk9iamVjdFBhdHRlcm5cIilcbiAgICAuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtvcihcbiAgICAgICAgZGVmKFwiUHJvcGVydHlQYXR0ZXJuXCIpLFxuICAgICAgICBkZWYoXCJTcHJlYWRQcm9wZXJ0eVBhdHRlcm5cIiksXG4gICAgICAgIC8vIHVzZWQgYnkgZXNwcmltYVxuICAgICAgICBkZWYoXCJQcm9wZXJ0eVwiKSxcbiAgICAgICAgZGVmKFwiU3ByZWFkUHJvcGVydHlcIilcbiAgICApXSk7XG5cbmRlZihcIkF3YWl0RXhwcmVzc2lvblwiKVxuICAgIC5iYXNlcyhcIkV4cHJlc3Npb25cIilcbiAgICAuYnVpbGQoXCJhcmd1bWVudFwiLCBcImFsbFwiKVxuICAgIC5maWVsZChcImFyZ3VtZW50XCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKVxuICAgIC5maWVsZChcImFsbFwiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuIiwicmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi9saWIvdHlwZXNcIik7XG52YXIgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG52YXIgb3IgPSB0eXBlcy5UeXBlLm9yO1xudmFyIGJ1aWx0aW4gPSB0eXBlcy5idWlsdEluVHlwZXM7XG52YXIgaXNTdHJpbmcgPSBidWlsdGluLnN0cmluZztcbnZhciBpc0Jvb2xlYW4gPSBidWlsdGluLmJvb2xlYW47XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKFwiLi4vbGliL3NoYXJlZFwiKS5kZWZhdWx0cztcblxuZGVmKFwiWEpTQXR0cmlidXRlXCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcIm5hbWVcIiwgXCJ2YWx1ZVwiKVxuICAgIC5maWVsZChcIm5hbWVcIiwgb3IoZGVmKFwiWEpTSWRlbnRpZmllclwiKSwgZGVmKFwiWEpTTmFtZXNwYWNlZE5hbWVcIikpKVxuICAgIC5maWVsZChcInZhbHVlXCIsIG9yKFxuICAgICAgICBkZWYoXCJMaXRlcmFsXCIpLCAvLyBhdHRyPVwidmFsdWVcIlxuICAgICAgICBkZWYoXCJYSlNFeHByZXNzaW9uQ29udGFpbmVyXCIpLCAvLyBhdHRyPXt2YWx1ZX1cbiAgICAgICAgbnVsbCAvLyBhdHRyPSBvciBqdXN0IGF0dHJcbiAgICApLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuXG5kZWYoXCJYSlNJZGVudGlmaWVyXCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKVxuICAgIC5idWlsZChcIm5hbWVcIilcbiAgICAuZmllbGQoXCJuYW1lXCIsIGlzU3RyaW5nKTtcblxuZGVmKFwiWEpTTmFtZXNwYWNlZE5hbWVcIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwibmFtZXNwYWNlXCIsIFwibmFtZVwiKVxuICAgIC5maWVsZChcIm5hbWVzcGFjZVwiLCBkZWYoXCJYSlNJZGVudGlmaWVyXCIpKVxuICAgIC5maWVsZChcIm5hbWVcIiwgZGVmKFwiWEpTSWRlbnRpZmllclwiKSk7XG5cbmRlZihcIlhKU01lbWJlckV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIilcbiAgICAuZmllbGQoXCJvYmplY3RcIiwgb3IoZGVmKFwiWEpTSWRlbnRpZmllclwiKSwgZGVmKFwiWEpTTWVtYmVyRXhwcmVzc2lvblwiKSkpXG4gICAgLmZpZWxkKFwicHJvcGVydHlcIiwgZGVmKFwiWEpTSWRlbnRpZmllclwiKSlcbiAgICAuZmllbGQoXCJjb21wdXRlZFwiLCBpc0Jvb2xlYW4sIGRlZmF1bHRzLmZhbHNlKTtcblxudmFyIFhKU0VsZW1lbnROYW1lID0gb3IoXG4gICAgZGVmKFwiWEpTSWRlbnRpZmllclwiKSxcbiAgICBkZWYoXCJYSlNOYW1lc3BhY2VkTmFtZVwiKSxcbiAgICBkZWYoXCJYSlNNZW1iZXJFeHByZXNzaW9uXCIpXG4pO1xuXG5kZWYoXCJYSlNTcHJlYWRBdHRyaWJ1dGVcIilcbiAgICAuYmFzZXMoXCJOb2RlXCIpXG4gICAgLmJ1aWxkKFwiYXJndW1lbnRcIilcbiAgICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcblxudmFyIFhKU0F0dHJpYnV0ZXMgPSBbb3IoXG4gICAgZGVmKFwiWEpTQXR0cmlidXRlXCIpLFxuICAgIGRlZihcIlhKU1NwcmVhZEF0dHJpYnV0ZVwiKVxuKV07XG5cbmRlZihcIlhKU0V4cHJlc3Npb25Db250YWluZXJcIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiZXhwcmVzc2lvblwiKVxuICAgIC5maWVsZChcImV4cHJlc3Npb25cIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG5cbmRlZihcIlhKU0VsZW1lbnRcIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwib3BlbmluZ0VsZW1lbnRcIiwgXCJjbG9zaW5nRWxlbWVudFwiLCBcImNoaWxkcmVuXCIpXG4gICAgLmZpZWxkKFwib3BlbmluZ0VsZW1lbnRcIiwgZGVmKFwiWEpTT3BlbmluZ0VsZW1lbnRcIikpXG4gICAgLmZpZWxkKFwiY2xvc2luZ0VsZW1lbnRcIiwgb3IoZGVmKFwiWEpTQ2xvc2luZ0VsZW1lbnRcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pXG4gICAgLmZpZWxkKFwiY2hpbGRyZW5cIiwgW29yKFxuICAgICAgICBkZWYoXCJYSlNFbGVtZW50XCIpLFxuICAgICAgICBkZWYoXCJYSlNFeHByZXNzaW9uQ29udGFpbmVyXCIpLFxuICAgICAgICBkZWYoXCJYSlNUZXh0XCIpLFxuICAgICAgICBkZWYoXCJMaXRlcmFsXCIpIC8vIFRPRE8gRXNwcmltYSBzaG91bGQgcmV0dXJuIFhKU1RleHQgaW5zdGVhZC5cbiAgICApXSwgZGVmYXVsdHMuZW1wdHlBcnJheSlcbiAgICAuZmllbGQoXCJuYW1lXCIsIFhKU0VsZW1lbnROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTGl0dGxlLWtub3duIGZhY3Q6IHRoZSBgdGhpc2Agb2JqZWN0IGluc2lkZSBhIGRlZmF1bHQgZnVuY3Rpb25cbiAgICAgICAgLy8gaXMgbm9uZSBvdGhlciB0aGFuIHRoZSBwYXJ0aWFsbHktYnVpbHQgb2JqZWN0IGl0c2VsZiwgYW5kIGFueVxuICAgICAgICAvLyBmaWVsZHMgaW5pdGlhbGl6ZWQgZGlyZWN0bHkgZnJvbSBidWlsZGVyIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgICAvLyAobGlrZSBvcGVuaW5nRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIGFuZCBjaGlsZHJlbikgYXJlXG4gICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgYXZhaWxhYmxlLlxuICAgICAgICByZXR1cm4gdGhpcy5vcGVuaW5nRWxlbWVudC5uYW1lO1xuICAgIH0pXG4gICAgLmZpZWxkKFwic2VsZkNsb3NpbmdcIiwgaXNCb29sZWFuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbmluZ0VsZW1lbnQuc2VsZkNsb3Npbmc7XG4gICAgfSlcbiAgICAuZmllbGQoXCJhdHRyaWJ1dGVzXCIsIFhKU0F0dHJpYnV0ZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIH0pO1xuXG5kZWYoXCJYSlNPcGVuaW5nRWxlbWVudFwiKVxuICAgIC5iYXNlcyhcIk5vZGVcIikgLy8gVE9ETyBEb2VzIHRoaXMgbWFrZSBzZW5zZT8gQ2FuJ3QgcmVhbGx5IGJlIGFuIFhKU0VsZW1lbnQuXG4gICAgLmJ1aWxkKFwibmFtZVwiLCBcImF0dHJpYnV0ZXNcIiwgXCJzZWxmQ2xvc2luZ1wiKVxuICAgIC5maWVsZChcIm5hbWVcIiwgWEpTRWxlbWVudE5hbWUpXG4gICAgLmZpZWxkKFwiYXR0cmlidXRlc1wiLCBYSlNBdHRyaWJ1dGVzLCBkZWZhdWx0cy5lbXB0eUFycmF5KVxuICAgIC5maWVsZChcInNlbGZDbG9zaW5nXCIsIGlzQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG5cbmRlZihcIlhKU0Nsb3NpbmdFbGVtZW50XCIpXG4gICAgLmJhc2VzKFwiTm9kZVwiKSAvLyBUT0RPIFNhbWUgY29uY2Vybi5cbiAgICAuYnVpbGQoXCJuYW1lXCIpXG4gICAgLmZpZWxkKFwibmFtZVwiLCBYSlNFbGVtZW50TmFtZSk7XG5cbmRlZihcIlhKU1RleHRcIilcbiAgICAuYmFzZXMoXCJMaXRlcmFsXCIpXG4gICAgLmJ1aWxkKFwidmFsdWVcIilcbiAgICAuZmllbGQoXCJ2YWx1ZVwiLCBpc1N0cmluZyk7XG5cbmRlZihcIlhKU0VtcHR5RXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoKTtcblxuLy8gVHlwZSBBbm5vdGF0aW9uc1xuZGVmKFwiVHlwZVwiKVxuICAuYmFzZXMoXCJOb2RlXCIpO1xuXG5kZWYoXCJBbnlUeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJUeXBlXCIpO1xuXG5kZWYoXCJWb2lkVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKTtcblxuZGVmKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKTtcblxuZGVmKFwiU3RyaW5nVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKTtcblxuZGVmKFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpXG4gIC5iYXNlcyhcIlR5cGVcIilcbiAgLmJ1aWxkKFwidmFsdWVcIiwgXCJyYXdcIilcbiAgLmZpZWxkKFwidmFsdWVcIiwgaXNTdHJpbmcpXG4gIC5maWVsZChcInJhd1wiLCBpc1N0cmluZyk7XG5cbmRlZihcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJUeXBlXCIpO1xuXG5kZWYoXCJUeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJOb2RlXCIpXG4gIC5idWlsZChcInR5cGVBbm5vdGF0aW9uXCIpXG4gIC5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlR5cGVcIikpO1xuXG5kZWYoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIpXG4gIC5iYXNlcyhcIlR5cGVcIilcbiAgLmJ1aWxkKFwidHlwZUFubm90YXRpb25cIilcbiAgLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgZGVmKFwiVHlwZVwiKSk7XG5cbmRlZihcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKVxuICAuYnVpbGQoXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCIsIFwicmVzdFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIpXG4gIC5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiRnVuY3Rpb25UeXBlUGFyYW1cIildKVxuICAuZmllbGQoXCJyZXR1cm5UeXBlXCIsIGRlZihcIlR5cGVcIikpXG4gIC5maWVsZChcInJlc3RcIiwgb3IoZGVmKFwiRnVuY3Rpb25UeXBlUGFyYW1cIiksIG51bGwpKVxuICAuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwpKTtcblxuZGVmKFwiRnVuY3Rpb25UeXBlUGFyYW1cIilcbiAgLmJhc2VzKFwiTm9kZVwiKVxuICAuYnVpbGQoXCJuYW1lXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJvcHRpb25hbFwiKVxuICAuZmllbGQoXCJuYW1lXCIsIGRlZihcIklkZW50aWZpZXJcIikpXG4gIC5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlR5cGVcIikpXG4gIC5maWVsZChcIm9wdGlvbmFsXCIsIGlzQm9vbGVhbik7XG4gIFxuZGVmKFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJUeXBlXCIpXG4gIC5idWlsZChcImVsZW1lbnRUeXBlXCIpXG4gIC5maWVsZChcImVsZW1lbnRUeXBlXCIsIGRlZihcIlR5cGVcIikpO1xuXG5kZWYoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJUeXBlXCIpXG4gIC5idWlsZChcInByb3BlcnRpZXNcIilcbiAgLmZpZWxkKFwicHJvcGVydGllc1wiLCBbZGVmKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpXSlcbiAgLmZpZWxkKFwiaW5kZXhlcnNcIiwgW2RlZihcIk9iamVjdFR5cGVJbmRleGVyXCIpXSwgZGVmYXVsdHMuZW1wdHlBcnJheSlcbiAgLmZpZWxkKFwiY2FsbFByb3BlcnRpZXNcIiwgW2RlZihcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIildLCBkZWZhdWx0cy5lbXB0eUFycmF5KTtcblxuZGVmKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpXG4gIC5iYXNlcyhcIk5vZGVcIilcbiAgLmJ1aWxkKFwia2V5XCIsIFwidmFsdWVcIiwgXCJvcHRpb25hbFwiKVxuICAuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgZGVmKFwiSWRlbnRpZmllclwiKSkpXG4gIC5maWVsZChcInZhbHVlXCIsIGRlZihcIlR5cGVcIikpXG4gIC5maWVsZChcIm9wdGlvbmFsXCIsIGlzQm9vbGVhbik7XG5cbmRlZihcIk9iamVjdFR5cGVJbmRleGVyXCIpXG4gIC5iYXNlcyhcIk5vZGVcIilcbiAgLmJ1aWxkKFwiaWRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiKVxuICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKVxuICAuZmllbGQoXCJrZXlcIiwgZGVmKFwiVHlwZVwiKSlcbiAgLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiVHlwZVwiKSk7XG5cbmRlZihcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIilcbiAgLmJhc2VzKFwiTm9kZVwiKVxuICAuYnVpbGQoXCJ2YWx1ZVwiKVxuICAuZmllbGQoXCJ2YWx1ZVwiLCBkZWYoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpKVxuICAuZmllbGQoXCJzdGF0aWNcIiwgaXNCb29sZWFuLCBmYWxzZSk7XG5cbmRlZihcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpXG4gIC5iYXNlcyhcIk5vZGVcIilcbiAgLmJ1aWxkKFwicXVhbGlmaWNhdGlvblwiLCBcImlkXCIpXG4gIC5maWVsZChcInF1YWxpZmljYXRpb25cIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIikpKVxuICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcblxuZGVmKFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpXG4gIC5iYXNlcyhcIlR5cGVcIilcbiAgLmJ1aWxkKFwiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiKVxuICAuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKSkpXG4gIC5maWVsZChcInR5cGVQYXJhbWV0ZXJzXCIsIG9yKGRlZihcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLCBudWxsKSk7XG5cbmRlZihcIk1lbWJlclR5cGVBbm5vdGF0aW9uXCIpXG4gIC5iYXNlcyhcIlR5cGVcIilcbiAgLmJ1aWxkKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIilcbiAgLmZpZWxkKFwib2JqZWN0XCIsIGRlZihcIklkZW50aWZpZXJcIikpXG4gIC5maWVsZChcInByb3BlcnR5XCIsIG9yKGRlZihcIk1lbWJlclR5cGVBbm5vdGF0aW9uXCIpLCBkZWYoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIikpKTtcblxuZGVmKFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKVxuICAuYmFzZXMoXCJUeXBlXCIpXG4gIC5idWlsZChcInR5cGVzXCIpXG4gIC5maWVsZChcInR5cGVzXCIsIFtkZWYoXCJUeXBlXCIpXSk7XG5cbmRlZihcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpXG4gIC5iYXNlcyhcIlR5cGVcIilcbiAgLmJ1aWxkKFwidHlwZXNcIilcbiAgLmZpZWxkKFwidHlwZXNcIiwgW2RlZihcIlR5cGVcIildKTtcblxuZGVmKFwiVHlwZW9mVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKVxuICAuYnVpbGQoXCJhcmd1bWVudFwiKVxuICAuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJUeXBlXCIpKTtcblxuZGVmKFwiSWRlbnRpZmllclwiKVxuICAuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBvcihkZWYoXCJUeXBlQW5ub3RhdGlvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG5cbmRlZihcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKVxuICAuYmFzZXMoXCJOb2RlXCIpXG4gIC5idWlsZChcInBhcmFtc1wiKVxuICAuZmllbGQoXCJwYXJhbXNcIiwgW2RlZihcIklkZW50aWZpZXJcIildKTtcblxuZGVmKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgLmJhc2VzKFwiTm9kZVwiKVxuICAuYnVpbGQoXCJwYXJhbXNcIilcbiAgLmZpZWxkKFwicGFyYW1zXCIsIFtkZWYoXCJUeXBlXCIpXSk7XG5cbmRlZihcIkZ1bmN0aW9uXCIpXG4gIC5maWVsZChcInJldHVyblR5cGVcIiwgb3IoZGVmKFwiVHlwZUFubm90YXRpb25cIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pXG4gIC5maWVsZChcInR5cGVQYXJhbWV0ZXJzXCIsIG9yKGRlZihcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG5cbmRlZihcIkNsYXNzUHJvcGVydHlcIilcbiAgLmJ1aWxkKFwia2V5XCIsIFwidHlwZUFubm90YXRpb25cIilcbiAgLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgZGVmKFwiVHlwZUFubm90YXRpb25cIikpXG4gIC5maWVsZChcInN0YXRpY1wiLCBpc0Jvb2xlYW4sIGZhbHNlKTtcblxuZGVmKFwiQ2xhc3NJbXBsZW1lbnRzXCIpXG4gIC5maWVsZChcInR5cGVQYXJhbWV0ZXJzXCIsIG9yKGRlZihcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcblxuZGVmKFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIilcbiAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gIC5idWlsZChcImlkXCIsIFwiYm9keVwiLCBcImV4dGVuZHNcIilcbiAgLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSlcbiAgLmZpZWxkKFwidHlwZVBhcmFtZXRlcnNcIiwgb3IoZGVmKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKVxuICAuZmllbGQoXCJib2R5XCIsIGRlZihcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpKVxuICAuZmllbGQoXCJleHRlbmRzXCIsIFtkZWYoXCJJbnRlcmZhY2VFeHRlbmRzXCIpXSk7XG5cbmRlZihcIkludGVyZmFjZUV4dGVuZHNcIilcbiAgLmJhc2VzKFwiTm9kZVwiKVxuICAuYnVpbGQoXCJpZFwiKVxuICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKVxuICAuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSwgbnVsbCkpO1xuXG5kZWYoXCJUeXBlQWxpYXNcIilcbiAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gIC5idWlsZChcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiKVxuICAuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKVxuICAuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwpKVxuICAuZmllbGQoXCJyaWdodFwiLCBkZWYoXCJUeXBlXCIpKTtcbiAgXG5kZWYoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIilcbiAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAuYnVpbGQoXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIilcbiAgLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBkZWYoXCJUeXBlQW5ub3RhdGlvblwiKSk7XG5cbmRlZihcIlR1cGxlVHlwZUFubm90YXRpb25cIilcbiAgLmJhc2VzKFwiVHlwZVwiKVxuICAuYnVpbGQoXCJ0eXBlc1wiKVxuICAuZmllbGQoXCJ0eXBlc1wiLCBbZGVmKFwiVHlwZVwiKV0pO1xuXG5kZWYoXCJEZWNsYXJlVmFyaWFibGVcIilcbiAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gIC5idWlsZChcImlkXCIpXG4gIC5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpO1xuXG5kZWYoXCJEZWNsYXJlRnVuY3Rpb25cIilcbiAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gIC5idWlsZChcImlkXCIpXG4gIC5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpO1xuXG5kZWYoXCJEZWNsYXJlQ2xhc3NcIilcbiAgLmJhc2VzKFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIilcbiAgLmJ1aWxkKFwiaWRcIik7XG5cbmRlZihcIkRlY2xhcmVNb2R1bGVcIilcbiAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gIC5idWlsZChcImlkXCIsIFwiYm9keVwiKVxuICAuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJMaXRlcmFsXCIpKSlcbiAgLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSk7XG4iLCJyZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL2xpYi90eXBlc1wiKTtcbnZhciBkZWYgPSB0eXBlcy5UeXBlLmRlZjtcbnZhciBvciA9IHR5cGVzLlR5cGUub3I7XG52YXIgZ2VxID0gcmVxdWlyZShcIi4uL2xpYi9zaGFyZWRcIikuZ2VxO1xuXG5kZWYoXCJGb3JPZlN0YXRlbWVudFwiKVxuICAgIC5iYXNlcyhcIlN0YXRlbWVudFwiKVxuICAgIC5idWlsZChcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIilcbiAgICAuZmllbGQoXCJsZWZ0XCIsIG9yKFxuICAgICAgICBkZWYoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpLFxuICAgICAgICBkZWYoXCJFeHByZXNzaW9uXCIpKSlcbiAgICAuZmllbGQoXCJyaWdodFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKVxuICAgIC5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcblxuZGVmKFwiTGV0U3RhdGVtZW50XCIpXG4gICAgLmJhc2VzKFwiU3RhdGVtZW50XCIpXG4gICAgLmJ1aWxkKFwiaGVhZFwiLCBcImJvZHlcIilcbiAgICAvLyBUT0RPIERldmlhdGluZyBmcm9tIHRoZSBzcGVjIGJ5IHJldXNpbmcgVmFyaWFibGVEZWNsYXJhdG9yIGhlcmUuXG4gICAgLmZpZWxkKFwiaGVhZFwiLCBbZGVmKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpXSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIlN0YXRlbWVudFwiKSk7XG5cbmRlZihcIkxldEV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiaGVhZFwiLCBcImJvZHlcIilcbiAgICAvLyBUT0RPIERldmlhdGluZyBmcm9tIHRoZSBzcGVjIGJ5IHJldXNpbmcgVmFyaWFibGVEZWNsYXJhdG9yIGhlcmUuXG4gICAgLmZpZWxkKFwiaGVhZFwiLCBbZGVmKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpXSlcbiAgICAuZmllbGQoXCJib2R5XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuXG5kZWYoXCJHcmFwaEV4cHJlc3Npb25cIilcbiAgICAuYmFzZXMoXCJFeHByZXNzaW9uXCIpXG4gICAgLmJ1aWxkKFwiaW5kZXhcIiwgXCJleHByZXNzaW9uXCIpXG4gICAgLmZpZWxkKFwiaW5kZXhcIiwgZ2VxKDApKVxuICAgIC5maWVsZChcImV4cHJlc3Npb25cIiwgZGVmKFwiTGl0ZXJhbFwiKSk7XG5cbmRlZihcIkdyYXBoSW5kZXhFeHByZXNzaW9uXCIpXG4gICAgLmJhc2VzKFwiRXhwcmVzc2lvblwiKVxuICAgIC5idWlsZChcImluZGV4XCIpXG4gICAgLmZpZWxkKFwiaW5kZXhcIiwgZ2VxKDApKTtcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL21haW5cIik7XG52YXIgZ2V0RmllbGROYW1lcyA9IHR5cGVzLmdldEZpZWxkTmFtZXM7XG52YXIgZ2V0RmllbGRWYWx1ZSA9IHR5cGVzLmdldEZpZWxkVmFsdWU7XG52YXIgaXNBcnJheSA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5hcnJheTtcbnZhciBpc09iamVjdCA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5vYmplY3Q7XG52YXIgaXNEYXRlID0gdHlwZXMuYnVpbHRJblR5cGVzLkRhdGU7XG52YXIgaXNSZWdFeHAgPSB0eXBlcy5idWlsdEluVHlwZXMuUmVnRXhwO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGFzdE5vZGVzQXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCkge1xuICAgIGlmIChpc0FycmF5LmNoZWNrKHByb2JsZW1QYXRoKSkge1xuICAgICAgICBwcm9ibGVtUGF0aC5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2JsZW1QYXRoID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCk7XG59XG5cbmFzdE5vZGVzQXJlRXF1aXZhbGVudC5hc3NlcnQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHByb2JsZW1QYXRoID0gW107XG4gICAgaWYgKCFhc3ROb2Rlc0FyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpKSB7XG4gICAgICAgIGlmIChwcm9ibGVtUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChhLCBiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIk5vZGVzIGRpZmZlciBpbiB0aGUgZm9sbG93aW5nIHBhdGg6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgcHJvYmxlbVBhdGgubWFwKHN1YnNjcmlwdEZvclByb3BlcnR5KS5qb2luKFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3Vic2NyaXB0Rm9yUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAoL1tfJGEtel1bXyRhLXowLTldKi9pLnRlc3QocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIHByb3BlcnR5O1xuICAgIH1cbiAgICByZXR1cm4gXCJbXCIgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eSkgKyBcIl1cIjtcbn1cblxuZnVuY3Rpb24gYXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCkge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5LmNoZWNrKGEpKSB7XG4gICAgICAgIHJldHVybiBhcnJheXNBcmVFcXVpdmFsZW50KGEsIGIsIHByb2JsZW1QYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QuY2hlY2soYSkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdHNBcmVFcXVpdmFsZW50KGEsIGIsIHByb2JsZW1QYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEYXRlLmNoZWNrKGEpKSB7XG4gICAgICAgIHJldHVybiBpc0RhdGUuY2hlY2soYikgJiYgKCthID09PSArYik7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwLmNoZWNrKGEpKSB7XG4gICAgICAgIHJldHVybiBpc1JlZ0V4cC5jaGVjayhiKSAmJiAoXG4gICAgICAgICAgICBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhID09IGI7XG59XG5cbmZ1bmN0aW9uIGFycmF5c0FyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpIHtcbiAgICBpc0FycmF5LmFzc2VydChhKTtcbiAgICB2YXIgYUxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgaWYgKCFpc0FycmF5LmNoZWNrKGIpIHx8IGIubGVuZ3RoICE9PSBhTGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcm9ibGVtUGF0aCkge1xuICAgICAgICAgICAgcHJvYmxlbVBhdGgucHVzaChcImxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHByb2JsZW1QYXRoKSB7XG4gICAgICAgICAgICBwcm9ibGVtUGF0aC5wdXNoKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgaW4gYSAhPT0gaSBpbiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFyZUVxdWl2YWxlbnQoYVtpXSwgYltpXSwgcHJvYmxlbVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvYmxlbVBhdGgpIHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwcm9ibGVtUGF0aC5wb3AoKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0c0FyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpIHtcbiAgICBpc09iamVjdC5hc3NlcnQoYSk7XG4gICAgaWYgKCFpc09iamVjdC5jaGVjayhiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBwYXRoIGZvciBhIGNvbW1vbiBwcm9wZXJ0eSBvZiBBU1Qgbm9kZXMuXG4gICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIGlmIChwcm9ibGVtUGF0aCkge1xuICAgICAgICAgICAgcHJvYmxlbVBhdGgucHVzaChcInR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhTmFtZXMgPSBnZXRGaWVsZE5hbWVzKGEpO1xuICAgIHZhciBhTmFtZUNvdW50ID0gYU5hbWVzLmxlbmd0aDtcblxuICAgIHZhciBiTmFtZXMgPSBnZXRGaWVsZE5hbWVzKGIpO1xuICAgIHZhciBiTmFtZUNvdW50ID0gYk5hbWVzLmxlbmd0aDtcblxuICAgIGlmIChhTmFtZUNvdW50ID09PSBiTmFtZUNvdW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYU5hbWVDb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFOYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciBhQ2hpbGQgPSBnZXRGaWVsZFZhbHVlKGEsIG5hbWUpO1xuICAgICAgICAgICAgdmFyIGJDaGlsZCA9IGdldEZpZWxkVmFsdWUoYiwgbmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9ibGVtUGF0aCkge1xuICAgICAgICAgICAgICAgIHByb2JsZW1QYXRoLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYXJlRXF1aXZhbGVudChhQ2hpbGQsIGJDaGlsZCwgcHJvYmxlbVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvYmxlbVBhdGgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocHJvYmxlbVBhdGgucG9wKCksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9ibGVtUGF0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2luY2UgYU5hbWVDb3VudCAhPT0gYk5hbWVDb3VudCwgd2UgbmVlZCB0byBmaW5kIHNvbWUgbmFtZSB0aGF0J3NcbiAgICAvLyBtaXNzaW5nIGluIGFOYW1lcyBidXQgcHJlc2VudCBpbiBiTmFtZXMsIG9yIHZpY2UtdmVyc2EuXG5cbiAgICB2YXIgc2Vlbk5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhTmFtZUNvdW50OyArK2kpIHtcbiAgICAgICAgc2Vlbk5hbWVzW2FOYW1lc1tpXV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBiTmFtZUNvdW50OyArK2kpIHtcbiAgICAgICAgbmFtZSA9IGJOYW1lc1tpXTtcblxuICAgICAgICBpZiAoIWhhc093bi5jYWxsKHNlZW5OYW1lcywgbmFtZSkpIHtcbiAgICAgICAgICAgIHByb2JsZW1QYXRoLnB1c2gobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc2Vlbk5hbWVzW25hbWVdO1xuICAgIH1cblxuICAgIGZvciAobmFtZSBpbiBzZWVuTmFtZXMpIHtcbiAgICAgICAgcHJvYmxlbVBhdGgucHVzaChuYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzdE5vZGVzQXJlRXF1aXZhbGVudDtcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgbiA9IHR5cGVzLm5hbWVkVHlwZXM7XG52YXIgYiA9IHR5cGVzLmJ1aWxkZXJzO1xudmFyIGlzTnVtYmVyID0gdHlwZXMuYnVpbHRJblR5cGVzLm51bWJlcjtcbnZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xudmFyIFBhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xudmFyIFNjb3BlID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5cbmZ1bmN0aW9uIE5vZGVQYXRoKHZhbHVlLCBwYXJlbnRQYXRoLCBuYW1lKSB7XG4gICAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiBOb2RlUGF0aCk7XG4gICAgUGF0aC5jYWxsKHRoaXMsIHZhbHVlLCBwYXJlbnRQYXRoLCBuYW1lKTtcbn1cblxucmVxdWlyZShcInV0aWxcIikuaW5oZXJpdHMoTm9kZVBhdGgsIFBhdGgpO1xudmFyIE5QcCA9IE5vZGVQYXRoLnByb3RvdHlwZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTlBwLCB7XG4gICAgbm9kZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZVwiLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLCAvLyBFbmFibGUgZGVsZXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2NvbXB1dGVOb2RlKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhcmVudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsIC8vIEVuYWJsZSBkZWxldGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fY29tcHV0ZVBhcmVudCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNjb3BlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY29wZVwiLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLCAvLyBFbmFibGUgZGVsZXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2NvbXB1dGVTY29wZSgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuTlBwLnJlcGxhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5ub2RlO1xuICAgIGRlbGV0ZSB0aGlzLnBhcmVudDtcbiAgICBkZWxldGUgdGhpcy5zY29wZTtcbiAgICByZXR1cm4gUGF0aC5wcm90b3R5cGUucmVwbGFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuTlBwLnBydW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbWFpbmluZ05vZGVQYXRoID0gdGhpcy5wYXJlbnQ7XG5cbiAgICB0aGlzLnJlcGxhY2UoKTtcblxuICAgIHJldHVybiBjbGVhblVwTm9kZXNBZnRlclBydW5lKHJlbWFpbmluZ05vZGVQYXRoKTtcbn07XG5cbi8vIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYW5jZXN0b3IgUGF0aCB3aG9zZSB2YWx1ZSBpcyBhIE5vZGUuXG5OUHAuX2NvbXB1dGVOb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBpZiAobi5Ob2RlLmNoZWNrKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIHBwID0gdGhpcy5wYXJlbnRQYXRoO1xuICAgIHJldHVybiBwcCAmJiBwcC5ub2RlIHx8IG51bGw7XG59O1xuXG4vLyBUaGUgZmlyc3QgYW5jZXN0b3IgUGF0aCB3aG9zZSB2YWx1ZSBpcyBhIE5vZGUgZGlzdGluY3QgZnJvbSB0aGlzLm5vZGUuXG5OUHAuX2NvbXB1dGVQYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHZhciBwcCA9IHRoaXMucGFyZW50UGF0aDtcblxuICAgIGlmICghbi5Ob2RlLmNoZWNrKHZhbHVlKSkge1xuICAgICAgICB3aGlsZSAocHAgJiYgIW4uTm9kZS5jaGVjayhwcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHBwID0gcHAucGFyZW50UGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcCkge1xuICAgICAgICAgICAgcHAgPSBwcC5wYXJlbnRQYXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHBwICYmICFuLk5vZGUuY2hlY2socHAudmFsdWUpKSB7XG4gICAgICAgIHBwID0gcHAucGFyZW50UGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHAgfHwgbnVsbDtcbn07XG5cbi8vIFRoZSBjbG9zZXN0IGVuY2xvc2luZyBzY29wZSB0aGF0IGdvdmVybnMgdGhpcyBub2RlLlxuTlBwLl9jb21wdXRlU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHZhciBwcCA9IHRoaXMucGFyZW50UGF0aDtcbiAgICB2YXIgc2NvcGUgPSBwcCAmJiBwcC5zY29wZTtcblxuICAgIGlmIChuLk5vZGUuY2hlY2sodmFsdWUpICYmXG4gICAgICAgIFNjb3BlLmlzRXN0YWJsaXNoZWRCeSh2YWx1ZSkpIHtcbiAgICAgICAgc2NvcGUgPSBuZXcgU2NvcGUodGhpcywgc2NvcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZSB8fCBudWxsO1xufTtcblxuTlBwLmdldFZhbHVlUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHR5cGVzLmdldEZpZWxkVmFsdWUodGhpcy52YWx1ZSwgbmFtZSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoaXMubm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIHBhcmVudGhlc2VzIGluIG9yZGVyXG4gKiBmb3IgYSBwYXJzZXIgdG8gcmVwcm9kdWNlIHRoZSBzYW1lIGxvY2FsIEFTVCBzdHJ1Y3R1cmUuXG4gKlxuICogRm9yIGluc3RhbmNlLCBpbiB0aGUgZXhwcmVzc2lvbiBgKDEgKyAyKSAqIDNgLCB0aGUgQmluYXJ5RXhwcmVzc2lvblxuICogd2hvc2Ugb3BlcmF0b3IgaXMgXCIrXCIgbmVlZHMgcGFyZW50aGVzZXMsIGJlY2F1c2UgYDEgKyAyICogM2Agd291bGRcbiAqIHBhcnNlIGRpZmZlcmVudGx5LlxuICpcbiAqIElmIGFzc3VtZUV4cHJlc3Npb25Db250ZXh0ID09PSB0cnVlLCB3ZSBkb24ndCB3b3JyeSBhYm91dCBlZGdlIGNhc2VzXG4gKiBsaWtlIGFuIGFub255bW91cyBGdW5jdGlvbkV4cHJlc3Npb24gYXBwZWFyaW5nIGxleGljYWxseSBmaXJzdCBpbiBpdHNcbiAqIGVuY2xvc2luZyBzdGF0ZW1lbnQgYW5kIHRodXMgbmVlZGluZyBwYXJlbnRoZXNlcyB0byBhdm9pZCBiZWluZyBwYXJzZWRcbiAqIGFzIGEgRnVuY3Rpb25EZWNsYXJhdGlvbiB3aXRoIGEgbWlzc2luZyBuYW1lLlxuICovXG5OUHAubmVlZHNQYXJlbnMgPSBmdW5jdGlvbihhc3N1bWVFeHByZXNzaW9uQ29udGV4dCkge1xuICAgIHZhciBwcCA9IHRoaXMucGFyZW50UGF0aDtcbiAgICBpZiAoIXBwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG5cbiAgICAvLyBPbmx5IGV4cHJlc3Npb25zIG5lZWQgcGFyZW50aGVzZXMuXG4gICAgaWYgKCFuLkV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpZXJzIG5ldmVyIG5lZWQgcGFyZW50aGVzZXMuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlICghbi5Ob2RlLmNoZWNrKHBwLnZhbHVlKSkge1xuICAgICAgICBwcCA9IHBwLnBhcmVudFBhdGg7XG4gICAgICAgIGlmICghcHApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBwcC52YWx1ZTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbiAgICAgICAgICAgICYmIHRoaXMubmFtZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcImNhbGxlZVwiXG4gICAgICAgICAgICAgICAgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZTtcblxuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuXG4gICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgdmFyIHBvID0gcGFyZW50Lm9wZXJhdG9yO1xuICAgICAgICAgICAgdmFyIHBwID0gUFJFQ0VERU5DRVtwb107XG4gICAgICAgICAgICB2YXIgbm8gPSBub2RlLm9wZXJhdG9yO1xuICAgICAgICAgICAgdmFyIG5wID0gUFJFQ0VERU5DRVtub107XG5cbiAgICAgICAgICAgIGlmIChwcCA+IG5wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcCA9PT0gbnAgJiYgdGhpcy5uYW1lID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50LnJpZ2h0LCBub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgICAgICAgLy8gQWx0aG91Z2ggcGFyZW50aGVzZXMgd291bGRuJ3QgaHVydCBhcm91bmQgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zIGluIHRoZSBoZWFkIG9mIGZvciBsb29wcywgdHJhZGl0aW9uYWwgc3R5bGVcbiAgICAgICAgICAgIC8vIGRpY3RhdGVzIHRoYXQgZS5nLiBpKyssIGorKyBzaG91bGQgbm90IGJlIHdyYXBwZWQgd2l0aFxuICAgICAgICAgICAgLy8gcGFyZW50aGVzZXMuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgIT09IFwiZXhwcmVzc2lvblwiO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZXJyIG9uIHRoZSBzaWRlIG9mIG92ZXJwYXJlbnRoZXNpemF0aW9uLCBhZGRpbmdcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0IGV4Y2VwdGlvbnMgYWJvdmUgaWYgdGhpcyBwcm92ZXMgb3ZlcnplYWxvdXMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgY2FzZSBcIllpZWxkRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG4gICAgICAgICAgICAmJiBpc051bWJlci5jaGVjayhub2RlLnZhbHVlKVxuICAgICAgICAgICAgJiYgdGhpcy5uYW1lID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcImNhbGxlZVwiXG4gICAgICAgICAgICAgICAgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZTtcblxuICAgICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcInRlc3RcIlxuICAgICAgICAgICAgICAgICYmIHBhcmVudC50ZXN0ID09PSBub2RlO1xuXG4gICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiICYmXG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09IFwiY2FsbGVlXCIgJiZcbiAgICAgICAgICAgIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc0NhbGxFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzc3VtZUV4cHJlc3Npb25Db250ZXh0ICE9PSB0cnVlICYmXG4gICAgICAgICF0aGlzLmNhbkJlRmlyc3RJblN0YXRlbWVudCgpICYmXG4gICAgICAgIHRoaXMuZmlyc3RJblN0YXRlbWVudCgpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG5vZGUpIHtcbiAgICByZXR1cm4gbi5CaW5hcnlFeHByZXNzaW9uLmNoZWNrKG5vZGUpXG4gICAgICAgIHx8IG4uTG9naWNhbEV4cHJlc3Npb24uY2hlY2sobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzVW5hcnlMaWtlKG5vZGUpIHtcbiAgICByZXR1cm4gbi5VbmFyeUV4cHJlc3Npb24uY2hlY2sobm9kZSlcbiAgICAgICAgLy8gSSBjb25zaWRlcmVkIG1ha2luZyBTcHJlYWRFbGVtZW50IGFuZCBTcHJlYWRQcm9wZXJ0eSBzdWJ0eXBlc1xuICAgICAgICAvLyBvZiBVbmFyeUV4cHJlc3Npb24sIGJ1dCB0aGV5J3JlIG5vdCByZWFsbHkgRXhwcmVzc2lvbiBub2Rlcy5cbiAgICAgICAgfHwgKG4uU3ByZWFkRWxlbWVudCAmJiBuLlNwcmVhZEVsZW1lbnQuY2hlY2sobm9kZSkpXG4gICAgICAgIHx8IChuLlNwcmVhZFByb3BlcnR5ICYmIG4uU3ByZWFkUHJvcGVydHkuY2hlY2sobm9kZSkpO1xufVxuXG52YXIgUFJFQ0VERU5DRSA9IHt9O1xuW1tcInx8XCJdLFxuIFtcIiYmXCJdLFxuIFtcInxcIl0sXG4gW1wiXlwiXSxcbiBbXCImXCJdLFxuIFtcIj09XCIsIFwiPT09XCIsIFwiIT1cIiwgXCIhPT1cIl0sXG4gW1wiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdLFxuIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gW1wiK1wiLCBcIi1cIl0sXG4gW1wiKlwiLCBcIi9cIiwgXCIlXCJdXG5dLmZvckVhY2goZnVuY3Rpb24odGllciwgaSkge1xuICAgIHRpZXIuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgICBQUkVDRURFTkNFW29wXSA9IGk7XG4gICAgfSk7XG59KTtcblxuZnVuY3Rpb24gY29udGFpbnNDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKG4uQ2FsbEV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkuY2hlY2sobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc29tZShjb250YWluc0NhbGxFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAobi5Ob2RlLmNoZWNrKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlcy5zb21lRmllbGQobm9kZSwgZnVuY3Rpb24obmFtZSwgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc0NhbGxFeHByZXNzaW9uKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5OUHAuY2FuQmVGaXJzdEluU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgcmV0dXJuICFuLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhub2RlKVxuICAgICAgICAmJiAhbi5PYmplY3RFeHByZXNzaW9uLmNoZWNrKG5vZGUpO1xufTtcblxuTlBwLmZpcnN0SW5TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmlyc3RJblN0YXRlbWVudCh0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIGZpcnN0SW5TdGF0ZW1lbnQocGF0aCkge1xuICAgIGZvciAodmFyIG5vZGUsIHBhcmVudDsgcGF0aC5wYXJlbnQ7IHBhdGggPSBwYXRoLnBhcmVudCkge1xuICAgICAgICBub2RlID0gcGF0aC5ub2RlO1xuICAgICAgICBwYXJlbnQgPSBwYXRoLnBhcmVudC5ub2RlO1xuXG4gICAgICAgIGlmIChuLkJsb2NrU3RhdGVtZW50LmNoZWNrKHBhcmVudCkgJiZcbiAgICAgICAgICAgIHBhdGgucGFyZW50Lm5hbWUgPT09IFwiYm9keVwiICYmXG4gICAgICAgICAgICBwYXRoLm5hbWUgPT09IDApIHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJlbnQuYm9keVswXSwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLkV4cHJlc3Npb25TdGF0ZW1lbnQuY2hlY2socGFyZW50KSAmJlxuICAgICAgICAgICAgcGF0aC5uYW1lID09PSBcImV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHBhcmVudC5leHByZXNzaW9uLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uU2VxdWVuY2VFeHByZXNzaW9uLmNoZWNrKHBhcmVudCkgJiZcbiAgICAgICAgICAgIHBhdGgucGFyZW50Lm5hbWUgPT09IFwiZXhwcmVzc2lvbnNcIiAmJlxuICAgICAgICAgICAgcGF0aC5uYW1lID09PSAwKSB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50LmV4cHJlc3Npb25zWzBdLCBub2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uQ2FsbEV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJlxuICAgICAgICAgICAgcGF0aC5uYW1lID09PSBcImNhbGxlZVwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50LmNhbGxlZSwgbm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLk1lbWJlckV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJlxuICAgICAgICAgICAgcGF0aC5uYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50Lm9iamVjdCwgbm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLkNvbmRpdGlvbmFsRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmXG4gICAgICAgICAgICBwYXRoLm5hbWUgPT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50LnRlc3QsIG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCaW5hcnkocGFyZW50KSAmJlxuICAgICAgICAgICAgcGF0aC5uYW1lID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHBhcmVudC5sZWZ0LCBub2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uVW5hcnlFeHByZXNzaW9uLmNoZWNrKHBhcmVudCkgJiZcbiAgICAgICAgICAgICFwYXJlbnQucHJlZml4ICYmXG4gICAgICAgICAgICBwYXRoLm5hbWUgPT09IFwiYXJndW1lbnRcIikge1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHBhcmVudC5hcmd1bWVudCwgbm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBQcnVuaW5nIGNlcnRhaW4gbm9kZXMgd2lsbCByZXN1bHQgaW4gZW1wdHkgb3IgaW5jb21wbGV0ZSBub2RlcywgaGVyZSB3ZSBjbGVhbiB0aG9zZSBub2RlcyB1cC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcE5vZGVzQWZ0ZXJQcnVuZShyZW1haW5pbmdOb2RlUGF0aCkge1xuICAgIGlmIChuLlZhcmlhYmxlRGVjbGFyYXRpb24uY2hlY2socmVtYWluaW5nTm9kZVBhdGgubm9kZSkpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHJlbWFpbmluZ05vZGVQYXRoLmdldCgnZGVjbGFyYXRpb25zJykudmFsdWU7XG4gICAgICAgIGlmICghZGVjbGFyYXRpb25zIHx8IGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmdOb2RlUGF0aC5wcnVuZSgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLkV4cHJlc3Npb25TdGF0ZW1lbnQuY2hlY2socmVtYWluaW5nTm9kZVBhdGgubm9kZSkpIHtcbiAgICAgICAgaWYgKCFyZW1haW5pbmdOb2RlUGF0aC5nZXQoJ2V4cHJlc3Npb24nKS52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZ05vZGVQYXRoLnBydW5lKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG4uSWZTdGF0ZW1lbnQuY2hlY2socmVtYWluaW5nTm9kZVBhdGgubm9kZSkpIHtcbiAgICAgICAgY2xlYW5VcElmU3RhdGVtZW50QWZ0ZXJQcnVuZShyZW1haW5pbmdOb2RlUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ05vZGVQYXRoO1xufVxuXG5mdW5jdGlvbiBjbGVhblVwSWZTdGF0ZW1lbnRBZnRlclBydW5lKGlmU3RhdGVtZW50KSB7XG4gICAgdmFyIHRlc3RFeHByZXNzaW9uID0gaWZTdGF0ZW1lbnQuZ2V0KCd0ZXN0JykudmFsdWU7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGlmU3RhdGVtZW50LmdldCgnYWx0ZXJuYXRlJykudmFsdWU7XG4gICAgdmFyIGNvbnNlcXVlbnQgPSBpZlN0YXRlbWVudC5nZXQoJ2NvbnNlcXVlbnQnKS52YWx1ZTtcblxuICAgIGlmICghY29uc2VxdWVudCAmJiAhYWx0ZXJuYXRlKSB7XG4gICAgICAgIHZhciB0ZXN0RXhwcmVzc2lvblN0YXRlbWVudCA9IGIuZXhwcmVzc2lvblN0YXRlbWVudCh0ZXN0RXhwcmVzc2lvbik7XG5cbiAgICAgICAgaWZTdGF0ZW1lbnQucmVwbGFjZSh0ZXN0RXhwcmVzc2lvblN0YXRlbWVudCk7XG4gICAgfSBlbHNlIGlmICghY29uc2VxdWVudCAmJiBhbHRlcm5hdGUpIHtcbiAgICAgICAgdmFyIG5lZ2F0ZWRUZXN0RXhwcmVzc2lvbiA9IGIudW5hcnlFeHByZXNzaW9uKCchJywgdGVzdEV4cHJlc3Npb24sIHRydWUpO1xuXG4gICAgICAgIGlmIChuLlVuYXJ5RXhwcmVzc2lvbi5jaGVjayh0ZXN0RXhwcmVzc2lvbikgJiYgdGVzdEV4cHJlc3Npb24ub3BlcmF0b3IgPT09ICchJykge1xuICAgICAgICAgICAgbmVnYXRlZFRlc3RFeHByZXNzaW9uID0gdGVzdEV4cHJlc3Npb24uYXJndW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZlN0YXRlbWVudC5nZXQoXCJ0ZXN0XCIpLnJlcGxhY2UobmVnYXRlZFRlc3RFeHByZXNzaW9uKTtcbiAgICAgICAgaWZTdGF0ZW1lbnQuZ2V0KFwiY29uc2VxdWVudFwiKS5yZXBsYWNlKGFsdGVybmF0ZSk7XG4gICAgICAgIGlmU3RhdGVtZW50LmdldChcImFsdGVybmF0ZVwiKS5yZXBsYWNlKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVQYXRoO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBOb2RlUGF0aCA9IHJlcXVpcmUoXCIuL25vZGUtcGF0aFwiKTtcbnZhciBOb2RlID0gdHlwZXMubmFtZWRUeXBlcy5Ob2RlO1xudmFyIGlzQXJyYXkgPSB0eXBlcy5idWlsdEluVHlwZXMuYXJyYXk7XG52YXIgaXNPYmplY3QgPSB0eXBlcy5idWlsdEluVHlwZXMub2JqZWN0O1xudmFyIGlzRnVuY3Rpb24gPSB0eXBlcy5idWlsdEluVHlwZXMuZnVuY3Rpb247XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIFBhdGhWaXNpdG9yKCkge1xuICAgIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgUGF0aFZpc2l0b3IpO1xuXG4gICAgLy8gUGVybWFuZW50IHN0YXRlLlxuICAgIHRoaXMuX3JldXNhYmxlQ29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5fbWV0aG9kTmFtZVRhYmxlID0gY29tcHV0ZU1ldGhvZE5hbWVUYWJsZSh0aGlzKTtcbiAgICB0aGlzLkNvbnRleHQgPSBtYWtlQ29udGV4dENvbnN0cnVjdG9yKHRoaXMpO1xuXG4gICAgLy8gU3RhdGUgcmVzZXQgZXZlcnkgdGltZSBQYXRoVmlzaXRvci5wcm90b3R5cGUudmlzaXQgaXMgY2FsbGVkLlxuICAgIHRoaXMuX3Zpc2l0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY2hhbmdlUmVwb3J0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU1ldGhvZE5hbWVUYWJsZSh2aXNpdG9yKSB7XG4gICAgdmFyIHR5cGVOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHZpc2l0b3IpIHtcbiAgICAgICAgaWYgKC9edmlzaXRbQS1aXS8udGVzdChtZXRob2ROYW1lKSkge1xuICAgICAgICAgICAgdHlwZU5hbWVzW21ldGhvZE5hbWUuc2xpY2UoXCJ2aXNpdFwiLmxlbmd0aCldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdXBlcnR5cGVUYWJsZSA9IHR5cGVzLmNvbXB1dGVTdXBlcnR5cGVMb29rdXBUYWJsZSh0eXBlTmFtZXMpO1xuICAgIHZhciBtZXRob2ROYW1lVGFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdmFyIHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKHN1cGVydHlwZVRhYmxlKTtcbiAgICB2YXIgdHlwZU5hbWVDb3VudCA9IHR5cGVOYW1lcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTmFtZUNvdW50OyArK2kpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZU5hbWVzW2ldO1xuICAgICAgICBtZXRob2ROYW1lID0gXCJ2aXNpdFwiICsgc3VwZXJ0eXBlVGFibGVbdHlwZU5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbi5jaGVjayh2aXNpdG9yW21ldGhvZE5hbWVdKSkge1xuICAgICAgICAgICAgbWV0aG9kTmFtZVRhYmxlW3R5cGVOYW1lXSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kTmFtZVRhYmxlO1xufVxuXG5QYXRoVmlzaXRvci5mcm9tTWV0aG9kc09iamVjdCA9IGZ1bmN0aW9uIGZyb21NZXRob2RzT2JqZWN0KG1ldGhvZHMpIHtcbiAgICBpZiAobWV0aG9kcyBpbnN0YW5jZW9mIFBhdGhWaXNpdG9yKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3QuY2hlY2sobWV0aG9kcykpIHtcbiAgICAgICAgLy8gQW4gZW1wdHkgdmlzaXRvcj9cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoVmlzaXRvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWaXNpdG9yKCkge1xuICAgICAgICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIFZpc2l0b3IpO1xuICAgICAgICBQYXRoVmlzaXRvci5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBWcCA9IFZpc2l0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQVnApO1xuICAgIFZwLmNvbnN0cnVjdG9yID0gVmlzaXRvcjtcblxuICAgIGV4dGVuZChWcCwgbWV0aG9kcyk7XG4gICAgZXh0ZW5kKFZpc2l0b3IsIFBhdGhWaXNpdG9yKTtcblxuICAgIGlzRnVuY3Rpb24uYXNzZXJ0KFZpc2l0b3IuZnJvbU1ldGhvZHNPYmplY3QpO1xuICAgIGlzRnVuY3Rpb24uYXNzZXJ0KFZpc2l0b3IudmlzaXQpO1xuXG4gICAgcmV0dXJuIG5ldyBWaXNpdG9yO1xufTtcblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChzb3VyY2UsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5QYXRoVmlzaXRvci52aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIG1ldGhvZHMpIHtcbiAgICByZXR1cm4gUGF0aFZpc2l0b3IuZnJvbU1ldGhvZHNPYmplY3QobWV0aG9kcykudmlzaXQobm9kZSk7XG59O1xuXG52YXIgUFZwID0gUGF0aFZpc2l0b3IucHJvdG90eXBlO1xuXG52YXIgcmVjdXJzaXZlVmlzaXRXYXJuaW5nID0gW1xuICAgIFwiUmVjdXJzaXZlbHkgY2FsbGluZyB2aXNpdG9yLnZpc2l0KHBhdGgpIHJlc2V0cyB2aXNpdG9yIHN0YXRlLlwiLFxuICAgIFwiVHJ5IHRoaXMudmlzaXQocGF0aCkgb3IgdGhpcy50cmF2ZXJzZShwYXRoKSBpbnN0ZWFkLlwiXG5dLmpvaW4oXCIgXCIpO1xuXG5QVnAudmlzaXQgPSBmdW5jdGlvbigpIHtcbiAgICBhc3NlcnQub2soIXRoaXMuX3Zpc2l0aW5nLCByZWN1cnNpdmVWaXNpdFdhcm5pbmcpO1xuXG4gICAgLy8gUHJpdmF0ZSBzdGF0ZSB0aGF0IG5lZWRzIHRvIGJlIHJlc2V0IGJlZm9yZSBldmVyeSB0cmF2ZXJzYWwuXG4gICAgdGhpcy5fdmlzaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NoYW5nZVJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYWJvcnRSZXF1ZXN0ZWQgPSBmYWxzZTtcblxuICAgIHZhciBhcmdjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmdjKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgaWYgKCEoYXJnc1swXSBpbnN0YW5jZW9mIE5vZGVQYXRoKSkge1xuICAgICAgICBhcmdzWzBdID0gbmV3IE5vZGVQYXRoKHsgcm9vdDogYXJnc1swXSB9KS5nZXQoXCJyb290XCIpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyAudmlzaXQuXG4gICAgdGhpcy5yZXNldC5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy52aXNpdFdpdGhvdXRSZXNldChhcmdzWzBdKTtcbiAgICAgICAgdmFyIGRpZE5vdFRocm93ID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl92aXNpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZGlkTm90VGhyb3cgJiYgdGhpcy5fYWJvcnRSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMudmlzaXRXaXRob3V0UmVzZXQgdGhyZXcgYW4gZXhjZXB0aW9uIGFuZFxuICAgICAgICAgICAgLy8gdGhpcy5fYWJvcnRSZXF1ZXN0ZWQgd2FzIHNldCB0byB0cnVlLCByZXR1cm4gdGhlIHJvb3Qgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBBU1QgaW5zdGVhZCBvZiBsZXR0aW5nIHRoZSBleGNlcHRpb24gcHJvcGFnYXRlLCBzbyB0aGF0XG4gICAgICAgICAgICAvLyBjbGllbnQgY29kZSBkb2VzIG5vdCBoYXZlIHRvIHByb3ZpZGUgYSB0cnktY2F0Y2ggYmxvY2sgdG9cbiAgICAgICAgICAgIC8vIGludGVyY2VwdCB0aGUgQWJvcnRSZXF1ZXN0IGV4Y2VwdGlvbi4gIE90aGVyIGtpbmRzIG9mXG4gICAgICAgICAgICAvLyBleGNlcHRpb25zIHdpbGwgcHJvcGFnYXRlIHdpdGhvdXQgYmVpbmcgaW50ZXJjZXB0ZWQgYW5kXG4gICAgICAgICAgICAvLyByZXRocm93biBieSBhIGNhdGNoIGJsb2NrLCBzbyB0aGVpciBzdGFja3Mgd2lsbCBhY2N1cmF0ZWx5XG4gICAgICAgICAgICAvLyByZWZsZWN0IHRoZSBvcmlnaW5hbCB0aHJvd2luZyBjb250ZXh0LlxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cblBWcC5BYm9ydFJlcXVlc3QgPSBmdW5jdGlvbiBBYm9ydFJlcXVlc3QoKSB7fTtcblBWcC5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2aXNpdG9yID0gdGhpcztcbiAgICB2aXNpdG9yLl9hYm9ydFJlcXVlc3RlZCA9IHRydWU7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgdmlzaXRvci5BYm9ydFJlcXVlc3QoKTtcblxuICAgIC8vIElmIHlvdSBkZWNpZGUgdG8gY2F0Y2ggdGhpcyBleGNlcHRpb24gYW5kIHN0b3AgaXQgZnJvbSBwcm9wYWdhdGluZyxcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2FsbCBpdHMgY2FuY2VsIG1ldGhvZCB0byBhdm9pZCBzaWxlbmNpbmcgb3RoZXJcbiAgICAvLyBleGNlcHRpb25zIHRoYXQgbWlnaHQgYmUgdGhyb3duIGxhdGVyIGluIHRoZSB0cmF2ZXJzYWwuXG4gICAgcmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmlzaXRvci5fYWJvcnRSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhyb3cgcmVxdWVzdDtcbn07XG5cblBWcC5yZXNldCA9IGZ1bmN0aW9uKHBhdGgvKiwgYWRkaXRpb25hbCBhcmd1bWVudHMgKi8pIHtcbiAgICAvLyBFbXB0eSBzdHViOyBtYXkgYmUgcmVhc3NpZ25lZCBvciBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG59O1xuXG5QVnAudmlzaXRXaXRob3V0UmVzZXQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpIHtcbiAgICAgICAgLy8gU2luY2UgdGhpcy5Db250ZXh0LnByb3RvdHlwZSA9PT0gdGhpcywgdGhlcmUncyBhIGNoYW5jZSB3ZVxuICAgICAgICAvLyBtaWdodCBhY2NpZGVudGFsbHkgY2FsbCBjb250ZXh0LnZpc2l0V2l0aG91dFJlc2V0LiBJZiB0aGF0XG4gICAgICAgIC8vIGhhcHBlbnMsIHJlLWludm9rZSB0aGUgbWV0aG9kIGFnYWluc3QgY29udGV4dC52aXNpdG9yLlxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdG9yLnZpc2l0V2l0aG91dFJlc2V0KHBhdGgpO1xuICAgIH1cblxuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuICAgIHZhciB2YWx1ZSA9IHBhdGgudmFsdWU7XG5cbiAgICB2YXIgbWV0aG9kTmFtZSA9IE5vZGUuY2hlY2sodmFsdWUpICYmIHRoaXMuX21ldGhvZE5hbWVUYWJsZVt2YWx1ZS50eXBlXTtcbiAgICBpZiAobWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuYWNxdWlyZUNvbnRleHQocGF0aCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5pbnZva2VWaXNpdG9yTWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIHZpc2l0b3IgbWV0aG9kIHRvIGNhbGwsIHZpc2l0IHRoZSBjaGlsZHJlbiBvZlxuICAgICAgICAvLyB0aGlzIG5vZGUgZ2VuZXJpY2FsbHkuXG4gICAgICAgIHJldHVybiB2aXNpdENoaWxkcmVuKHBhdGgsIHRoaXMpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHZpc2l0Q2hpbGRyZW4ocGF0aCwgdmlzaXRvcikge1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuICAgIGFzc2VydC5vayh2aXNpdG9yIGluc3RhbmNlb2YgUGF0aFZpc2l0b3IpO1xuXG4gICAgdmFyIHZhbHVlID0gcGF0aC52YWx1ZTtcblxuICAgIGlmIChpc0FycmF5LmNoZWNrKHZhbHVlKSkge1xuICAgICAgICBwYXRoLmVhY2godmlzaXRvci52aXNpdFdpdGhvdXRSZXNldCwgdmlzaXRvcik7XG4gICAgfSBlbHNlIGlmICghaXNPYmplY3QuY2hlY2sodmFsdWUpKSB7XG4gICAgICAgIC8vIE5vIGNoaWxkcmVuIHRvIHZpc2l0LlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZE5hbWVzID0gdHlwZXMuZ2V0RmllbGROYW1lcyh2YWx1ZSk7XG4gICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROYW1lcy5sZW5ndGg7XG4gICAgICAgIHZhciBjaGlsZFBhdGhzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBjaGlsZE5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh2YWx1ZSwgY2hpbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2NoaWxkTmFtZV0gPSB0eXBlcy5nZXRGaWVsZFZhbHVlKHZhbHVlLCBjaGlsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRQYXRocy5wdXNoKHBhdGguZ2V0KGNoaWxkTmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZpc2l0b3IudmlzaXRXaXRob3V0UmVzZXQoY2hpbGRQYXRoc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC52YWx1ZTtcbn1cblxuUFZwLmFjcXVpcmVDb250ZXh0ID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICh0aGlzLl9yZXVzYWJsZUNvbnRleHRTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbnRleHQocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXVzYWJsZUNvbnRleHRTdGFjay5wb3AoKS5yZXNldChwYXRoKTtcbn07XG5cblBWcC5yZWxlYXNlQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBhc3NlcnQub2soY29udGV4dCBpbnN0YW5jZW9mIHRoaXMuQ29udGV4dCk7XG4gICAgdGhpcy5fcmV1c2FibGVDb250ZXh0U3RhY2sucHVzaChjb250ZXh0KTtcbiAgICBjb250ZXh0LmN1cnJlbnRQYXRoID0gbnVsbDtcbn07XG5cblBWcC5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2hhbmdlUmVwb3J0ZWQgPSB0cnVlO1xufTtcblxuUFZwLndhc0NoYW5nZVJlcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZVJlcG9ydGVkO1xufTtcblxuZnVuY3Rpb24gbWFrZUNvbnRleHRDb25zdHJ1Y3Rvcih2aXNpdG9yKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dChwYXRoKSB7XG4gICAgICAgIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgQ29udGV4dCk7XG4gICAgICAgIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgUGF0aFZpc2l0b3IpO1xuICAgICAgICBhc3NlcnQub2socGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aXNpdG9yXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB2aXNpdG9yLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gdHJ1ZTtcblxuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG5cbiAgICBhc3NlcnQub2sodmlzaXRvciBpbnN0YW5jZW9mIFBhdGhWaXNpdG9yKTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgdmlzaXRvciBvYmplY3QgaXMgdGhlIHByb3RvdHlwZSBvZiBDb250ZXh0LnByb3RvdHlwZSxcbiAgICAvLyBzbyBhbGwgdmlzaXRvciBtZXRob2RzIGFyZSBpbmhlcml0ZWQgYnkgY29udGV4dCBvYmplY3RzLlxuICAgIHZhciBDcCA9IENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh2aXNpdG9yKTtcblxuICAgIENwLmNvbnN0cnVjdG9yID0gQ29udGV4dDtcbiAgICBleHRlbmQoQ3AsIHNoYXJlZENvbnRleHRQcm90b01ldGhvZHMpO1xuXG4gICAgcmV0dXJuIENvbnRleHQ7XG59XG5cbi8vIEV2ZXJ5IFBhdGhWaXNpdG9yIGhhcyBhIGRpZmZlcmVudCB0aGlzLkNvbnRleHQgY29uc3RydWN0b3IgYW5kXG4vLyB0aGlzLkNvbnRleHQucHJvdG90eXBlIG9iamVjdCwgYnV0IHRob3NlIHByb3RvdHlwZXMgY2FuIGFsbCB1c2UgdGhlXG4vLyBzYW1lIHJlc2V0LCBpbnZva2VWaXNpdG9yTWV0aG9kLCBhbmQgdHJhdmVyc2UgZnVuY3Rpb24gb2JqZWN0cy5cbnZhciBzaGFyZWRDb250ZXh0UHJvdG9NZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy5yZXNldCA9XG5mdW5jdGlvbiByZXNldChwYXRoKSB7XG4gICAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpO1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuXG4gICAgdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5zaGFyZWRDb250ZXh0UHJvdG9NZXRob2RzLmludm9rZVZpc2l0b3JNZXRob2QgPVxuZnVuY3Rpb24gaW52b2tlVmlzaXRvck1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpO1xuICAgIGFzc2VydC5vayh0aGlzLmN1cnJlbnRQYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmlzaXRvclttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVmlzaXRvciBtZXRob2RzIHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgaGF2ZSBoYW5kbGVkXG4gICAgICAgIC8vIHRoZWlyIG93biB0cmF2ZXJzYWwgbmVlZHMsIGFuZCB3ZSBzaG91bGQgbm90IGNvbXBsYWluIGlmXG4gICAgICAgIC8vIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlIGlzIHN0aWxsIHRydWUuXG4gICAgICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gZmFsc2U7XG5cbiAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEFueSBvdGhlciBub24tdW5kZWZpbmVkIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHZpc2l0b3IgbWV0aG9kXG4gICAgICAgIC8vIGlzIGludGVycHJldGVkIGFzIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoLnJlcGxhY2UocmVzdWx0KVswXTtcblxuICAgICAgICBpZiAodGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMudHJhdmVyc2Ugc3RpbGwgaGFzbid0IGJlZW4gY2FsbGVkLCB2aXNpdCB0aGVcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSByZXBsYWNlbWVudCBub2RlLlxuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZSh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChcbiAgICAgICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UsIGZhbHNlLFxuICAgICAgICBcIk11c3QgZWl0aGVyIGNhbGwgdGhpcy50cmF2ZXJzZSBvciByZXR1cm4gZmFsc2UgaW4gXCIgKyBtZXRob2ROYW1lXG4gICAgKTtcblxuICAgIHZhciBwYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICByZXR1cm4gcGF0aCAmJiBwYXRoLnZhbHVlO1xufTtcblxuc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy50cmF2ZXJzZSA9XG5mdW5jdGlvbiB0cmF2ZXJzZShwYXRoLCBuZXdWaXNpdG9yKSB7XG4gICAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpO1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuICAgIGFzc2VydC5vayh0aGlzLmN1cnJlbnRQYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuXG4gICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UgPSBmYWxzZTtcblxuICAgIHJldHVybiB2aXNpdENoaWxkcmVuKHBhdGgsIFBhdGhWaXNpdG9yLmZyb21NZXRob2RzT2JqZWN0KFxuICAgICAgICBuZXdWaXNpdG9yIHx8IHRoaXMudmlzaXRvclxuICAgICkpO1xufTtcblxuc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy52aXNpdCA9XG5mdW5jdGlvbiB2aXNpdChwYXRoLCBuZXdWaXNpdG9yKSB7XG4gICAgYXNzZXJ0Lm9rKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpO1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuICAgIGFzc2VydC5vayh0aGlzLmN1cnJlbnRQYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgpO1xuXG4gICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UgPSBmYWxzZTtcblxuICAgIHJldHVybiBQYXRoVmlzaXRvci5mcm9tTWV0aG9kc09iamVjdChcbiAgICAgICAgbmV3VmlzaXRvciB8fCB0aGlzLnZpc2l0b3JcbiAgICApLnZpc2l0V2l0aG91dFJlc2V0KHBhdGgpO1xufTtcblxuc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gcmVwb3J0Q2hhbmdlZCgpIHtcbiAgICB0aGlzLnZpc2l0b3IucmVwb3J0Q2hhbmdlZCgpO1xufTtcblxuc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy52aXNpdG9yLmFib3J0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGhWaXNpdG9yO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgaXNBcnJheSA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5hcnJheTtcbnZhciBpc051bWJlciA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5udW1iZXI7XG52YXIgQXAgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgc2xpY2UgPSBBcC5zbGljZTtcbnZhciBtYXAgPSBBcC5tYXA7XG5cbmZ1bmN0aW9uIFBhdGgodmFsdWUsIHBhcmVudFBhdGgsIG5hbWUpIHtcbiAgICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIFBhdGgpO1xuXG4gICAgaWYgKHBhcmVudFBhdGgpIHtcbiAgICAgICAgYXNzZXJ0Lm9rKHBhcmVudFBhdGggaW5zdGFuY2VvZiBQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVGhlIHZhbHVlIGVuY2Fwc3VsYXRlZCBieSB0aGlzIFBhdGgsIGdlbmVyYWxseSBlcXVhbCB0b1xuICAgIC8vIHBhcmVudFBhdGgudmFsdWVbbmFtZV0gaWYgd2UgaGF2ZSBhIHBhcmVudFBhdGguXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgLy8gVGhlIGltbWVkaWF0ZSBwYXJlbnQgUGF0aCBvZiB0aGlzIFBhdGguXG4gICAgdGhpcy5wYXJlbnRQYXRoID0gcGFyZW50UGF0aDtcblxuICAgIC8vIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBvZiBwYXJlbnRQYXRoLnZhbHVlIHRocm91Z2ggd2hpY2ggdGhpc1xuICAgIC8vIFBhdGgncyB2YWx1ZSB3YXMgcmVhY2hlZC5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLy8gQ2FsbGluZyBwYXRoLmdldChcImNoaWxkXCIpIG11bHRpcGxlIHRpbWVzIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lXG4gICAgLy8gY2hpbGQgUGF0aCBvYmplY3QsIGZvciBib3RoIHBlcmZvcm1hbmNlIGFuZCBjb25zaXN0ZW5jeSByZWFzb25zLlxuICAgIHRoaXMuX19jaGlsZENhY2hlID0gbnVsbDtcbn1cblxudmFyIFBwID0gUGF0aC5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGdldENoaWxkQ2FjaGUocGF0aCkge1xuICAgIC8vIExhemlseSBjcmVhdGUgdGhlIGNoaWxkIGNhY2hlLiBUaGlzIGFsc28gY2hlYXBlbnMgY2FjaGVcbiAgICAvLyBpbnZhbGlkYXRpb24sIHNpbmNlIHlvdSBjYW4ganVzdCByZXNldCBwYXRoLl9fY2hpbGRDYWNoZSB0byBudWxsLlxuICAgIHJldHVybiBwYXRoLl9fY2hpbGRDYWNoZSB8fCAocGF0aC5fX2NoaWxkQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRQYXRoKHBhdGgsIG5hbWUpIHtcbiAgICB2YXIgY2FjaGUgPSBnZXRDaGlsZENhY2hlKHBhdGgpO1xuICAgIHZhciBhY3R1YWxDaGlsZFZhbHVlID0gcGF0aC5nZXRWYWx1ZVByb3BlcnR5KG5hbWUpO1xuICAgIHZhciBjaGlsZFBhdGggPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAoIWhhc093bi5jYWxsKGNhY2hlLCBuYW1lKSB8fFxuICAgICAgICAvLyBFbnN1cmUgY29uc2lzdGVuY3kgYmV0d2VlbiBjYWNoZSBhbmQgcmVhbGl0eS5cbiAgICAgICAgY2hpbGRQYXRoLnZhbHVlICE9PSBhY3R1YWxDaGlsZFZhbHVlKSB7XG4gICAgICAgIGNoaWxkUGF0aCA9IGNhY2hlW25hbWVdID0gbmV3IHBhdGguY29uc3RydWN0b3IoXG4gICAgICAgICAgICBhY3R1YWxDaGlsZFZhbHVlLCBwYXRoLCBuYW1lXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZFBhdGg7XG59XG5cbi8vIFRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0aGF0IG5lZWQgdG9cbi8vIGhhbmRsZSBtaXNzaW5nIHByb3BlcnRpZXMsIGV0Yy5cblBwLmdldFZhbHVlUHJvcGVydHkgPSBmdW5jdGlvbiBnZXRWYWx1ZVByb3BlcnR5KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVtuYW1lXTtcbn07XG5cblBwLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzO1xuICAgIHZhciBuYW1lcyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY291bnQgPSBuYW1lcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcGF0aCA9IGdldENoaWxkUGF0aChwYXRoLCBuYW1lc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5QcC5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBjaGlsZFBhdGhzID0gW107XG4gICAgdmFyIGxlbiA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcblxuICAgIC8vIENvbGxlY3QgYWxsIHRoZSBvcmlnaW5hbCBjaGlsZCBwYXRocyBiZWZvcmUgaW52b2tpbmcgdGhlIGNhbGxiYWNrLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKHRoaXMudmFsdWUsIGkpKSB7XG4gICAgICAgICAgICBjaGlsZFBhdGhzW2ldID0gdGhpcy5nZXQoaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIG9uIGp1c3QgdGhlIG9yaWdpbmFsIGNoaWxkIHBhdGhzLCByZWdhcmRsZXNzIG9mXG4gICAgLy8gYW55IG1vZGlmaWNhdGlvbnMgbWFkZSB0byB0aGUgYXJyYXkgYnkgdGhlIGNhbGxiYWNrLiBJIGNob3NlIHRoZXNlXG4gICAgLy8gc2VtYW50aWNzIG92ZXIgY2xldmVybHkgaW52b2tpbmcgdGhlIGNhbGxiYWNrIG9uIG5ldyBlbGVtZW50cyBiZWNhdXNlXG4gICAgLy8gdGhpcyB3YXkgaXMgbXVjaCBlYXNpZXIgdG8gcmVhc29uIGFib3V0LlxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChjaGlsZFBhdGhzLCBpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBjaGlsZFBhdGhzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBwLm1hcCA9IGZ1bmN0aW9uIG1hcChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZFBhdGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzLCBjaGlsZFBhdGgpKTtcbiAgICB9LCBjb250ZXh0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5QcC5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oY2hpbGRQYXRoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXMsIGNoaWxkUGF0aCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBjb250ZXh0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBlbXB0eU1vdmVzKCkge31cbmZ1bmN0aW9uIGdldE1vdmVzKHBhdGgsIG9mZnNldCwgc3RhcnQsIGVuZCkge1xuICAgIGlzQXJyYXkuYXNzZXJ0KHBhdGgudmFsdWUpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHlNb3ZlcztcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gcGF0aC52YWx1ZS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5TW92ZXM7XG4gICAgfVxuXG4gICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChhcmdjID09PSAyKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoYXJnYyA9PT0gMykge1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgaXNOdW1iZXIuYXNzZXJ0KHN0YXJ0KTtcbiAgICBpc051bWJlci5hc3NlcnQoZW5kKTtcblxuICAgIHZhciBtb3ZlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGNhY2hlID0gZ2V0Q2hpbGRDYWNoZShwYXRoKTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChwYXRoLnZhbHVlLCBpKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguZ2V0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNoaWxkUGF0aC5uYW1lLCBpKTtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IGkgKyBvZmZzZXQ7XG4gICAgICAgICAgICBjaGlsZFBhdGgubmFtZSA9IG5ld0luZGV4O1xuICAgICAgICAgICAgbW92ZXNbbmV3SW5kZXhdID0gY2hpbGRQYXRoO1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIGNhY2hlLmxlbmd0aDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbmV3SW5kZXggaW4gbW92ZXMpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBtb3Zlc1tuZXdJbmRleF07XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2hpbGRQYXRoLm5hbWUsICtuZXdJbmRleCk7XG4gICAgICAgICAgICBjYWNoZVtuZXdJbmRleF0gPSBjaGlsZFBhdGg7XG4gICAgICAgICAgICBwYXRoLnZhbHVlW25ld0luZGV4XSA9IGNoaWxkUGF0aC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblBwLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgdmFyIG1vdmUgPSBnZXRNb3Zlcyh0aGlzLCAtMSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWUuc2hpZnQoKTtcbiAgICBtb3ZlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBwLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KG5vZGUpIHtcbiAgICB2YXIgbW92ZSA9IGdldE1vdmVzKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlLnVuc2hpZnQuYXBwbHkodGhpcy52YWx1ZSwgYXJndW1lbnRzKTtcbiAgICBtb3ZlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBwLnB1c2ggPSBmdW5jdGlvbiBwdXNoKG5vZGUpIHtcbiAgICBpc0FycmF5LmFzc2VydCh0aGlzLnZhbHVlKTtcbiAgICBkZWxldGUgZ2V0Q2hpbGRDYWNoZSh0aGlzKS5sZW5ndGhcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5wdXNoLmFwcGx5KHRoaXMudmFsdWUsIGFyZ3VtZW50cyk7XG59O1xuXG5QcC5wb3AgPSBmdW5jdGlvbiBwb3AoKSB7XG4gICAgaXNBcnJheS5hc3NlcnQodGhpcy52YWx1ZSk7XG4gICAgdmFyIGNhY2hlID0gZ2V0Q2hpbGRDYWNoZSh0aGlzKTtcbiAgICBkZWxldGUgY2FjaGVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICBkZWxldGUgY2FjaGUubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnBvcCgpO1xufTtcblxuUHAuaW5zZXJ0QXQgPSBmdW5jdGlvbiBpbnNlcnRBdChpbmRleCwgbm9kZSkge1xuICAgIHZhciBhcmdjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbW92ZSA9IGdldE1vdmVzKHRoaXMsIGFyZ2MgLSAxLCBpbmRleCk7XG4gICAgaWYgKG1vdmUgPT09IGVtcHR5TW92ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICB0aGlzLnZhbHVlW2luZGV4ICsgaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIG1vdmUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUHAuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKG5vZGUpIHtcbiAgICB2YXIgcHAgPSB0aGlzLnBhcmVudFBhdGg7XG4gICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRBdEFyZ3MgPSBbdGhpcy5uYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgICBpbnNlcnRBdEFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHAuaW5zZXJ0QXQuYXBwbHkocHAsIGluc2VydEF0QXJncyk7XG59O1xuXG5QcC5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgcHAgPSB0aGlzLnBhcmVudFBhdGg7XG4gICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRBdEFyZ3MgPSBbdGhpcy5uYW1lICsgMV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgICAgaW5zZXJ0QXRBcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHBwLmluc2VydEF0LmFwcGx5KHBwLCBpbnNlcnRBdEFyZ3MpO1xufTtcblxuZnVuY3Rpb24gcmVwYWlyUmVsYXRpb25zaGlwV2l0aFBhcmVudChwYXRoKSB7XG4gICAgYXNzZXJ0Lm9rKHBhdGggaW5zdGFuY2VvZiBQYXRoKTtcblxuICAgIHZhciBwcCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICBpZiAoIXBwKSB7XG4gICAgICAgIC8vIE9ycGhhbiBwYXRocyBoYXZlIG5vIHJlbGF0aW9uc2hpcCB0byByZXBhaXIuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRWYWx1ZSA9IHBwLnZhbHVlO1xuICAgIHZhciBwYXJlbnRDYWNoZSA9IGdldENoaWxkQ2FjaGUocHApO1xuXG4gICAgLy8gTWFrZSBzdXJlIHBhcmVudENhY2hlW3BhdGgubmFtZV0gaXMgcG9wdWxhdGVkLlxuICAgIGlmIChwYXJlbnRWYWx1ZVtwYXRoLm5hbWVdID09PSBwYXRoLnZhbHVlKSB7XG4gICAgICAgIHBhcmVudENhY2hlW3BhdGgubmFtZV0gPSBwYXRoO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheS5jaGVjayhwYXJlbnRWYWx1ZSkpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIGNhdXNlZCBwYXRoLm5hbWUgdG8gYmVjb21lIG91dCBvZiBkYXRlLCBzbyBhdHRlbXB0IHRvXG4gICAgICAgIC8vIHJlY292ZXIgYnkgc2VhcmNoaW5nIGZvciBwYXRoLnZhbHVlIGluIHBhcmVudFZhbHVlLlxuICAgICAgICB2YXIgaSA9IHBhcmVudFZhbHVlLmluZGV4T2YocGF0aC52YWx1ZSk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHBhcmVudENhY2hlW3BhdGgubmFtZSA9IGldID0gcGF0aDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHBhdGgudmFsdWUgZGlzYWdyZWVzIHdpdGggcGFyZW50VmFsdWVbcGF0aC5uYW1lXSwgYW5kXG4gICAgICAgIC8vIHBhdGgubmFtZSBpcyBub3QgYW4gYXJyYXkgaW5kZXgsIGxldCBwYXRoLnZhbHVlIGJlY29tZSB0aGUgbmV3XG4gICAgICAgIC8vIHBhcmVudFZhbHVlW3BhdGgubmFtZV0gYW5kIHVwZGF0ZSBwYXJlbnRDYWNoZSBhY2NvcmRpbmdseS5cbiAgICAgICAgcGFyZW50VmFsdWVbcGF0aC5uYW1lXSA9IHBhdGgudmFsdWU7XG4gICAgICAgIHBhcmVudENhY2hlW3BhdGgubmFtZV0gPSBwYXRoO1xuICAgIH1cblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJlbnRWYWx1ZVtwYXRoLm5hbWVdLCBwYXRoLnZhbHVlKTtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGF0aC5wYXJlbnRQYXRoLmdldChwYXRoLm5hbWUpLCBwYXRoKTtcblxuICAgIHJldHVybiBwYXRoO1xufVxuXG5QcC5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShyZXBsYWNlbWVudCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHBhcmVudFZhbHVlID0gdGhpcy5wYXJlbnRQYXRoLnZhbHVlO1xuICAgIHZhciBwYXJlbnRDYWNoZSA9IGdldENoaWxkQ2FjaGUodGhpcy5wYXJlbnRQYXRoKTtcbiAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgcmVwYWlyUmVsYXRpb25zaGlwV2l0aFBhcmVudCh0aGlzKTtcblxuICAgIGlmIChpc0FycmF5LmNoZWNrKHBhcmVudFZhbHVlKSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMZW5ndGggPSBwYXJlbnRWYWx1ZS5sZW5ndGg7XG4gICAgICAgIHZhciBtb3ZlID0gZ2V0TW92ZXModGhpcy5wYXJlbnRQYXRoLCBjb3VudCAtIDEsIHRoaXMubmFtZSArIDEpO1xuXG4gICAgICAgIHZhciBzcGxpY2VBcmdzID0gW3RoaXMubmFtZSwgMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgc3BsaWNlQXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaWNlZE91dCA9IHBhcmVudFZhbHVlLnNwbGljZS5hcHBseShwYXJlbnRWYWx1ZSwgc3BsaWNlQXJncyk7XG5cbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHNwbGljZWRPdXRbMF0sIHRoaXMudmFsdWUpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gICAgICAgICAgICBwYXJlbnRWYWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICBvcmlnaW5hbExlbmd0aCAtIDEgKyBjb3VudFxuICAgICAgICApO1xuXG4gICAgICAgIG1vdmUoKTtcblxuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIHBhcmVudENhY2hlW3RoaXMubmFtZV07XG4gICAgICAgICAgICB0aGlzLl9fY2hpbGRDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJlbnRWYWx1ZVt0aGlzLm5hbWVdLCByZXBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2hpbGRDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGFyZW50UGF0aC5nZXQodGhpcy5uYW1lICsgaSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocmVzdWx0c1swXSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hpbGRDYWNoZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHBhcmVudFZhbHVlW3RoaXMubmFtZV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgcGFyZW50VmFsdWVbdGhpcy5uYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMuX19jaGlsZENhY2hlID0gbnVsbDtcblxuICAgICAgICAvLyBMZWF2ZSB0aGlzIHBhdGggY2FjaGVkIGFzIHBhcmVudENhY2hlW3RoaXMubmFtZV0sIGV2ZW4gdGhvdWdoXG4gICAgICAgIC8vIGl0IG5vIGxvbmdlciBoYXMgYSB2YWx1ZSBkZWZpbmVkLlxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCBcIkNvdWxkIG5vdCByZXBsYWNlIHBhdGhcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIFR5cGUgPSB0eXBlcy5UeXBlO1xudmFyIG5hbWVkVHlwZXMgPSB0eXBlcy5uYW1lZFR5cGVzO1xudmFyIE5vZGUgPSBuYW1lZFR5cGVzLk5vZGU7XG52YXIgRXhwcmVzc2lvbiA9IG5hbWVkVHlwZXMuRXhwcmVzc2lvbjtcbnZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYiA9IHR5cGVzLmJ1aWxkZXJzO1xuXG5mdW5jdGlvbiBTY29wZShwYXRoLCBwYXJlbnRTY29wZSkge1xuICAgIGFzc2VydC5vayh0aGlzIGluc3RhbmNlb2YgU2NvcGUpO1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgcmVxdWlyZShcIi4vbm9kZS1wYXRoXCIpKTtcbiAgICBTY29wZVR5cGUuYXNzZXJ0KHBhdGgudmFsdWUpO1xuXG4gICAgdmFyIGRlcHRoO1xuXG4gICAgaWYgKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIGFzc2VydC5vayhwYXJlbnRTY29wZSBpbnN0YW5jZW9mIFNjb3BlKTtcbiAgICAgICAgZGVwdGggPSBwYXJlbnRTY29wZS5kZXB0aCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBwYXRoOiB7IHZhbHVlOiBwYXRoIH0sXG4gICAgICAgIG5vZGU6IHsgdmFsdWU6IHBhdGgudmFsdWUgfSxcbiAgICAgICAgaXNHbG9iYWw6IHsgdmFsdWU6ICFwYXJlbnRTY29wZSwgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXB0aDogeyB2YWx1ZTogZGVwdGggfSxcbiAgICAgICAgcGFyZW50OiB7IHZhbHVlOiBwYXJlbnRTY29wZSB9LFxuICAgICAgICBiaW5kaW5nczogeyB2YWx1ZToge30gfVxuICAgIH0pO1xufVxuXG52YXIgc2NvcGVUeXBlcyA9IFtcbiAgICAvLyBQcm9ncmFtIG5vZGVzIGludHJvZHVjZSBnbG9iYWwgc2NvcGVzLlxuICAgIG5hbWVkVHlwZXMuUHJvZ3JhbSxcblxuICAgIC8vIEZ1bmN0aW9uIGlzIHRoZSBzdXBlcnR5cGUgb2YgRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgIC8vIEZ1bmN0aW9uRGVjbGFyYXRpb24sIEFycm93RXhwcmVzc2lvbiwgZXRjLlxuICAgIG5hbWVkVHlwZXMuRnVuY3Rpb24sXG5cbiAgICAvLyBJbiBjYXNlIHlvdSBkaWRuJ3Qga25vdywgdGhlIGNhdWdodCBwYXJhbWV0ZXIgc2hhZG93cyBhbnkgdmFyaWFibGVcbiAgICAvLyBvZiB0aGUgc2FtZSBuYW1lIGluIGFuIG91dGVyIHNjb3BlLlxuICAgIG5hbWVkVHlwZXMuQ2F0Y2hDbGF1c2Vcbl07XG5cbnZhciBTY29wZVR5cGUgPSBUeXBlLm9yLmFwcGx5KFR5cGUsIHNjb3BlVHlwZXMpO1xuXG5TY29wZS5pc0VzdGFibGlzaGVkQnkgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIFNjb3BlVHlwZS5jaGVjayhub2RlKTtcbn07XG5cbnZhciBTcCA9IFNjb3BlLnByb3RvdHlwZTtcblxuLy8gV2lsbCBiZSBvdmVycmlkZGVuIGFmdGVyIGFuIGluc3RhbmNlIGxhemlseSBjYWxscyBzY2FuU2NvcGUuXG5TcC5kaWRTY2FuID0gZmFsc2U7XG5cblNwLmRlY2xhcmVzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXMuc2NhbigpO1xuICAgIHJldHVybiBoYXNPd24uY2FsbCh0aGlzLmJpbmRpbmdzLCBuYW1lKTtcbn07XG5cblNwLmRlY2xhcmVUZW1wb3JhcnkgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGFzc2VydC5vaygvXlthLXokX10vaS50ZXN0KHByZWZpeCksIHByZWZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4ID0gXCJ0JFwiO1xuICAgIH1cblxuICAgIC8vIEluY2x1ZGUgdGhpcy5kZXB0aCBpbiB0aGUgbmFtZSB0byBtYWtlIHN1cmUgdGhlIG5hbWUgZG9lcyBub3RcbiAgICAvLyBjb2xsaWRlIHdpdGggYW55IHZhcmlhYmxlcyBpbiBuZXN0ZWQvZW5jbG9zaW5nIHNjb3Blcy5cbiAgICBwcmVmaXggKz0gdGhpcy5kZXB0aC50b1N0cmluZygzNikgKyBcIiRcIjtcblxuICAgIHRoaXMuc2NhbigpO1xuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAodGhpcy5kZWNsYXJlcyhwcmVmaXggKyBpbmRleCkpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHByZWZpeCArIGluZGV4O1xuICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdID0gdHlwZXMuYnVpbGRlcnMuaWRlbnRpZmllcihuYW1lKTtcbn07XG5cblNwLmluamVjdFRlbXBvcmFyeSA9IGZ1bmN0aW9uKGlkZW50aWZpZXIsIGluaXQpIHtcbiAgICBpZGVudGlmaWVyIHx8IChpZGVudGlmaWVyID0gdGhpcy5kZWNsYXJlVGVtcG9yYXJ5KCkpO1xuXG4gICAgdmFyIGJvZHlQYXRoID0gdGhpcy5wYXRoLmdldChcImJvZHlcIik7XG4gICAgaWYgKG5hbWVkVHlwZXMuQmxvY2tTdGF0ZW1lbnQuY2hlY2soYm9keVBhdGgudmFsdWUpKSB7XG4gICAgICAgIGJvZHlQYXRoID0gYm9keVBhdGguZ2V0KFwiYm9keVwiKTtcbiAgICB9XG5cbiAgICBib2R5UGF0aC51bnNoaWZ0KFxuICAgICAgICBiLnZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgICAgICAgICBcInZhclwiLFxuICAgICAgICAgICAgW2IudmFyaWFibGVEZWNsYXJhdG9yKGlkZW50aWZpZXIsIGluaXQgfHwgbnVsbCldXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG59O1xuXG5TcC5zY2FuID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgIXRoaXMuZGlkU2Nhbikge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IG91dCB0aGlzLmJpbmRpbmdzLCBqdXN0IGluIGNhc2VzLlxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgc2NhblNjb3BlKHRoaXMucGF0aCwgdGhpcy5iaW5kaW5ncyk7XG4gICAgICAgIHRoaXMuZGlkU2NhbiA9IHRydWU7XG4gICAgfVxufTtcblxuU3AuZ2V0QmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY2FuKCk7XG4gICAgcmV0dXJuIHRoaXMuYmluZGluZ3M7XG59O1xuXG5mdW5jdGlvbiBzY2FuU2NvcGUocGF0aCwgYmluZGluZ3MpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGgudmFsdWU7XG4gICAgU2NvcGVUeXBlLmFzc2VydChub2RlKTtcblxuICAgIGlmIChuYW1lZFR5cGVzLkNhdGNoQ2xhdXNlLmNoZWNrKG5vZGUpKSB7XG4gICAgICAgIC8vIEEgY2F0Y2ggY2xhdXNlIGVzdGFibGlzaGVzIGEgbmV3IHNjb3BlIGJ1dCB0aGUgb25seSB2YXJpYWJsZVxuICAgICAgICAvLyBib3VuZCBpbiB0aGF0IHNjb3BlIGlzIHRoZSBjYXRjaCBwYXJhbWV0ZXIuIEFueSBvdGhlclxuICAgICAgICAvLyBkZWNsYXJhdGlvbnMgY3JlYXRlIGJpbmRpbmdzIGluIHRoZSBvdXRlciBzY29wZS5cbiAgICAgICAgYWRkUGF0dGVybihwYXRoLmdldChcInBhcmFtXCIpLCBiaW5kaW5ncyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByZWN1cnNpdmVTY2FuU2NvcGUocGF0aCwgYmluZGluZ3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlU2NhblNjb3BlKHBhdGgsIGJpbmRpbmdzKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLnZhbHVlO1xuXG4gICAgaWYgKHBhdGgucGFyZW50ICYmXG4gICAgICAgIG5hbWVkVHlwZXMuRnVuY3Rpb25FeHByZXNzaW9uLmNoZWNrKHBhdGgucGFyZW50Lm5vZGUpICYmXG4gICAgICAgIHBhdGgucGFyZW50Lm5vZGUuaWQpIHtcbiAgICAgICAgYWRkUGF0dGVybihwYXRoLnBhcmVudC5nZXQoXCJpZFwiKSwgYmluZGluZ3MpO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgICAvLyBOb25lIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgbWF0dGVyIGlmIG5vZGUgaXMgZmFsc3kuXG5cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkuY2hlY2sobm9kZSkpIHtcbiAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKGNoaWxkUGF0aCkge1xuICAgICAgICAgICAgcmVjdXJzaXZlU2NhbkNoaWxkKGNoaWxkUGF0aCwgYmluZGluZ3MpO1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5GdW5jdGlvbi5jaGVjayhub2RlKSkge1xuICAgICAgICBwYXRoLmdldChcInBhcmFtc1wiKS5lYWNoKGZ1bmN0aW9uKHBhcmFtUGF0aCkge1xuICAgICAgICAgICAgYWRkUGF0dGVybihwYXJhbVBhdGgsIGJpbmRpbmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVjdXJzaXZlU2NhbkNoaWxkKHBhdGguZ2V0KFwiYm9keVwiKSwgYmluZGluZ3MpO1xuXG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLlZhcmlhYmxlRGVjbGFyYXRvci5jaGVjayhub2RlKSkge1xuICAgICAgICBhZGRQYXR0ZXJuKHBhdGguZ2V0KFwiaWRcIiksIGJpbmRpbmdzKTtcbiAgICAgICAgcmVjdXJzaXZlU2NhbkNoaWxkKHBhdGguZ2V0KFwiaW5pdFwiKSwgYmluZGluZ3MpO1xuXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIgfHxcbiAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiB8fFxuICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICBhZGRQYXR0ZXJuKFxuICAgICAgICAgICAgbm9kZS5uYW1lID8gcGF0aC5nZXQoXCJuYW1lXCIpIDogcGF0aC5nZXQoXCJpZFwiKSxcbiAgICAgICAgICAgIGJpbmRpbmdzXG4gICAgICAgICk7XG5cbiAgICB9IGVsc2UgaWYgKE5vZGUuY2hlY2sobm9kZSkgJiYgIUV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgICAgdHlwZXMuZWFjaEZpZWxkKG5vZGUsIGZ1bmN0aW9uKG5hbWUsIGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5nZXQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2hpbGRQYXRoLnZhbHVlLCBjaGlsZCk7XG4gICAgICAgICAgICByZWN1cnNpdmVTY2FuQ2hpbGQoY2hpbGRQYXRoLCBiaW5kaW5ncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlU2NhbkNoaWxkKHBhdGgsIGJpbmRpbmdzKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLnZhbHVlO1xuXG4gICAgaWYgKCFub2RlIHx8IEV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgICAgLy8gSWdub3JlIGZhbHN5IHZhbHVlcyBhbmQgRXhwcmVzc2lvbnMuXG5cbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuRnVuY3Rpb25EZWNsYXJhdGlvbi5jaGVjayhub2RlKSkge1xuICAgICAgICBhZGRQYXR0ZXJuKHBhdGguZ2V0KFwiaWRcIiksIGJpbmRpbmdzKTtcblxuICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5DbGFzc0RlY2xhcmF0aW9uICYmXG4gICAgICAgICAgICAgICBuYW1lZFR5cGVzLkNsYXNzRGVjbGFyYXRpb24uY2hlY2sobm9kZSkpIHtcbiAgICAgICAgYWRkUGF0dGVybihwYXRoLmdldChcImlkXCIpLCBiaW5kaW5ncyk7XG5cbiAgICB9IGVsc2UgaWYgKFNjb3BlVHlwZS5jaGVjayhub2RlKSkge1xuICAgICAgICBpZiAobmFtZWRUeXBlcy5DYXRjaENsYXVzZS5jaGVjayhub2RlKSkge1xuICAgICAgICAgICAgdmFyIGNhdGNoUGFyYW1OYW1lID0gbm9kZS5wYXJhbS5uYW1lO1xuICAgICAgICAgICAgdmFyIGhhZEJpbmRpbmcgPSBoYXNPd24uY2FsbChiaW5kaW5ncywgY2F0Y2hQYXJhbU5hbWUpO1xuXG4gICAgICAgICAgICAvLyBBbnkgZGVjbGFyYXRpb25zIHRoYXQgb2NjdXIgaW5zaWRlIHRoZSBjYXRjaCBib2R5IHRoYXQgZG9cbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGNhdGNoIHBhcmFtZXRlciBzaG91bGQgY291bnRcbiAgICAgICAgICAgIC8vIGFzIGJpbmRpbmdzIGluIHRoZSBvdXRlciBzY29wZS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZVNjYW5TY29wZShwYXRoLmdldChcImJvZHlcIiksIGJpbmRpbmdzKTtcblxuICAgICAgICAgICAgLy8gSWYgYSBuZXcgYmluZGluZyBtYXRjaGluZyB0aGUgY2F0Y2ggcGFyYW1ldGVyIG5hbWUgd2FzXG4gICAgICAgICAgICAvLyBjcmVhdGVkIHdoaWxlIHNjYW5uaW5nIHRoZSBjYXRjaCBib2R5LCBpZ25vcmUgaXQgYmVjYXVzZSBpdFxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgcmVmZXJzIHRvIHRoZSBjYXRjaCBwYXJhbWV0ZXIgYW5kIG5vdCB0aGUgb3V0ZXJcbiAgICAgICAgICAgIC8vIHNjb3BlIHRoYXQgd2UncmUgY3VycmVudGx5IHNjYW5uaW5nLlxuICAgICAgICAgICAgaWYgKCFoYWRCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJpbmRpbmdzW2NhdGNoUGFyYW1OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdXJzaXZlU2NhblNjb3BlKHBhdGgsIGJpbmRpbmdzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFBhdHRlcm4ocGF0dGVyblBhdGgsIGJpbmRpbmdzKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuUGF0aC52YWx1ZTtcbiAgICBuYW1lZFR5cGVzLlBhdHRlcm4uYXNzZXJ0KHBhdHRlcm4pO1xuXG4gICAgaWYgKG5hbWVkVHlwZXMuSWRlbnRpZmllci5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwoYmluZGluZ3MsIHBhdHRlcm4ubmFtZSkpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzW3BhdHRlcm4ubmFtZV0ucHVzaChwYXR0ZXJuUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaW5kaW5nc1twYXR0ZXJuLm5hbWVdID0gW3BhdHRlcm5QYXRoXTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLk9iamVjdFBhdHRlcm4gJiZcbiAgICAgICAgICAgICAgIG5hbWVkVHlwZXMuT2JqZWN0UGF0dGVybi5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuUGF0aC5nZXQoJ3Byb3BlcnRpZXMnKS5lYWNoKGZ1bmN0aW9uKHByb3BlcnR5UGF0aCkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydHlQYXRoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG5hbWVkVHlwZXMuUGF0dGVybi5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHByb3BlcnR5UGF0aCwgYmluZGluZ3MpO1xuICAgICAgICAgICAgfSBlbHNlICBpZiAobmFtZWRUeXBlcy5Qcm9wZXJ0eS5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHByb3BlcnR5UGF0aC5nZXQoJ3ZhbHVlJyksIGJpbmRpbmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5TcHJlYWRQcm9wZXJ0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lZFR5cGVzLlNwcmVhZFByb3BlcnR5LmNoZWNrKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocHJvcGVydHlQYXRoLmdldCgnYXJndW1lbnQnKSwgYmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5BcnJheVBhdHRlcm4gJiZcbiAgICAgICAgICAgICAgIG5hbWVkVHlwZXMuQXJyYXlQYXR0ZXJuLmNoZWNrKHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm5QYXRoLmdldCgnZWxlbWVudHMnKS5lYWNoKGZ1bmN0aW9uKGVsZW1lbnRQYXRoKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRQYXRoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG5hbWVkVHlwZXMuUGF0dGVybi5jaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4oZWxlbWVudFBhdGgsIGJpbmRpbmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5TcHJlYWRFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWVkVHlwZXMuU3ByZWFkRWxlbWVudC5jaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4oZWxlbWVudFBhdGguZ2V0KFwiYXJndW1lbnRcIiksIGJpbmRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuUHJvcGVydHlQYXR0ZXJuICYmXG4gICAgICAgICAgICAgICBuYW1lZFR5cGVzLlByb3BlcnR5UGF0dGVybi5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgICBhZGRQYXR0ZXJuKHBhdHRlcm5QYXRoLmdldCgncGF0dGVybicpLCBiaW5kaW5ncyk7XG5cbiAgICB9IGVsc2UgaWYgKChuYW1lZFR5cGVzLlNwcmVhZEVsZW1lbnRQYXR0ZXJuICYmXG4gICAgICAgICAgICAgICAgbmFtZWRUeXBlcy5TcHJlYWRFbGVtZW50UGF0dGVybi5jaGVjayhwYXR0ZXJuKSkgfHxcbiAgICAgICAgICAgICAgIChuYW1lZFR5cGVzLlNwcmVhZFByb3BlcnR5UGF0dGVybiAmJlxuICAgICAgICAgICAgICAgIG5hbWVkVHlwZXMuU3ByZWFkUHJvcGVydHlQYXR0ZXJuLmNoZWNrKHBhdHRlcm4pKSkge1xuICAgICAgICBhZGRQYXR0ZXJuKHBhdHRlcm5QYXRoLmdldCgnYXJndW1lbnQnKSwgYmluZGluZ3MpO1xuICAgIH1cbn1cblxuU3AubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGZvciAodmFyIHNjb3BlID0gdGhpczsgc2NvcGU7IHNjb3BlID0gc2NvcGUucGFyZW50KVxuICAgICAgICBpZiAoc2NvcGUuZGVjbGFyZXMobmFtZSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICByZXR1cm4gc2NvcGU7XG59O1xuXG5TcC5nZXRHbG9iYWxTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgd2hpbGUgKCFzY29wZS5pc0dsb2JhbClcbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgcmV0dXJuIHNjb3BlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY29wZTtcbiIsInZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi9saWIvdHlwZXNcIik7XG52YXIgVHlwZSA9IHR5cGVzLlR5cGU7XG52YXIgYnVpbHRpbiA9IHR5cGVzLmJ1aWx0SW5UeXBlcztcbnZhciBpc051bWJlciA9IGJ1aWx0aW4ubnVtYmVyO1xuXG4vLyBBbiBleGFtcGxlIG9mIGNvbnN0cnVjdGluZyBhIG5ldyB0eXBlIHdpdGggYXJiaXRyYXJ5IGNvbnN0cmFpbnRzIGZyb21cbi8vIGFuIGV4aXN0aW5nIHR5cGUuXG5leHBvcnRzLmdlcSA9IGZ1bmN0aW9uKHRoYW4pIHtcbiAgICByZXR1cm4gbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyLmNoZWNrKHZhbHVlKSAmJiB2YWx1ZSA+PSB0aGFuO1xuICAgIH0sIGlzTnVtYmVyICsgXCIgPj0gXCIgKyB0aGFuKTtcbn07XG5cbi8vIERlZmF1bHQgdmFsdWUtcmV0dXJuaW5nIGZ1bmN0aW9ucyB0aGF0IG1heSBvcHRpb25hbGx5IGJlIHBhc3NlZCBhcyBhXG4vLyB0aGlyZCBhcmd1bWVudCB0byBEZWYucHJvdG90eXBlLmZpZWxkLlxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgICAvLyBGdW5jdGlvbnMgd2VyZSB1c2VkIGJlY2F1c2UgKGFtb25nIG90aGVyIHJlYXNvbnMpIHRoYXQncyB0aGUgbW9zdFxuICAgIC8vIGVsZWdhbnQgd2F5IHRvIGFsbG93IGZvciB0aGUgZW1wdHlBcnJheSBvbmUgYWx3YXlzIHRvIGdpdmUgYSBuZXdcbiAgICAvLyBhcnJheSBpbnN0YW5jZS5cbiAgICBcIm51bGxcIjogZnVuY3Rpb24oKSB7IHJldHVybiBudWxsIH0sXG4gICAgXCJlbXB0eUFycmF5XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW10gfSxcbiAgICBcImZhbHNlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfSxcbiAgICBcInRydWVcIjogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0sXG4gICAgXCJ1bmRlZmluZWRcIjogZnVuY3Rpb24oKSB7fVxufTtcblxudmFyIG5haXZlSXNQcmltaXRpdmUgPSBUeXBlLm9yKFxuICAgIGJ1aWx0aW4uc3RyaW5nLFxuICAgIGJ1aWx0aW4ubnVtYmVyLFxuICAgIGJ1aWx0aW4uYm9vbGVhbixcbiAgICBidWlsdGluLm51bGwsXG4gICAgYnVpbHRpbi51bmRlZmluZWRcbik7XG5cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBuZXcgVHlwZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuICEodHlwZSA9PT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgIHR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG59LCBuYWl2ZUlzUHJpbWl0aXZlLnRvU3RyaW5nKCkpO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgQXAgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgc2xpY2UgPSBBcC5zbGljZTtcbnZhciBtYXAgPSBBcC5tYXA7XG52YXIgZWFjaCA9IEFwLmZvckVhY2g7XG52YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIG9ialRvU3RyID0gT3AudG9TdHJpbmc7XG52YXIgZnVuT2JqU3RyID0gb2JqVG9TdHIuY2FsbChmdW5jdGlvbigpe30pO1xudmFyIHN0ck9ialN0ciA9IG9ialRvU3RyLmNhbGwoXCJcIik7XG52YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG5cbi8vIEEgdHlwZSBpcyBhbiBvYmplY3Qgd2l0aCBhIC5jaGVjayBtZXRob2QgdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGFjY29yZGluZyB0byB3aGV0aGVyIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZSB0eXBlLlxuXG5mdW5jdGlvbiBUeXBlKGNoZWNrLCBuYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGFzc2VydC5vayhzZWxmIGluc3RhbmNlb2YgVHlwZSwgc2VsZik7XG5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0IGVsZWdhbnRseSByZXVzZSBpc0Z1bmN0aW9uIGFuZCBpc1N0cmluZyxcbiAgICAvLyBoZXJlLCBiZWNhdXNlIHRoaXMgY29kZSBpcyBleGVjdXRlZCB3aGlsZSBkZWZpbmluZyB0aG9zZSB0eXBlcy5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwob2JqVG9TdHIuY2FsbChjaGVjayksIGZ1bk9ialN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblxuICAgIC8vIFRoZSBgbmFtZWAgcGFyYW1ldGVyIGNhbiBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhIHN0cmluZy5cbiAgICB2YXIgbmFtZU9ialN0ciA9IG9ialRvU3RyLmNhbGwobmFtZSk7XG4gICAgYXNzZXJ0Lm9rKG5hbWVPYmpTdHIgPT09IGZ1bk9ialN0ciB8fFxuICAgICAgICAgICAgICBuYW1lT2JqU3RyID09PSBzdHJPYmpTdHIsXG4gICAgICAgICAgICAgIG5hbWUgKyBcIiBpcyBuZWl0aGVyIGEgZnVuY3Rpb24gbm9yIGEgc3RyaW5nXCIpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2VsZiwge1xuICAgICAgICBuYW1lOiB7IHZhbHVlOiBuYW1lIH0sXG4gICAgICAgIGNoZWNrOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24odmFsdWUsIGRlZXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hlY2suY2FsbChzZWxmLCB2YWx1ZSwgZGVlcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgZGVlcCAmJiBvYmpUb1N0ci5jYWxsKGRlZXApID09PSBmdW5PYmpTdHIpXG4gICAgICAgICAgICAgICAgICAgIGRlZXAoc2VsZiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIFRwID0gVHlwZS5wcm90b3R5cGU7XG5cbi8vIFRocm91Z2hvdXQgdGhpcyBmaWxlIHdlIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgdG8gcHJldmVudFxuLy8gcmVkZWZpbml0aW9uIG9mIGV4cG9ydGVkIHByb3BlcnRpZXMuXG5leHBvcnRzLlR5cGUgPSBUeXBlO1xuXG4vLyBMaWtlIC5jaGVjaywgZXhjZXB0IHRoYXQgZmFpbHVyZSB0cmlnZ2VycyBhbiBBc3NlcnRpb25FcnJvci5cblRwLmFzc2VydCA9IGZ1bmN0aW9uKHZhbHVlLCBkZWVwKSB7XG4gICAgaWYgKCF0aGlzLmNoZWNrKHZhbHVlLCBkZWVwKSkge1xuICAgICAgICB2YXIgc3RyID0gc2hhbGxvd1N0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgc3RyICsgXCIgZG9lcyBub3QgbWF0Y2ggdHlwZSBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gc2hhbGxvd1N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGlmIChpc09iamVjdC5jaGVjayh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBcIntcIiArIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ICsgXCI6IFwiICsgdmFsdWVba2V5XTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG5cbiAgICBpZiAoaXNBcnJheS5jaGVjayh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBcIltcIiArIHZhbHVlLm1hcChzaGFsbG93U3RyaW5naWZ5KS5qb2luKFwiLCBcIikgKyBcIl1cIjtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5cblRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBpZiAoaXNTdHJpbmcuY2hlY2sobmFtZSkpXG4gICAgICAgIHJldHVybiBuYW1lO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24uY2hlY2sobmFtZSkpXG4gICAgICAgIHJldHVybiBuYW1lLmNhbGwodGhpcykgKyBcIlwiO1xuXG4gICAgcmV0dXJuIG5hbWUgKyBcIiB0eXBlXCI7XG59O1xuXG52YXIgYnVpbHRJblR5cGVzID0ge307XG5leHBvcnRzLmJ1aWx0SW5UeXBlcyA9IGJ1aWx0SW5UeXBlcztcblxuZnVuY3Rpb24gZGVmQnVpbHRJblR5cGUoZXhhbXBsZSwgbmFtZSkge1xuICAgIHZhciBvYmpTdHIgPSBvYmpUb1N0ci5jYWxsKGV4YW1wbGUpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1aWx0SW5UeXBlcywgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpUb1N0ci5jYWxsKHZhbHVlKSA9PT0gb2JqU3RyO1xuICAgICAgICB9LCBuYW1lKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJ1aWx0SW5UeXBlc1tuYW1lXTtcbn1cblxuLy8gVGhlc2UgdHlwZXMgY2hlY2sgdGhlIHVuZGVybHlpbmcgW1tDbGFzc11dIGF0dHJpYnV0ZSBvZiB0aGUgZ2l2ZW5cbi8vIHZhbHVlLCByYXRoZXIgdGhhbiB1c2luZyB0aGUgcHJvYmxlbWF0aWMgdHlwZW9mIG9wZXJhdG9yLiBOb3RlIGhvd2V2ZXJcbi8vIHRoYXQgbm8gc3VidHlwaW5nIGlzIGNvbnNpZGVyZWQ7IHNvLCBmb3IgaW5zdGFuY2UsIGlzT2JqZWN0LmNoZWNrXG4vLyByZXR1cm5zIGZhbHNlIGZvciBbXSwgLy4vLCBuZXcgRGF0ZSwgYW5kIG51bGwuXG52YXIgaXNTdHJpbmcgPSBkZWZCdWlsdEluVHlwZShcIlwiLCBcInN0cmluZ1wiKTtcbnZhciBpc0Z1bmN0aW9uID0gZGVmQnVpbHRJblR5cGUoZnVuY3Rpb24oKXt9LCBcImZ1bmN0aW9uXCIpO1xudmFyIGlzQXJyYXkgPSBkZWZCdWlsdEluVHlwZShbXSwgXCJhcnJheVwiKTtcbnZhciBpc09iamVjdCA9IGRlZkJ1aWx0SW5UeXBlKHt9LCBcIm9iamVjdFwiKTtcbnZhciBpc1JlZ0V4cCA9IGRlZkJ1aWx0SW5UeXBlKC8uLywgXCJSZWdFeHBcIik7XG52YXIgaXNEYXRlID0gZGVmQnVpbHRJblR5cGUobmV3IERhdGUsIFwiRGF0ZVwiKTtcbnZhciBpc051bWJlciA9IGRlZkJ1aWx0SW5UeXBlKDMsIFwibnVtYmVyXCIpO1xudmFyIGlzQm9vbGVhbiA9IGRlZkJ1aWx0SW5UeXBlKHRydWUsIFwiYm9vbGVhblwiKTtcbnZhciBpc051bGwgPSBkZWZCdWlsdEluVHlwZShudWxsLCBcIm51bGxcIik7XG52YXIgaXNVbmRlZmluZWQgPSBkZWZCdWlsdEluVHlwZSh2b2lkIDAsIFwidW5kZWZpbmVkXCIpO1xuXG4vLyBUaGVyZSBhcmUgYSBudW1iZXIgb2YgaWRpb21hdGljIHdheXMgb2YgZXhwcmVzc2luZyB0eXBlcywgc28gdGhpc1xuLy8gZnVuY3Rpb24gc2VydmVzIHRvIGNvZXJjZSB0aGVtIGFsbCB0byBhY3R1YWwgVHlwZSBvYmplY3RzLiBOb3RlIHRoYXRcbi8vIHByb3ZpZGluZyB0aGUgbmFtZSBhcmd1bWVudCBpcyBub3QgbmVjZXNzYXJ5IGluIG1vc3QgY2FzZXMuXG5mdW5jdGlvbiB0b1R5cGUoZnJvbSwgbmFtZSkge1xuICAgIC8vIFRoZSB0b1R5cGUgZnVuY3Rpb24gc2hvdWxkIG9mIGNvdXJzZSBiZSBpZGVtcG90ZW50LlxuICAgIGlmIChmcm9tIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgcmV0dXJuIGZyb207XG5cbiAgICAvLyBUaGUgRGVmIHR5cGUgaXMgdXNlZCBhcyBhIGhlbHBlciBmb3IgY29uc3RydWN0aW5nIGNvbXBvdW5kXG4gICAgLy8gaW50ZXJmYWNlIHR5cGVzIGZvciBBU1Qgbm9kZXMuXG4gICAgaWYgKGZyb20gaW5zdGFuY2VvZiBEZWYpXG4gICAgICAgIHJldHVybiBmcm9tLnR5cGU7XG5cbiAgICAvLyBTdXBwb3J0IFtFbGVtVHlwZV0gc3ludGF4LlxuICAgIGlmIChpc0FycmF5LmNoZWNrKGZyb20pKVxuICAgICAgICByZXR1cm4gVHlwZS5mcm9tQXJyYXkoZnJvbSk7XG5cbiAgICAvLyBTdXBwb3J0IHsgc29tZUZpZWxkOiBGaWVsZFR5cGUsIC4uLiB9IHN5bnRheC5cbiAgICBpZiAoaXNPYmplY3QuY2hlY2soZnJvbSkpXG4gICAgICAgIHJldHVybiBUeXBlLmZyb21PYmplY3QoZnJvbSk7XG5cbiAgICAvLyBJZiBpc0Z1bmN0aW9uLmNoZWNrKGZyb20pLCBhc3N1bWUgdGhhdCBmcm9tIGlzIGEgYmluYXJ5IHByZWRpY2F0ZVxuICAgIC8vIGZ1bmN0aW9uIHdlIGNhbiB1c2UgdG8gZGVmaW5lIHRoZSB0eXBlLlxuICAgIGlmIChpc0Z1bmN0aW9uLmNoZWNrKGZyb20pKVxuICAgICAgICByZXR1cm4gbmV3IFR5cGUoZnJvbSwgbmFtZSk7XG5cbiAgICAvLyBBcyBhIGxhc3QgcmVzb3J0LCB0b1R5cGUgcmV0dXJucyBhIHR5cGUgdGhhdCBtYXRjaGVzIGFueSB2YWx1ZSB0aGF0XG4gICAgLy8gaXMgPT09IGZyb20uIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgbGl0ZXJhbCB2YWx1ZXMgbGlrZVxuICAgIC8vIHRvVHlwZShudWxsKSwgYnV0IGl0IGhhcyB0aGUgYWRkaXRpb25hbCBhZHZhbnRhZ2Ugb2YgYWxsb3dpbmdcbiAgICAvLyB0b1R5cGUgdG8gYmUgYSB0b3RhbCBmdW5jdGlvbi5cbiAgICByZXR1cm4gbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmcm9tO1xuICAgIH0sIGlzVW5kZWZpbmVkLmNoZWNrKG5hbWUpID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmcm9tICsgXCJcIjtcbiAgICB9IDogbmFtZSk7XG59XG5cbi8vIFJldHVybnMgYSB0eXBlIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gdmFsdWUgaWZmIGFueSBvZiB0eXBlMSwgdHlwZTIsXG4vLyBldGMuIG1hdGNoIHRoZSB2YWx1ZS5cblR5cGUub3IgPSBmdW5jdGlvbigvKiB0eXBlMSwgdHlwZTIsIC4uLiAqLykge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godG9UeXBlKGFyZ3VtZW50c1tpXSkpO1xuXG4gICAgcmV0dXJuIG5ldyBUeXBlKGZ1bmN0aW9uKHZhbHVlLCBkZWVwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uY2hlY2sodmFsdWUsIGRlZXApKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlcy5qb2luKFwiIHwgXCIpO1xuICAgIH0pO1xufTtcblxuVHlwZS5mcm9tQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgICBhc3NlcnQub2soaXNBcnJheS5jaGVjayhhcnIpKTtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoXG4gICAgICAgIGFyci5sZW5ndGgsIDEsXG4gICAgICAgIFwib25seSBvbmUgZWxlbWVudCB0eXBlIGlzIHBlcm1pdHRlZCBmb3IgdHlwZWQgYXJyYXlzXCIpO1xuICAgIHJldHVybiB0b1R5cGUoYXJyWzBdKS5hcnJheU9mKCk7XG59O1xuXG5UcC5hcnJheU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW1UeXBlID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUsIGRlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkuY2hlY2sodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtVHlwZS5jaGVjayhlbGVtLCBkZWVwKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIGVsZW1UeXBlICsgXCJdXCI7XG4gICAgfSk7XG59O1xuXG5UeXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpZWxkKG5hbWUsIG9ialtuYW1lXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUsIGRlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0LmNoZWNrKHZhbHVlKSAmJiBmaWVsZHMuZXZlcnkoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC50eXBlLmNoZWNrKHZhbHVlW2ZpZWxkLm5hbWVdLCBkZWVwKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcInsgXCIgKyBmaWVsZHMuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gRmllbGQobmFtZSwgdHlwZSwgZGVmYXVsdEZuLCBoaWRkZW4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBhc3NlcnQub2soc2VsZiBpbnN0YW5jZW9mIEZpZWxkKTtcbiAgICBpc1N0cmluZy5hc3NlcnQobmFtZSk7XG5cbiAgICB0eXBlID0gdG9UeXBlKHR5cGUpO1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG5hbWU6IHsgdmFsdWU6IG5hbWUgfSxcbiAgICAgICAgdHlwZTogeyB2YWx1ZTogdHlwZSB9LFxuICAgICAgICBoaWRkZW46IHsgdmFsdWU6ICEhaGlkZGVuIH1cbiAgICB9O1xuXG4gICAgaWYgKGlzRnVuY3Rpb24uY2hlY2soZGVmYXVsdEZuKSkge1xuICAgICAgICBwcm9wZXJ0aWVzLmRlZmF1bHRGbiA9IHsgdmFsdWU6IGRlZmF1bHRGbiB9O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BlcnRpZXMpO1xufVxuXG52YXIgRnAgPSBGaWVsZC5wcm90b3R5cGU7XG5cbkZwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMubmFtZSkgKyBcIjogXCIgKyB0aGlzLnR5cGU7XG59O1xuXG5GcC5nZXRWYWx1ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB2YWx1ZSA9IG9ialt0aGlzLm5hbWVdO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZC5jaGVjayh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGlmICh0aGlzLmRlZmF1bHRGbilcbiAgICAgICAgdmFsdWUgPSB0aGlzLmRlZmF1bHRGbi5jYWxsKG9iaik7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBEZWZpbmUgYSB0eXBlIHdob3NlIG5hbWUgaXMgcmVnaXN0ZXJlZCBpbiBhIG5hbWVzcGFjZSAodGhlIGRlZkNhY2hlKSBzb1xuLy8gdGhhdCBmdXR1cmUgZGVmaW5pdGlvbnMgd2lsbCByZXR1cm4gdGhlIHNhbWUgdHlwZSBnaXZlbiB0aGUgc2FtZSBuYW1lLlxuLy8gSW4gcGFydGljdWxhciwgdGhpcyBzeXN0ZW0gYWxsb3dzIGZvciBjaXJjdWxhciBhbmQgZm9yd2FyZCBkZWZpbml0aW9ucy5cbi8vIFRoZSBEZWYgb2JqZWN0IGQgcmV0dXJuZWQgZnJvbSBUeXBlLmRlZiBtYXkgYmUgdXNlZCB0byBjb25maWd1cmUgdGhlXG4vLyB0eXBlIGQudHlwZSBieSBjYWxsaW5nIG1ldGhvZHMgc3VjaCBhcyBkLmJhc2VzLCBkLmJ1aWxkLCBhbmQgZC5maWVsZC5cblR5cGUuZGVmID0gZnVuY3Rpb24odHlwZU5hbWUpIHtcbiAgICBpc1N0cmluZy5hc3NlcnQodHlwZU5hbWUpO1xuICAgIHJldHVybiBoYXNPd24uY2FsbChkZWZDYWNoZSwgdHlwZU5hbWUpXG4gICAgICAgID8gZGVmQ2FjaGVbdHlwZU5hbWVdXG4gICAgICAgIDogZGVmQ2FjaGVbdHlwZU5hbWVdID0gbmV3IERlZih0eXBlTmFtZSk7XG59O1xuXG4vLyBJbiBvcmRlciB0byByZXR1cm4gdGhlIHNhbWUgRGVmIGluc3RhbmNlIGV2ZXJ5IHRpbWUgVHlwZS5kZWYgaXMgY2FsbGVkXG4vLyB3aXRoIGEgcGFydGljdWxhciBuYW1lLCB0aG9zZSBpbnN0YW5jZXMgbmVlZCB0byBiZSBzdG9yZWQgaW4gYSBjYWNoZS5cbnZhciBkZWZDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIERlZih0eXBlTmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBhc3NlcnQub2soc2VsZiBpbnN0YW5jZW9mIERlZik7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzZWxmLCB7XG4gICAgICAgIHR5cGVOYW1lOiB7IHZhbHVlOiB0eXBlTmFtZSB9LFxuICAgICAgICBiYXNlTmFtZXM6IHsgdmFsdWU6IFtdIH0sXG4gICAgICAgIG93bkZpZWxkczogeyB2YWx1ZTogT2JqZWN0LmNyZWF0ZShudWxsKSB9LFxuXG4gICAgICAgIC8vIFRoZXNlIHR3byBhcmUgcG9wdWxhdGVkIGR1cmluZyBmaW5hbGl6YXRpb24uXG4gICAgICAgIGFsbFN1cGVydHlwZXM6IHsgdmFsdWU6IE9iamVjdC5jcmVhdGUobnVsbCkgfSwgLy8gSW5jbHVkZXMgb3duIHR5cGVOYW1lLlxuICAgICAgICBzdXBlcnR5cGVMaXN0OiB7IHZhbHVlOiBbXSB9LCAvLyBMaW5lYXIgaW5oZXJpdGFuY2UgaGllcmFyY2h5LlxuICAgICAgICBhbGxGaWVsZHM6IHsgdmFsdWU6IE9iamVjdC5jcmVhdGUobnVsbCkgfSwgLy8gSW5jbHVkZXMgaW5oZXJpdGVkIGZpZWxkcy5cbiAgICAgICAgZmllbGROYW1lczogeyB2YWx1ZTogW10gfSwgLy8gTm9uLWhpZGRlbiBrZXlzIG9mIGFsbEZpZWxkcy5cblxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFR5cGUoZnVuY3Rpb24odmFsdWUsIGRlZXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jaGVjayh2YWx1ZSwgZGVlcCk7XG4gICAgICAgICAgICB9LCB0eXBlTmFtZSlcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5EZWYuZnJvbVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB0eXBlID0gdmFsdWUudHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChkZWZDYWNoZSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBkID0gZGVmQ2FjaGVbdHlwZV07XG4gICAgICAgICAgICBpZiAoZC5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxudmFyIERwID0gRGVmLnByb3RvdHlwZTtcblxuRHAuaXNTdXBlcnR5cGVPZiA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgICBpZiAodGhhdCBpbnN0YW5jZW9mIERlZikge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy5maW5hbGl6ZWQsIHRydWUpO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhhdC5maW5hbGl6ZWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gaGFzT3duLmNhbGwodGhhdC5hbGxTdXBlcnR5cGVzLCB0aGlzLnR5cGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHRoYXQgKyBcIiBpcyBub3QgYSBEZWZcIik7XG4gICAgfVxufTtcblxuLy8gTm90ZSB0aGF0IHRoZSBsaXN0IHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbFxuLy8gc3VwZXJ0eXBlTGlzdCwgKndpdGhvdXQqIHRoZSB0eXBlTmFtZSBpdHNlbGYgYXMgdGhlIGZpcnN0IGVsZW1lbnQuXG5leHBvcnRzLmdldFN1cGVydHlwZU5hbWVzID0gZnVuY3Rpb24odHlwZU5hbWUpIHtcbiAgICBhc3NlcnQub2soaGFzT3duLmNhbGwoZGVmQ2FjaGUsIHR5cGVOYW1lKSk7XG4gICAgdmFyIGQgPSBkZWZDYWNoZVt0eXBlTmFtZV07XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKGQuZmluYWxpemVkLCB0cnVlKTtcbiAgICByZXR1cm4gZC5zdXBlcnR5cGVMaXN0LnNsaWNlKDEpO1xufTtcblxuLy8gUmV0dXJucyBhbiBvYmplY3QgbWFwcGluZyBmcm9tIGV2ZXJ5IGtub3duIHR5cGUgaW4gdGhlIGRlZkNhY2hlIHRvIHRoZVxuLy8gbW9zdCBzcGVjaWZpYyBzdXBlcnR5cGUgd2hvc2UgbmFtZSBpcyBhbiBvd24gcHJvcGVydHkgb2YgdGhlIGNhbmRpZGF0ZXNcbi8vIG9iamVjdC5cbmV4cG9ydHMuY29tcHV0ZVN1cGVydHlwZUxvb2t1cFRhYmxlID0gZnVuY3Rpb24oY2FuZGlkYXRlcykge1xuICAgIHZhciB0YWJsZSA9IHt9O1xuICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhkZWZDYWNoZSk7XG4gICAgdmFyIHR5cGVOYW1lQ291bnQgPSB0eXBlTmFtZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTmFtZUNvdW50OyArK2kpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZU5hbWVzW2ldO1xuICAgICAgICB2YXIgZCA9IGRlZkNhY2hlW3R5cGVOYW1lXTtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGQuZmluYWxpemVkLCB0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkLnN1cGVydHlwZUxpc3QubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBzdXBlclR5cGVOYW1lID0gZC5zdXBlcnR5cGVMaXN0W2pdO1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGNhbmRpZGF0ZXMsIHN1cGVyVHlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGFibGVbdHlwZU5hbWVdID0gc3VwZXJUeXBlTmFtZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn07XG5cbkRwLmNoZWNrQWxsRmllbGRzID0gZnVuY3Rpb24odmFsdWUsIGRlZXApIHtcbiAgICB2YXIgYWxsRmllbGRzID0gdGhpcy5hbGxGaWVsZHM7XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMuZmluYWxpemVkLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrRmllbGRCeU5hbWUobmFtZSkge1xuICAgICAgICB2YXIgZmllbGQgPSBhbGxGaWVsZHNbbmFtZV07XG4gICAgICAgIHZhciB0eXBlID0gZmllbGQudHlwZTtcbiAgICAgICAgdmFyIGNoaWxkID0gZmllbGQuZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHlwZS5jaGVjayhjaGlsZCwgZGVlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzT2JqZWN0LmNoZWNrKHZhbHVlKVxuICAgICAgICAmJiBPYmplY3Qua2V5cyhhbGxGaWVsZHMpLmV2ZXJ5KGNoZWNrRmllbGRCeU5hbWUpO1xufTtcblxuRHAuY2hlY2sgPSBmdW5jdGlvbih2YWx1ZSwgZGVlcCkge1xuICAgIGFzc2VydC5zdHJpY3RFcXVhbChcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQsIHRydWUsXG4gICAgICAgIFwicHJlbWF0dXJlbHkgY2hlY2tpbmcgdW5maW5hbGl6ZWQgdHlwZSBcIiArIHRoaXMudHlwZU5hbWUpO1xuXG4gICAgLy8gQSBEZWYgdHlwZSBjYW4gb25seSBtYXRjaCBhbiBvYmplY3QgdmFsdWUuXG4gICAgaWYgKCFpc09iamVjdC5jaGVjayh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB2RGVmID0gRGVmLmZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKCF2RGVmKSB7XG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGluZmVyIHRoZSBEZWYgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZSxcbiAgICAgICAgLy8gYW5kIHdlIGV4cGVjdGVkIGl0IHRvIGJlIGEgU291cmNlTG9jYXRpb24gb3IgYSBQb3NpdGlvbiwgaXQgd2FzXG4gICAgICAgIC8vIHByb2JhYmx5IGp1c3QgbWlzc2luZyBhIFwidHlwZVwiIGZpZWxkIChiZWNhdXNlIEVzcHJpbWEgZG9lcyBub3RcbiAgICAgICAgLy8gYXNzaWduIGEgdHlwZSBwcm9wZXJ0eSB0byBzdWNoIG5vZGVzKS4gQmUgb3B0aW1pc3RpYyBhbmQgbGV0XG4gICAgICAgIC8vIHRoaXMuY2hlY2tBbGxGaWVsZHMgbWFrZSB0aGUgZmluYWwgZGVjaXNpb24uXG4gICAgICAgIGlmICh0aGlzLnR5cGVOYW1lID09PSBcIlNvdXJjZUxvY2F0aW9uXCIgfHxcbiAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgPT09IFwiUG9zaXRpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbGluZyB0aGlzLmNoZWNrQWxsRmllbGRzIGZvciBhbnkgb3RoZXIgdHlwZSBvZiBub2RlIGlzIGJvdGhcbiAgICAgICAgLy8gYmFkIGZvciBwZXJmb3JtYW5jZSBhbmQgd2F5IHRvbyBmb3JnaXZpbmcuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiBjaGVja2luZyBkZWVwbHkgYW5kIHZEZWYgPT09IHRoaXMsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNhbGxcbiAgICAvLyBjaGVja0FsbEZpZWxkcyBvbmNlLiBDYWxsaW5nIGNoZWNrQWxsRmllbGRzIGlzIHRvbyBzdHJpY3Qgd2hlbiBkZWVwXG4gICAgLy8gaXMgZmFsc2UsIGJlY2F1c2UgdGhlbiB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhpcy5pc1N1cGVydHlwZU9mKHZEZWYpLlxuICAgIGlmIChkZWVwICYmIHZEZWYgPT09IHRoaXMpXG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrQWxsRmllbGRzKHZhbHVlLCBkZWVwKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgd2UgcmVseSBleGNsdXNpdmVseSBvbiBpc1N1cGVydHlwZU9mIHRvIG1ha2UgTygxKVxuICAgIC8vIHN1YnR5cGluZyBkZXRlcm1pbmF0aW9ucy4gVGhpcyBzdWZmaWNlcyBpbiBtb3N0IHNpdHVhdGlvbnMgb3V0c2lkZVxuICAgIC8vIG9mIHVuaXQgdGVzdHMsIHNpbmNlIGludGVyZmFjZSBjb25mb3JtYW5jZSBpcyBjaGVja2VkIHdoZW5ldmVyIG5ld1xuICAgIC8vIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB1c2luZyBidWlsZGVyIGZ1bmN0aW9ucy5cbiAgICBpZiAoIXRoaXMuaXNTdXBlcnR5cGVPZih2RGVmKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVGhlIGV4Y2VwdGlvbiBpcyB3aGVuIGRlZXAgaXMgdHJ1ZTsgdGhlbiwgd2UgcmVjdXJzaXZlbHkgY2hlY2sgYWxsXG4gICAgLy8gZmllbGRzLlxuICAgIGlmICghZGVlcClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBVc2UgdGhlIG1vcmUgc3BlY2lmaWMgRGVmICh2RGVmKSB0byBwZXJmb3JtIHRoZSBkZWVwIGNoZWNrLCBidXRcbiAgICAvLyBzaGFsbG93LWNoZWNrIGZpZWxkcyBkZWZpbmVkIGJ5IHRoZSBsZXNzIHNwZWNpZmljIERlZiAodGhpcykuXG4gICAgcmV0dXJuIHZEZWYuY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApXG4gICAgICAgICYmIHRoaXMuY2hlY2tBbGxGaWVsZHModmFsdWUsIGZhbHNlKTtcbn07XG5cbkRwLmJhc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhc2VzID0gdGhpcy5iYXNlTmFtZXM7XG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy5maW5hbGl6ZWQsIGZhbHNlKTtcblxuICAgIGVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGJhc2VOYW1lKSB7XG4gICAgICAgIGlzU3RyaW5nLmFzc2VydChiYXNlTmFtZSk7XG5cbiAgICAgICAgLy8gVGhpcyBpbmRleE9mIGxvb2t1cCBtYXkgYmUgTyhuKSwgYnV0IHRoZSB0eXBpY2FsIG51bWJlciBvZiBiYXNlXG4gICAgICAgIC8vIG5hbWVzIGlzIHZlcnkgc21hbGwsIGFuZCBpbmRleE9mIGlzIGEgbmF0aXZlIEFycmF5IG1ldGhvZC5cbiAgICAgICAgaWYgKGJhc2VzLmluZGV4T2YoYmFzZU5hbWUpIDwgMClcbiAgICAgICAgICAgIGJhc2VzLnB1c2goYmFzZU5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIEZvciBjaGFpbmluZy5cbn07XG5cbi8vIEZhbHNlIGJ5IGRlZmF1bHQgdW50aWwgLmJ1aWxkKC4uLikgaXMgY2FsbGVkIG9uIGFuIGluc3RhbmNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERwLCBcImJ1aWxkYWJsZVwiLCB7IHZhbHVlOiBmYWxzZSB9KTtcblxudmFyIGJ1aWxkZXJzID0ge307XG5leHBvcnRzLmJ1aWxkZXJzID0gYnVpbGRlcnM7XG5cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYXMgcHJvdG90eXBlIGZvciBhbnkgbm9kZSBjcmVhdGVkIGJ5IGEgYnVpbGRlci5cbnZhciBub2RlUHJvdG90eXBlID0ge307XG5cbi8vIENhbGwgdGhpcyBmdW5jdGlvbiB0byBkZWZpbmUgYSBuZXcgbWV0aG9kIHRvIGJlIHNoYXJlZCBieSBhbGwgQVNUXG4vLyBub2Rlcy4gVGhlIHJlcGxhY2VkIG1ldGhvZCAoaWYgYW55KSBpcyByZXR1cm5lZCBmb3IgZWFzeSB3cmFwcGluZy5cbmV4cG9ydHMuZGVmaW5lTWV0aG9kID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIHZhciBvbGQgPSBub2RlUHJvdG90eXBlW25hbWVdO1xuXG4gICAgLy8gUGFzcyB1bmRlZmluZWQgYXMgZnVuYyB0byBkZWxldGUgbm9kZVByb3RvdHlwZVtuYW1lXS5cbiAgICBpZiAoaXNVbmRlZmluZWQuY2hlY2soZnVuYykpIHtcbiAgICAgICAgZGVsZXRlIG5vZGVQcm90b3R5cGVbbmFtZV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpc0Z1bmN0aW9uLmFzc2VydChmdW5jKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZVByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgLy8gRm9yIGRpc2NvdmVyYWJpbGl0eS5cbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgLy8gRm9yIGRlbGV0ZSBwcm90b1tuYW1lXS5cbiAgICAgICAgICAgIHZhbHVlOiBmdW5jXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvbGQ7XG59O1xuXG4vLyBDYWxsaW5nIHRoZSAuYnVpbGQgbWV0aG9kIG9mIGEgRGVmIHNpbXVsdGFuZW91c2x5IG1hcmtzIHRoZSB0eXBlIGFzXG4vLyBidWlsZGFibGUgKGJ5IGRlZmluaW5nIGJ1aWxkZXJzW2dldEJ1aWxkZXJOYW1lKHR5cGVOYW1lKV0pIGFuZFxuLy8gc3BlY2lmaWVzIHRoZSBvcmRlciBvZiBhcmd1bWVudHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBidWlsZGVyXG4vLyBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUuXG5EcC5idWlsZCA9IGZ1bmN0aW9uKC8qIHBhcmFtMSwgcGFyYW0yLCAuLi4gKi8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDYWxsaW5nIERlZi5wcm90b3R5cGUuYnVpbGQgbXVsdGlwbGUgdGltZXMgaGFzIHRoZSBlZmZlY3Qgb2YgbWVyZWx5XG4gICAgLy8gcmVkZWZpbmluZyB0aGlzIHByb3BlcnR5LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcImJ1aWxkUGFyYW1zXCIsIHtcbiAgICAgICAgdmFsdWU6IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoc2VsZi5maW5hbGl6ZWQsIGZhbHNlKTtcbiAgICBpc1N0cmluZy5hcnJheU9mKCkuYXNzZXJ0KHNlbGYuYnVpbGRQYXJhbXMpO1xuXG4gICAgaWYgKHNlbGYuYnVpbGRhYmxlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgRGVmIGlzIGFscmVhZHkgYnVpbGRhYmxlLCB1cGRhdGUgc2VsZi5idWlsZFBhcmFtcyBhbmRcbiAgICAgICAgLy8gY29udGludWUgdXNpbmcgdGhlIG9sZCBidWlsZGVyIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBFdmVyeSBidWlsZGFibGUgdHlwZSB3aWxsIGhhdmUgaXRzIFwidHlwZVwiIGZpZWxkIGZpbGxlZCBpblxuICAgIC8vIGF1dG9tYXRpY2FsbHkuIFRoaXMgaW5jbHVkZXMgdHlwZXMgdGhhdCBhcmUgbm90IHN1YnR5cGVzIG9mIE5vZGUsXG4gICAgLy8gbGlrZSBTb3VyY2VMb2NhdGlvbiwgYnV0IHRoYXQgc2VlbXMgaGFybWxlc3MgKFRPRE8/KS5cbiAgICBzZWxmLmZpZWxkKFwidHlwZVwiLCBzZWxmLnR5cGVOYW1lLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYudHlwZU5hbWUgfSk7XG5cbiAgICAvLyBPdmVycmlkZSBEcC5idWlsZGFibGUgZm9yIHRoaXMgRGVmIGluc3RhbmNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcImJ1aWxkYWJsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1aWxkZXJzLCBnZXRCdWlsZGVyTmFtZShzZWxmLnR5cGVOYW1lKSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIGFyZ2MgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBidWlsdCA9IE9iamVjdC5jcmVhdGUobm9kZVByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmFsaXplZCxcbiAgICAgICAgICAgICAgICBcImF0dGVtcHRpbmcgdG8gaW5zdGFudGlhdGUgdW5maW5hbGl6ZWQgdHlwZSBcIiArIHNlbGYudHlwZU5hbWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGQocGFyYW0sIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoYnVpbHQsIHBhcmFtKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFsbCA9IHNlbGYuYWxsRmllbGRzO1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhoYXNPd24uY2FsbChhbGwsIHBhcmFtKSwgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gYWxsW3BhcmFtXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpZWxkLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyLmNoZWNrKGkpICYmIGkgPCBhcmdjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmRlZmF1bHRGbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBvc2UgdGhlIHBhcnRpYWxseS1idWlsdCBvYmplY3QgdG8gdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gYXMgaXRzIGB0aGlzYCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmllbGQuZGVmYXVsdEZuLmNhbGwoYnVpbHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJubyB2YWx1ZSBvciBkZWZhdWx0IGZ1bmN0aW9uIGdpdmVuIGZvciBmaWVsZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXJhbSkgKyBcIiBvZiBcIiArIHNlbGYudHlwZU5hbWUgKyBcIihcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5idWlsZFBhcmFtcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soZmFsc2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdHlwZS5jaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93U3RyaW5naWZ5KHZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgZG9lcyBub3QgbWF0Y2ggZmllbGQgXCIgKyBmaWVsZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgb2YgdHlwZSBcIiArIHNlbGYudHlwZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIENvdWxkIGF0dGFjaCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGhlcmUgdG8gZW5mb3JjZVxuICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMgdHlwZSBzYWZldHkuXG4gICAgICAgICAgICAgICAgYnVpbHRbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuYnVpbGRQYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAgICAgICAgIGFkZChwYXJhbSwgaSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5hbGxGaWVsZHMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICBhZGQocGFyYW0pOyAvLyBVc2UgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIFwidHlwZVwiIGZpZWxkIHdhcyBmaWxsZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChidWlsdC50eXBlLCBzZWxmLnR5cGVOYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2VsZjsgLy8gRm9yIGNoYWluaW5nLlxufTtcblxuZnVuY3Rpb24gZ2V0QnVpbGRlck5hbWUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUucmVwbGFjZSgvXltBLVpdKy8sIGZ1bmN0aW9uKHVwcGVyQ2FzZVByZWZpeCkge1xuICAgICAgICB2YXIgbGVuID0gdXBwZXJDYXNlUHJlZml4Lmxlbmd0aDtcbiAgICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gXCJcIjtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBpbml0aWFsIGNhcGl0YWwgbGV0dGVyLCBqdXN0IGxvd2VyLWNhc2UgaXQuXG4gICAgICAgIGNhc2UgMTogcmV0dXJuIHVwcGVyQ2FzZVByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRoYW4gb25lIGluaXRpYWwgY2FwaXRhbCBsZXR0ZXIsIGxvd2VyLWNhc2VcbiAgICAgICAgICAgIC8vIGFsbCBidXQgdGhlIGxhc3Qgb25lLCBzbyB0aGF0IFhNTERlZmF1bHREZWNsYXJhdGlvbiAoZm9yXG4gICAgICAgICAgICAvLyBleGFtcGxlKSBiZWNvbWVzIHhtbERlZmF1bHREZWNsYXJhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB1cHBlckNhc2VQcmVmaXguc2xpY2UoXG4gICAgICAgICAgICAgICAgMCwgbGVuIC0gMSkudG9Mb3dlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgdXBwZXJDYXNlUHJlZml4LmNoYXJBdChsZW4gLSAxKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBUaGUgcmVhc29uIGZpZWxkcyBhcmUgc3BlY2lmaWVkIHVzaW5nIC5maWVsZCguLi4pIGluc3RlYWQgb2YgYW4gb2JqZWN0XG4vLyBsaXRlcmFsIHN5bnRheCBpcyBzb21ld2hhdCBzdWJ0bGU6IHRoZSBvYmplY3QgbGl0ZXJhbCBzeW50YXggd291bGRcbi8vIHN1cHBvcnQgb25seSBvbmUga2V5IGFuZCBvbmUgdmFsdWUsIGJ1dCB3aXRoIC5maWVsZCguLi4pIHdlIGNhbiBwYXNzXG4vLyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBzcGVjaWZ5IHRoZSBmaWVsZC5cbkRwLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdHlwZSwgZGVmYXVsdEZuLCBoaWRkZW4pIHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy5maW5hbGl6ZWQsIGZhbHNlKTtcbiAgICB0aGlzLm93bkZpZWxkc1tuYW1lXSA9IG5ldyBGaWVsZChuYW1lLCB0eXBlLCBkZWZhdWx0Rm4sIGhpZGRlbik7XG4gICAgcmV0dXJuIHRoaXM7IC8vIEZvciBjaGFpbmluZy5cbn07XG5cbnZhciBuYW1lZFR5cGVzID0ge307XG5leHBvcnRzLm5hbWVkVHlwZXMgPSBuYW1lZFR5cGVzO1xuXG4vLyBMaWtlIE9iamVjdC5rZXlzLCBidXQgYXdhcmUgb2Ygd2hhdCBmaWVsZHMgZWFjaCBBU1QgdHlwZSBzaG91bGQgaGF2ZS5cbmZ1bmN0aW9uIGdldEZpZWxkTmFtZXMob2JqZWN0KSB7XG4gICAgdmFyIGQgPSBEZWYuZnJvbVZhbHVlKG9iamVjdCk7XG4gICAgaWYgKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZmllbGROYW1lcy5zbGljZSgwKTtcbiAgICB9XG5cbiAgICBpZiAoXCJ0eXBlXCIgaW4gb2JqZWN0KSB7XG4gICAgICAgIGFzc2VydC5vayhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJkaWQgbm90IHJlY29nbml6ZSBvYmplY3Qgb2YgdHlwZSBcIiArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob2JqZWN0LnR5cGUpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG59XG5leHBvcnRzLmdldEZpZWxkTmFtZXMgPSBnZXRGaWVsZE5hbWVzO1xuXG4vLyBHZXQgdGhlIHZhbHVlIG9mIGFuIG9iamVjdCBwcm9wZXJ0eSwgdGFraW5nIG9iamVjdC50eXBlIGFuZCBkZWZhdWx0XG4vLyBmdW5jdGlvbnMgaW50byBhY2NvdW50LlxuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZShvYmplY3QsIGZpZWxkTmFtZSkge1xuICAgIHZhciBkID0gRGVmLmZyb21WYWx1ZShvYmplY3QpO1xuICAgIGlmIChkKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGQuYWxsRmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmdldFZhbHVlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0W2ZpZWxkTmFtZV07XG59XG5leHBvcnRzLmdldEZpZWxkVmFsdWUgPSBnZXRGaWVsZFZhbHVlO1xuXG4vLyBJdGVyYXRlIG92ZXIgYWxsIGRlZmluZWQgZmllbGRzIG9mIGFuIG9iamVjdCwgaW5jbHVkaW5nIHRob3NlIG1pc3Npbmdcbi8vIG9yIHVuZGVmaW5lZCwgcGFzc2luZyBlYWNoIGZpZWxkIG5hbWUgYW5kIGVmZmVjdGl2ZSB2YWx1ZSAoYXMgcmV0dXJuZWRcbi8vIGJ5IGdldEZpZWxkVmFsdWUpIHRvIHRoZSBjYWxsYmFjay4gSWYgdGhlIG9iamVjdCBoYXMgbm8gY29ycmVzcG9uZGluZ1xuLy8gRGVmLCB0aGUgY2FsbGJhY2sgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG5leHBvcnRzLmVhY2hGaWVsZCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBnZXRGaWVsZE5hbWVzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgZ2V0RmllbGRWYWx1ZShvYmplY3QsIG5hbWUpKTtcbiAgICB9LCBjb250ZXh0KTtcbn07XG5cbi8vIFNpbWlsYXIgdG8gZWFjaEZpZWxkLCBleGNlcHQgdGhhdCBpdGVyYXRpb24gc3RvcHMgYXMgc29vbiBhcyB0aGVcbi8vIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuIExpa2UgQXJyYXkucHJvdG90eXBlLnNvbWUsIHRoZSBmaW5hbFxuLy8gcmVzdWx0IGlzIGVpdGhlciB0cnVlIG9yIGZhbHNlIHRvIGluZGljYXRlcyB3aGV0aGVyIHRoZSBjYWxsYmFja1xuLy8gcmV0dXJuZWQgdHJ1ZSBmb3IgYW55IGVsZW1lbnQgb3Igbm90LlxuZXhwb3J0cy5zb21lRmllbGQgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdldEZpZWxkTmFtZXMob2JqZWN0KS5zb21lKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgZ2V0RmllbGRWYWx1ZShvYmplY3QsIG5hbWUpKTtcbiAgICB9LCBjb250ZXh0KTtcbn07XG5cbi8vIFRoaXMgcHJvcGVydHkgd2lsbCBiZSBvdmVycmlkZGVuIGFzIHRydWUgYnkgaW5kaXZpZHVhbCBEZWYgaW5zdGFuY2VzXG4vLyB3aGVuIHRoZXkgYXJlIGZpbmFsaXplZC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEcCwgXCJmaW5hbGl6ZWRcIiwgeyB2YWx1ZTogZmFsc2UgfSk7XG5cbkRwLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gSXQncyBub3QgYW4gZXJyb3IgdG8gZmluYWxpemUgYSB0eXBlIG1vcmUgdGhhbiBvbmNlLCBidXQgb25seSB0aGVcbiAgICAvLyBmaXJzdCBjYWxsIHRvIC5maW5hbGl6ZSBkb2VzIGFueXRoaW5nLlxuICAgIGlmICghdGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgdmFyIGFsbEZpZWxkcyA9IHRoaXMuYWxsRmllbGRzO1xuICAgICAgICB2YXIgYWxsU3VwZXJ0eXBlcyA9IHRoaXMuYWxsU3VwZXJ0eXBlcztcblxuICAgICAgICB0aGlzLmJhc2VOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZDYWNoZVtuYW1lXTtcbiAgICAgICAgICAgIGRlZi5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgZXh0ZW5kKGFsbEZpZWxkcywgZGVmLmFsbEZpZWxkcyk7XG4gICAgICAgICAgICBleHRlbmQoYWxsU3VwZXJ0eXBlcywgZGVmLmFsbFN1cGVydHlwZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPIFdhcm4gaWYgZmllbGRzIGFyZSBvdmVycmlkZGVuIHdpdGggaW5jb21wYXRpYmxlIHR5cGVzLlxuICAgICAgICBleHRlbmQoYWxsRmllbGRzLCB0aGlzLm93bkZpZWxkcyk7XG4gICAgICAgIGFsbFN1cGVydHlwZXNbdGhpcy50eXBlTmFtZV0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZmllbGROYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gYWxsRmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoYWxsRmllbGRzLCBmaWVsZE5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWFsbEZpZWxkc1tmaWVsZE5hbWVdLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmllbGROYW1lcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUeXBlcyBhcmUgZXhwb3J0ZWQgb25seSBvbmNlIHRoZXkgaGF2ZSBiZWVuIGZpbmFsaXplZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVkVHlwZXMsIHRoaXMudHlwZU5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50eXBlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsaXplZFwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIEEgbGluZWFyaXphdGlvbiBvZiB0aGUgaW5oZXJpdGFuY2UgaGllcmFyY2h5LlxuICAgICAgICBwb3B1bGF0ZVN1cGVydHlwZUxpc3QodGhpcy50eXBlTmFtZSwgdGhpcy5zdXBlcnR5cGVMaXN0KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZVN1cGVydHlwZUxpc3QodHlwZU5hbWUsIGxpc3QpIHtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgbGlzdC5wdXNoKHR5cGVOYW1lKTtcblxuICAgIHZhciBsYXN0U2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBsaXN0Lmxlbmd0aDsgKytwb3MpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBsaXN0W3Bvc107XG4gICAgICAgIHZhciBkID0gZGVmQ2FjaGVbdHlwZU5hbWVdO1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoZC5maW5hbGl6ZWQsIHRydWUpO1xuXG4gICAgICAgIC8vIElmIHdlIHNhdyB0eXBlTmFtZSBlYXJsaWVyIGluIHRoZSBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbCxcbiAgICAgICAgLy8gZGVsZXRlIHRoZSBsYXN0LXNlZW4gb2NjdXJyZW5jZS5cbiAgICAgICAgaWYgKGhhc093bi5jYWxsKGxhc3RTZWVuLCB0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0W2xhc3RTZWVuW3R5cGVOYW1lXV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvcmQgdGhlIG5ldyBpbmRleCBvZiB0aGUgbGFzdC1zZWVuIG9jY3VycmVuY2Ugb2YgdHlwZU5hbWUuXG4gICAgICAgIGxhc3RTZWVuW3R5cGVOYW1lXSA9IHBvcztcblxuICAgICAgICAvLyBFbnF1ZXVlIHRoZSBiYXNlIG5hbWVzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIGQuYmFzZU5hbWVzKTtcbiAgICB9XG5cbiAgICAvLyBDb21wYWN0aW9uIGxvb3AgdG8gcmVtb3ZlIGFycmF5IGhvbGVzLlxuICAgIGZvciAodmFyIHRvID0gMCwgZnJvbSA9IHRvLCBsZW4gPSBsaXN0Lmxlbmd0aDsgZnJvbSA8IGxlbjsgKytmcm9tKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChsaXN0LCBmcm9tKSkge1xuICAgICAgICAgICAgbGlzdFt0bysrXSA9IGxpc3RbZnJvbV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0Lmxlbmd0aCA9IHRvO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoaW50bywgZnJvbSkge1xuICAgIE9iamVjdC5rZXlzKGZyb20pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpbnRvW25hbWVdID0gZnJvbVtuYW1lXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBpbnRvO1xufTtcblxuZXhwb3J0cy5maW5hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5rZXlzKGRlZkNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZGVmQ2FjaGVbbmFtZV0uZmluYWxpemUoKTtcbiAgICB9KTtcbn07XG4iLCJ2YXIgdHlwZXMgPSByZXF1aXJlKFwiLi9saWIvdHlwZXNcIik7XG5cbi8vIFRoaXMgY29yZSBtb2R1bGUgb2YgQVNUIHR5cGVzIGNhcHR1cmVzIEVTNSBhcyBpdCBpcyBwYXJzZWQgdG9kYXkgYnlcbi8vIGdpdDovL2dpdGh1Yi5jb20vYXJpeWEvZXNwcmltYS5naXQjbWFzdGVyLlxucmVxdWlyZShcIi4vZGVmL2NvcmVcIik7XG5cbi8vIEZlZWwgZnJlZSB0byBhZGQgdG8gb3IgcmVtb3ZlIGZyb20gdGhpcyBsaXN0IG9mIGV4dGVuc2lvbiBtb2R1bGVzIHRvXG4vLyBjb25maWd1cmUgdGhlIHByZWNpc2UgdHlwZSBoaWVyYXJjaHkgdGhhdCB5b3UgbmVlZC5cbnJlcXVpcmUoXCIuL2RlZi9lczZcIik7XG5yZXF1aXJlKFwiLi9kZWYvZXM3XCIpO1xucmVxdWlyZShcIi4vZGVmL21vemlsbGFcIik7XG5yZXF1aXJlKFwiLi9kZWYvZTR4XCIpO1xucmVxdWlyZShcIi4vZGVmL2ZiLWhhcm1vbnlcIik7XG5cbnR5cGVzLmZpbmFsaXplKCk7XG5cbmV4cG9ydHMuVHlwZSA9IHR5cGVzLlR5cGU7XG5leHBvcnRzLmJ1aWx0SW5UeXBlcyA9IHR5cGVzLmJ1aWx0SW5UeXBlcztcbmV4cG9ydHMubmFtZWRUeXBlcyA9IHR5cGVzLm5hbWVkVHlwZXM7XG5leHBvcnRzLmJ1aWxkZXJzID0gdHlwZXMuYnVpbGRlcnM7XG5leHBvcnRzLmRlZmluZU1ldGhvZCA9IHR5cGVzLmRlZmluZU1ldGhvZDtcbmV4cG9ydHMuZ2V0RmllbGROYW1lcyA9IHR5cGVzLmdldEZpZWxkTmFtZXM7XG5leHBvcnRzLmdldEZpZWxkVmFsdWUgPSB0eXBlcy5nZXRGaWVsZFZhbHVlO1xuZXhwb3J0cy5lYWNoRmllbGQgPSB0eXBlcy5lYWNoRmllbGQ7XG5leHBvcnRzLnNvbWVGaWVsZCA9IHR5cGVzLnNvbWVGaWVsZDtcbmV4cG9ydHMuZ2V0U3VwZXJ0eXBlTmFtZXMgPSB0eXBlcy5nZXRTdXBlcnR5cGVOYW1lcztcbmV4cG9ydHMuYXN0Tm9kZXNBcmVFcXVpdmFsZW50ID0gcmVxdWlyZShcIi4vbGliL2VxdWl2XCIpO1xuZXhwb3J0cy5maW5hbGl6ZSA9IHR5cGVzLmZpbmFsaXplO1xuZXhwb3J0cy5Ob2RlUGF0aCA9IHJlcXVpcmUoXCIuL2xpYi9ub2RlLXBhdGhcIik7XG5leHBvcnRzLlBhdGhWaXNpdG9yID0gcmVxdWlyZShcIi4vbGliL3BhdGgtdmlzaXRvclwiKTtcbmV4cG9ydHMudmlzaXQgPSBleHBvcnRzLlBhdGhWaXNpdG9yLnZpc2l0O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGhhc0Fuc2kgPSByZXF1aXJlKCdoYXMtYW5zaScpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgY2hhbGsgPSBtb2R1bGUuZXhwb3J0cztcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuXHR2YXIgYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG5cdFx0cmV0dXJuIGFwcGx5U3R5bGUuYXBwbHkoYnVpbGRlciwgYXJndW1lbnRzKTtcblx0fTtcblx0YnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcblx0Ly8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuXHRyZXR1cm4gYnVpbGRlcjtcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRhbnNpU3R5bGVzLmdyZXkgPSBhbnNpU3R5bGVzLmdyYXk7XG5cblx0T2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdFx0cmV0W2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkKHRoaXMuX3N0eWxlcy5jb25jYXQoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn0pKCk7XG5cbnZhciBwcm90byA9IGRlZmluZVByb3BzKGZ1bmN0aW9uIGNoYWxrKCkge30sIHN0eWxlcyk7XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG5cdC8vIHN1cHBvcnQgdmFyYWdzLCBidXQgc2ltcGx5IGNhc3QgdG8gc3RyaW5nIGluIGNhc2UgdGhlcmUncyBvbmx5IG9uZSBhcmdcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG5cdHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXHRpZiAoYXJnc0xlbiA+IDEpIHtcblx0XHQvLyBkb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgdjggb3B0aW1pemF0aW9uc1xuXHRcdGZvciAodmFyIGEgPSAxOyBhIDwgYXJnc0xlbjsgYSsrKSB7XG5cdFx0XHRzdHIgKz0gJyAnICsgYXJnc1thXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoYWxrLmVuYWJsZWQgfHwgIXN0cikge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHQvKmpzaGludCB2YWxpZHRoaXM6IHRydWUqL1xuXHR2YXIgbmVzdGVkU3R5bGVzID0gdGhpcy5fc3R5bGVzO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbmVzdGVkU3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG5cdFx0Ly8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG5cdFx0Ly8gb3RoZXJ3aXNlIG9ubHkgdGhlIHBhcnQgb2YgdGhlIHN0cmluZyB1bnRpbCBzYWlkIGNsb3NpbmcgY29kZVxuXHRcdC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG5cdFx0c3RyID0gY29kZS5vcGVuICsgc3RyLnJlcGxhY2UoY29kZS5jbG9zZVJlLCBjb2RlLm9wZW4pICsgY29kZS5jbG9zZTtcblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXRbbmFtZV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkKFtuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZGVmaW5lUHJvcHMoY2hhbGssIGluaXQoKSk7XG5cbmNoYWxrLnN0eWxlcyA9IGFuc2lTdHlsZXM7XG5jaGFsay5oYXNDb2xvciA9IGhhc0Fuc2k7XG5jaGFsay5zdHJpcENvbG9yID0gc3RyaXBBbnNpO1xuY2hhbGsuc3VwcG9ydHNDb2xvciA9IHN1cHBvcnRzQ29sb3I7XG5cbi8vIGRldGVjdCBtb2RlIGlmIG5vdCBzZXQgbWFudWFsbHlcbmlmIChjaGFsay5lbmFibGVkID09PSB1bmRlZmluZWQpIHtcblx0Y2hhbGsuZW5hYmxlZCA9IGNoYWxrLnN1cHBvcnRzQ29sb3I7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3R5bGVzID0gbW9kdWxlLmV4cG9ydHM7XG5cbnZhciBjb2RlcyA9IHtcblx0cmVzZXQ6IFswLCAwXSxcblxuXHRib2xkOiBbMSwgMjJdLCAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdGRpbTogWzIsIDIyXSxcblx0aXRhbGljOiBbMywgMjNdLFxuXHR1bmRlcmxpbmU6IFs0LCAyNF0sXG5cdGludmVyc2U6IFs3LCAyN10sXG5cdGhpZGRlbjogWzgsIDI4XSxcblx0c3RyaWtldGhyb3VnaDogWzksIDI5XSxcblxuXHRibGFjazogWzMwLCAzOV0sXG5cdHJlZDogWzMxLCAzOV0sXG5cdGdyZWVuOiBbMzIsIDM5XSxcblx0eWVsbG93OiBbMzMsIDM5XSxcblx0Ymx1ZTogWzM0LCAzOV0sXG5cdG1hZ2VudGE6IFszNSwgMzldLFxuXHRjeWFuOiBbMzYsIDM5XSxcblx0d2hpdGU6IFszNywgMzldLFxuXHRncmF5OiBbOTAsIDM5XSxcblxuXHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0YmdSZWQ6IFs0MSwgNDldLFxuXHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRiZ0N5YW46IFs0NiwgNDldLFxuXHRiZ1doaXRlOiBbNDcsIDQ5XVxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHR2YXIgdmFsID0gY29kZXNba2V5XTtcblx0dmFyIHN0eWxlID0gc3R5bGVzW2tleV0gPSB7fTtcblx0c3R5bGUub3BlbiA9ICdcXHUwMDFiWycgKyB2YWxbMF0gKyAnbSc7XG5cdHN0eWxlLmNsb3NlID0gJ1xcdTAwMWJbJyArIHZhbFsxXSArICdtJztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRyZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgICdcXFxcJCYnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xudmFyIHJlID0gbmV3IFJlZ0V4cChhbnNpUmVnZXgoKS5zb3VyY2UpOyAvLyByZW1vdmUgdGhlIGBnYCBmbGFnXG5tb2R1bGUuZXhwb3J0cyA9IHJlLnRlc3QuYmluZChyZSk7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9cXHUwMDFiXFxbKD86WzAtOV17MSwzfSg/OjtbMC05XXsxLDN9KSopP1ttfEtdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAocHJvY2Vzcy5hcmd2LmluZGV4T2YoJy0tbm8tY29sb3InKSAhPT0gLTEpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5hcmd2LmluZGV4T2YoJy0tY29sb3InKSAhPT0gLTEpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnN0ZG91dCAmJiAhcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCdDT0xPUlRFUk0nIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5lbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8Y29sb3J8YW5zaXxjeWd3aW58bGludXgvaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59KSgpO1xuIiwiLyoqXG4gKiBDb3JlLmpzIDAuNS40XG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qc1xuICogTGljZW5zZTogaHR0cDovL3JvY2subWl0LWxpY2Vuc2Uub3JnXG4gKiDCqSAyMDE1IERlbmlzIFB1c2hrYXJldlxuICovXG4hZnVuY3Rpb24oZ2xvYmFsLCBmcmFtZXdvcmssIHVuZGVmaW5lZCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gU2hvcnRjdXRzIGZvciBbW0NsYXNzXV0gJiBwcm9wZXJ0eSBuYW1lc1xyXG52YXIgT0JKRUNUICAgICAgICAgID0gJ09iamVjdCdcclxuICAsIEZVTkNUSU9OICAgICAgICA9ICdGdW5jdGlvbidcclxuICAsIEFSUkFZICAgICAgICAgICA9ICdBcnJheSdcclxuICAsIFNUUklORyAgICAgICAgICA9ICdTdHJpbmcnXHJcbiAgLCBOVU1CRVIgICAgICAgICAgPSAnTnVtYmVyJ1xyXG4gICwgUkVHRVhQICAgICAgICAgID0gJ1JlZ0V4cCdcclxuICAsIERBVEUgICAgICAgICAgICA9ICdEYXRlJ1xyXG4gICwgTUFQICAgICAgICAgICAgID0gJ01hcCdcclxuICAsIFNFVCAgICAgICAgICAgICA9ICdTZXQnXHJcbiAgLCBXRUFLTUFQICAgICAgICAgPSAnV2Vha01hcCdcclxuICAsIFdFQUtTRVQgICAgICAgICA9ICdXZWFrU2V0J1xyXG4gICwgU1lNQk9MICAgICAgICAgID0gJ1N5bWJvbCdcclxuICAsIFBST01JU0UgICAgICAgICA9ICdQcm9taXNlJ1xyXG4gICwgTUFUSCAgICAgICAgICAgID0gJ01hdGgnXHJcbiAgLCBBUkdVTUVOVFMgICAgICAgPSAnQXJndW1lbnRzJ1xyXG4gICwgUFJPVE9UWVBFICAgICAgID0gJ3Byb3RvdHlwZSdcclxuICAsIENPTlNUUlVDVE9SICAgICA9ICdjb25zdHJ1Y3RvcidcclxuICAsIFRPX1NUUklORyAgICAgICA9ICd0b1N0cmluZydcclxuICAsIFRPX1NUUklOR19UQUcgICA9IFRPX1NUUklORyArICdUYWcnXHJcbiAgLCBUT19MT0NBTEUgICAgICAgPSAndG9Mb2NhbGVTdHJpbmcnXHJcbiAgLCBIQVNfT1dOICAgICAgICAgPSAnaGFzT3duUHJvcGVydHknXHJcbiAgLCBGT1JfRUFDSCAgICAgICAgPSAnZm9yRWFjaCdcclxuICAsIElURVJBVE9SICAgICAgICA9ICdpdGVyYXRvcidcclxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQCcgKyBJVEVSQVRPUlxyXG4gICwgUFJPQ0VTUyAgICAgICAgID0gJ3Byb2Nlc3MnXHJcbiAgLCBDUkVBVEVfRUxFTUVOVCAgPSAnY3JlYXRlRWxlbWVudCdcclxuICAvLyBBbGlhc2VzIGdsb2JhbCBvYmplY3RzIGFuZCBwcm90b3R5cGVzXHJcbiAgLCBGdW5jdGlvbiAgICAgICAgPSBnbG9iYWxbRlVOQ1RJT05dXHJcbiAgLCBPYmplY3QgICAgICAgICAgPSBnbG9iYWxbT0JKRUNUXVxyXG4gICwgQXJyYXkgICAgICAgICAgID0gZ2xvYmFsW0FSUkFZXVxyXG4gICwgU3RyaW5nICAgICAgICAgID0gZ2xvYmFsW1NUUklOR11cclxuICAsIE51bWJlciAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXHJcbiAgLCBSZWdFeHAgICAgICAgICAgPSBnbG9iYWxbUkVHRVhQXVxyXG4gICwgRGF0ZSAgICAgICAgICAgID0gZ2xvYmFsW0RBVEVdXHJcbiAgLCBNYXAgICAgICAgICAgICAgPSBnbG9iYWxbTUFQXVxyXG4gICwgU2V0ICAgICAgICAgICAgID0gZ2xvYmFsW1NFVF1cclxuICAsIFdlYWtNYXAgICAgICAgICA9IGdsb2JhbFtXRUFLTUFQXVxyXG4gICwgV2Vha1NldCAgICAgICAgID0gZ2xvYmFsW1dFQUtTRVRdXHJcbiAgLCBTeW1ib2wgICAgICAgICAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICwgTWF0aCAgICAgICAgICAgID0gZ2xvYmFsW01BVEhdXHJcbiAgLCBUeXBlRXJyb3IgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXHJcbiAgLCBSYW5nZUVycm9yICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxyXG4gICwgc2V0VGltZW91dCAgICAgID0gZ2xvYmFsLnNldFRpbWVvdXRcclxuICAsIHNldEltbWVkaWF0ZSAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcclxuICAsIGNsZWFySW1tZWRpYXRlICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxyXG4gICwgcGFyc2VJbnQgICAgICAgID0gZ2xvYmFsLnBhcnNlSW50XHJcbiAgLCBpc0Zpbml0ZSAgICAgICAgPSBnbG9iYWwuaXNGaW5pdGVcclxuICAsIHByb2Nlc3MgICAgICAgICA9IGdsb2JhbFtQUk9DRVNTXVxyXG4gICwgbmV4dFRpY2sgICAgICAgID0gcHJvY2VzcyAmJiBwcm9jZXNzLm5leHRUaWNrXHJcbiAgLCBkb2N1bWVudCAgICAgICAgPSBnbG9iYWwuZG9jdW1lbnRcclxuICAsIGh0bWwgICAgICAgICAgICA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICwgbmF2aWdhdG9yICAgICAgID0gZ2xvYmFsLm5hdmlnYXRvclxyXG4gICwgZGVmaW5lICAgICAgICAgID0gZ2xvYmFsLmRlZmluZVxyXG4gICwgQXJyYXlQcm90byAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxyXG4gICwgT2JqZWN0UHJvdG8gICAgID0gT2JqZWN0W1BST1RPVFlQRV1cclxuICAsIEZ1bmN0aW9uUHJvdG8gICA9IEZ1bmN0aW9uW1BST1RPVFlQRV1cclxuICAsIEluZmluaXR5ICAgICAgICA9IDEgLyAwXHJcbiAgLCBET1QgICAgICAgICAgICAgPSAnLidcclxuICAvLyBNZXRob2RzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0RldmVsb3BlclRvb2xzV0cvY29uc29sZS1vYmplY3QvYmxvYi9tYXN0ZXIvYXBpLm1kXHJcbiAgLCBDT05TT0xFX01FVEhPRFMgPSAnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLCcgK1xyXG4gICAgICAnZ3JvdXAsZ3JvdXBDb2xsYXBzZWQsZ3JvdXBFbmQsaW5mbyxpc0luZGVwZW5kZW50bHlDb21wb3NlZCxsb2csJyArXHJcbiAgICAgICdtYXJrVGltZWxpbmUscHJvZmlsZSxwcm9maWxlRW5kLHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSwnICtcclxuICAgICAgJ3RpbWVsaW5lRW5kLHRpbWVTdGFtcCx0cmFjZSx3YXJuJztcclxuXHJcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcmUtanMtaXNvYmplY3RcclxuZnVuY3Rpb24gaXNPYmplY3QoaXQpe1xyXG4gIHJldHVybiBpdCAhPT0gbnVsbCAmJiAodHlwZW9mIGl0ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gdHlwZW9mIGl0ID09ICdmdW5jdGlvbic7XHJcbn1cclxuLy8gTmF0aXZlIGZ1bmN0aW9uP1xyXG52YXIgaXNOYXRpdmUgPSBjdHgoLy4vLnRlc3QsIC9cXFtuYXRpdmUgY29kZVxcXVxccypcXH1cXHMqJC8sIDEpO1xyXG5cclxuLy8gT2JqZWN0IGludGVybmFsIFtbQ2xhc3NdXSBvciB0b1N0cmluZ1RhZ1xyXG4vLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXHJcbnZhciB0b1N0cmluZyA9IE9iamVjdFByb3RvW1RPX1NUUklOR107XHJcbmZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKGl0LCB0YWcsIHN0YXQpe1xyXG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdFtQUk9UT1RZUEVdLCBTWU1CT0xfVEFHKSloaWRkZW4oaXQsIFNZTUJPTF9UQUcsIHRhZyk7XHJcbn1cclxuZnVuY3Rpb24gY29mKGl0KXtcclxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xyXG59XHJcbmZ1bmN0aW9uIGNsYXNzb2YoaXQpe1xyXG4gIHZhciBPLCBUO1xyXG4gIHJldHVybiBpdCA9PSB1bmRlZmluZWQgPyBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiAnTnVsbCdcclxuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtTWU1CT0xfVEFHXSkgPT0gJ3N0cmluZycgPyBUIDogY29mKE8pO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvblxyXG52YXIgY2FsbCAgPSBGdW5jdGlvblByb3RvLmNhbGxcclxuICAsIGFwcGx5ID0gRnVuY3Rpb25Qcm90by5hcHBseVxyXG4gICwgUkVGRVJFTkNFX0dFVDtcclxuLy8gUGFydGlhbCBhcHBseVxyXG5mdW5jdGlvbiBwYXJ0KC8qIC4uLmFyZ3MgKi8pe1xyXG4gIHZhciBmbiAgICAgPSBhc3NlcnRGdW5jdGlvbih0aGlzKVxyXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGFyZ3MgICA9IEFycmF5KGxlbmd0aClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCBfICAgICAgPSBwYXRoLl9cclxuICAgICwgaG9sZGVyID0gZmFsc2U7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigoYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xyXG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgIHZhciB0aGF0ICAgID0gdGhpc1xyXG4gICAgICAsIF9sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICwgaSA9IDAsIGogPSAwLCBfYXJncztcclxuICAgIGlmKCFob2xkZXIgJiYgIV9sZW5ndGgpcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XHJcbiAgICBfYXJncyA9IGFyZ3Muc2xpY2UoKTtcclxuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGk7IGkrKylpZihfYXJnc1tpXSA9PT0gXylfYXJnc1tpXSA9IGFyZ3VtZW50c1tqKytdO1xyXG4gICAgd2hpbGUoX2xlbmd0aCA+IGopX2FyZ3MucHVzaChhcmd1bWVudHNbaisrXSk7XHJcbiAgICByZXR1cm4gaW52b2tlKGZuLCBfYXJncywgdGhhdCk7XHJcbiAgfVxyXG59XHJcbi8vIE9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xyXG5mdW5jdGlvbiBjdHgoZm4sIHRoYXQsIGxlbmd0aCl7XHJcbiAgYXNzZXJ0RnVuY3Rpb24oZm4pO1xyXG4gIGlmKH5sZW5ndGggJiYgdGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcclxuICBzd2l0Y2gobGVuZ3RoKXtcclxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuICAgIH1cclxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcclxuICAgIH1cclxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcclxuICAgIH1cclxuICB9IHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59XHJcbi8vIEZhc3QgYXBwbHlcclxuLy8gaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XHJcbmZ1bmN0aW9uIGludm9rZShmbiwgYXJncywgdGhhdCl7XHJcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xyXG4gIHN3aXRjaChhcmdzLmxlbmd0aCB8IDApe1xyXG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XHJcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XHJcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XHJcbiAgICBjYXNlIDU6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XHJcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgLyosIG5ld1RhcmdldCovKXtcclxuICB2YXIgcHJvdG8gICAgPSBhc3NlcnRGdW5jdGlvbihhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXSlbUFJPVE9UWVBFXVxyXG4gICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvKVxyXG4gICAgLCByZXN1bHQgICA9IGFwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XHJcbiAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcclxufVxyXG5cclxuLy8gT2JqZWN0OlxyXG52YXIgY3JlYXRlICAgICAgICAgICA9IE9iamVjdC5jcmVhdGVcclxuICAsIGdldFByb3RvdHlwZU9mICAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcclxuICAsIHNldFByb3RvdHlwZU9mICAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAsIGRlZmluZVByb3BlcnR5ICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcclxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xyXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcclxuICAsIGdldEtleXMgICAgICAgICAgPSBPYmplY3Qua2V5c1xyXG4gICwgZ2V0TmFtZXMgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgLCBnZXRTeW1ib2xzICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xyXG4gICwgaXNGcm96ZW4gICAgICAgICA9IE9iamVjdC5pc0Zyb3plblxyXG4gICwgaGFzICAgICAgICAgICAgICA9IGN0eChjYWxsLCBPYmplY3RQcm90b1tIQVNfT1dOXSwgMilcclxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcclxuICAsIEVTNU9iamVjdCAgICAgICAgPSBPYmplY3RcclxuICAsIERpY3Q7XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGl0KXtcclxuICByZXR1cm4gRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5JdChpdCl7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIHJldHVyblRoaXMoKXtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBrZXkpe1xyXG4gIGlmKGhhcyhvYmplY3QsIGtleSkpcmV0dXJuIG9iamVjdFtrZXldO1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXMoaXQpe1xyXG4gIGFzc2VydE9iamVjdChpdCk7XHJcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBnZXROYW1lcyhpdCkuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGdldE5hbWVzKGl0KTtcclxufVxyXG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXHJcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKXtcclxuICB2YXIgVCA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRhcmdldCkpXHJcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGkgPSAxO1xyXG4gIHdoaWxlKGwgPiBpKXtcclxuICAgIHZhciBTICAgICAgPSBFUzVPYmplY3QoYXJndW1lbnRzW2krK10pXHJcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhTKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaiAgICAgID0gMFxyXG4gICAgICAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xyXG4gIH1cclxuICByZXR1cm4gVDtcclxufVxyXG5mdW5jdGlvbiBrZXlPZihvYmplY3QsIGVsKXtcclxuICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGluZGV4ICA9IDBcclxuICAgICwga2V5O1xyXG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XHJcbn1cclxuXHJcbi8vIEFycmF5XHJcbi8vIGFycmF5KCdzdHIxLHN0cjIsc3RyMycpID0+IFsnc3RyMScsICdzdHIyJywgJ3N0cjMnXVxyXG5mdW5jdGlvbiBhcnJheShpdCl7XHJcbiAgcmV0dXJuIFN0cmluZyhpdCkuc3BsaXQoJywnKTtcclxufVxyXG52YXIgcHVzaCAgICA9IEFycmF5UHJvdG8ucHVzaFxyXG4gICwgdW5zaGlmdCA9IEFycmF5UHJvdG8udW5zaGlmdFxyXG4gICwgc2xpY2UgICA9IEFycmF5UHJvdG8uc2xpY2VcclxuICAsIHNwbGljZSAgPSBBcnJheVByb3RvLnNwbGljZVxyXG4gICwgaW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZlxyXG4gICwgZm9yRWFjaCA9IEFycmF5UHJvdG9bRk9SX0VBQ0hdO1xyXG4vKlxyXG4gKiAwIC0+IGZvckVhY2hcclxuICogMSAtPiBtYXBcclxuICogMiAtPiBmaWx0ZXJcclxuICogMyAtPiBzb21lXHJcbiAqIDQgLT4gZXZlcnlcclxuICogNSAtPiBmaW5kXHJcbiAqIDYgLT4gZmluZEluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheU1ldGhvZCh0eXBlKXtcclxuICB2YXIgaXNNYXAgICAgICAgPSB0eXBlID09IDFcclxuICAgICwgaXNGaWx0ZXIgICAgPSB0eXBlID09IDJcclxuICAgICwgaXNTb21lICAgICAgPSB0eXBlID09IDNcclxuICAgICwgaXNFdmVyeSAgICAgPSB0eXBlID09IDRcclxuICAgICwgaXNGaW5kSW5kZXggPSB0eXBlID09IDZcclxuICAgICwgbm9ob2xlcyAgICAgPSB0eXBlID09IDUgfHwgaXNGaW5kSW5kZXg7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgdGhhdCAgID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICwgc2VsZiAgID0gRVM1T2JqZWN0KE8pXHJcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gMFxyXG4gICAgICAsIHJlc3VsdCA9IGlzTWFwID8gQXJyYXkobGVuZ3RoKSA6IGlzRmlsdGVyID8gW10gOiB1bmRlZmluZWRcclxuICAgICAgLCB2YWwsIHJlcztcclxuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYobm9ob2xlcyB8fCBpbmRleCBpbiBzZWxmKXtcclxuICAgICAgdmFsID0gc2VsZltpbmRleF07XHJcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XHJcbiAgICAgIGlmKHR5cGUpe1xyXG4gICAgICAgIGlmKGlzTWFwKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgIC8vIG1hcFxyXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXHJcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxyXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxyXG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxyXG4gICAgICAgIH0gZWxzZSBpZihpc0V2ZXJ5KXJldHVybiBmYWxzZTsgICAgICAgICAgIC8vIGV2ZXJ5XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0ZpbmRJbmRleCA/IC0xIDogaXNTb21lIHx8IGlzRXZlcnkgPyBpc0V2ZXJ5IDogcmVzdWx0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUNvbnRhaW5zKGlzQ29udGFpbnMpe1xyXG4gIHJldHVybiBmdW5jdGlvbihlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGFyZ3VtZW50c1sxXSwgbGVuZ3RoKTtcclxuICAgIGlmKGlzQ29udGFpbnMgJiYgZWwgIT0gZWwpe1xyXG4gICAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKHNhbWVOYU4oT1tpbmRleF0pKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoaXNDb250YWlucyB8fCBpbmRleCBpbiBPKXtcclxuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSByZXR1cm4gIWlzQ29udGFpbnMgJiYgLTE7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbmVyaWMoQSwgQil7XHJcbiAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiB2cyBpc0Z1bmN0aW9uXHJcbiAgcmV0dXJuIHR5cGVvZiBBID09ICdmdW5jdGlvbicgPyBBIDogQjtcclxufVxyXG5cclxuLy8gTWF0aFxyXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxyXG4gICwgcG93ICAgID0gTWF0aC5wb3dcclxuICAsIGFicyAgICA9IE1hdGguYWJzXHJcbiAgLCBjZWlsICAgPSBNYXRoLmNlaWxcclxuICAsIGZsb29yICA9IE1hdGguZmxvb3JcclxuICAsIG1heCAgICA9IE1hdGgubWF4XHJcbiAgLCBtaW4gICAgPSBNYXRoLm1pblxyXG4gICwgcmFuZG9tID0gTWF0aC5yYW5kb21cclxuICAsIHRydW5jICA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xyXG4gICAgfVxyXG4vLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG5mdW5jdGlvbiBzYW1lTmFOKG51bWJlcil7XHJcbiAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XHJcbn1cclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XHJcbiAgcmV0dXJuIGlzTmFOKGl0KSA/IDAgOiB0cnVuYyhpdCk7XHJcbn1cclxuLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbmZ1bmN0aW9uIHRvTGVuZ3RoKGl0KXtcclxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIE1BWF9TQUZFX0lOVEVHRVIpIDogMDtcclxufVxyXG5mdW5jdGlvbiB0b0luZGV4KGluZGV4LCBsZW5ndGgpe1xyXG4gIHZhciBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XHJcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gbHoobnVtKXtcclxuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUmVwbGFjZXIocmVnRXhwLCByZXBsYWNlLCBpc1N0YXRpYyl7XHJcbiAgdmFyIHJlcGxhY2VyID0gaXNPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcclxuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xyXG4gIH0gOiByZXBsYWNlO1xyXG4gIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gU3RyaW5nKGlzU3RhdGljID8gaXQgOiB0aGlzKS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludEF0KHRvU3RyaW5nKXtcclxuICByZXR1cm4gZnVuY3Rpb24ocG9zKXtcclxuICAgIHZhciBzID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXHJcbiAgICAgICwgbCA9IHMubGVuZ3RoXHJcbiAgICAgICwgYSwgYjtcclxuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gdG9TdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcclxuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxyXG4gICAgICA/IHRvU3RyaW5nID8gcy5jaGFyQXQoaSkgOiBhXHJcbiAgICAgIDogdG9TdHJpbmcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBc3NlcnRpb24gJiBlcnJvcnNcclxudmFyIFJFRFVDRV9FUlJPUiA9ICdSZWR1Y2Ugb2YgZW1wdHkgb2JqZWN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZzEsIG1zZzIpe1xyXG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xyXG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihpdCl7XHJcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oaXQpLCBpdCwgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KGl0KXtcclxuICBhc3NlcnQoaXNPYmplY3QoaXQpLCBpdCwgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJbnN0YW5jZShpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xyXG4gIGFzc2VydChpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCBuYW1lLCBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XHJcbn1cclxuXHJcbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzICYgU3ltYm9sXHJcbmZ1bmN0aW9uIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSl7XHJcbiAgcmV0dXJuIHtcclxuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcclxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcclxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcclxuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSkpO1xyXG4gIH0gOiBzaW1wbGVTZXQ7XHJcbn1cclxuZnVuY3Rpb24gdWlkKGtleSl7XHJcbiAgcmV0dXJuIFNZTUJPTCArICcoJyArIGtleSArICcpXycgKyAoKytzaWQgKyByYW5kb20oKSlbVE9fU1RSSU5HXSgzNik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2VsbEtub3duU3ltYm9sKG5hbWUsIHNldHRlcil7XHJcbiAgcmV0dXJuIChTeW1ib2wgJiYgU3ltYm9sW25hbWVdKSB8fCAoc2V0dGVyID8gU3ltYm9sIDogc2FmZVN5bWJvbCkoU1lNQk9MICsgRE9UICsgbmFtZSk7XHJcbn1cclxuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXHJcbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMiB9fSkuYSA9PSAyO1xyXG4gICAgICB9IGNhdGNoKGUpe31cclxuICAgIH0oKVxyXG4gICwgc2lkICAgID0gMFxyXG4gICwgaGlkZGVuID0gY3JlYXRlRGVmaW5lcigxKVxyXG4gICwgc2V0ICAgID0gU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZGVuXHJcbiAgLCBzYWZlU3ltYm9sID0gU3ltYm9sIHx8IHVpZDtcclxuZnVuY3Rpb24gYXNzaWduSGlkZGVuKHRhcmdldCwgc3JjKXtcclxuICBmb3IodmFyIGtleSBpbiBzcmMpaGlkZGVuKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxudmFyIFNZTUJPTF9VTlNDT1BBQkxFUyA9IGdldFdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKVxyXG4gICwgQXJyYXlVbnNjb3BhYmxlcyAgID0gQXJyYXlQcm90b1tTWU1CT0xfVU5TQ09QQUJMRVNdIHx8IHt9XHJcbiAgLCBTWU1CT0xfU1BFQ0lFUyAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcclxuZnVuY3Rpb24gc2V0U3BlY2llcyhDKXtcclxuICBpZihmcmFtZXdvcmsgfHwgIWlzTmF0aXZlKEMpKWRlZmluZVByb3BlcnR5KEMsIFNZTUJPTF9TUEVDSUVTLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IHJldHVyblRoaXNcclxuICB9KTtcclxufVxyXG5cclxuLy8gSXRlcmF0b3JzXHJcbnZhciBTWU1CT0xfSVRFUkFUT1IgPSBnZXRXZWxsS25vd25TeW1ib2woSVRFUkFUT1IpXHJcbiAgLCBTWU1CT0xfVEFHICAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRylcclxuICAsIFNVUFBPUlRfRkZfSVRFUiA9IEZGX0lURVJBVE9SIGluIEFycmF5UHJvdG9cclxuICAsIElURVIgID0gc2FmZVN5bWJvbCgnaXRlcicpXHJcbiAgLCBLRVkgICA9IDFcclxuICAsIFZBTFVFID0gMlxyXG4gICwgSXRlcmF0b3JzID0ge31cclxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge31cclxuICAsIE5BVElWRV9JVEVSQVRPUlMgPSBTWU1CT0xfSVRFUkFUT1IgaW4gQXJyYXlQcm90b1xyXG4gICAgLy8gU2FmYXJpIGRlZmluZSBieWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxyXG4gICwgQlVHR1lfSVRFUkFUT1JTID0gJ2tleXMnIGluIEFycmF5UHJvdG8gJiYgISgnbmV4dCcgaW4gW10ua2V5cygpKTtcclxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcclxuc2V0SXRlcmF0b3IoSXRlcmF0b3JQcm90b3R5cGUsIHJldHVyblRoaXMpO1xyXG5mdW5jdGlvbiBzZXRJdGVyYXRvcihPLCB2YWx1ZSl7XHJcbiAgaGlkZGVuKE8sIFNZTUJPTF9JVEVSQVRPUiwgdmFsdWUpO1xyXG4gIC8vIEFkZCBpdGVyYXRvciBmb3IgRkYgaXRlcmF0b3IgcHJvdG9jb2xcclxuICBTVVBQT1JUX0ZGX0lURVIgJiYgaGlkZGVuKE8sIEZGX0lURVJBVE9SLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcclxuICBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gY3JlYXRlKHByb3RvIHx8IEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xyXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBOQU1FLCB2YWx1ZSwgREVGQVVMVCl7XHJcbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXVxyXG4gICAgLCBpdGVyICA9IGdldChwcm90bywgU1lNQk9MX0lURVJBVE9SKSB8fCBnZXQocHJvdG8sIEZGX0lURVJBVE9SKSB8fCAoREVGQVVMVCAmJiBnZXQocHJvdG8sIERFRkFVTFQpKSB8fCB2YWx1ZTtcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gRGVmaW5lIGl0ZXJhdG9yXHJcbiAgICBzZXRJdGVyYXRvcihwcm90bywgaXRlcik7XHJcbiAgICBpZihpdGVyICE9PSB2YWx1ZSl7XHJcbiAgICAgIHZhciBpdGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdGVyLmNhbGwobmV3IENvbnN0cnVjdG9yKSk7XHJcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcclxuICAgICAgc2V0VG9TdHJpbmdUYWcoaXRlclByb3RvLCBOQU1FICsgJyBJdGVyYXRvcicsIHRydWUpO1xyXG4gICAgICAvLyBGRiBmaXhcclxuICAgICAgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikgJiYgc2V0SXRlcmF0b3IoaXRlclByb3RvLCByZXR1cm5UaGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxyXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGl0ZXI7XHJcbiAgLy8gRkYgJiB2OCBmaXhcclxuICBJdGVyYXRvcnNbTkFNRSArICcgSXRlcmF0b3InXSA9IHJldHVyblRoaXM7XHJcbiAgcmV0dXJuIGl0ZXI7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lU3RkSXRlcmF0b3JzKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQpe1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXIoa2luZCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcclxuICAgIH1cclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xyXG4gIHZhciBlbnRyaWVzID0gY3JlYXRlSXRlcihLRVkrVkFMVUUpXHJcbiAgICAsIHZhbHVlcyAgPSBjcmVhdGVJdGVyKFZBTFVFKTtcclxuICBpZihERUZBVUxUID09IFZBTFVFKXZhbHVlcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIHZhbHVlcywgJ3ZhbHVlcycpO1xyXG4gIGVsc2UgZW50cmllcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIGVudHJpZXMsICdlbnRyaWVzJyk7XHJcbiAgaWYoREVGQVVMVCl7XHJcbiAgICAkZGVmaW5lKFBST1RPICsgRk9SQ0VEICogQlVHR1lfSVRFUkFUT1JTLCBOQU1FLCB7XHJcbiAgICAgIGVudHJpZXM6IGVudHJpZXMsXHJcbiAgICAgIGtleXM6IElTX1NFVCA/IHZhbHVlcyA6IGNyZWF0ZUl0ZXIoS0VZKSxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXNcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyUmVzdWx0KGRvbmUsIHZhbHVlKXtcclxuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcclxufVxyXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGl0KXtcclxuICB2YXIgTyAgICAgID0gT2JqZWN0KGl0KVxyXG4gICAgLCBTeW1ib2wgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBoYXNFeHQgPSAoU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1IpIGluIE87XHJcbiAgcmV0dXJuIGhhc0V4dCB8fCBTWU1CT0xfSVRFUkFUT1IgaW4gTyB8fCBoYXMoSXRlcmF0b3JzLCBjbGFzc29mKE8pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdCl7XHJcbiAgdmFyIFN5bWJvbCAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBleHQgICAgID0gaXRbU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1JdXHJcbiAgICAsIGdldEl0ZXIgPSBleHQgfHwgaXRbU1lNQk9MX0lURVJBVE9SXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xyXG4gIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gc3RlcENhbGwoZm4sIHZhbHVlLCBlbnRyaWVzKXtcclxuICByZXR1cm4gZW50cmllcyA/IGludm9rZShmbiwgdmFsdWUpIDogZm4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGZvck9mKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XHJcbiAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpXHJcbiAgICAsIGYgICAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXHJcbiAgICAsIHN0ZXA7XHJcbiAgd2hpbGUoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKWlmKHN0ZXBDYWxsKGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpID09PSBmYWxzZSlyZXR1cm47XHJcbn1cclxuXHJcbi8vIGNvcmVcclxudmFyIE5PREUgPSBjb2YocHJvY2VzcykgPT0gUFJPQ0VTU1xyXG4gICwgY29yZSA9IHt9XHJcbiAgLCBwYXRoID0gZnJhbWV3b3JrID8gZ2xvYmFsIDogY29yZVxyXG4gICwgb2xkICA9IGdsb2JhbC5jb3JlXHJcbiAgLCBleHBvcnRHbG9iYWxcclxuICAvLyB0eXBlIGJpdG1hcFxyXG4gICwgRk9SQ0VEID0gMVxyXG4gICwgR0xPQkFMID0gMlxyXG4gICwgU1RBVElDID0gNFxyXG4gICwgUFJPVE8gID0gOFxyXG4gICwgQklORCAgID0gMTZcclxuICAsIFdSQVAgICA9IDMyXHJcbiAgLCBTSU1QTEUgPSA2NDtcclxuZnVuY3Rpb24gJGRlZmluZSh0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcclxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgR0xPQkFMXHJcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiAodHlwZSAmIFNUQVRJQylcclxuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwgT2JqZWN0UHJvdG8pW1BST1RPVFlQRV1cclxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xyXG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG4gICAgLy8gdGhlcmUgaXMgYSBzaW1pbGFyIG5hdGl2ZVxyXG4gICAgb3duID0gISh0eXBlICYgRk9SQ0VEKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAmJiAoIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pIHx8IGlzTmF0aXZlKHRhcmdldFtrZXldKSk7XHJcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcclxuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xyXG4gICAgaWYoIWZyYW1ld29yayAmJiBpc0dsb2JhbCAmJiAhaXNGdW5jdGlvbih0YXJnZXRba2V5XSkpZXhwID0gc291cmNlW2tleV07XHJcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG4gICAgZWxzZSBpZih0eXBlICYgQklORCAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcclxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcbiAgICBlbHNlIGlmKHR5cGUgJiBXUkFQICYmICFmcmFtZXdvcmsgJiYgdGFyZ2V0W2tleV0gPT0gb3V0KXtcclxuICAgICAgZXhwID0gZnVuY3Rpb24ocGFyYW0pe1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygb3V0ID8gbmV3IG91dChwYXJhbSkgOiBvdXQocGFyYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGV4cFtQUk9UT1RZUEVdID0gb3V0W1BST1RPVFlQRV07XHJcbiAgICB9IGVsc2UgZXhwID0gdHlwZSAmIFBST1RPICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChjYWxsLCBvdXQpIDogb3V0O1xyXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxyXG4gICAgaWYoZnJhbWV3b3JrICYmIHRhcmdldCAmJiAhb3duKXtcclxuICAgICAgaWYoaXNHbG9iYWwgfHwgdHlwZSAmIFNJTVBMRSl0YXJnZXRba2V5XSA9IG91dDtcclxuICAgICAgZWxzZSBkZWxldGUgdGFyZ2V0W2tleV0gJiYgaGlkZGVuKHRhcmdldCwga2V5LCBvdXQpO1xyXG4gICAgfVxyXG4gICAgLy8gZXhwb3J0XHJcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGRlbihleHBvcnRzLCBrZXksIGV4cCk7XHJcbiAgfVxyXG59XHJcbi8vIENvbW1vbkpTIGV4cG9ydFxyXG5pZih0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKW1vZHVsZS5leHBvcnRzID0gY29yZTtcclxuLy8gUmVxdWlyZUpTIGV4cG9ydFxyXG5lbHNlIGlmKGlzRnVuY3Rpb24oZGVmaW5lKSAmJiBkZWZpbmUuYW1kKWRlZmluZShmdW5jdGlvbigpe3JldHVybiBjb3JlfSk7XHJcbi8vIEV4cG9ydCB0byBnbG9iYWwgb2JqZWN0XHJcbmVsc2UgZXhwb3J0R2xvYmFsID0gdHJ1ZTtcclxuaWYoZXhwb3J0R2xvYmFsIHx8IGZyYW1ld29yayl7XHJcbiAgY29yZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKXtcclxuICAgIGdsb2JhbC5jb3JlID0gb2xkO1xyXG4gICAgcmV0dXJuIGNvcmU7XHJcbiAgfVxyXG4gIGdsb2JhbC5jb3JlID0gY29yZTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuc3ltYm9sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcbiFmdW5jdGlvbihUQUcsIFN5bWJvbFJlZ2lzdHJ5LCBBbGxTeW1ib2xzLCBzZXR0ZXIpe1xyXG4gIC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG4gIGlmKCFpc05hdGl2ZShTeW1ib2wpKXtcclxuICAgIFN5bWJvbCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKXtcclxuICAgICAgYXNzZXJ0KCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCksIFNZTUJPTCArICcgaXMgbm90IGEgJyArIENPTlNUUlVDVE9SKTtcclxuICAgICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbilcclxuICAgICAgICAsIHN5bSA9IHNldChjcmVhdGUoU3ltYm9sW1BST1RPVFlQRV0pLCBUQUcsIHRhZyk7XHJcbiAgICAgIEFsbFN5bWJvbHNbdGFnXSA9IHN5bTtcclxuICAgICAgREVTQyAmJiBzZXR0ZXIgJiYgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIHRhZywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgIGhpZGRlbih0aGlzLCB0YWcsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc3ltO1xyXG4gICAgfVxyXG4gICAgaGlkZGVuKFN5bWJvbFtQUk9UT1RZUEVdLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzW1RBR107XHJcbiAgICB9KTtcclxuICB9XHJcbiAgJGRlZmluZShHTE9CQUwgKyBXUkFQLCB7U3ltYm9sOiBTeW1ib2x9KTtcclxuICBcclxuICB2YXIgc3ltYm9sU3RhdGljcyA9IHtcclxuICAgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxyXG4gICAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcclxuICAgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuICAgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSBTeW1ib2woa2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3JcclxuICAgIGl0ZXJhdG9yOiBTWU1CT0xfSVRFUkFUT1IsXHJcbiAgICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuICAgIGtleUZvcjogcGFydC5jYWxsKGtleU9mLCBTeW1ib2xSZWdpc3RyeSksXHJcbiAgICAvLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcclxuICAgIHNwZWNpZXM6IFNZTUJPTF9TUEVDSUVTLFxyXG4gICAgLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xyXG4gICAgdG9TdHJpbmdUYWc6IFNZTUJPTF9UQUcgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRywgdHJ1ZSksXHJcbiAgICAvLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXHJcbiAgICB1bnNjb3BhYmxlczogU1lNQk9MX1VOU0NPUEFCTEVTLFxyXG4gICAgcHVyZTogc2FmZVN5bWJvbCxcclxuICAgIHNldDogc2V0LFxyXG4gICAgdXNlU2V0dGVyOiBmdW5jdGlvbigpe3NldHRlciA9IHRydWV9LFxyXG4gICAgdXNlU2ltcGxlOiBmdW5jdGlvbigpe3NldHRlciA9IGZhbHNlfVxyXG4gIH07XHJcbiAgLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcbiAgLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxyXG4gIC8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxyXG4gIC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcbiAgLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG4gIC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcclxuICAvLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXHJcbiAgZm9yRWFjaC5jYWxsKGFycmF5KCdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BsaXQsdG9QcmltaXRpdmUnKSxcclxuICAgIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgc3ltYm9sU3RhdGljc1tpdF0gPSBnZXRXZWxsS25vd25TeW1ib2woaXQpO1xyXG4gICAgfVxyXG4gICk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwgc3ltYm9sU3RhdGljcyk7XHJcbiAgXHJcbiAgc2V0VG9TdHJpbmdUYWcoU3ltYm9sLCBTWU1CT0wpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogIWlzTmF0aXZlKFN5bWJvbCksIE9CSkVDVCwge1xyXG4gICAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuICAgIGdldE93blByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHZhciBuYW1lcyA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSksIHJlc3VsdCA9IFtdLCBrZXksIGkgPSAwO1xyXG4gICAgICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KHNhZmVTeW1ib2woJ3RhZycpLCB7fSwge30sIHRydWUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24odG1wKXtcclxuICB2YXIgb2JqZWN0U3RhdGljID0ge1xyXG4gICAgLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcclxuICAgIGFzc2lnbjogYXNzaWduLFxyXG4gICAgLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcclxuICAgIGlzOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxyXG4gIC8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrcyB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cclxuICAnX19wcm90b19fJyBpbiBPYmplY3RQcm90byAmJiBmdW5jdGlvbihidWdneSwgc2V0KXtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldCA9IGN0eChjYWxsLCBnZXRPd25EZXNjcmlwdG9yKE9iamVjdFByb3RvLCAnX19wcm90b19fJykuc2V0LCAyKTtcclxuICAgICAgc2V0KHt9LCBBcnJheVByb3RvKTtcclxuICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZSB9XHJcbiAgICBvYmplY3RTdGF0aWMuc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8sIHByb3RvKXtcclxuICAgICAgYXNzZXJ0T2JqZWN0KE8pO1xyXG4gICAgICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG8pLCBwcm90bywgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xyXG4gICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xyXG4gICAgICBlbHNlIHNldChPLCBwcm90byk7XHJcbiAgICAgIHJldHVybiBPO1xyXG4gICAgfVxyXG4gIH0oKTtcclxuICAkZGVmaW5lKFNUQVRJQywgT0JKRUNULCBvYmplY3RTdGF0aWMpO1xyXG4gIFxyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcclxuICAgIHRtcFtTWU1CT0xfVEFHXSA9IERPVDtcclxuICAgIGlmKGNvZih0bXApICE9IERPVCloaWRkZW4oT2JqZWN0UHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuICBzZXRUb1N0cmluZ1RhZyhNYXRoLCBNQVRILCB0cnVlKTtcclxuICAvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm9iamVjdC5zdGF0aWNzLWFjY2VwdC1wcmltaXRpdmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gT2JqZWN0IHN0YXRpYyBtZXRob2RzIGFjY2VwdCBwcmltaXRpdmVzXHJcbiAgZnVuY3Rpb24gd3JhcE9iamVjdE1ldGhvZChrZXksIE1PREUpe1xyXG4gICAgdmFyIGZuICA9IE9iamVjdFtrZXldXHJcbiAgICAgICwgZXhwID0gY29yZVtPQkpFQ1RdW2tleV1cclxuICAgICAgLCBmICAgPSAwXHJcbiAgICAgICwgbyAgID0ge307XHJcbiAgICBpZighZXhwIHx8IGlzTmF0aXZlKGV4cCkpe1xyXG4gICAgICBvW2tleV0gPSBNT0RFID09IDEgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xyXG4gICAgICB9IDogTU9ERSA9PSAyID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xyXG4gICAgICB9IDogTU9ERSA9PSAzID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBmYWxzZTtcclxuICAgICAgfSA6IE1PREUgPT0gNCA/IGZ1bmN0aW9uKGl0LCBrZXkpe1xyXG4gICAgICAgIHJldHVybiBmbih0b09iamVjdChpdCksIGtleSk7XHJcbiAgICAgIH0gOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRyeSB7IGZuKERPVCkgfVxyXG4gICAgICBjYXRjaChlKXsgZiA9IDEgfVxyXG4gICAgICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCAqIGYsIE9CSkVDVCwgbyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2ZyZWV6ZScsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ3NlYWwnLCAxKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdwcmV2ZW50RXh0ZW5zaW9ucycsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzRnJvemVuJywgMik7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNTZWFsZWQnLCAyKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc0V4dGVuc2libGUnLCAzKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCA0KTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRQcm90b3R5cGVPZicpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2tleXMnKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJyk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm51bWJlciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGlzSW50ZWdlcil7XHJcbiAgJGRlZmluZShTVEFUSUMsIE5VTUJFUiwge1xyXG4gICAgLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cclxuICAgIEVQU0lMT046IHBvdygyLCAtNTIpLFxyXG4gICAgLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcclxuICAgIGlzRmluaXRlOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgaXNGaW5pdGUoaXQpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxyXG4gICAgaXNJbnRlZ2VyOiBpc0ludGVnZXIsXHJcbiAgICAvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG4gICAgaXNOYU46IHNhbWVOYU4sXHJcbiAgICAvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXHJcbiAgICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbihudW1iZXIpe1xyXG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gTUFYX1NBRkVfSU5URUdFUjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gICAgTUFYX1NBRkVfSU5URUdFUjogTUFYX1NBRkVfSU5URUdFUixcclxuICAgIC8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxyXG4gICAgTUlOX1NBRkVfSU5URUdFUjogLU1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAvLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxyXG4gICAgcGFyc2VGbG9hdDogcGFyc2VGbG9hdCxcclxuICAgIC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcclxuICAgIHBhcnNlSW50OiBwYXJzZUludFxyXG4gIH0pO1xyXG4vLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcclxufShOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcclxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5tYXRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVDTUFTY3JpcHQgNiBzaGltXHJcbiFmdW5jdGlvbigpe1xyXG4gIC8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcclxuICB2YXIgRSAgICA9IE1hdGguRVxyXG4gICAgLCBleHAgID0gTWF0aC5leHBcclxuICAgICwgbG9nICA9IE1hdGgubG9nXHJcbiAgICAsIHNxcnQgPSBNYXRoLnNxcnRcclxuICAgICwgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KXtcclxuICAgICAgICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIH07XHJcbiAgXHJcbiAgLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxyXG4gIGZ1bmN0aW9uIGFzaW5oKHgpe1xyXG4gICAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBsb2coeCArIHNxcnQoeCAqIHggKyAxKSk7XHJcbiAgfVxyXG4gIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXHJcbiAgZnVuY3Rpb24gZXhwbTEoeCl7XHJcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogZXhwKHgpIC0gMTtcclxuICB9XHJcbiAgICBcclxuICAkZGVmaW5lKFNUQVRJQywgTUFUSCwge1xyXG4gICAgLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxyXG4gICAgYWNvc2g6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogaXNGaW5pdGUoeCkgPyBsb2coeCAvIEUgKyBzcXJ0KHggKyAxKSAqIHNxcnQoeCAtIDEpIC8gRSkgKyAxIDogeDtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXHJcbiAgICBhc2luaDogYXNpbmgsXHJcbiAgICAvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXHJcbiAgICBhdGFuaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IGxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxyXG4gICAgY2JydDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBzaWduKHggPSAreCkgKiBwb3coYWJzKHgpLCAxIC8gMyk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcclxuICAgIGNsejMyOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMiAtIHhbVE9fU1RSSU5HXSgyKS5sZW5ndGggOiAzMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXHJcbiAgICBjb3NoOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxyXG4gICAgZXhwbTE6IGV4cG0xLFxyXG4gICAgLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXHJcbiAgICAvLyBUT0RPOiBmYWxsYmFjayBmb3IgSUU5LVxyXG4gICAgZnJvdW5kOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3hdKVswXTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcclxuICAgIGh5cG90OiBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMil7XHJcbiAgICAgIHZhciBzdW0gID0gMFxyXG4gICAgICAgICwgbGVuMSA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIGxlbjIgPSBsZW4xXHJcbiAgICAgICAgLCBhcmdzID0gQXJyYXkobGVuMSlcclxuICAgICAgICAsIGxhcmcgPSAtSW5maW5pdHlcclxuICAgICAgICAsIGFyZztcclxuICAgICAgd2hpbGUobGVuMS0tKXtcclxuICAgICAgICBhcmcgPSBhcmdzW2xlbjFdID0gK2FyZ3VtZW50c1tsZW4xXTtcclxuICAgICAgICBpZihhcmcgPT0gSW5maW5pdHkgfHwgYXJnID09IC1JbmZpbml0eSlyZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgICAgaWYoYXJnID4gbGFyZylsYXJnID0gYXJnO1xyXG4gICAgICB9XHJcbiAgICAgIGxhcmcgPSBhcmcgfHwgMTtcclxuICAgICAgd2hpbGUobGVuMi0tKXN1bSArPSBwb3coYXJnc1tsZW4yXSAvIGxhcmcsIDIpO1xyXG4gICAgICByZXR1cm4gbGFyZyAqIHNxcnQoc3VtKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXHJcbiAgICBpbXVsOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgdmFyIFVJbnQxNiA9IDB4ZmZmZlxyXG4gICAgICAgICwgeG4gPSAreFxyXG4gICAgICAgICwgeW4gPSAreVxyXG4gICAgICAgICwgeGwgPSBVSW50MTYgJiB4blxyXG4gICAgICAgICwgeWwgPSBVSW50MTYgJiB5bjtcclxuICAgICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSW50MTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSW50MTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxyXG4gICAgbG9nMXA6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2coMSArIHgpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXHJcbiAgICBsb2cxMDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMTA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxyXG4gICAgbG9nMjogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBsb2coeCkgLyBNYXRoLkxOMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXHJcbiAgICBzaWduOiBzaWduLFxyXG4gICAgLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxyXG4gICAgc2luaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoYWJzKHggPSAreCkgPCAxKSA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoRSAvIDIpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcclxuICAgIHRhbmg6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcclxuICAgICAgICAsIGIgPSBleHBtMSgteCk7XHJcbiAgICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcclxuICAgIHRydW5jOiB0cnVuY1xyXG4gIH0pO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5zdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihmcm9tQ2hhckNvZGUpe1xyXG4gIGZ1bmN0aW9uIGFzc2VydE5vdFJlZ0V4cChpdCl7XHJcbiAgICBpZihjb2YoaXQpID09IFJFR0VYUCl0aHJvdyBUeXBlRXJyb3IoKTtcclxuICB9XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIFNUUklORywge1xyXG4gICAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcclxuICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICB2YXIgcmVzID0gW11cclxuICAgICAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIGkgICA9IDBcclxuICAgICAgICAsIGNvZGVcclxuICAgICAgd2hpbGUobGVuID4gaSl7XHJcbiAgICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcclxuICAgICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcclxuICAgICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxyXG4gICAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcclxuICAgICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcclxuICAgICAgICApO1xyXG4gICAgICB9IHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcclxuICAgIHJhdzogZnVuY3Rpb24oY2FsbFNpdGUpe1xyXG4gICAgICB2YXIgcmF3ID0gdG9PYmplY3QoY2FsbFNpdGUucmF3KVxyXG4gICAgICAgICwgbGVuID0gdG9MZW5ndGgocmF3Lmxlbmd0aClcclxuICAgICAgICAsIHNsbiA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIHJlcyA9IFtdXHJcbiAgICAgICAgLCBpICAgPSAwO1xyXG4gICAgICB3aGlsZShsZW4gPiBpKXtcclxuICAgICAgICByZXMucHVzaChTdHJpbmcocmF3W2krK10pKTtcclxuICAgICAgICBpZihpIDwgc2xuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcclxuICAgICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gICRkZWZpbmUoUFJPVE8sIFNUUklORywge1xyXG4gICAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXHJcbiAgICBjb2RlUG9pbnRBdDogY3JlYXRlUG9pbnRBdChmYWxzZSksXHJcbiAgICAvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXHJcbiAgICBlbmRzV2l0aDogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgdmFyIHRoYXQgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICAgLCBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcclxuICAgICAgICAsIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBtaW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xyXG4gICAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XHJcbiAgICAgIHJldHVybiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaFN0cmluZy5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaFN0cmluZztcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxyXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcclxuICAgICAgYXNzZXJ0Tm90UmVnRXhwKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHJldHVybiAhIX5TdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSkuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxyXG4gICAgcmVwZWF0OiBmdW5jdGlvbihjb3VudCl7XHJcbiAgICAgIHZhciBzdHIgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIHJlcyA9ICcnXHJcbiAgICAgICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xyXG4gICAgICBpZigwID4gbiB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcclxuICAgICAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxyXG4gICAgc3RhcnRzV2l0aDogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgdmFyIHRoYXQgID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBpbmRleCA9IHRvTGVuZ3RoKG1pbihhcmd1bWVudHNbMV0sIHRoYXQubGVuZ3RoKSk7XHJcbiAgICAgIHNlYXJjaFN0cmluZyArPSAnJztcclxuICAgICAgcmV0dXJuIHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcclxuICAgIH1cclxuICB9KTtcclxufShTdHJpbmcuZnJvbUNoYXJDb2RlKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmFycmF5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShTVEFUSUMsIEFSUkFZLCB7XHJcbiAgICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmcm9tOiBmdW5jdGlvbihhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XHJcbiAgICAgIHZhciBPICAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQoYXJyYXlMaWtlKSlcclxuICAgICAgICAsIG1hcGZuICAgPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgLCBmICAgICAgID0gbWFwcGluZyA/IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICwgaW5kZXggICA9IDBcclxuICAgICAgICAsIGxlbmd0aCwgcmVzdWx0LCBpdGVyLCBzdGVwO1xyXG4gICAgICBpZihpc0l0ZXJhYmxlKE8pKWZvcihpdGVyID0gZ2V0SXRlcmF0b3IoTyksIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpOyAhKHN0ZXAgPSBpdGVyLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBmKHN0ZXAudmFsdWUsIGluZGV4KSA6IHN0ZXAudmFsdWU7XHJcbiAgICAgIH0gZWxzZSBmb3IocmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSkobGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xyXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcclxuICAgIG9mOiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgdmFyIGluZGV4ICA9IDBcclxuICAgICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpKGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGRlZmluZShQUk9UTywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxyXG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcclxuICAgICAgdmFyIE8gICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxyXG4gICAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXHJcbiAgICAgICAgLCBlbmQgICA9IGFyZ3VtZW50c1syXVxyXG4gICAgICAgICwgZmluICAgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pXHJcbiAgICAgICAgLCBjb3VudCA9IG1pbihmaW4gLSBmcm9tLCBsZW4gLSB0bylcclxuICAgICAgICAsIGluYyAgID0gMTtcclxuICAgICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcclxuICAgICAgICBpbmMgID0gLTE7XHJcbiAgICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XHJcbiAgICAgICAgdG8gICA9IHRvICsgY291bnQgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcclxuICAgICAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xyXG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xyXG4gICAgICAgIHRvICs9IGluYztcclxuICAgICAgICBmcm9tICs9IGluYztcclxuICAgICAgfSByZXR1cm4gTztcclxuICAgIH0sXHJcbiAgICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcclxuICAgIGZpbGw6IGZ1bmN0aW9uKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xyXG4gICAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXHJcbiAgICAgICAgLCBlbmQgICAgPSBhcmd1bWVudHNbMl1cclxuICAgICAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIE87XHJcbiAgICB9LFxyXG4gICAgLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZmluZDogY3JlYXRlQXJyYXlNZXRob2QoNSksXHJcbiAgICAvLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZpbmRJbmRleDogY3JlYXRlQXJyYXlNZXRob2QoNilcclxuICB9KTtcclxuICBcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdmaW5kLGZpbmRJbmRleCxmaWxsLGNvcHlXaXRoaW4sZW50cmllcyxrZXlzLHZhbHVlcycpLCBmdW5jdGlvbihpdCl7XHJcbiAgICAgIEFycmF5VW5zY29wYWJsZXNbaXRdID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgU1lNQk9MX1VOU0NPUEFCTEVTIGluIEFycmF5UHJvdG8gfHwgaGlkZGVuKEFycmF5UHJvdG8sIFNZTUJPTF9VTlNDT1BBQkxFUywgQXJyYXlVbnNjb3BhYmxlcyk7XHJcbiAgfSAgXHJcbiAgXHJcbiAgc2V0U3BlY2llcyhBcnJheSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lml0ZXJhdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGF0KXtcclxuICAvLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXHJcbiAgLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcclxuICAvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXHJcbiAgLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXHJcbiAgZGVmaW5lU3RkSXRlcmF0b3JzKEFycmF5LCBBUlJBWSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiB0b09iamVjdChpdGVyYXRlZCksIGk6IDAsIGs6IGtpbmR9KTtcclxuICAvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxuICB9LCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIE8gICAgID0gaXRlci5vXHJcbiAgICAgICwga2luZCAgPSBpdGVyLmtcclxuICAgICAgLCBpbmRleCA9IGl0ZXIuaSsrO1xyXG4gICAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xyXG4gICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgfVxyXG4gICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBpbmRleCk7XHJcbiAgICBpZihraW5kID09IFZBTFVFKXJldHVybiBpdGVyUmVzdWx0KDAsIE9baW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xyXG4gIH0sIFZBTFVFKTtcclxuICBcclxuICAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXHJcbiAgSXRlcmF0b3JzW0FSR1VNRU5UU10gPSBJdGVyYXRvcnNbQVJSQVldO1xyXG4gIFxyXG4gIC8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcclxuICBkZWZpbmVTdGRJdGVyYXRvcnMoU3RyaW5nLCBTVFJJTkcsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bzogU3RyaW5nKGl0ZXJhdGVkKSwgaTogMH0pO1xyXG4gIC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxuICB9LCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIE8gICAgID0gaXRlci5vXHJcbiAgICAgICwgaW5kZXggPSBpdGVyLmlcclxuICAgICAgLCBwb2ludDtcclxuICAgIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgcG9pbnQgPSBhdC5jYWxsKE8sIGluZGV4KTtcclxuICAgIGl0ZXIuaSArPSBwb2ludC5sZW5ndGg7XHJcbiAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBwb2ludCk7XHJcbiAgfSk7XHJcbn0oY3JlYXRlUG9pbnRBdCh0cnVlKSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IHdlYi5pbW1lZGlhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIHNldEltbWVkaWF0ZSBzaGltXHJcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIGVsc2U6XHJcbmlzRnVuY3Rpb24oc2V0SW1tZWRpYXRlKSAmJiBpc0Z1bmN0aW9uKGNsZWFySW1tZWRpYXRlKSB8fCBmdW5jdGlvbihPTlJFQURZU1RBVEVDSEFOR0Upe1xyXG4gIHZhciBwb3N0TWVzc2FnZSAgICAgID0gZ2xvYmFsLnBvc3RNZXNzYWdlXHJcbiAgICAsIGFkZEV2ZW50TGlzdGVuZXIgPSBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgLCBNZXNzYWdlQ2hhbm5lbCAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXHJcbiAgICAsIGNvdW50ZXIgICAgICAgICAgPSAwXHJcbiAgICAsIHF1ZXVlICAgICAgICAgICAgPSB7fVxyXG4gICAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcclxuICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmbil7XHJcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcclxuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcclxuICAgICAgaW52b2tlKGlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVmZXIoY291bnRlcik7XHJcbiAgICByZXR1cm4gY291bnRlcjtcclxuICB9XHJcbiAgY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbihpZCl7XHJcbiAgICBkZWxldGUgcXVldWVbaWRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBydW4oaWQpe1xyXG4gICAgaWYoaGFzKHF1ZXVlLCBpZCkpe1xyXG4gICAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XHJcbiAgICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGxpc3RuZXIoZXZlbnQpe1xyXG4gICAgcnVuKGV2ZW50LmRhdGEpO1xyXG4gIH1cclxuICAvLyBOb2RlLmpzIDAuOC1cclxuICBpZihOT0RFKXtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBuZXh0VGljayhwYXJ0LmNhbGwocnVuLCBpZCkpO1xyXG4gICAgfVxyXG4gIC8vIE1vZGVybiBicm93c2Vycywgc2tpcCBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViV29ya2Vyc1xyXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzIG9iamVjdFxyXG4gIH0gZWxzZSBpZihhZGRFdmVudExpc3RlbmVyICYmIGlzRnVuY3Rpb24ocG9zdE1lc3NhZ2UpICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgcG9zdE1lc3NhZ2UoaWQsICcqJyk7XHJcbiAgICB9XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xyXG4gIC8vIFdlYldvcmtlcnNcclxuICB9IGVsc2UgaWYoaXNGdW5jdGlvbihNZXNzYWdlQ2hhbm5lbCkpe1xyXG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcclxuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xyXG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xyXG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XHJcbiAgLy8gSUU4LVxyXG4gIH0gZWxzZSBpZihkb2N1bWVudCAmJiBPTlJFQURZU1RBVEVDSEFOR0UgaW4gZG9jdW1lbnRbQ1JFQVRFX0VMRU1FTlRdKCdzY3JpcHQnKSl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChkb2N1bWVudFtDUkVBVEVfRUxFTUVOVF0oJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIHJ1bihpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgc2V0VGltZW91dChydW4sIDAsIGlkKTtcclxuICAgIH1cclxuICB9XHJcbn0oJ29ucmVhZHlzdGF0ZWNoYW5nZScpO1xyXG4kZGVmaW5lKEdMT0JBTCArIEJJTkQsIHtcclxuICBzZXRJbW1lZGlhdGU6ICAgc2V0SW1tZWRpYXRlLFxyXG4gIGNsZWFySW1tZWRpYXRlOiBjbGVhckltbWVkaWF0ZVxyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnByb21pc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRVM2IHByb21pc2VzIHNoaW1cclxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9uYXRpdmUtcHJvbWlzZS1vbmx5L1xyXG4hZnVuY3Rpb24oUHJvbWlzZSwgdGVzdCl7XHJcbiAgaXNGdW5jdGlvbihQcm9taXNlKSAmJiBpc0Z1bmN0aW9uKFByb21pc2UucmVzb2x2ZSlcclxuICAmJiBQcm9taXNlLnJlc29sdmUodGVzdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCl7fSkpID09IHRlc3RcclxuICB8fCBmdW5jdGlvbihhc2FwLCBERUYpe1xyXG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZShvKXtcclxuICAgICAgdmFyIHRoZW47XHJcbiAgICAgIGlmKGlzT2JqZWN0KG8pKXRoZW4gPSBvLnRoZW47XHJcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoZW4pID8gdGhlbiA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm90aWZ5KGRlZil7XHJcbiAgICAgIHZhciBjaGFpbiA9IGRlZi5jaGFpbjtcclxuICAgICAgY2hhaW4ubGVuZ3RoICYmIGFzYXAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbXNnID0gZGVmLm1zZ1xyXG4gICAgICAgICAgLCBvayAgPSBkZWYuc3RhdGUgPT0gMVxyXG4gICAgICAgICAgLCBpICAgPSAwO1xyXG4gICAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpIWZ1bmN0aW9uKHJlYWN0KXtcclxuICAgICAgICAgIHZhciBjYiA9IG9rID8gcmVhY3Qub2sgOiByZWFjdC5mYWlsXHJcbiAgICAgICAgICAgICwgcmV0LCB0aGVuO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoY2Ipe1xyXG4gICAgICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gbXNnIDogY2IobXNnKTtcclxuICAgICAgICAgICAgICBpZihyZXQgPT09IHJlYWN0LlApe1xyXG4gICAgICAgICAgICAgICAgcmVhY3QucmVqKFR5cGVFcnJvcihQUk9NSVNFICsgJy1jaGFpbiBjeWNsZScpKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmV0KSl7XHJcbiAgICAgICAgICAgICAgICB0aGVuLmNhbGwocmV0LCByZWFjdC5yZXMsIHJlYWN0LnJlaik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHJlYWN0LnJlcyhyZXQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmVhY3QucmVqKG1zZyk7XHJcbiAgICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIHJlYWN0LnJlaihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0oY2hhaW5baSsrXSk7XHJcbiAgICAgICAgY2hhaW4ubGVuZ3RoID0gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKG1zZyl7XHJcbiAgICAgIHZhciBkZWYgPSB0aGlzXHJcbiAgICAgICAgLCB0aGVuLCB3cmFwcGVyO1xyXG4gICAgICBpZihkZWYuZG9uZSlyZXR1cm47XHJcbiAgICAgIGRlZi5kb25lID0gdHJ1ZTtcclxuICAgICAgZGVmID0gZGVmLmRlZiB8fCBkZWY7IC8vIHVud3JhcFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKG1zZykpe1xyXG4gICAgICAgICAgd3JhcHBlciA9IHtkZWY6IGRlZiwgZG9uZTogZmFsc2V9OyAvLyB3cmFwXHJcbiAgICAgICAgICB0aGVuLmNhbGwobXNnLCBjdHgocmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eChyZWplY3QsIHdyYXBwZXIsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVmLm1zZyA9IG1zZztcclxuICAgICAgICAgIGRlZi5zdGF0ZSA9IDE7XHJcbiAgICAgICAgICBub3RpZnkoZGVmKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICByZWplY3QuY2FsbCh3cmFwcGVyIHx8IHtkZWY6IGRlZiwgZG9uZTogZmFsc2V9LCBlcnIpOyAvLyB3cmFwXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdChtc2cpe1xyXG4gICAgICB2YXIgZGVmID0gdGhpcztcclxuICAgICAgaWYoZGVmLmRvbmUpcmV0dXJuO1xyXG4gICAgICBkZWYuZG9uZSA9IHRydWU7XHJcbiAgICAgIGRlZiA9IGRlZi5kZWYgfHwgZGVmOyAvLyB1bndyYXBcclxuICAgICAgZGVmLm1zZyA9IG1zZztcclxuICAgICAgZGVmLnN0YXRlID0gMjtcclxuICAgICAgbm90aWZ5KGRlZik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihDKXtcclxuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoQylbU1lNQk9MX1NQRUNJRVNdO1xyXG4gICAgICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcclxuICAgIH1cclxuICAgIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXHJcbiAgICBQcm9taXNlID0gZnVuY3Rpb24oZXhlY3V0b3Ipe1xyXG4gICAgICBhc3NlcnRGdW5jdGlvbihleGVjdXRvcik7XHJcbiAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIFByb21pc2UsIFBST01JU0UpO1xyXG4gICAgICB2YXIgZGVmID0ge2NoYWluOiBbXSwgc3RhdGU6IDAsIGRvbmU6IGZhbHNlLCBtc2c6IHVuZGVmaW5lZH07XHJcbiAgICAgIGhpZGRlbih0aGlzLCBERUYsIGRlZik7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY3V0b3IoY3R4KHJlc29sdmUsIGRlZiwgMSksIGN0eChyZWplY3QsIGRlZiwgMSkpO1xyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwoZGVmLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NpZ25IaWRkZW4oUHJvbWlzZVtQUk9UT1RZUEVdLCB7XHJcbiAgICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcclxuICAgICAgICB2YXIgUyA9IGFzc2VydE9iamVjdChhc3NlcnRPYmplY3QodGhpcylbQ09OU1RSVUNUT1JdKVtTWU1CT0xfU1BFQ0lFU107XHJcbiAgICAgICAgdmFyIHJlYWN0ID0ge1xyXG4gICAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXHJcbiAgICAgICAgICBmYWlsOiBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcclxuICAgICAgICB9ICwgUCA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXNvbHZlKTtcclxuICAgICAgICAgIHJlYWN0LnJlaiA9IGFzc2VydEZ1bmN0aW9uKHJlamVjdCk7XHJcbiAgICAgICAgfSksIGRlZiA9IHRoaXNbREVGXTtcclxuICAgICAgICBkZWYuY2hhaW4ucHVzaChyZWFjdCk7XHJcbiAgICAgICAgZGVmLnN0YXRlICYmIG5vdGlmeShkZWYpO1xyXG4gICAgICAgIHJldHVybiBQO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxyXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgYXNzaWduSGlkZGVuKFByb21pc2UsIHtcclxuICAgICAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXHJcbiAgICAgIGFsbDogZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgIHZhciBQcm9taXNlID0gZ2V0Q29uc3RydWN0b3IodGhpcylcclxuICAgICAgICAgICwgdmFsdWVzICA9IFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBwdXNoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xyXG4gICAgICAgICAgaWYocmVtYWluaW5nKWZvckVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXHJcbiAgICAgIHJhY2U6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICB2YXIgUHJvbWlzZSA9IGdldENvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxyXG4gICAgICByZWplY3Q6IGZ1bmN0aW9uKHIpe1xyXG4gICAgICAgIHJldHVybiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgcmVqZWN0KHIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcclxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24oeCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIERFRiBpbiB4ICYmIGdldFByb3RvdHlwZU9mKHgpID09PSB0aGlzW1BST1RPVFlQRV1cclxuICAgICAgICAgID8geCA6IG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICAgIHJlc29sdmUoeCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfShuZXh0VGljayB8fCBzZXRJbW1lZGlhdGUsIHNhZmVTeW1ib2woJ2RlZicpKTtcclxuICBzZXRUb1N0cmluZ1RhZyhQcm9taXNlLCBQUk9NSVNFKTtcclxuICBzZXRTcGVjaWVzKFByb21pc2UpO1xyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VEICogIWlzTmF0aXZlKFByb21pc2UpLCB7UHJvbWlzZTogUHJvbWlzZX0pO1xyXG59KGdsb2JhbFtQUk9NSVNFXSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5jb2xsZWN0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVDTUFTY3JpcHQgNiBjb2xsZWN0aW9ucyBzaGltXHJcbiFmdW5jdGlvbigpe1xyXG4gIHZhciBVSUQgICA9IHNhZmVTeW1ib2woJ3VpZCcpXHJcbiAgICAsIE8xICAgID0gc2FmZVN5bWJvbCgnTzEnKVxyXG4gICAgLCBXRUFLICA9IHNhZmVTeW1ib2woJ3dlYWsnKVxyXG4gICAgLCBMRUFLICA9IHNhZmVTeW1ib2woJ2xlYWsnKVxyXG4gICAgLCBMQVNUICA9IHNhZmVTeW1ib2woJ2xhc3QnKVxyXG4gICAgLCBGSVJTVCA9IHNhZmVTeW1ib2woJ2ZpcnN0JylcclxuICAgICwgU0laRSAgPSBERVNDID8gc2FmZVN5bWJvbCgnc2l6ZScpIDogJ3NpemUnXHJcbiAgICAsIHVpZCAgID0gMFxyXG4gICAgLCB0bXAgICA9IHt9O1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldENvbGxlY3Rpb24oQywgTkFNRSwgbWV0aG9kcywgY29tbW9uTWV0aG9kcywgaXNNYXAsIGlzV2Vhayl7XHJcbiAgICB2YXIgQURERVIgPSBpc01hcCA/ICdzZXQnIDogJ2FkZCdcclxuICAgICAgLCBwcm90byA9IEMgJiYgQ1tQUk9UT1RZUEVdXHJcbiAgICAgICwgTyAgICAgPSB7fTtcclxuICAgIGZ1bmN0aW9uIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpe1xyXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIGlzTWFwLCB0aGF0W0FEREVSXSwgdGhhdCk7XHJcbiAgICAgIHJldHVybiB0aGF0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZml4U1ZaKGtleSwgY2hhaW4pe1xyXG4gICAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcclxuICAgICAgaWYoZnJhbWV3b3JrKXByb3RvW2tleV0gPSBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTtcclxuICAgICAgICByZXR1cm4gY2hhaW4gPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYoIWlzTmF0aXZlKEMpIHx8ICEoaXNXZWFrIHx8ICghQlVHR1lfSVRFUkFUT1JTICYmIGhhcyhwcm90bywgRk9SX0VBQ0gpICYmIGhhcyhwcm90bywgJ2VudHJpZXMnKSkpKXtcclxuICAgICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcclxuICAgICAgQyA9IGlzV2Vha1xyXG4gICAgICAgID8gZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoaXMsIFVJRCwgdWlkKyspO1xyXG4gICAgICAgICAgICBpbml0RnJvbUl0ZXJhYmxlKHRoaXMsIGl0ZXJhYmxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICA6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGF0LCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIE8xLCBjcmVhdGUobnVsbCkpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgU0laRSwgMCk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBMQVNULCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgRklSU1QsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgYXNzaWduSGlkZGVuKGFzc2lnbkhpZGRlbihDW1BST1RPVFlQRV0sIG1ldGhvZHMpLCBjb21tb25NZXRob2RzKTtcclxuICAgICAgaXNXZWFrIHx8IGRlZmluZVByb3BlcnR5KENbUFJPVE9UWVBFXSwgJ3NpemUnLCB7Z2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBhc3NlcnREZWZpbmVkKHRoaXNbU0laRV0pO1xyXG4gICAgICB9fSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgTmF0aXZlID0gQ1xyXG4gICAgICAgICwgaW5zdCAgID0gbmV3IENcclxuICAgICAgICAsIGNoYWluICA9IGluc3RbQURERVJdKGlzV2VhayA/IHt9IDogLTAsIDEpXHJcbiAgICAgICAgLCBidWdneVplcm87XHJcbiAgICAgIC8vIHdyYXAgdG8gaW5pdCBjb2xsZWN0aW9ucyBmcm9tIGl0ZXJhYmxlXHJcbiAgICAgIGlmKCFOQVRJVkVfSVRFUkFUT1JTIHx8ICFDLmxlbmd0aCl7XHJcbiAgICAgICAgQyA9IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgcmV0dXJuIGluaXRGcm9tSXRlcmFibGUobmV3IE5hdGl2ZSwgaXRlcmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDW1BST1RPVFlQRV0gPSBwcm90bztcclxuICAgICAgICBpZihmcmFtZXdvcmspcHJvdG9bQ09OU1RSVUNUT1JdID0gQztcclxuICAgICAgfVxyXG4gICAgICBpc1dlYWsgfHwgaW5zdFtGT1JfRUFDSF0oZnVuY3Rpb24odmFsLCBrZXkpe1xyXG4gICAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxyXG4gICAgICBpZihidWdneVplcm8pe1xyXG4gICAgICAgIGZpeFNWWignZGVsZXRlJyk7XHJcbiAgICAgICAgZml4U1ZaKCdoYXMnKTtcclxuICAgICAgICBpc01hcCAmJiBmaXhTVlooJ2dldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vICsgZml4IC5hZGQgJiAuc2V0IGZvciBjaGFpbmluZ1xyXG4gICAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4U1ZaKEFEREVSLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xyXG4gICAgc2V0U3BlY2llcyhDKTtcclxuICAgIFxyXG4gICAgT1tOQU1FXSA9IEM7XHJcbiAgICAkZGVmaW5lKEdMT0JBTCArIFdSQVAgKyBGT1JDRUQgKiAhaXNOYXRpdmUoQyksIE8pO1xyXG4gICAgXHJcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cclxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcclxuICAgIGlzV2VhayB8fCBkZWZpbmVTdGRJdGVyYXRvcnMoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBrOiBraW5kfSk7XHJcbiAgICB9LCBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAgICwgZW50cnkgPSBpdGVyLmw7XHJcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcclxuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcclxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xyXG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXHJcbiAgICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcclxuICAgICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS5rKTtcclxuICAgICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS52KTtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbZW50cnkuaywgZW50cnkudl0pOyAgIFxyXG4gICAgfSwgaXNNYXAgPyBLRVkrVkFMVUUgOiBWQUxVRSwgIWlzTWFwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIEM7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGZhc3RLZXkoaXQsIGNyZWF0ZSl7XHJcbiAgICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XHJcbiAgICBpZighaXNPYmplY3QoaXQpKXJldHVybiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xyXG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcclxuICAgIGlmKGlzRnJvemVuKGl0KSlyZXR1cm4gJ0YnO1xyXG4gICAgaWYoIWhhcyhpdCwgVUlEKSl7XHJcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXHJcbiAgICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcclxuICAgICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXHJcbiAgICAgIGhpZGRlbihpdCwgVUlELCArK3VpZCk7XHJcbiAgICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XHJcbiAgICB9IHJldHVybiAnTycgKyBpdFtVSURdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xyXG4gICAgLy8gZmFzdCBjYXNlXHJcbiAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xyXG4gICAgaWYoaW5kZXggIT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcclxuICAgIGZvcihlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcclxuICAgICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZWYodGhhdCwga2V5LCB2YWx1ZSl7XHJcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXHJcbiAgICAgICwgcHJldiwgaW5kZXg7XHJcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcclxuICAgIGlmKGVudHJ5KWVudHJ5LnYgPSB2YWx1ZTtcclxuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XHJcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XHJcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxyXG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxyXG4gICAgICAgIHA6IHByZXYgPSB0aGF0W0xBU1RdLCAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxyXG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XHJcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcclxuICAgICAgfTtcclxuICAgICAgaWYoIXRoYXRbRklSU1RdKXRoYXRbRklSU1RdID0gZW50cnk7XHJcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XHJcbiAgICAgIHRoYXRbU0laRV0rKztcclxuICAgICAgLy8gYWRkIHRvIGluZGV4XHJcbiAgICAgIGlmKGluZGV4ICE9ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcclxuICAgIH0gcmV0dXJuIHRoYXQ7XHJcbiAgfVxyXG5cclxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcclxuICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0W08xXSwgZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XHJcbiAgICAgICAgZW50cnkuciA9IHRydWU7XHJcbiAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xyXG4gICAgICB9XHJcbiAgICAgIHRoYXRbRklSU1RdID0gdGhhdFtMQVNUXSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhhdFtTSVpFXSA9IDA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXHJcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIHRoYXQgID0gdGhpc1xyXG4gICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xyXG4gICAgICBpZihlbnRyeSl7XHJcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXHJcbiAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xyXG4gICAgICAgIGRlbGV0ZSB0aGF0W08xXVtlbnRyeS5pXTtcclxuICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcclxuICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XHJcbiAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xyXG4gICAgICAgIGlmKHRoYXRbRklSU1RdID09IGVudHJ5KXRoYXRbRklSU1RdID0gbmV4dDtcclxuICAgICAgICBpZih0aGF0W0xBU1RdID09IGVudHJ5KXRoYXRbTEFTVF0gPSBwcmV2O1xyXG4gICAgICAgIHRoYXRbU0laRV0tLTtcclxuICAgICAgfSByZXR1cm4gISFlbnRyeTtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSwgMylcclxuICAgICAgICAsIGVudHJ5O1xyXG4gICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXNbRklSU1RdKXtcclxuICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xyXG4gICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjEgTWFwIE9iamVjdHNcclxuICBNYXAgPSBnZXRDb2xsZWN0aW9uKE1hcCwgTUFQLCB7XHJcbiAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCBjb2xsZWN0aW9uTWV0aG9kcywgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gMjMuMiBTZXQgT2JqZWN0c1xyXG4gIFNldCA9IGdldENvbGxlY3Rpb24oU2V0LCBTRVQsIHtcclxuICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIGNvbGxlY3Rpb25NZXRob2RzKTtcclxuICBcclxuICBmdW5jdGlvbiBkZWZXZWFrKHRoYXQsIGtleSwgdmFsdWUpe1xyXG4gICAgaWYoaXNGcm96ZW4oYXNzZXJ0T2JqZWN0KGtleSkpKWxlYWtTdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaGFzKGtleSwgV0VBSykgfHwgaGlkZGVuKGtleSwgV0VBSywge30pO1xyXG4gICAgICBrZXlbV0VBS11bdGhhdFtVSURdXSA9IHZhbHVlO1xyXG4gICAgfSByZXR1cm4gdGhhdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbGVha1N0b3JlKHRoYXQpe1xyXG4gICAgcmV0dXJuIHRoYXRbTEVBS10gfHwgaGlkZGVuKHRoYXQsIExFQUssIG5ldyBNYXApW0xFQUtdO1xyXG4gIH1cclxuICBcclxuICB2YXIgd2Vha01ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxyXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcclxuICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xyXG4gICAgICByZXR1cm4gaGFzKGtleSwgV0VBSykgJiYgaGFzKGtleVtXRUFLXSwgdGhpc1tVSURdKSAmJiBkZWxldGUga2V5W1dFQUtdW3RoaXNbVUlEXV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcclxuICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcclxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XHJcbiAgICAgIHJldHVybiBoYXMoa2V5LCBXRUFLKSAmJiBoYXMoa2V5W1dFQUtdLCB0aGlzW1VJRF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcclxuICBXZWFrTWFwID0gZ2V0Q29sbGVjdGlvbihXZWFrTWFwLCBXRUFLTUFQLCB7XHJcbiAgICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihpc09iamVjdChrZXkpKXtcclxuICAgICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoaGFzKGtleSwgV0VBSykpcmV0dXJuIGtleVtXRUFLXVt0aGlzW1VJRF1dO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmV2Vhayh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgdHJ1ZSwgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxyXG4gIGlmKGZyYW1ld29yayAmJiBuZXcgV2Vha01hcCgpLnNldChPYmplY3QuZnJlZXplKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdkZWxldGUsaGFzLGdldCxzZXQnKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIG1ldGhvZCA9IFdlYWtNYXBbUFJPVE9UWVBFXVtrZXldO1xyXG4gICAgICBXZWFrTWFwW1BST1RPVFlQRV1ba2V5XSA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxyXG4gICAgICAgIGlmKGlzT2JqZWN0KGEpICYmIGlzRnJvemVuKGEpKXtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxyXG4gICAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXHJcbiAgV2Vha1NldCA9IGdldENvbGxlY3Rpb24oV2Vha1NldCwgV0VBS1NFVCwge1xyXG4gICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWZXZWFrKHRoaXMsIHZhbHVlLCB0cnVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgZmFsc2UsIHRydWUpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5yZWZsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XHJcbiAgICB2YXIga2V5cyA9IFtdLCBrZXk7XHJcbiAgICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgYToga2V5cywgaTogMH0pO1xyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihFbnVtZXJhdGUsIE9CSkVDVCwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIGtleXMgPSBpdGVyLmFcclxuICAgICAgLCBrZXk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH0gd2hpbGUoISgoa2V5ID0ga2V5c1tpdGVyLmkrK10pIGluIGl0ZXIubykpO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwga2V5KTtcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiB3cmFwKGZuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIGFzc2VydE9iamVjdChpdCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSwgdHJ1ZTtcclxuICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gcmVmbGVjdEdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xyXG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cclxuICAgICAgLCBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpLCBwcm90bztcclxuICAgIGlmKGRlc2MpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxyXG4gICAgICA/IGRlc2MudmFsdWVcclxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICA6IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcclxuICAgICAgPyByZWZsZWN0R2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZWZsZWN0U2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XHJcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxyXG4gICAgICAsIG93bkRlc2MgID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXHJcbiAgICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcclxuICAgIGlmKCFvd25EZXNjKXtcclxuICAgICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XHJcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RTZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XHJcbiAgICAgIH1cclxuICAgICAgb3duRGVzYyA9IGRlc2NyaXB0b3IoMCk7XHJcbiAgICB9XHJcbiAgICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xyXG4gICAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcclxuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ2V0T3duRGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGRlc2NyaXB0b3IoMCk7XHJcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XHJcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvciksIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZFxyXG4gICAgICA/IGZhbHNlXHJcbiAgICAgIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcclxuICB9XHJcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgcmV0dXJuSXQ7XHJcbiAgXHJcbiAgdmFyIHJlZmxlY3QgPSB7XHJcbiAgICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcclxuICAgIGFwcGx5OiBjdHgoY2FsbCwgYXBwbHksIDMpLFxyXG4gICAgLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxyXG4gICAgY29uc3RydWN0OiBjb25zdHJ1Y3QsXHJcbiAgICAvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxyXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXAoZGVmaW5lUHJvcGVydHkpLFxyXG4gICAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgdmFyIGRlc2MgPSBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcclxuICAgIGVudW1lcmF0ZTogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcclxuICAgIGdldDogcmVmbGVjdEdldCxcclxuICAgIC8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXHJcbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGhhczogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXHJcbiAgICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiAhIWlzRXh0ZW5zaWJsZShhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxyXG4gICAgb3duS2V5czogb3duS2V5cyxcclxuICAgIC8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXHJcbiAgICBwcmV2ZW50RXh0ZW5zaW9uczogd3JhcChPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHwgcmV0dXJuSXQpLFxyXG4gICAgLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcclxuICAgIHNldDogcmVmbGVjdFNldFxyXG4gIH1cclxuICAvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcclxuICBpZihzZXRQcm90b3R5cGVPZilyZWZsZWN0LnNldFByb3RvdHlwZU9mID0gZnVuY3Rpb24odGFyZ2V0LCBwcm90byl7XHJcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3RvKSwgdHJ1ZTtcclxuICB9O1xyXG4gIFxyXG4gICRkZWZpbmUoR0xPQkFMLCB7UmVmbGVjdDoge319KTtcclxuICAkZGVmaW5lKFNUQVRJQywgJ1JlZmxlY3QnLCByZWZsZWN0KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcucHJvcG9zYWxzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFBST1RPLCBBUlJBWSwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvbWVuaWMvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXHJcbiAgICBpbmNsdWRlczogY3JlYXRlQXJyYXlDb250YWlucyh0cnVlKVxyXG4gIH0pO1xyXG4gICRkZWZpbmUoUFJPVE8sIFNUUklORywge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxyXG4gICAgYXQ6IGNyZWF0ZVBvaW50QXQodHJ1ZSlcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RUb0FycmF5KGlzRW50cmllcyl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIGtleXMgICA9IGdldEtleXMob2JqZWN0KVxyXG4gICAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICAgICAsIGkgICAgICA9IDBcclxuICAgICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcclxuICAgICAgICAsIGtleTtcclxuICAgICAgaWYoaXNFbnRyaWVzKXdoaWxlKGxlbmd0aCA+IGkpcmVzdWx0W2ldID0gW2tleSA9IGtleXNbaSsrXSwgT1trZXldXTtcclxuICAgICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbiAgJGRlZmluZShTVEFUSUMsIE9CSkVDVCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDQvYXByLTkubWQjNTEtb2JqZWN0ZW50cmllcy1vYmplY3R2YWx1ZXNcclxuICAgIHZhbHVlczogY3JlYXRlT2JqZWN0VG9BcnJheShmYWxzZSksXHJcbiAgICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXHJcbiAgfSk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFJFR0VYUCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2FuZ2F4Lzk2OTgxMDBcclxuICAgIGVzY2FwZTogY3JlYXRlUmVwbGFjZXIoLyhbXFxcXFxcLVtcXF17fSgpKis/LixeJHxdKS9nLCAnXFxcXCQxJywgdHJ1ZSlcclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcuYWJzdHJhY3QtcmVmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1hYnN0cmFjdC1yZWZzXHJcbiFmdW5jdGlvbihSRUZFUkVOQ0Upe1xyXG4gIFJFRkVSRU5DRV9HRVQgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFKydHZXQnLCB0cnVlKTtcclxuICB2YXIgUkVGRVJFTkNFX1NFVCA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrU0VULCB0cnVlKVxyXG4gICAgLCBSRUZFUkVOQ0VfREVMRVRFID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRSsnRGVsZXRlJywgdHJ1ZSk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwge1xyXG4gICAgcmVmZXJlbmNlR2V0OiBSRUZFUkVOQ0VfR0VULFxyXG4gICAgcmVmZXJlbmNlU2V0OiBSRUZFUkVOQ0VfU0VULFxyXG4gICAgcmVmZXJlbmNlRGVsZXRlOiBSRUZFUkVOQ0VfREVMRVRFXHJcbiAgfSk7XHJcbiAgXHJcbiAgaGlkZGVuKEZ1bmN0aW9uUHJvdG8sIFJFRkVSRU5DRV9HRVQsIHJldHVyblRoaXMpO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHNldE1hcE1ldGhvZHMoQ29uc3RydWN0b3Ipe1xyXG4gICAgaWYoQ29uc3RydWN0b3Ipe1xyXG4gICAgICB2YXIgTWFwUHJvdG8gPSBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9HRVQsIE1hcFByb3RvLmdldCk7XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX1NFVCwgTWFwUHJvdG8uc2V0KTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfREVMRVRFLCBNYXBQcm90b1snZGVsZXRlJ10pO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRNYXBNZXRob2RzKE1hcCk7XHJcbiAgc2V0TWFwTWV0aG9kcyhXZWFrTWFwKTtcclxufSgncmVmZXJlbmNlJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuZGljdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihESUNUKXtcclxuICBEaWN0ID0gZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XHJcbiAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpe1xyXG4gICAgICBpZihpc0l0ZXJhYmxlKGl0ZXJhYmxlKSl7XHJcbiAgICAgICAgZm9yKHZhciBpdGVyID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpLCBzdGVwLCB2YWx1ZTsgIShzdGVwID0gaXRlci5uZXh0KCkpLmRvbmU7KXtcclxuICAgICAgICAgIHZhbHVlID0gc3RlcC52YWx1ZTtcclxuICAgICAgICAgIGRpY3RbdmFsdWVbMF1dID0gdmFsdWVbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgYXNzaWduKGRpY3QsIGl0ZXJhYmxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaWN0O1xyXG4gIH1cclxuICBEaWN0W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIERpY3RJdGVyYXRvcihpdGVyYXRlZCwga2luZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IHRvT2JqZWN0KGl0ZXJhdGVkKSwgYTogZ2V0S2V5cyhpdGVyYXRlZCksIGk6IDAsIGs6IGtpbmR9KTtcclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoRGljdEl0ZXJhdG9yLCBESUNULCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgTyAgICA9IGl0ZXIub1xyXG4gICAgICAsIGtleXMgPSBpdGVyLmFcclxuICAgICAgLCBraW5kID0gaXRlci5rXHJcbiAgICAgICwga2V5O1xyXG4gICAgZG8ge1xyXG4gICAgICBpZihpdGVyLmkgPj0ga2V5cy5sZW5ndGgpe1xyXG4gICAgICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgICAgfVxyXG4gICAgfSB3aGlsZSghaGFzKE8sIGtleSA9IGtleXNbaXRlci5pKytdKSk7XHJcbiAgICBpZihraW5kID09IEtFWSkgIHJldHVybiBpdGVyUmVzdWx0KDAsIGtleSk7XHJcbiAgICBpZihraW5kID09IFZBTFVFKXJldHVybiBpdGVyUmVzdWx0KDAsIE9ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIFtrZXksIE9ba2V5XV0pO1xyXG4gIH0pO1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZURpY3RJdGVyKGtpbmQpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIG5ldyBEaWN0SXRlcmF0b3IoaXQsIGtpbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvKlxyXG4gICAqIDAgLT4gZm9yRWFjaFxyXG4gICAqIDEgLT4gbWFwXHJcbiAgICogMiAtPiBmaWx0ZXJcclxuICAgKiAzIC0+IHNvbWVcclxuICAgKiA0IC0+IGV2ZXJ5XHJcbiAgICogNSAtPiBmaW5kXHJcbiAgICogNiAtPiBmaW5kS2V5XHJcbiAgICogNyAtPiBtYXBQYWlyc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZURpY3RNZXRob2QodHlwZSl7XHJcbiAgICB2YXIgaXNNYXAgICAgPSB0eXBlID09IDFcclxuICAgICAgLCBpc0V2ZXJ5ICA9IHR5cGUgPT0gNDtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrZm4sIHRoYXQgLyogPSB1bmRlZmluZWQgKi8pe1xyXG4gICAgICB2YXIgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXHJcbiAgICAgICAgLCBPICAgICAgPSB0b09iamVjdChvYmplY3QpXHJcbiAgICAgICAgLCByZXN1bHQgPSBpc01hcCB8fCB0eXBlID09IDcgfHwgdHlwZSA9PSAyID8gbmV3IChnZW5lcmljKHRoaXMsIERpY3QpKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICwga2V5LCB2YWwsIHJlcztcclxuICAgICAgZm9yKGtleSBpbiBPKWlmKGhhcyhPLCBrZXkpKXtcclxuICAgICAgICB2YWwgPSBPW2tleV07XHJcbiAgICAgICAgcmVzID0gZih2YWwsIGtleSwgb2JqZWN0KTtcclxuICAgICAgICBpZih0eXBlKXtcclxuICAgICAgICAgIGlmKGlzTWFwKXJlc3VsdFtrZXldID0gcmVzOyAgICAgICAgICAgICAvLyBtYXBcclxuICAgICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgY2FzZSAyOiByZXN1bHRba2V5XSA9IHZhbDsgYnJlYWsgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAvLyBzb21lXHJcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgLy8gZmluZFxyXG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBrZXk7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRLZXlcclxuICAgICAgICAgICAgY2FzZSA3OiByZXN1bHRbcmVzWzBdXSA9IHJlc1sxXTsgICAgICAvLyBtYXBQYWlyc1xyXG4gICAgICAgICAgfSBlbHNlIGlmKGlzRXZlcnkpcmV0dXJuIGZhbHNlOyAgICAgICAgIC8vIGV2ZXJ5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0eXBlID09IDMgfHwgaXNFdmVyeSA/IGlzRXZlcnkgOiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNyZWF0ZURpY3RSZWR1Y2UoaXNUdXJuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIG1hcGZuLCBpbml0KXtcclxuICAgICAgYXNzZXJ0RnVuY3Rpb24obWFwZm4pO1xyXG4gICAgICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxyXG4gICAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICAgICAsIGkgICAgICA9IDBcclxuICAgICAgICAsIG1lbW8sIGtleSwgcmVzdWx0O1xyXG4gICAgICBpZihpc1R1cm4pbWVtbyA9IGluaXQgPT0gdW5kZWZpbmVkID8gbmV3IChnZW5lcmljKHRoaXMsIERpY3QpKSA6IE9iamVjdChpbml0KTtcclxuICAgICAgZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgYXNzZXJ0KGxlbmd0aCwgUkVEVUNFX0VSUk9SKTtcclxuICAgICAgICBtZW1vID0gT1trZXlzW2krK11dO1xyXG4gICAgICB9IGVsc2UgbWVtbyA9IE9iamVjdChpbml0KTtcclxuICAgICAgd2hpbGUobGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0ga2V5c1tpKytdKSl7XHJcbiAgICAgICAgcmVzdWx0ID0gbWFwZm4obWVtbywgT1trZXldLCBrZXksIG9iamVjdCk7XHJcbiAgICAgICAgaWYoaXNUdXJuKXtcclxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gZmFsc2UpYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIG1lbW8gPSByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBmaW5kS2V5ID0gY3JlYXRlRGljdE1ldGhvZCg2KTtcclxuICBmdW5jdGlvbiBpbmNsdWRlcyhvYmplY3QsIGVsKXtcclxuICAgIHJldHVybiAoZWwgPT0gZWwgPyBrZXlPZihvYmplY3QsIGVsKSA6IGZpbmRLZXkob2JqZWN0LCBzYW1lTmFOKSkgIT09IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGRpY3RNZXRob2RzID0ge1xyXG4gICAga2V5czogICAgY3JlYXRlRGljdEl0ZXIoS0VZKSxcclxuICAgIHZhbHVlczogIGNyZWF0ZURpY3RJdGVyKFZBTFVFKSxcclxuICAgIGVudHJpZXM6IGNyZWF0ZURpY3RJdGVyKEtFWStWQUxVRSksXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVEaWN0TWV0aG9kKDApLFxyXG4gICAgbWFwOiAgICAgY3JlYXRlRGljdE1ldGhvZCgxKSxcclxuICAgIGZpbHRlcjogIGNyZWF0ZURpY3RNZXRob2QoMiksXHJcbiAgICBzb21lOiAgICBjcmVhdGVEaWN0TWV0aG9kKDMpLFxyXG4gICAgZXZlcnk6ICAgY3JlYXRlRGljdE1ldGhvZCg0KSxcclxuICAgIGZpbmQ6ICAgIGNyZWF0ZURpY3RNZXRob2QoNSksXHJcbiAgICBmaW5kS2V5OiBmaW5kS2V5LFxyXG4gICAgbWFwUGFpcnM6Y3JlYXRlRGljdE1ldGhvZCg3KSxcclxuICAgIHJlZHVjZTogIGNyZWF0ZURpY3RSZWR1Y2UoZmFsc2UpLFxyXG4gICAgdHVybjogICAgY3JlYXRlRGljdFJlZHVjZSh0cnVlKSxcclxuICAgIGtleU9mOiAgIGtleU9mLFxyXG4gICAgaW5jbHVkZXM6aW5jbHVkZXMsXHJcbiAgICAvLyBIYXMgLyBnZXQgLyBzZXQgb3duIHByb3BlcnR5XHJcbiAgICBoYXM6IGhhcyxcclxuICAgIGdldDogZ2V0LFxyXG4gICAgc2V0OiBjcmVhdGVEZWZpbmVyKDApLFxyXG4gICAgaXNEaWN0OiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHJldHVybiBpc09iamVjdChpdCkgJiYgZ2V0UHJvdG90eXBlT2YoaXQpID09PSBEaWN0W1BST1RPVFlQRV07XHJcbiAgICB9XHJcbiAgfTtcclxuICBcclxuICBpZihSRUZFUkVOQ0VfR0VUKWZvcih2YXIga2V5IGluIGRpY3RNZXRob2RzKSFmdW5jdGlvbihmbil7XHJcbiAgICBmdW5jdGlvbiBtZXRob2QoKXtcclxuICAgICAgZm9yKHZhciBhcmdzID0gW3RoaXNdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZm5bUkVGRVJFTkNFX0dFVF0gPSBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgfVxyXG4gIH0oZGljdE1ldGhvZHNba2V5XSk7XHJcbiAgXHJcbiAgJGRlZmluZShHTE9CQUwgKyBGT1JDRUQsIHtEaWN0OiBhc3NpZ25IaWRkZW4oRGljdCwgZGljdE1ldGhvZHMpfSk7XHJcbn0oJ0RpY3QnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS4kZm9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKEVOVFJJRVMsIEZOKXsgIFxyXG4gIGZ1bmN0aW9uICRmb3IoaXRlcmFibGUsIGVudHJpZXMpe1xyXG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2YgJGZvcikpcmV0dXJuIG5ldyAkZm9yKGl0ZXJhYmxlLCBlbnRyaWVzKTtcclxuICAgIHRoaXNbSVRFUl0gICAgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XHJcbiAgICB0aGlzW0VOVFJJRVNdID0gISFlbnRyaWVzO1xyXG4gIH1cclxuICBcclxuICBjcmVhdGVJdGVyYXRvcigkZm9yLCAnV3JhcHBlcicsIGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpc1tJVEVSXS5uZXh0KCk7XHJcbiAgfSk7XHJcbiAgdmFyICRmb3JQcm90byA9ICRmb3JbUFJPVE9UWVBFXTtcclxuICBzZXRJdGVyYXRvcigkZm9yUHJvdG8sIGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpc1tJVEVSXTsgLy8gdW53cmFwXHJcbiAgfSk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5JdGVyYXRvcihuZXh0KXtcclxuICAgIGZ1bmN0aW9uIEl0ZXIoSSwgZm4sIHRoYXQpe1xyXG4gICAgICB0aGlzW0lURVJdICAgID0gZ2V0SXRlcmF0b3IoSSk7XHJcbiAgICAgIHRoaXNbRU5UUklFU10gPSBJW0VOVFJJRVNdO1xyXG4gICAgICB0aGlzW0ZOXSAgICAgID0gY3R4KGZuLCB0aGF0LCBJW0VOVFJJRVNdID8gMiA6IDEpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlSXRlcmF0b3IoSXRlciwgJ0NoYWluJywgbmV4dCwgJGZvclByb3RvKTtcclxuICAgIHNldEl0ZXJhdG9yKEl0ZXJbUFJPVE9UWVBFXSwgcmV0dXJuVGhpcyk7IC8vIG92ZXJyaWRlICRmb3JQcm90byBpdGVyYXRvclxyXG4gICAgcmV0dXJuIEl0ZXI7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBNYXBJdGVyID0gY3JlYXRlQ2hhaW5JdGVyYXRvcihmdW5jdGlvbigpe1xyXG4gICAgdmFyIHN0ZXAgPSB0aGlzW0lURVJdLm5leHQoKTtcclxuICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlclJlc3VsdCgwLCBzdGVwQ2FsbCh0aGlzW0ZOXSwgc3RlcC52YWx1ZSwgdGhpc1tFTlRSSUVTXSkpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIHZhciBGaWx0ZXJJdGVyID0gY3JlYXRlQ2hhaW5JdGVyYXRvcihmdW5jdGlvbigpe1xyXG4gICAgZm9yKDs7KXtcclxuICAgICAgdmFyIHN0ZXAgPSB0aGlzW0lURVJdLm5leHQoKTtcclxuICAgICAgaWYoc3RlcC5kb25lIHx8IHN0ZXBDYWxsKHRoaXNbRk5dLCBzdGVwLnZhbHVlLCB0aGlzW0VOVFJJRVNdKSlyZXR1cm4gc3RlcDtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICBhc3NpZ25IaWRkZW4oJGZvclByb3RvLCB7XHJcbiAgICBvZjogZnVuY3Rpb24oZm4sIHRoYXQpe1xyXG4gICAgICBmb3JPZih0aGlzLCB0aGlzW0VOVFJJRVNdLCBmbiwgdGhhdCk7XHJcbiAgICB9LFxyXG4gICAgYXJyYXk6IGZ1bmN0aW9uKGZuLCB0aGF0KXtcclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBmb3JPZihmbiAhPSB1bmRlZmluZWQgPyB0aGlzLm1hcChmbiwgdGhhdCkgOiB0aGlzLCBmYWxzZSwgcHVzaCwgcmVzdWx0KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKGZuLCB0aGF0KXtcclxuICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJJdGVyKHRoaXMsIGZuLCB0aGF0KTtcclxuICAgIH0sXHJcbiAgICBtYXA6IGZ1bmN0aW9uKGZuLCB0aGF0KXtcclxuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyKHRoaXMsIGZuLCB0aGF0KTtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAkZm9yLmlzSXRlcmFibGUgID0gaXNJdGVyYWJsZTtcclxuICAkZm9yLmdldEl0ZXJhdG9yID0gZ2V0SXRlcmF0b3I7XHJcbiAgXHJcbiAgJGRlZmluZShHTE9CQUwgKyBGT1JDRUQsIHskZm9yOiAkZm9yfSk7XHJcbn0oJ2VudHJpZXMnLCBzYWZlU3ltYm9sKCdmbicpKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5kZWxheSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gaHR0cHM6Ly9lc2Rpc2N1c3Mub3JnL3RvcGljL3Byb21pc2UtcmV0dXJuaW5nLWRlbGF5LWZ1bmN0aW9uXHJcbiRkZWZpbmUoR0xPQkFMICsgRk9SQ0VELCB7XHJcbiAgZGVsYXk6IGZ1bmN0aW9uKHRpbWUpe1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xyXG4gICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5iaW5kaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKF8sIHRvTG9jYWxlU3RyaW5nKXtcclxuICAvLyBQbGFjZWhvbGRlclxyXG4gIGNvcmUuXyA9IHBhdGguXyA9IHBhdGguXyB8fCB7fTtcclxuXHJcbiAgJGRlZmluZShQUk9UTyArIEZPUkNFRCwgRlVOQ1RJT04sIHtcclxuICAgIHBhcnQ6IHBhcnQsXHJcbiAgICBvbmx5OiBmdW5jdGlvbihudW1iZXJBcmd1bWVudHMsIHRoYXQgLyogPSBAICovKXtcclxuICAgICAgdmFyIGZuICAgICA9IGFzc2VydEZ1bmN0aW9uKHRoaXMpXHJcbiAgICAgICAgLCBuICAgICAgPSB0b0xlbmd0aChudW1iZXJBcmd1bWVudHMpXHJcbiAgICAgICAgLCBpc1RoYXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBtaW4obiwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICwgYXJncyAgID0gQXJyYXkobGVuZ3RoKVxyXG4gICAgICAgICAgLCBpICAgICAgPSAwO1xyXG4gICAgICAgIHdoaWxlKGxlbmd0aCA+IGkpYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xyXG4gICAgICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIGlzVGhhdCA/IHRoYXQgOiB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHRpZShrZXkpe1xyXG4gICAgdmFyIHRoYXQgID0gdGhpc1xyXG4gICAgICAsIGJvdW5kID0ge307XHJcbiAgICByZXR1cm4gaGlkZGVuKHRoYXQsIF8sIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKGtleSA9PT0gdW5kZWZpbmVkIHx8ICEoa2V5IGluIHRoYXQpKXJldHVybiB0b0xvY2FsZVN0cmluZy5jYWxsKHRoYXQpO1xyXG4gICAgICByZXR1cm4gaGFzKGJvdW5kLCBrZXkpID8gYm91bmRba2V5XSA6IChib3VuZFtrZXldID0gY3R4KHRoYXRba2V5XSwgdGhhdCwgLTEpKTtcclxuICAgIH0pW19dKGtleSk7XHJcbiAgfVxyXG4gIFxyXG4gIGhpZGRlbihwYXRoLl8sIFRPX1NUUklORywgZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiBfO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGhpZGRlbihPYmplY3RQcm90bywgXywgdGllKTtcclxuICBERVNDIHx8IGhpZGRlbihBcnJheVByb3RvLCBfLCB0aWUpO1xyXG4gIC8vIElFOC0gZGlydHkgaGFjayAtIHJlZGVmaW5lZCB0b0xvY2FsZVN0cmluZyBpcyBub3QgZW51bWVyYWJsZVxyXG59KERFU0MgPyB1aWQoJ3RpZScpIDogVE9fTE9DQUxFLCBPYmplY3RQcm90b1tUT19MT0NBTEVdKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5vYmplY3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgZnVuY3Rpb24gZGVmaW5lKHRhcmdldCwgbWl4aW4pe1xyXG4gICAgdmFyIGtleXMgICA9IG93bktleXModG9PYmplY3QobWl4aW4pKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaSA9IDAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGkpZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXkgPSBrZXlzW2krK10sIGdldE93bkRlc2NyaXB0b3IobWl4aW4sIGtleSkpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9O1xyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VELCBPQkpFQ1QsIHtcclxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcclxuICAgIGNsYXNzb2Y6IGNsYXNzb2YsXHJcbiAgICBkZWZpbmU6IGRlZmluZSxcclxuICAgIG1ha2U6IGZ1bmN0aW9uKHByb3RvLCBtaXhpbil7XHJcbiAgICAgIHJldHVybiBkZWZpbmUoY3JlYXRlKHByb3RvKSwgbWl4aW4pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuYXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiRkZWZpbmUoUFJPVE8gKyBGT1JDRUQsIEFSUkFZLCB7XHJcbiAgdHVybjogZnVuY3Rpb24oZm4sIHRhcmdldCAvKiA9IFtdICovKXtcclxuICAgIGFzc2VydEZ1bmN0aW9uKGZuKTtcclxuICAgIHZhciBtZW1vICAgPSB0YXJnZXQgPT0gdW5kZWZpbmVkID8gW10gOiBPYmplY3QodGFyZ2V0KVxyXG4gICAgICAsIE8gICAgICA9IEVTNU9iamVjdCh0aGlzKVxyXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAsIGluZGV4ICA9IDA7XHJcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClpZihmbihtZW1vLCBPW2luZGV4XSwgaW5kZXgrKywgdGhpcykgPT09IGZhbHNlKWJyZWFrO1xyXG4gICAgcmV0dXJuIG1lbW87XHJcbiAgfVxyXG59KTtcclxuaWYoZnJhbWV3b3JrKUFycmF5VW5zY29wYWJsZXMudHVybiA9IHRydWU7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUubnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihudW1iZXJNZXRob2RzKXsgIFxyXG4gIGZ1bmN0aW9uIE51bWJlckl0ZXJhdG9yKGl0ZXJhdGVkKXtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bDogdG9MZW5ndGgoaXRlcmF0ZWQpLCBpOiAwfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZUl0ZXJhdG9yKE51bWJlckl0ZXJhdG9yLCBOVU1CRVIsIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBpICAgID0gaXRlci5pKys7XHJcbiAgICByZXR1cm4gaSA8IGl0ZXIubCA/IGl0ZXJSZXN1bHQoMCwgaSkgOiBpdGVyUmVzdWx0KDEpO1xyXG4gIH0pO1xyXG4gIGRlZmluZUl0ZXJhdG9yKE51bWJlciwgTlVNQkVSLCBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG5ldyBOdW1iZXJJdGVyYXRvcih0aGlzKTtcclxuICB9KTtcclxuICBcclxuICBudW1iZXJNZXRob2RzLnJhbmRvbSA9IGZ1bmN0aW9uKGxpbSAvKiA9IDAgKi8pe1xyXG4gICAgdmFyIGEgPSArdGhpc1xyXG4gICAgICAsIGIgPSBsaW0gPT0gdW5kZWZpbmVkID8gMCA6ICtsaW1cclxuICAgICAgLCBtID0gbWluKGEsIGIpO1xyXG4gICAgcmV0dXJuIHJhbmRvbSgpICogKG1heChhLCBiKSAtIG0pICsgbTtcclxuICB9O1xyXG5cclxuICBmb3JFYWNoLmNhbGwoYXJyYXkoXHJcbiAgICAgIC8vIEVTMzpcclxuICAgICAgJ3JvdW5kLGZsb29yLGNlaWwsYWJzLHNpbixhc2luLGNvcyxhY29zLHRhbixhdGFuLGV4cCxzcXJ0LG1heCxtaW4scG93LGF0YW4yLCcgK1xyXG4gICAgICAvLyBFUzY6XHJcbiAgICAgICdhY29zaCxhc2luaCxhdGFuaCxjYnJ0LGNsejMyLGNvc2gsZXhwbTEsaHlwb3QsaW11bCxsb2cxcCxsb2cxMCxsb2cyLHNpZ24sc2luaCx0YW5oLHRydW5jJ1xyXG4gICAgKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIGZuID0gTWF0aFtrZXldO1xyXG4gICAgICBpZihmbiludW1iZXJNZXRob2RzW2tleV0gPSBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgICAvLyBpZTktIGRvbnQgc3VwcG9ydCBzdHJpY3QgbW9kZSAmIGNvbnZlcnQgYHRoaXNgIHRvIG9iamVjdCAtPiBjb252ZXJ0IGl0IHRvIG51bWJlclxyXG4gICAgICAgIHZhciBhcmdzID0gWyt0aGlzXVxyXG4gICAgICAgICAgLCBpICAgID0gMDtcclxuICAgICAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxuICBcclxuICAkZGVmaW5lKFBST1RPICsgRk9SQ0VELCBOVU1CRVIsIG51bWJlck1ldGhvZHMpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29yZS5zdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgdmFyIGVzY2FwZUhUTUxEaWN0ID0ge1xyXG4gICAgJyYnOiAnJmFtcDsnLFxyXG4gICAgJzwnOiAnJmx0OycsXHJcbiAgICAnPic6ICcmZ3Q7JyxcclxuICAgICdcIic6ICcmcXVvdDsnLFxyXG4gICAgXCInXCI6ICcmYXBvczsnXHJcbiAgfSwgdW5lc2NhcGVIVE1MRGljdCA9IHt9LCBrZXk7XHJcbiAgZm9yKGtleSBpbiBlc2NhcGVIVE1MRGljdCl1bmVzY2FwZUhUTUxEaWN0W2VzY2FwZUhUTUxEaWN0W2tleV1dID0ga2V5O1xyXG4gICRkZWZpbmUoUFJPVE8gKyBGT1JDRUQsIFNUUklORywge1xyXG4gICAgZXNjYXBlSFRNTDogICBjcmVhdGVSZXBsYWNlcigvWyY8PlwiJ10vZywgZXNjYXBlSFRNTERpY3QpLFxyXG4gICAgdW5lc2NhcGVIVE1MOiBjcmVhdGVSZXBsYWNlcigvJig/OmFtcHxsdHxndHxxdW90fGFwb3MpOy9nLCB1bmVzY2FwZUhUTUxEaWN0KVxyXG4gIH0pO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvcmUuZGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihmb3JtYXRSZWdFeHAsIGZsZXhpb1JlZ0V4cCwgbG9jYWxlcywgY3VycmVudCwgU0VDT05EUywgTUlOVVRFUywgSE9VUlMsIE1PTlRILCBZRUFSKXtcclxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXQocHJlZml4KXtcclxuICAgIHJldHVybiBmdW5jdGlvbih0ZW1wbGF0ZSwgbG9jYWxlIC8qID0gY3VycmVudCAqLyl7XHJcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xyXG4gICAgICAgICwgZGljdCA9IGxvY2FsZXNbaGFzKGxvY2FsZXMsIGxvY2FsZSkgPyBsb2NhbGUgOiBjdXJyZW50XTtcclxuICAgICAgZnVuY3Rpb24gZ2V0KHVuaXQpe1xyXG4gICAgICAgIHJldHVybiB0aGF0W3ByZWZpeCArIHVuaXRdKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFN0cmluZyh0ZW1wbGF0ZSkucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgIHN3aXRjaChwYXJ0KXtcclxuICAgICAgICAgIGNhc2UgJ3MnICA6IHJldHVybiBnZXQoU0VDT05EUyk7ICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kcyA6IDAtNTlcclxuICAgICAgICAgIGNhc2UgJ3NzJyA6IHJldHVybiBseihnZXQoU0VDT05EUykpOyAgICAgICAgICAgICAgLy8gU2Vjb25kcyA6IDAwLTU5XHJcbiAgICAgICAgICBjYXNlICdtJyAgOiByZXR1cm4gZ2V0KE1JTlVURVMpOyAgICAgICAgICAgICAgICAgIC8vIE1pbnV0ZXMgOiAwLTU5XHJcbiAgICAgICAgICBjYXNlICdtbScgOiByZXR1cm4gbHooZ2V0KE1JTlVURVMpKTsgICAgICAgICAgICAgIC8vIE1pbnV0ZXMgOiAwMC01OVxyXG4gICAgICAgICAgY2FzZSAnaCcgIDogcmV0dXJuIGdldChIT1VSUyk7ICAgICAgICAgICAgICAgICAgICAvLyBIb3VycyAgIDogMC0yM1xyXG4gICAgICAgICAgY2FzZSAnaGgnIDogcmV0dXJuIGx6KGdldChIT1VSUykpOyAgICAgICAgICAgICAgICAvLyBIb3VycyAgIDogMDAtMjNcclxuICAgICAgICAgIGNhc2UgJ0QnICA6IHJldHVybiBnZXQoREFURSk7ICAgICAgICAgICAgICAgICAgICAgLy8gRGF0ZSAgICA6IDEtMzFcclxuICAgICAgICAgIGNhc2UgJ0REJyA6IHJldHVybiBseihnZXQoREFURSkpOyAgICAgICAgICAgICAgICAgLy8gRGF0ZSAgICA6IDAxLTMxXHJcbiAgICAgICAgICBjYXNlICdXJyAgOiByZXR1cm4gZGljdFswXVtnZXQoJ0RheScpXTsgICAgICAgICAgIC8vIERheSAgICAgOiDQn9C+0L3QtdC00LXQu9GM0L3QuNC6XHJcbiAgICAgICAgICBjYXNlICdOJyAgOiByZXR1cm4gZ2V0KE1PTlRIKSArIDE7ICAgICAgICAgICAgICAgIC8vIE1vbnRoICAgOiAxLTEyXHJcbiAgICAgICAgICBjYXNlICdOTicgOiByZXR1cm4gbHooZ2V0KE1PTlRIKSArIDEpOyAgICAgICAgICAgIC8vIE1vbnRoICAgOiAwMS0xMlxyXG4gICAgICAgICAgY2FzZSAnTScgIDogcmV0dXJuIGRpY3RbMl1bZ2V0KE1PTlRIKV07ICAgICAgICAgICAvLyBNb250aCAgIDog0K/QvdCy0LDRgNGMXHJcbiAgICAgICAgICBjYXNlICdNTScgOiByZXR1cm4gZGljdFsxXVtnZXQoTU9OVEgpXTsgICAgICAgICAgIC8vIE1vbnRoICAgOiDQr9C90LLQsNGA0Y9cclxuICAgICAgICAgIGNhc2UgJ1knICA6IHJldHVybiBnZXQoWUVBUik7ICAgICAgICAgICAgICAgICAgICAgLy8gWWVhciAgICA6IDIwMTRcclxuICAgICAgICAgIGNhc2UgJ1lZJyA6IHJldHVybiBseihnZXQoWUVBUikgJSAxMDApOyAgICAgICAgICAgLy8gWWVhciAgICA6IDE0XHJcbiAgICAgICAgfSByZXR1cm4gcGFydDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFkZExvY2FsZShsYW5nLCBsb2NhbGUpe1xyXG4gICAgZnVuY3Rpb24gc3BsaXQoaW5kZXgpe1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIGZvckVhY2guY2FsbChhcnJheShsb2NhbGUubW9udGhzKSwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0LnJlcGxhY2UoZmxleGlvUmVnRXhwLCAnJCcgKyBpbmRleCkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGxvY2FsZXNbbGFuZ10gPSBbYXJyYXkobG9jYWxlLndlZWtkYXlzKSwgc3BsaXQoMSksIHNwbGl0KDIpXTtcclxuICAgIHJldHVybiBjb3JlO1xyXG4gIH1cclxuICAkZGVmaW5lKFBST1RPICsgRk9SQ0VELCBEQVRFLCB7XHJcbiAgICBmb3JtYXQ6ICAgIGNyZWF0ZUZvcm1hdCgnZ2V0JyksXHJcbiAgICBmb3JtYXRVVEM6IGNyZWF0ZUZvcm1hdCgnZ2V0VVRDJylcclxuICB9KTtcclxuICBhZGRMb2NhbGUoY3VycmVudCwge1xyXG4gICAgd2Vla2RheXM6ICdTdW5kYXksTW9uZGF5LFR1ZXNkYXksV2VkbmVzZGF5LFRodXJzZGF5LEZyaWRheSxTYXR1cmRheScsXHJcbiAgICBtb250aHM6ICdKYW51YXJ5LEZlYnJ1YXJ5LE1hcmNoLEFwcmlsLE1heSxKdW5lLEp1bHksQXVndXN0LFNlcHRlbWJlcixPY3RvYmVyLE5vdmVtYmVyLERlY2VtYmVyJ1xyXG4gIH0pO1xyXG4gIGFkZExvY2FsZSgncnUnLCB7XHJcbiAgICB3ZWVrZGF5czogJ9CS0L7RgdC60YDQtdGB0LXQvdGM0LUs0J/QvtC90LXQtNC10LvRjNC90LjQuizQktGC0L7RgNC90LjQuizQodGA0LXQtNCwLNCn0LXRgtCy0LXRgNCzLNCf0Y/RgtC90LjRhtCwLNCh0YPQsdCx0L7RgtCwJyxcclxuICAgIG1vbnRoczogJ9Cv0L3QstCw0YA60Y980Yws0KTQtdCy0YDQsNC7OtGPfNGMLNCc0LDRgNGCOtCwfCzQkNC/0YDQtdC7OtGPfNGMLNCc0LA60Y980Lks0JjRjtC9OtGPfNGMLCcgK1xyXG4gICAgICAgICAgICAn0JjRjtC7OtGPfNGMLNCQ0LLQs9GD0YHRgjrQsHws0KHQtdC90YLRj9Cx0YA60Y980Yws0J7QutGC0Y/QsdGAOtGPfNGMLNCd0L7Rj9Cx0YA60Y980Yws0JTQtdC60LDQsdGAOtGPfNGMJ1xyXG4gIH0pO1xyXG4gIGNvcmUubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlKXtcclxuICAgIHJldHVybiBoYXMobG9jYWxlcywgbG9jYWxlKSA/IGN1cnJlbnQgPSBsb2NhbGUgOiBjdXJyZW50O1xyXG4gIH07XHJcbiAgY29yZS5hZGRMb2NhbGUgPSBhZGRMb2NhbGU7XHJcbn0oL1xcYlxcd1xcdz9cXGIvZywgLzooLiopXFx8KC4qKSQvLCB7fSwgJ2VuJywgJ1NlY29uZHMnLCAnTWludXRlcycsICdIb3VycycsICdNb250aCcsICdGdWxsWWVhcicpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb3JlLmdsb2JhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4kZGVmaW5lKEdMT0JBTCArIEZPUkNFRCwge2dsb2JhbDogZ2xvYmFsfSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGpzLmFycmF5LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEphdmFTY3JpcHQgMS42IC8gU3RyYXdtYW4gYXJyYXkgc3RhdGljcyBzaGltXHJcbiFmdW5jdGlvbihhcnJheVN0YXRpY3Mpe1xyXG4gIGZ1bmN0aW9uIHNldEFycmF5U3RhdGljcyhrZXlzLCBsZW5ndGgpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KGtleXMpLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihrZXkgaW4gQXJyYXlQcm90bylhcnJheVN0YXRpY3Nba2V5XSA9IGN0eChjYWxsLCBBcnJheVByb3RvW2tleV0sIGxlbmd0aCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzJywgMSk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzJywgMyk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YsJyArXHJcbiAgICAgICAgICAgICAgICAgICdyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsLHR1cm4nKTtcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIGFycmF5U3RhdGljcyk7XHJcbn0oe30pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiB3ZWIuZG9tLml0YXJhYmxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oTm9kZUxpc3Qpe1xyXG4gIGlmKGZyYW1ld29yayAmJiBOb2RlTGlzdCAmJiAhKFNZTUJPTF9JVEVSQVRPUiBpbiBOb2RlTGlzdFtQUk9UT1RZUEVdKSl7XHJcbiAgICBoaWRkZW4oTm9kZUxpc3RbUFJPVE9UWVBFXSwgU1lNQk9MX0lURVJBVE9SLCBJdGVyYXRvcnNbQVJSQVldKTtcclxuICB9XHJcbiAgSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzW0FSUkFZXTtcclxufShnbG9iYWwuTm9kZUxpc3QpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb3JlLmxvZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24obG9nLCBjb25zb2xlLCBlbmFibGVkKXtcclxuICBmb3JFYWNoLmNhbGwoYXJyYXkoQ09OU09MRV9NRVRIT0RTKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgIGxvZ1trZXldID0gZnVuY3Rpb24oKXtcclxuICAgICAgaWYoZW5hYmxlZCAmJiBrZXkgaW4gY29uc29sZSlyZXR1cm4gYXBwbHkuY2FsbChjb25zb2xlW2tleV0sIGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VELCB7bG9nOiBhc3NpZ24obG9nLmxvZywgbG9nLCB7XHJcbiAgICBlbmFibGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRpc2FibGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9KX0pO1xyXG59KHt9LCBnbG9iYWwuY29uc29sZSB8fCB7fSwgdHJ1ZSk7XG59KHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLCBmYWxzZSk7IiwiLyoqXG4gKiBDb3JlLmpzIDAuNS40XG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qc1xuICogTGljZW5zZTogaHR0cDovL3JvY2subWl0LWxpY2Vuc2Uub3JnXG4gKiDCqSAyMDE1IERlbmlzIFB1c2hrYXJldlxuICovXG4hZnVuY3Rpb24oZ2xvYmFsLCBmcmFtZXdvcmssIHVuZGVmaW5lZCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gU2hvcnRjdXRzIGZvciBbW0NsYXNzXV0gJiBwcm9wZXJ0eSBuYW1lc1xyXG52YXIgT0JKRUNUICAgICAgICAgID0gJ09iamVjdCdcclxuICAsIEZVTkNUSU9OICAgICAgICA9ICdGdW5jdGlvbidcclxuICAsIEFSUkFZICAgICAgICAgICA9ICdBcnJheSdcclxuICAsIFNUUklORyAgICAgICAgICA9ICdTdHJpbmcnXHJcbiAgLCBOVU1CRVIgICAgICAgICAgPSAnTnVtYmVyJ1xyXG4gICwgUkVHRVhQICAgICAgICAgID0gJ1JlZ0V4cCdcclxuICAsIERBVEUgICAgICAgICAgICA9ICdEYXRlJ1xyXG4gICwgTUFQICAgICAgICAgICAgID0gJ01hcCdcclxuICAsIFNFVCAgICAgICAgICAgICA9ICdTZXQnXHJcbiAgLCBXRUFLTUFQICAgICAgICAgPSAnV2Vha01hcCdcclxuICAsIFdFQUtTRVQgICAgICAgICA9ICdXZWFrU2V0J1xyXG4gICwgU1lNQk9MICAgICAgICAgID0gJ1N5bWJvbCdcclxuICAsIFBST01JU0UgICAgICAgICA9ICdQcm9taXNlJ1xyXG4gICwgTUFUSCAgICAgICAgICAgID0gJ01hdGgnXHJcbiAgLCBBUkdVTUVOVFMgICAgICAgPSAnQXJndW1lbnRzJ1xyXG4gICwgUFJPVE9UWVBFICAgICAgID0gJ3Byb3RvdHlwZSdcclxuICAsIENPTlNUUlVDVE9SICAgICA9ICdjb25zdHJ1Y3RvcidcclxuICAsIFRPX1NUUklORyAgICAgICA9ICd0b1N0cmluZydcclxuICAsIFRPX1NUUklOR19UQUcgICA9IFRPX1NUUklORyArICdUYWcnXHJcbiAgLCBUT19MT0NBTEUgICAgICAgPSAndG9Mb2NhbGVTdHJpbmcnXHJcbiAgLCBIQVNfT1dOICAgICAgICAgPSAnaGFzT3duUHJvcGVydHknXHJcbiAgLCBGT1JfRUFDSCAgICAgICAgPSAnZm9yRWFjaCdcclxuICAsIElURVJBVE9SICAgICAgICA9ICdpdGVyYXRvcidcclxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQCcgKyBJVEVSQVRPUlxyXG4gICwgUFJPQ0VTUyAgICAgICAgID0gJ3Byb2Nlc3MnXHJcbiAgLCBDUkVBVEVfRUxFTUVOVCAgPSAnY3JlYXRlRWxlbWVudCdcclxuICAvLyBBbGlhc2VzIGdsb2JhbCBvYmplY3RzIGFuZCBwcm90b3R5cGVzXHJcbiAgLCBGdW5jdGlvbiAgICAgICAgPSBnbG9iYWxbRlVOQ1RJT05dXHJcbiAgLCBPYmplY3QgICAgICAgICAgPSBnbG9iYWxbT0JKRUNUXVxyXG4gICwgQXJyYXkgICAgICAgICAgID0gZ2xvYmFsW0FSUkFZXVxyXG4gICwgU3RyaW5nICAgICAgICAgID0gZ2xvYmFsW1NUUklOR11cclxuICAsIE51bWJlciAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXHJcbiAgLCBSZWdFeHAgICAgICAgICAgPSBnbG9iYWxbUkVHRVhQXVxyXG4gICwgRGF0ZSAgICAgICAgICAgID0gZ2xvYmFsW0RBVEVdXHJcbiAgLCBNYXAgICAgICAgICAgICAgPSBnbG9iYWxbTUFQXVxyXG4gICwgU2V0ICAgICAgICAgICAgID0gZ2xvYmFsW1NFVF1cclxuICAsIFdlYWtNYXAgICAgICAgICA9IGdsb2JhbFtXRUFLTUFQXVxyXG4gICwgV2Vha1NldCAgICAgICAgID0gZ2xvYmFsW1dFQUtTRVRdXHJcbiAgLCBTeW1ib2wgICAgICAgICAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICwgTWF0aCAgICAgICAgICAgID0gZ2xvYmFsW01BVEhdXHJcbiAgLCBUeXBlRXJyb3IgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXHJcbiAgLCBSYW5nZUVycm9yICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxyXG4gICwgc2V0VGltZW91dCAgICAgID0gZ2xvYmFsLnNldFRpbWVvdXRcclxuICAsIHNldEltbWVkaWF0ZSAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcclxuICAsIGNsZWFySW1tZWRpYXRlICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxyXG4gICwgcGFyc2VJbnQgICAgICAgID0gZ2xvYmFsLnBhcnNlSW50XHJcbiAgLCBpc0Zpbml0ZSAgICAgICAgPSBnbG9iYWwuaXNGaW5pdGVcclxuICAsIHByb2Nlc3MgICAgICAgICA9IGdsb2JhbFtQUk9DRVNTXVxyXG4gICwgbmV4dFRpY2sgICAgICAgID0gcHJvY2VzcyAmJiBwcm9jZXNzLm5leHRUaWNrXHJcbiAgLCBkb2N1bWVudCAgICAgICAgPSBnbG9iYWwuZG9jdW1lbnRcclxuICAsIGh0bWwgICAgICAgICAgICA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICwgbmF2aWdhdG9yICAgICAgID0gZ2xvYmFsLm5hdmlnYXRvclxyXG4gICwgZGVmaW5lICAgICAgICAgID0gZ2xvYmFsLmRlZmluZVxyXG4gICwgQXJyYXlQcm90byAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxyXG4gICwgT2JqZWN0UHJvdG8gICAgID0gT2JqZWN0W1BST1RPVFlQRV1cclxuICAsIEZ1bmN0aW9uUHJvdG8gICA9IEZ1bmN0aW9uW1BST1RPVFlQRV1cclxuICAsIEluZmluaXR5ICAgICAgICA9IDEgLyAwXHJcbiAgLCBET1QgICAgICAgICAgICAgPSAnLidcclxuICAvLyBNZXRob2RzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0RldmVsb3BlclRvb2xzV0cvY29uc29sZS1vYmplY3QvYmxvYi9tYXN0ZXIvYXBpLm1kXHJcbiAgLCBDT05TT0xFX01FVEhPRFMgPSAnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLCcgK1xyXG4gICAgICAnZ3JvdXAsZ3JvdXBDb2xsYXBzZWQsZ3JvdXBFbmQsaW5mbyxpc0luZGVwZW5kZW50bHlDb21wb3NlZCxsb2csJyArXHJcbiAgICAgICdtYXJrVGltZWxpbmUscHJvZmlsZSxwcm9maWxlRW5kLHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSwnICtcclxuICAgICAgJ3RpbWVsaW5lRW5kLHRpbWVTdGFtcCx0cmFjZSx3YXJuJztcclxuXHJcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcmUtanMtaXNvYmplY3RcclxuZnVuY3Rpb24gaXNPYmplY3QoaXQpe1xyXG4gIHJldHVybiBpdCAhPT0gbnVsbCAmJiAodHlwZW9mIGl0ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nKTtcclxufVxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGl0KXtcclxuICByZXR1cm4gdHlwZW9mIGl0ID09ICdmdW5jdGlvbic7XHJcbn1cclxuLy8gTmF0aXZlIGZ1bmN0aW9uP1xyXG52YXIgaXNOYXRpdmUgPSBjdHgoLy4vLnRlc3QsIC9cXFtuYXRpdmUgY29kZVxcXVxccypcXH1cXHMqJC8sIDEpO1xyXG5cclxuLy8gT2JqZWN0IGludGVybmFsIFtbQ2xhc3NdXSBvciB0b1N0cmluZ1RhZ1xyXG4vLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXHJcbnZhciB0b1N0cmluZyA9IE9iamVjdFByb3RvW1RPX1NUUklOR107XHJcbmZ1bmN0aW9uIHNldFRvU3RyaW5nVGFnKGl0LCB0YWcsIHN0YXQpe1xyXG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdFtQUk9UT1RZUEVdLCBTWU1CT0xfVEFHKSloaWRkZW4oaXQsIFNZTUJPTF9UQUcsIHRhZyk7XHJcbn1cclxuZnVuY3Rpb24gY29mKGl0KXtcclxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xyXG59XHJcbmZ1bmN0aW9uIGNsYXNzb2YoaXQpe1xyXG4gIHZhciBPLCBUO1xyXG4gIHJldHVybiBpdCA9PSB1bmRlZmluZWQgPyBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiAnTnVsbCdcclxuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtTWU1CT0xfVEFHXSkgPT0gJ3N0cmluZycgPyBUIDogY29mKE8pO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvblxyXG52YXIgY2FsbCAgPSBGdW5jdGlvblByb3RvLmNhbGxcclxuICAsIGFwcGx5ID0gRnVuY3Rpb25Qcm90by5hcHBseVxyXG4gICwgUkVGRVJFTkNFX0dFVDtcclxuLy8gUGFydGlhbCBhcHBseVxyXG5mdW5jdGlvbiBwYXJ0KC8qIC4uLmFyZ3MgKi8pe1xyXG4gIHZhciBmbiAgICAgPSBhc3NlcnRGdW5jdGlvbih0aGlzKVxyXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGFyZ3MgICA9IEFycmF5KGxlbmd0aClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCBfICAgICAgPSBwYXRoLl9cclxuICAgICwgaG9sZGVyID0gZmFsc2U7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigoYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xyXG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgIHZhciB0aGF0ICAgID0gdGhpc1xyXG4gICAgICAsIF9sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICwgaSA9IDAsIGogPSAwLCBfYXJncztcclxuICAgIGlmKCFob2xkZXIgJiYgIV9sZW5ndGgpcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XHJcbiAgICBfYXJncyA9IGFyZ3Muc2xpY2UoKTtcclxuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGk7IGkrKylpZihfYXJnc1tpXSA9PT0gXylfYXJnc1tpXSA9IGFyZ3VtZW50c1tqKytdO1xyXG4gICAgd2hpbGUoX2xlbmd0aCA+IGopX2FyZ3MucHVzaChhcmd1bWVudHNbaisrXSk7XHJcbiAgICByZXR1cm4gaW52b2tlKGZuLCBfYXJncywgdGhhdCk7XHJcbiAgfVxyXG59XHJcbi8vIE9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xyXG5mdW5jdGlvbiBjdHgoZm4sIHRoYXQsIGxlbmd0aCl7XHJcbiAgYXNzZXJ0RnVuY3Rpb24oZm4pO1xyXG4gIGlmKH5sZW5ndGggJiYgdGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcclxuICBzd2l0Y2gobGVuZ3RoKXtcclxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuICAgIH1cclxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcclxuICAgIH1cclxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xyXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcclxuICAgIH1cclxuICB9IHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59XHJcbi8vIEZhc3QgYXBwbHlcclxuLy8gaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XHJcbmZ1bmN0aW9uIGludm9rZShmbiwgYXJncywgdGhhdCl7XHJcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xyXG4gIHN3aXRjaChhcmdzLmxlbmd0aCB8IDApe1xyXG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XHJcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XHJcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XHJcbiAgICBjYXNlIDU6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XHJcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgLyosIG5ld1RhcmdldCovKXtcclxuICB2YXIgcHJvdG8gICAgPSBhc3NlcnRGdW5jdGlvbihhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXSlbUFJPVE9UWVBFXVxyXG4gICAgLCBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvKVxyXG4gICAgLCByZXN1bHQgICA9IGFwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XHJcbiAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcclxufVxyXG5cclxuLy8gT2JqZWN0OlxyXG52YXIgY3JlYXRlICAgICAgICAgICA9IE9iamVjdC5jcmVhdGVcclxuICAsIGdldFByb3RvdHlwZU9mICAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcclxuICAsIHNldFByb3RvdHlwZU9mICAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAsIGRlZmluZVByb3BlcnR5ICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcclxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xyXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcclxuICAsIGdldEtleXMgICAgICAgICAgPSBPYmplY3Qua2V5c1xyXG4gICwgZ2V0TmFtZXMgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgLCBnZXRTeW1ib2xzICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xyXG4gICwgaXNGcm96ZW4gICAgICAgICA9IE9iamVjdC5pc0Zyb3plblxyXG4gICwgaGFzICAgICAgICAgICAgICA9IGN0eChjYWxsLCBPYmplY3RQcm90b1tIQVNfT1dOXSwgMilcclxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcclxuICAsIEVTNU9iamVjdCAgICAgICAgPSBPYmplY3RcclxuICAsIERpY3Q7XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGl0KXtcclxuICByZXR1cm4gRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5JdChpdCl7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIHJldHVyblRoaXMoKXtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBrZXkpe1xyXG4gIGlmKGhhcyhvYmplY3QsIGtleSkpcmV0dXJuIG9iamVjdFtrZXldO1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXMoaXQpe1xyXG4gIGFzc2VydE9iamVjdChpdCk7XHJcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBnZXROYW1lcyhpdCkuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGdldE5hbWVzKGl0KTtcclxufVxyXG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXHJcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKXtcclxuICB2YXIgVCA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRhcmdldCkpXHJcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGkgPSAxO1xyXG4gIHdoaWxlKGwgPiBpKXtcclxuICAgIHZhciBTICAgICAgPSBFUzVPYmplY3QoYXJndW1lbnRzW2krK10pXHJcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhTKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaiAgICAgID0gMFxyXG4gICAgICAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xyXG4gIH1cclxuICByZXR1cm4gVDtcclxufVxyXG5mdW5jdGlvbiBrZXlPZihvYmplY3QsIGVsKXtcclxuICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGluZGV4ICA9IDBcclxuICAgICwga2V5O1xyXG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XHJcbn1cclxuXHJcbi8vIEFycmF5XHJcbi8vIGFycmF5KCdzdHIxLHN0cjIsc3RyMycpID0+IFsnc3RyMScsICdzdHIyJywgJ3N0cjMnXVxyXG5mdW5jdGlvbiBhcnJheShpdCl7XHJcbiAgcmV0dXJuIFN0cmluZyhpdCkuc3BsaXQoJywnKTtcclxufVxyXG52YXIgcHVzaCAgICA9IEFycmF5UHJvdG8ucHVzaFxyXG4gICwgdW5zaGlmdCA9IEFycmF5UHJvdG8udW5zaGlmdFxyXG4gICwgc2xpY2UgICA9IEFycmF5UHJvdG8uc2xpY2VcclxuICAsIHNwbGljZSAgPSBBcnJheVByb3RvLnNwbGljZVxyXG4gICwgaW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZlxyXG4gICwgZm9yRWFjaCA9IEFycmF5UHJvdG9bRk9SX0VBQ0hdO1xyXG4vKlxyXG4gKiAwIC0+IGZvckVhY2hcclxuICogMSAtPiBtYXBcclxuICogMiAtPiBmaWx0ZXJcclxuICogMyAtPiBzb21lXHJcbiAqIDQgLT4gZXZlcnlcclxuICogNSAtPiBmaW5kXHJcbiAqIDYgLT4gZmluZEluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheU1ldGhvZCh0eXBlKXtcclxuICB2YXIgaXNNYXAgICAgICAgPSB0eXBlID09IDFcclxuICAgICwgaXNGaWx0ZXIgICAgPSB0eXBlID09IDJcclxuICAgICwgaXNTb21lICAgICAgPSB0eXBlID09IDNcclxuICAgICwgaXNFdmVyeSAgICAgPSB0eXBlID09IDRcclxuICAgICwgaXNGaW5kSW5kZXggPSB0eXBlID09IDZcclxuICAgICwgbm9ob2xlcyAgICAgPSB0eXBlID09IDUgfHwgaXNGaW5kSW5kZXg7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgdGhhdCAgID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICwgc2VsZiAgID0gRVM1T2JqZWN0KE8pXHJcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gMFxyXG4gICAgICAsIHJlc3VsdCA9IGlzTWFwID8gQXJyYXkobGVuZ3RoKSA6IGlzRmlsdGVyID8gW10gOiB1bmRlZmluZWRcclxuICAgICAgLCB2YWwsIHJlcztcclxuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYobm9ob2xlcyB8fCBpbmRleCBpbiBzZWxmKXtcclxuICAgICAgdmFsID0gc2VsZltpbmRleF07XHJcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XHJcbiAgICAgIGlmKHR5cGUpe1xyXG4gICAgICAgIGlmKGlzTWFwKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgIC8vIG1hcFxyXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXHJcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxyXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxyXG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxyXG4gICAgICAgIH0gZWxzZSBpZihpc0V2ZXJ5KXJldHVybiBmYWxzZTsgICAgICAgICAgIC8vIGV2ZXJ5XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0ZpbmRJbmRleCA/IC0xIDogaXNTb21lIHx8IGlzRXZlcnkgPyBpc0V2ZXJ5IDogcmVzdWx0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUNvbnRhaW5zKGlzQ29udGFpbnMpe1xyXG4gIHJldHVybiBmdW5jdGlvbihlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGFyZ3VtZW50c1sxXSwgbGVuZ3RoKTtcclxuICAgIGlmKGlzQ29udGFpbnMgJiYgZWwgIT0gZWwpe1xyXG4gICAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKHNhbWVOYU4oT1tpbmRleF0pKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoaXNDb250YWlucyB8fCBpbmRleCBpbiBPKXtcclxuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSByZXR1cm4gIWlzQ29udGFpbnMgJiYgLTE7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbmVyaWMoQSwgQil7XHJcbiAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiB2cyBpc0Z1bmN0aW9uXHJcbiAgcmV0dXJuIHR5cGVvZiBBID09ICdmdW5jdGlvbicgPyBBIDogQjtcclxufVxyXG5cclxuLy8gTWF0aFxyXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxyXG4gICwgcG93ICAgID0gTWF0aC5wb3dcclxuICAsIGFicyAgICA9IE1hdGguYWJzXHJcbiAgLCBjZWlsICAgPSBNYXRoLmNlaWxcclxuICAsIGZsb29yICA9IE1hdGguZmxvb3JcclxuICAsIG1heCAgICA9IE1hdGgubWF4XHJcbiAgLCBtaW4gICAgPSBNYXRoLm1pblxyXG4gICwgcmFuZG9tID0gTWF0aC5yYW5kb21cclxuICAsIHRydW5jICA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xyXG4gICAgfVxyXG4vLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG5mdW5jdGlvbiBzYW1lTmFOKG51bWJlcil7XHJcbiAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XHJcbn1cclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XHJcbiAgcmV0dXJuIGlzTmFOKGl0KSA/IDAgOiB0cnVuYyhpdCk7XHJcbn1cclxuLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbmZ1bmN0aW9uIHRvTGVuZ3RoKGl0KXtcclxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIE1BWF9TQUZFX0lOVEVHRVIpIDogMDtcclxufVxyXG5mdW5jdGlvbiB0b0luZGV4KGluZGV4LCBsZW5ndGgpe1xyXG4gIHZhciBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XHJcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gbHoobnVtKXtcclxuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUmVwbGFjZXIocmVnRXhwLCByZXBsYWNlLCBpc1N0YXRpYyl7XHJcbiAgdmFyIHJlcGxhY2VyID0gaXNPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcclxuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xyXG4gIH0gOiByZXBsYWNlO1xyXG4gIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gU3RyaW5nKGlzU3RhdGljID8gaXQgOiB0aGlzKS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludEF0KHRvU3RyaW5nKXtcclxuICByZXR1cm4gZnVuY3Rpb24ocG9zKXtcclxuICAgIHZhciBzID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXHJcbiAgICAgICwgbCA9IHMubGVuZ3RoXHJcbiAgICAgICwgYSwgYjtcclxuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gdG9TdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcclxuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxyXG4gICAgICA/IHRvU3RyaW5nID8gcy5jaGFyQXQoaSkgOiBhXHJcbiAgICAgIDogdG9TdHJpbmcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBc3NlcnRpb24gJiBlcnJvcnNcclxudmFyIFJFRFVDRV9FUlJPUiA9ICdSZWR1Y2Ugb2YgZW1wdHkgb2JqZWN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZzEsIG1zZzIpe1xyXG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xyXG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihpdCl7XHJcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oaXQpLCBpdCwgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KGl0KXtcclxuICBhc3NlcnQoaXNPYmplY3QoaXQpLCBpdCwgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJbnN0YW5jZShpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xyXG4gIGFzc2VydChpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCBuYW1lLCBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XHJcbn1cclxuXHJcbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzICYgU3ltYm9sXHJcbmZ1bmN0aW9uIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSl7XHJcbiAgcmV0dXJuIHtcclxuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcclxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcclxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcclxuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSkpO1xyXG4gIH0gOiBzaW1wbGVTZXQ7XHJcbn1cclxuZnVuY3Rpb24gdWlkKGtleSl7XHJcbiAgcmV0dXJuIFNZTUJPTCArICcoJyArIGtleSArICcpXycgKyAoKytzaWQgKyByYW5kb20oKSlbVE9fU1RSSU5HXSgzNik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2VsbEtub3duU3ltYm9sKG5hbWUsIHNldHRlcil7XHJcbiAgcmV0dXJuIChTeW1ib2wgJiYgU3ltYm9sW25hbWVdKSB8fCAoc2V0dGVyID8gU3ltYm9sIDogc2FmZVN5bWJvbCkoU1lNQk9MICsgRE9UICsgbmFtZSk7XHJcbn1cclxuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXHJcbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMiB9fSkuYSA9PSAyO1xyXG4gICAgICB9IGNhdGNoKGUpe31cclxuICAgIH0oKVxyXG4gICwgc2lkICAgID0gMFxyXG4gICwgaGlkZGVuID0gY3JlYXRlRGVmaW5lcigxKVxyXG4gICwgc2V0ICAgID0gU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZGVuXHJcbiAgLCBzYWZlU3ltYm9sID0gU3ltYm9sIHx8IHVpZDtcclxuZnVuY3Rpb24gYXNzaWduSGlkZGVuKHRhcmdldCwgc3JjKXtcclxuICBmb3IodmFyIGtleSBpbiBzcmMpaGlkZGVuKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxudmFyIFNZTUJPTF9VTlNDT1BBQkxFUyA9IGdldFdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKVxyXG4gICwgQXJyYXlVbnNjb3BhYmxlcyAgID0gQXJyYXlQcm90b1tTWU1CT0xfVU5TQ09QQUJMRVNdIHx8IHt9XHJcbiAgLCBTWU1CT0xfU1BFQ0lFUyAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcclxuZnVuY3Rpb24gc2V0U3BlY2llcyhDKXtcclxuICBpZihmcmFtZXdvcmsgfHwgIWlzTmF0aXZlKEMpKWRlZmluZVByb3BlcnR5KEMsIFNZTUJPTF9TUEVDSUVTLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IHJldHVyblRoaXNcclxuICB9KTtcclxufVxyXG5cclxuLy8gSXRlcmF0b3JzXHJcbnZhciBTWU1CT0xfSVRFUkFUT1IgPSBnZXRXZWxsS25vd25TeW1ib2woSVRFUkFUT1IpXHJcbiAgLCBTWU1CT0xfVEFHICAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRylcclxuICAsIFNVUFBPUlRfRkZfSVRFUiA9IEZGX0lURVJBVE9SIGluIEFycmF5UHJvdG9cclxuICAsIElURVIgID0gc2FmZVN5bWJvbCgnaXRlcicpXHJcbiAgLCBLRVkgICA9IDFcclxuICAsIFZBTFVFID0gMlxyXG4gICwgSXRlcmF0b3JzID0ge31cclxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge31cclxuICAsIE5BVElWRV9JVEVSQVRPUlMgPSBTWU1CT0xfSVRFUkFUT1IgaW4gQXJyYXlQcm90b1xyXG4gICAgLy8gU2FmYXJpIGRlZmluZSBieWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxyXG4gICwgQlVHR1lfSVRFUkFUT1JTID0gJ2tleXMnIGluIEFycmF5UHJvdG8gJiYgISgnbmV4dCcgaW4gW10ua2V5cygpKTtcclxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcclxuc2V0SXRlcmF0b3IoSXRlcmF0b3JQcm90b3R5cGUsIHJldHVyblRoaXMpO1xyXG5mdW5jdGlvbiBzZXRJdGVyYXRvcihPLCB2YWx1ZSl7XHJcbiAgaGlkZGVuKE8sIFNZTUJPTF9JVEVSQVRPUiwgdmFsdWUpO1xyXG4gIC8vIEFkZCBpdGVyYXRvciBmb3IgRkYgaXRlcmF0b3IgcHJvdG9jb2xcclxuICBTVVBQT1JUX0ZGX0lURVIgJiYgaGlkZGVuKE8sIEZGX0lURVJBVE9SLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcclxuICBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gY3JlYXRlKHByb3RvIHx8IEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xyXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBOQU1FLCB2YWx1ZSwgREVGQVVMVCl7XHJcbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXVxyXG4gICAgLCBpdGVyICA9IGdldChwcm90bywgU1lNQk9MX0lURVJBVE9SKSB8fCBnZXQocHJvdG8sIEZGX0lURVJBVE9SKSB8fCAoREVGQVVMVCAmJiBnZXQocHJvdG8sIERFRkFVTFQpKSB8fCB2YWx1ZTtcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gRGVmaW5lIGl0ZXJhdG9yXHJcbiAgICBzZXRJdGVyYXRvcihwcm90bywgaXRlcik7XHJcbiAgICBpZihpdGVyICE9PSB2YWx1ZSl7XHJcbiAgICAgIHZhciBpdGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdGVyLmNhbGwobmV3IENvbnN0cnVjdG9yKSk7XHJcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcclxuICAgICAgc2V0VG9TdHJpbmdUYWcoaXRlclByb3RvLCBOQU1FICsgJyBJdGVyYXRvcicsIHRydWUpO1xyXG4gICAgICAvLyBGRiBmaXhcclxuICAgICAgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikgJiYgc2V0SXRlcmF0b3IoaXRlclByb3RvLCByZXR1cm5UaGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxyXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGl0ZXI7XHJcbiAgLy8gRkYgJiB2OCBmaXhcclxuICBJdGVyYXRvcnNbTkFNRSArICcgSXRlcmF0b3InXSA9IHJldHVyblRoaXM7XHJcbiAgcmV0dXJuIGl0ZXI7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lU3RkSXRlcmF0b3JzKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQpe1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXIoa2luZCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcclxuICAgIH1cclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xyXG4gIHZhciBlbnRyaWVzID0gY3JlYXRlSXRlcihLRVkrVkFMVUUpXHJcbiAgICAsIHZhbHVlcyAgPSBjcmVhdGVJdGVyKFZBTFVFKTtcclxuICBpZihERUZBVUxUID09IFZBTFVFKXZhbHVlcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIHZhbHVlcywgJ3ZhbHVlcycpO1xyXG4gIGVsc2UgZW50cmllcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIGVudHJpZXMsICdlbnRyaWVzJyk7XHJcbiAgaWYoREVGQVVMVCl7XHJcbiAgICAkZGVmaW5lKFBST1RPICsgRk9SQ0VEICogQlVHR1lfSVRFUkFUT1JTLCBOQU1FLCB7XHJcbiAgICAgIGVudHJpZXM6IGVudHJpZXMsXHJcbiAgICAgIGtleXM6IElTX1NFVCA/IHZhbHVlcyA6IGNyZWF0ZUl0ZXIoS0VZKSxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXNcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyUmVzdWx0KGRvbmUsIHZhbHVlKXtcclxuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcclxufVxyXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGl0KXtcclxuICB2YXIgTyAgICAgID0gT2JqZWN0KGl0KVxyXG4gICAgLCBTeW1ib2wgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBoYXNFeHQgPSAoU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1IpIGluIE87XHJcbiAgcmV0dXJuIGhhc0V4dCB8fCBTWU1CT0xfSVRFUkFUT1IgaW4gTyB8fCBoYXMoSXRlcmF0b3JzLCBjbGFzc29mKE8pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdCl7XHJcbiAgdmFyIFN5bWJvbCAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBleHQgICAgID0gaXRbU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1JdXHJcbiAgICAsIGdldEl0ZXIgPSBleHQgfHwgaXRbU1lNQk9MX0lURVJBVE9SXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xyXG4gIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gc3RlcENhbGwoZm4sIHZhbHVlLCBlbnRyaWVzKXtcclxuICByZXR1cm4gZW50cmllcyA/IGludm9rZShmbiwgdmFsdWUpIDogZm4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGZvck9mKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XHJcbiAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpXHJcbiAgICAsIGYgICAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXHJcbiAgICAsIHN0ZXA7XHJcbiAgd2hpbGUoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKWlmKHN0ZXBDYWxsKGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpID09PSBmYWxzZSlyZXR1cm47XHJcbn1cclxuXHJcbi8vIGNvcmVcclxudmFyIE5PREUgPSBjb2YocHJvY2VzcykgPT0gUFJPQ0VTU1xyXG4gICwgY29yZSA9IHt9XHJcbiAgLCBwYXRoID0gZnJhbWV3b3JrID8gZ2xvYmFsIDogY29yZVxyXG4gICwgb2xkICA9IGdsb2JhbC5jb3JlXHJcbiAgLCBleHBvcnRHbG9iYWxcclxuICAvLyB0eXBlIGJpdG1hcFxyXG4gICwgRk9SQ0VEID0gMVxyXG4gICwgR0xPQkFMID0gMlxyXG4gICwgU1RBVElDID0gNFxyXG4gICwgUFJPVE8gID0gOFxyXG4gICwgQklORCAgID0gMTZcclxuICAsIFdSQVAgICA9IDMyXHJcbiAgLCBTSU1QTEUgPSA2NDtcclxuZnVuY3Rpb24gJGRlZmluZSh0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcclxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgR0xPQkFMXHJcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiAodHlwZSAmIFNUQVRJQylcclxuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwgT2JqZWN0UHJvdG8pW1BST1RPVFlQRV1cclxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xyXG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG4gICAgLy8gdGhlcmUgaXMgYSBzaW1pbGFyIG5hdGl2ZVxyXG4gICAgb3duID0gISh0eXBlICYgRk9SQ0VEKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAmJiAoIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pIHx8IGlzTmF0aXZlKHRhcmdldFtrZXldKSk7XHJcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcclxuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xyXG4gICAgaWYoIWZyYW1ld29yayAmJiBpc0dsb2JhbCAmJiAhaXNGdW5jdGlvbih0YXJnZXRba2V5XSkpZXhwID0gc291cmNlW2tleV07XHJcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG4gICAgZWxzZSBpZih0eXBlICYgQklORCAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcclxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcbiAgICBlbHNlIGlmKHR5cGUgJiBXUkFQICYmICFmcmFtZXdvcmsgJiYgdGFyZ2V0W2tleV0gPT0gb3V0KXtcclxuICAgICAgZXhwID0gZnVuY3Rpb24ocGFyYW0pe1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygb3V0ID8gbmV3IG91dChwYXJhbSkgOiBvdXQocGFyYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGV4cFtQUk9UT1RZUEVdID0gb3V0W1BST1RPVFlQRV07XHJcbiAgICB9IGVsc2UgZXhwID0gdHlwZSAmIFBST1RPICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChjYWxsLCBvdXQpIDogb3V0O1xyXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxyXG4gICAgaWYoZnJhbWV3b3JrICYmIHRhcmdldCAmJiAhb3duKXtcclxuICAgICAgaWYoaXNHbG9iYWwgfHwgdHlwZSAmIFNJTVBMRSl0YXJnZXRba2V5XSA9IG91dDtcclxuICAgICAgZWxzZSBkZWxldGUgdGFyZ2V0W2tleV0gJiYgaGlkZGVuKHRhcmdldCwga2V5LCBvdXQpO1xyXG4gICAgfVxyXG4gICAgLy8gZXhwb3J0XHJcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGRlbihleHBvcnRzLCBrZXksIGV4cCk7XHJcbiAgfVxyXG59XHJcbi8vIENvbW1vbkpTIGV4cG9ydFxyXG5pZih0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKW1vZHVsZS5leHBvcnRzID0gY29yZTtcclxuLy8gUmVxdWlyZUpTIGV4cG9ydFxyXG5lbHNlIGlmKGlzRnVuY3Rpb24oZGVmaW5lKSAmJiBkZWZpbmUuYW1kKWRlZmluZShmdW5jdGlvbigpe3JldHVybiBjb3JlfSk7XHJcbi8vIEV4cG9ydCB0byBnbG9iYWwgb2JqZWN0XHJcbmVsc2UgZXhwb3J0R2xvYmFsID0gdHJ1ZTtcclxuaWYoZXhwb3J0R2xvYmFsIHx8IGZyYW1ld29yayl7XHJcbiAgY29yZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKXtcclxuICAgIGdsb2JhbC5jb3JlID0gb2xkO1xyXG4gICAgcmV0dXJuIGNvcmU7XHJcbiAgfVxyXG4gIGdsb2JhbC5jb3JlID0gY29yZTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuc3ltYm9sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcbiFmdW5jdGlvbihUQUcsIFN5bWJvbFJlZ2lzdHJ5LCBBbGxTeW1ib2xzLCBzZXR0ZXIpe1xyXG4gIC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG4gIGlmKCFpc05hdGl2ZShTeW1ib2wpKXtcclxuICAgIFN5bWJvbCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKXtcclxuICAgICAgYXNzZXJ0KCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCksIFNZTUJPTCArICcgaXMgbm90IGEgJyArIENPTlNUUlVDVE9SKTtcclxuICAgICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbilcclxuICAgICAgICAsIHN5bSA9IHNldChjcmVhdGUoU3ltYm9sW1BST1RPVFlQRV0pLCBUQUcsIHRhZyk7XHJcbiAgICAgIEFsbFN5bWJvbHNbdGFnXSA9IHN5bTtcclxuICAgICAgREVTQyAmJiBzZXR0ZXIgJiYgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIHRhZywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgIGhpZGRlbih0aGlzLCB0YWcsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc3ltO1xyXG4gICAgfVxyXG4gICAgaGlkZGVuKFN5bWJvbFtQUk9UT1RZUEVdLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzW1RBR107XHJcbiAgICB9KTtcclxuICB9XHJcbiAgJGRlZmluZShHTE9CQUwgKyBXUkFQLCB7U3ltYm9sOiBTeW1ib2x9KTtcclxuICBcclxuICB2YXIgc3ltYm9sU3RhdGljcyA9IHtcclxuICAgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxyXG4gICAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcclxuICAgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuICAgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSBTeW1ib2woa2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3JcclxuICAgIGl0ZXJhdG9yOiBTWU1CT0xfSVRFUkFUT1IsXHJcbiAgICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuICAgIGtleUZvcjogcGFydC5jYWxsKGtleU9mLCBTeW1ib2xSZWdpc3RyeSksXHJcbiAgICAvLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcclxuICAgIHNwZWNpZXM6IFNZTUJPTF9TUEVDSUVTLFxyXG4gICAgLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xyXG4gICAgdG9TdHJpbmdUYWc6IFNZTUJPTF9UQUcgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRywgdHJ1ZSksXHJcbiAgICAvLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXHJcbiAgICB1bnNjb3BhYmxlczogU1lNQk9MX1VOU0NPUEFCTEVTLFxyXG4gICAgcHVyZTogc2FmZVN5bWJvbCxcclxuICAgIHNldDogc2V0LFxyXG4gICAgdXNlU2V0dGVyOiBmdW5jdGlvbigpe3NldHRlciA9IHRydWV9LFxyXG4gICAgdXNlU2ltcGxlOiBmdW5jdGlvbigpe3NldHRlciA9IGZhbHNlfVxyXG4gIH07XHJcbiAgLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcbiAgLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxyXG4gIC8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxyXG4gIC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcbiAgLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG4gIC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcclxuICAvLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXHJcbiAgZm9yRWFjaC5jYWxsKGFycmF5KCdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BsaXQsdG9QcmltaXRpdmUnKSxcclxuICAgIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgc3ltYm9sU3RhdGljc1tpdF0gPSBnZXRXZWxsS25vd25TeW1ib2woaXQpO1xyXG4gICAgfVxyXG4gICk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwgc3ltYm9sU3RhdGljcyk7XHJcbiAgXHJcbiAgc2V0VG9TdHJpbmdUYWcoU3ltYm9sLCBTWU1CT0wpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogIWlzTmF0aXZlKFN5bWJvbCksIE9CSkVDVCwge1xyXG4gICAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuICAgIGdldE93blByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHZhciBuYW1lcyA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSksIHJlc3VsdCA9IFtdLCBrZXksIGkgPSAwO1xyXG4gICAgICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KHNhZmVTeW1ib2woJ3RhZycpLCB7fSwge30sIHRydWUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24odG1wKXtcclxuICB2YXIgb2JqZWN0U3RhdGljID0ge1xyXG4gICAgLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcclxuICAgIGFzc2lnbjogYXNzaWduLFxyXG4gICAgLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcclxuICAgIGlzOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxyXG4gIC8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrcyB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cclxuICAnX19wcm90b19fJyBpbiBPYmplY3RQcm90byAmJiBmdW5jdGlvbihidWdneSwgc2V0KXtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldCA9IGN0eChjYWxsLCBnZXRPd25EZXNjcmlwdG9yKE9iamVjdFByb3RvLCAnX19wcm90b19fJykuc2V0LCAyKTtcclxuICAgICAgc2V0KHt9LCBBcnJheVByb3RvKTtcclxuICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZSB9XHJcbiAgICBvYmplY3RTdGF0aWMuc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8sIHByb3RvKXtcclxuICAgICAgYXNzZXJ0T2JqZWN0KE8pO1xyXG4gICAgICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG8pLCBwcm90bywgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xyXG4gICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xyXG4gICAgICBlbHNlIHNldChPLCBwcm90byk7XHJcbiAgICAgIHJldHVybiBPO1xyXG4gICAgfVxyXG4gIH0oKTtcclxuICAkZGVmaW5lKFNUQVRJQywgT0JKRUNULCBvYmplY3RTdGF0aWMpO1xyXG4gIFxyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcclxuICAgIHRtcFtTWU1CT0xfVEFHXSA9IERPVDtcclxuICAgIGlmKGNvZih0bXApICE9IERPVCloaWRkZW4oT2JqZWN0UHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuICBzZXRUb1N0cmluZ1RhZyhNYXRoLCBNQVRILCB0cnVlKTtcclxuICAvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm9iamVjdC5zdGF0aWNzLWFjY2VwdC1wcmltaXRpdmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gT2JqZWN0IHN0YXRpYyBtZXRob2RzIGFjY2VwdCBwcmltaXRpdmVzXHJcbiAgZnVuY3Rpb24gd3JhcE9iamVjdE1ldGhvZChrZXksIE1PREUpe1xyXG4gICAgdmFyIGZuICA9IE9iamVjdFtrZXldXHJcbiAgICAgICwgZXhwID0gY29yZVtPQkpFQ1RdW2tleV1cclxuICAgICAgLCBmICAgPSAwXHJcbiAgICAgICwgbyAgID0ge307XHJcbiAgICBpZighZXhwIHx8IGlzTmF0aXZlKGV4cCkpe1xyXG4gICAgICBvW2tleV0gPSBNT0RFID09IDEgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGl0O1xyXG4gICAgICB9IDogTU9ERSA9PSAyID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiB0cnVlO1xyXG4gICAgICB9IDogTU9ERSA9PSAzID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBmYWxzZTtcclxuICAgICAgfSA6IE1PREUgPT0gNCA/IGZ1bmN0aW9uKGl0LCBrZXkpe1xyXG4gICAgICAgIHJldHVybiBmbih0b09iamVjdChpdCksIGtleSk7XHJcbiAgICAgIH0gOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRyeSB7IGZuKERPVCkgfVxyXG4gICAgICBjYXRjaChlKXsgZiA9IDEgfVxyXG4gICAgICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCAqIGYsIE9CSkVDVCwgbyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2ZyZWV6ZScsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ3NlYWwnLCAxKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdwcmV2ZW50RXh0ZW5zaW9ucycsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzRnJvemVuJywgMik7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNTZWFsZWQnLCAyKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc0V4dGVuc2libGUnLCAzKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCA0KTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRQcm90b3R5cGVPZicpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2tleXMnKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJyk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmZ1bmN0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKE5BTUUpe1xyXG4gIC8vIDE5LjIuNC4yIG5hbWVcclxuICBOQU1FIGluIEZ1bmN0aW9uUHJvdG8gfHwgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90bywgTkFNRSwge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgbWF0Y2ggPSBTdHJpbmcodGhpcykubWF0Y2goL15cXHMqZnVuY3Rpb24gKFteIChdKikvKVxyXG4gICAgICAgICwgbmFtZSAgPSBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbiAgICAgIGhhcyh0aGlzLCBOQU1FKSB8fCBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBOQU1FLCBkZXNjcmlwdG9yKDUsIG5hbWUpKTtcclxuICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIGhhcyh0aGlzLCBOQU1FKSB8fCBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBOQU1FLCBkZXNjcmlwdG9yKDAsIHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0oJ25hbWUnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm51bWJlci5jb25zdHJ1Y3RvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuTnVtYmVyKCcwbzEnKSAmJiBOdW1iZXIoJzBiMScpIHx8IGZ1bmN0aW9uKF9OdW1iZXIsIE51bWJlclByb3RvKXtcclxuICBmdW5jdGlvbiB0b051bWJlcihpdCl7XHJcbiAgICBpZihpc09iamVjdChpdCkpaXQgPSB0b1ByaW1pdGl2ZShpdCk7XHJcbiAgICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMiAmJiBpdC5jaGFyQ29kZUF0KDApID09IDQ4KXtcclxuICAgICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xyXG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XHJcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogYmluYXJ5ID0gdHJ1ZTtcclxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcclxuICAgICAgfVxyXG4gICAgfSByZXR1cm4gK2l0O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0b1ByaW1pdGl2ZShpdCl7XHJcbiAgICB2YXIgZm4sIHZhbDtcclxuICAgIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XHJcbiAgICBpZihpc0Z1bmN0aW9uKGZuID0gaXRbVE9fU1RSSU5HXSkgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xyXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gbnVtYmVyXCIpO1xyXG4gIH1cclxuICBOdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIoaXQpe1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIgPyBuZXcgX051bWJlcih0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xyXG4gIH1cclxuICBmb3JFYWNoLmNhbGwoREVTQyA/IGdldE5hbWVzKF9OdW1iZXIpXHJcbiAgOiBhcnJheSgnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFknKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgIGtleSBpbiBOdW1iZXIgfHwgZGVmaW5lUHJvcGVydHkoTnVtYmVyLCBrZXksIGdldE93bkRlc2NyaXB0b3IoX051bWJlciwga2V5KSk7XHJcbiAgfSk7XHJcbiAgTnVtYmVyW1BST1RPVFlQRV0gPSBOdW1iZXJQcm90bztcclxuICBOdW1iZXJQcm90b1tDT05TVFJVQ1RPUl0gPSBOdW1iZXI7XHJcbiAgaGlkZGVuKGdsb2JhbCwgTlVNQkVSLCBOdW1iZXIpO1xyXG59KE51bWJlciwgTnVtYmVyW1BST1RPVFlQRV0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYubnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oaXNJbnRlZ2VyKXtcclxuICAkZGVmaW5lKFNUQVRJQywgTlVNQkVSLCB7XHJcbiAgICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxyXG4gICAgRVBTSUxPTjogcG93KDIsIC01MiksXHJcbiAgICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxyXG4gICAgaXNGaW5pdGU6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShpdCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXHJcbiAgICBpc0ludGVnZXI6IGlzSW50ZWdlcixcclxuICAgIC8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXHJcbiAgICBpc05hTjogc2FtZU5hTixcclxuICAgIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcclxuICAgIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxyXG4gICAgLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXHJcbiAgICBNSU5fU0FGRV9JTlRFR0VSOiAtTUFYX1NBRkVfSU5URUdFUixcclxuICAgIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXHJcbiAgICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0LFxyXG4gICAgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxyXG4gICAgcGFyc2VJbnQ6IHBhcnNlSW50XHJcbiAgfSk7XHJcbi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxyXG59KE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm1hdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IHNoaW1cclxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxyXG4gIHZhciBFICAgID0gTWF0aC5FXHJcbiAgICAsIGV4cCAgPSBNYXRoLmV4cFxyXG4gICAgLCBsb2cgID0gTWF0aC5sb2dcclxuICAgICwgc3FydCA9IE1hdGguc3FydFxyXG4gICAgLCBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcclxuICAgICAgfTtcclxuICBcclxuICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXHJcbiAgZnVuY3Rpb24gYXNpbmgoeCl7XHJcbiAgICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcclxuICB9XHJcbiAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcclxuICBmdW5jdGlvbiBleHBtMSh4KXtcclxuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBleHAoeCkgLSAxO1xyXG4gIH1cclxuICAgIFxyXG4gICRkZWZpbmUoU1RBVElDLCBNQVRILCB7XHJcbiAgICAvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXHJcbiAgICBhY29zaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiBpc0Zpbml0ZSh4KSA/IGxvZyh4IC8gRSArIHNxcnQoeCArIDEpICogc3FydCh4IC0gMSkgLyBFKSArIDEgOiB4O1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcclxuICAgIGFzaW5oOiBhc2luaCxcclxuICAgIC8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcclxuICAgIGF0YW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXHJcbiAgICBjYnJ0OiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxyXG4gICAgY2x6MzI6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMyIC0geFtUT19TVFJJTkddKDIpLmxlbmd0aCA6IDMyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcclxuICAgIGNvc2g6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXHJcbiAgICBleHBtMTogZXhwbTEsXHJcbiAgICAvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcclxuICAgIC8vIFRPRE86IGZhbGxiYWNrIGZvciBJRTktXHJcbiAgICBmcm91bmQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbeF0pWzBdO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxyXG4gICAgaHlwb3Q6IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKXtcclxuICAgICAgdmFyIHN1bSAgPSAwXHJcbiAgICAgICAgLCBsZW4xID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgbGVuMiA9IGxlbjFcclxuICAgICAgICAsIGFyZ3MgPSBBcnJheShsZW4xKVxyXG4gICAgICAgICwgbGFyZyA9IC1JbmZpbml0eVxyXG4gICAgICAgICwgYXJnO1xyXG4gICAgICB3aGlsZShsZW4xLS0pe1xyXG4gICAgICAgIGFyZyA9IGFyZ3NbbGVuMV0gPSArYXJndW1lbnRzW2xlbjFdO1xyXG4gICAgICAgIGlmKGFyZyA9PSBJbmZpbml0eSB8fCBhcmcgPT0gLUluZmluaXR5KXJldHVybiBJbmZpbml0eTtcclxuICAgICAgICBpZihhcmcgPiBsYXJnKWxhcmcgPSBhcmc7XHJcbiAgICAgIH1cclxuICAgICAgbGFyZyA9IGFyZyB8fCAxO1xyXG4gICAgICB3aGlsZShsZW4yLS0pc3VtICs9IHBvdyhhcmdzW2xlbjJdIC8gbGFyZywgMik7XHJcbiAgICAgIHJldHVybiBsYXJnICogc3FydChzdW0pO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcclxuICAgIGltdWw6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICB2YXIgVUludDE2ID0gMHhmZmZmXHJcbiAgICAgICAgLCB4biA9ICt4XHJcbiAgICAgICAgLCB5biA9ICt5XHJcbiAgICAgICAgLCB4bCA9IFVJbnQxNiAmIHhuXHJcbiAgICAgICAgLCB5bCA9IFVJbnQxNiAmIHluO1xyXG4gICAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJbnQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJbnQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXHJcbiAgICBsb2cxcDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IGxvZygxICsgeCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcclxuICAgIGxvZzEwOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4xMDtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXHJcbiAgICBsb2cyOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4yO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcclxuICAgIHNpZ246IHNpZ24sXHJcbiAgICAvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXHJcbiAgICBzaW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIChhYnMoeCA9ICt4KSA8IDEpID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChFIC8gMik7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxyXG4gICAgdGFuaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxyXG4gICAgICAgICwgYiA9IGV4cG0xKC14KTtcclxuICAgICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxyXG4gICAgdHJ1bmM6IHRydW5jXHJcbiAgfSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGZyb21DaGFyQ29kZSl7XHJcbiAgZnVuY3Rpb24gYXNzZXJ0Tm90UmVnRXhwKGl0KXtcclxuICAgIGlmKGNvZihpdCkgPT0gUkVHRVhQKXRocm93IFR5cGVFcnJvcigpO1xyXG4gIH1cclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxyXG4gICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciByZXMgPSBbXVxyXG4gICAgICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgaSAgID0gMFxyXG4gICAgICAgICwgY29kZVxyXG4gICAgICB3aGlsZShsZW4gPiBpKXtcclxuICAgICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xyXG4gICAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xyXG4gICAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXHJcbiAgICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxyXG4gICAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxyXG4gICAgcmF3OiBmdW5jdGlvbihjYWxsU2l0ZSl7XHJcbiAgICAgIHZhciByYXcgPSB0b09iamVjdChjYWxsU2l0ZS5yYXcpXHJcbiAgICAgICAgLCBsZW4gPSB0b0xlbmd0aChyYXcubGVuZ3RoKVxyXG4gICAgICAgICwgc2xuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgcmVzID0gW11cclxuICAgICAgICAsIGkgICA9IDA7XHJcbiAgICAgIHdoaWxlKGxlbiA+IGkpe1xyXG4gICAgICAgIHJlcy5wdXNoKFN0cmluZyhyYXdbaSsrXSkpO1xyXG4gICAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICB9IHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGRlZmluZShQUk9UTywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcclxuICAgIGNvZGVQb2ludEF0OiBjcmVhdGVQb2ludEF0KGZhbHNlKSxcclxuICAgIC8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcclxuICAgIGVuZHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxyXG4gICAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IG1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XHJcbiAgICAgIHNlYXJjaFN0cmluZyArPSAnJztcclxuICAgICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXHJcbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgcmV0dXJuICEhflN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXHJcbiAgICByZXBlYXQ6IGZ1bmN0aW9uKGNvdW50KXtcclxuICAgICAgdmFyIHN0ciA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgcmVzID0gJydcclxuICAgICAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XHJcbiAgICAgIGlmKDAgPiBuIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xyXG4gICAgICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXHJcbiAgICBzdGFydHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCAgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGluZGV4ID0gdG9MZW5ndGgobWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcclxuICAgICAgc2VhcmNoU3RyaW5nICs9ICcnO1xyXG4gICAgICByZXR1cm4gdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KFN0cmluZy5mcm9tQ2hhckNvZGUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuYXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZyb206IGZ1bmN0aW9uKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcclxuICAgICAgdmFyIE8gICAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZChhcnJheUxpa2UpKVxyXG4gICAgICAgICwgbWFwZm4gICA9IGFyZ3VtZW50c1sxXVxyXG4gICAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcclxuICAgICAgICAsIGYgICAgICAgPSBtYXBwaW5nID8gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgLCBpbmRleCAgID0gMFxyXG4gICAgICAgICwgbGVuZ3RoLCByZXN1bHQsIGl0ZXIsIHN0ZXA7XHJcbiAgICAgIGlmKGlzSXRlcmFibGUoTykpZm9yKGl0ZXIgPSBnZXRJdGVyYXRvcihPKSwgcmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSk7ICEoc3RlcCA9IGl0ZXIubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcclxuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGYoc3RlcC52YWx1ZSwgaW5kZXgpIDogc3RlcC52YWx1ZTtcclxuICAgICAgfSBlbHNlIGZvcihyZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKShsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCkpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBmKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcclxuICAgICAgfVxyXG4gICAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxyXG4gICAgb2Y6IGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgICB2YXIgaW5kZXggID0gMFxyXG4gICAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgcmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSkobGVuZ3RoKTtcclxuICAgICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAkZGVmaW5lKFBST1RPLCBBUlJBWSwge1xyXG4gICAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXHJcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xyXG4gICAgICB2YXIgTyAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXHJcbiAgICAgICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcclxuICAgICAgICAsIGVuZCAgID0gYXJndW1lbnRzWzJdXHJcbiAgICAgICAgLCBmaW4gICA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbilcclxuICAgICAgICAsIGNvdW50ID0gbWluKGZpbiAtIGZyb20sIGxlbiAtIHRvKVxyXG4gICAgICAgICwgaW5jICAgPSAxO1xyXG4gICAgICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xyXG4gICAgICAgIGluYyAgPSAtMTtcclxuICAgICAgICBmcm9tID0gZnJvbSArIGNvdW50IC0gMTtcclxuICAgICAgICB0byAgID0gdG8gKyBjb3VudCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUoY291bnQtLSA+IDApe1xyXG4gICAgICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XHJcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XHJcbiAgICAgICAgdG8gKz0gaW5jO1xyXG4gICAgICAgIGZyb20gKz0gaW5jO1xyXG4gICAgICB9IHJldHVybiBPO1xyXG4gICAgfSxcclxuICAgIC8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxyXG4gICAgZmlsbDogZnVuY3Rpb24odmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIHZhciBPICAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aClcclxuICAgICAgICAsIGVuZCAgICA9IGFyZ3VtZW50c1syXVxyXG4gICAgICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcclxuICAgICAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gTztcclxuICAgIH0sXHJcbiAgICAvLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmaW5kOiBjcmVhdGVBcnJheU1ldGhvZCg1KSxcclxuICAgIC8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZmluZEluZGV4OiBjcmVhdGVBcnJheU1ldGhvZCg2KVxyXG4gIH0pO1xyXG4gIFxyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXHJcbiAgICBmb3JFYWNoLmNhbGwoYXJyYXkoJ2ZpbmQsZmluZEluZGV4LGZpbGwsY29weVdpdGhpbixlbnRyaWVzLGtleXMsdmFsdWVzJyksIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgQXJyYXlVbnNjb3BhYmxlc1tpdF0gPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBTWU1CT0xfVU5TQ09QQUJMRVMgaW4gQXJyYXlQcm90byB8fCBoaWRkZW4oQXJyYXlQcm90bywgU1lNQk9MX1VOU0NPUEFCTEVTLCBBcnJheVVuc2NvcGFibGVzKTtcclxuICB9ICBcclxuICBcclxuICBzZXRTcGVjaWVzKEFycmF5KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuaXRlcmF0b3JzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oYXQpe1xyXG4gIC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcclxuICAvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxyXG4gIC8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcclxuICAvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcclxuICBkZWZpbmVTdGRJdGVyYXRvcnMoQXJyYXksIEFSUkFZLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IHRvT2JqZWN0KGl0ZXJhdGVkKSwgaTogMCwgazoga2luZH0pO1xyXG4gIC8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxyXG4gIH0sIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgTyAgICAgPSBpdGVyLm9cclxuICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAsIGluZGV4ID0gaXRlci5pKys7XHJcbiAgICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XHJcbiAgICAgIGl0ZXIubyA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICB9XHJcbiAgICBpZihraW5kID09IEtFWSkgIHJldHVybiBpdGVyUmVzdWx0KDAsIGluZGV4KTtcclxuICAgIGlmKGtpbmQgPT0gVkFMVUUpcmV0dXJuIGl0ZXJSZXN1bHQoMCwgT1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XHJcbiAgfSwgVkFMVUUpO1xyXG4gIFxyXG4gIC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcclxuICBJdGVyYXRvcnNbQVJHVU1FTlRTXSA9IEl0ZXJhdG9yc1tBUlJBWV07XHJcbiAgXHJcbiAgLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxyXG4gIGRlZmluZVN0ZEl0ZXJhdG9ycyhTdHJpbmcsIFNUUklORywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBTdHJpbmcoaXRlcmF0ZWQpLCBpOiAwfSk7XHJcbiAgLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxyXG4gIH0sIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICwgTyAgICAgPSBpdGVyLm9cclxuICAgICAgLCBpbmRleCA9IGl0ZXIuaVxyXG4gICAgICAsIHBvaW50O1xyXG4gICAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICBwb2ludCA9IGF0LmNhbGwoTywgaW5kZXgpO1xyXG4gICAgaXRlci5pICs9IHBvaW50Lmxlbmd0aDtcclxuICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIHBvaW50KTtcclxuICB9KTtcclxufShjcmVhdGVQb2ludEF0KHRydWUpKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnJlZ2V4cCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKFJlZ0V4cFByb3RvLCBfUmVnRXhwKXtcclxuICBmdW5jdGlvbiBhc3NlcnRSZWdFeHBXcmFwcGVyKGZuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICBhc3NlcnQoY29mKHRoaXMpID09PSBSRUdFWFApO1xyXG4gICAgICByZXR1cm4gZm4odGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFJlZ0V4cCBhbGxvd3MgYSByZWdleCB3aXRoIGZsYWdzIGFzIHRoZSBwYXR0ZXJuXHJcbiAgaWYoREVTQyAmJiAhZnVuY3Rpb24oKXt0cnl7cmV0dXJuIFJlZ0V4cCgvYS9nLCAnaScpID09ICcvYS9pJ31jYXRjaChlKXt9fSgpKXtcclxuICAgIFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyl7XHJcbiAgICAgIHJldHVybiBuZXcgX1JlZ0V4cChjb2YocGF0dGVybikgPT0gUkVHRVhQICYmIGZsYWdzICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaC5jYWxsKGdldE5hbWVzKF9SZWdFeHApLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBrZXkgaW4gUmVnRXhwIHx8IGRlZmluZVByb3BlcnR5KFJlZ0V4cCwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIF9SZWdFeHBba2V5XSB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBfUmVnRXhwW2tleV0gPSBpdCB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBSZWdFeHBQcm90b1tDT05TVFJVQ1RPUl0gPSBSZWdFeHA7XHJcbiAgICBSZWdFeHBbUFJPVE9UWVBFXSA9IFJlZ0V4cFByb3RvO1xyXG4gICAgaGlkZGVuKGdsb2JhbCwgUkVHRVhQLCBSZWdFeHApO1xyXG4gIH1cclxuICBcclxuICAvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXHJcbiAgaWYoLy4vZy5mbGFncyAhPSAnZycpZGVmaW5lUHJvcGVydHkoUmVnRXhwUHJvdG8sICdmbGFncycsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogYXNzZXJ0UmVnRXhwV3JhcHBlcihjcmVhdGVSZXBsYWNlcigvXi4qXFwvKFxcdyopJC8sICckMScsIHRydWUpKVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIDIxLjIuNS4xMiBnZXQgUmVnRXhwLnByb3RvdHlwZS5zdGlja3koKVxyXG4gIC8vIDIxLjIuNS4xNSBnZXQgUmVnRXhwLnByb3RvdHlwZS51bmljb2RlKClcclxuICBmb3JFYWNoLmNhbGwoYXJyYXkoJ3N0aWNreSx1bmljb2RlJyksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICBrZXkgaW4gLy4vIHx8IGRlZmluZVByb3BlcnR5KFJlZ0V4cFByb3RvLCBrZXksIERFU0MgPyB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgZ2V0OiBhc3NlcnRSZWdFeHBXcmFwcGVyKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KVxyXG4gICAgfSA6IGRlc2NyaXB0b3IoNSwgZmFsc2UpKTtcclxuICB9KTtcclxuICBcclxuICBzZXRTcGVjaWVzKFJlZ0V4cCk7XHJcbn0oUmVnRXhwW1BST1RPVFlQRV0sIFJlZ0V4cCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IHdlYi5pbW1lZGlhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIHNldEltbWVkaWF0ZSBzaGltXHJcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIGVsc2U6XHJcbmlzRnVuY3Rpb24oc2V0SW1tZWRpYXRlKSAmJiBpc0Z1bmN0aW9uKGNsZWFySW1tZWRpYXRlKSB8fCBmdW5jdGlvbihPTlJFQURZU1RBVEVDSEFOR0Upe1xyXG4gIHZhciBwb3N0TWVzc2FnZSAgICAgID0gZ2xvYmFsLnBvc3RNZXNzYWdlXHJcbiAgICAsIGFkZEV2ZW50TGlzdGVuZXIgPSBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgLCBNZXNzYWdlQ2hhbm5lbCAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXHJcbiAgICAsIGNvdW50ZXIgICAgICAgICAgPSAwXHJcbiAgICAsIHF1ZXVlICAgICAgICAgICAgPSB7fVxyXG4gICAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcclxuICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmbil7XHJcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcclxuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcclxuICAgICAgaW52b2tlKGlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVmZXIoY291bnRlcik7XHJcbiAgICByZXR1cm4gY291bnRlcjtcclxuICB9XHJcbiAgY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbihpZCl7XHJcbiAgICBkZWxldGUgcXVldWVbaWRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBydW4oaWQpe1xyXG4gICAgaWYoaGFzKHF1ZXVlLCBpZCkpe1xyXG4gICAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XHJcbiAgICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGxpc3RuZXIoZXZlbnQpe1xyXG4gICAgcnVuKGV2ZW50LmRhdGEpO1xyXG4gIH1cclxuICAvLyBOb2RlLmpzIDAuOC1cclxuICBpZihOT0RFKXtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBuZXh0VGljayhwYXJ0LmNhbGwocnVuLCBpZCkpO1xyXG4gICAgfVxyXG4gIC8vIE1vZGVybiBicm93c2Vycywgc2tpcCBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViV29ya2Vyc1xyXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzIG9iamVjdFxyXG4gIH0gZWxzZSBpZihhZGRFdmVudExpc3RlbmVyICYmIGlzRnVuY3Rpb24ocG9zdE1lc3NhZ2UpICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgcG9zdE1lc3NhZ2UoaWQsICcqJyk7XHJcbiAgICB9XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xyXG4gIC8vIFdlYldvcmtlcnNcclxuICB9IGVsc2UgaWYoaXNGdW5jdGlvbihNZXNzYWdlQ2hhbm5lbCkpe1xyXG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcclxuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xyXG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xyXG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XHJcbiAgLy8gSUU4LVxyXG4gIH0gZWxzZSBpZihkb2N1bWVudCAmJiBPTlJFQURZU1RBVEVDSEFOR0UgaW4gZG9jdW1lbnRbQ1JFQVRFX0VMRU1FTlRdKCdzY3JpcHQnKSl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChkb2N1bWVudFtDUkVBVEVfRUxFTUVOVF0oJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIHJ1bihpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgc2V0VGltZW91dChydW4sIDAsIGlkKTtcclxuICAgIH1cclxuICB9XHJcbn0oJ29ucmVhZHlzdGF0ZWNoYW5nZScpO1xyXG4kZGVmaW5lKEdMT0JBTCArIEJJTkQsIHtcclxuICBzZXRJbW1lZGlhdGU6ICAgc2V0SW1tZWRpYXRlLFxyXG4gIGNsZWFySW1tZWRpYXRlOiBjbGVhckltbWVkaWF0ZVxyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnByb21pc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRVM2IHByb21pc2VzIHNoaW1cclxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9uYXRpdmUtcHJvbWlzZS1vbmx5L1xyXG4hZnVuY3Rpb24oUHJvbWlzZSwgdGVzdCl7XHJcbiAgaXNGdW5jdGlvbihQcm9taXNlKSAmJiBpc0Z1bmN0aW9uKFByb21pc2UucmVzb2x2ZSlcclxuICAmJiBQcm9taXNlLnJlc29sdmUodGVzdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCl7fSkpID09IHRlc3RcclxuICB8fCBmdW5jdGlvbihhc2FwLCBERUYpe1xyXG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZShvKXtcclxuICAgICAgdmFyIHRoZW47XHJcbiAgICAgIGlmKGlzT2JqZWN0KG8pKXRoZW4gPSBvLnRoZW47XHJcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoZW4pID8gdGhlbiA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm90aWZ5KGRlZil7XHJcbiAgICAgIHZhciBjaGFpbiA9IGRlZi5jaGFpbjtcclxuICAgICAgY2hhaW4ubGVuZ3RoICYmIGFzYXAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbXNnID0gZGVmLm1zZ1xyXG4gICAgICAgICAgLCBvayAgPSBkZWYuc3RhdGUgPT0gMVxyXG4gICAgICAgICAgLCBpICAgPSAwO1xyXG4gICAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpIWZ1bmN0aW9uKHJlYWN0KXtcclxuICAgICAgICAgIHZhciBjYiA9IG9rID8gcmVhY3Qub2sgOiByZWFjdC5mYWlsXHJcbiAgICAgICAgICAgICwgcmV0LCB0aGVuO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoY2Ipe1xyXG4gICAgICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gbXNnIDogY2IobXNnKTtcclxuICAgICAgICAgICAgICBpZihyZXQgPT09IHJlYWN0LlApe1xyXG4gICAgICAgICAgICAgICAgcmVhY3QucmVqKFR5cGVFcnJvcihQUk9NSVNFICsgJy1jaGFpbiBjeWNsZScpKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmV0KSl7XHJcbiAgICAgICAgICAgICAgICB0aGVuLmNhbGwocmV0LCByZWFjdC5yZXMsIHJlYWN0LnJlaik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHJlYWN0LnJlcyhyZXQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmVhY3QucmVqKG1zZyk7XHJcbiAgICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIHJlYWN0LnJlaihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0oY2hhaW5baSsrXSk7XHJcbiAgICAgICAgY2hhaW4ubGVuZ3RoID0gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKG1zZyl7XHJcbiAgICAgIHZhciBkZWYgPSB0aGlzXHJcbiAgICAgICAgLCB0aGVuLCB3cmFwcGVyO1xyXG4gICAgICBpZihkZWYuZG9uZSlyZXR1cm47XHJcbiAgICAgIGRlZi5kb25lID0gdHJ1ZTtcclxuICAgICAgZGVmID0gZGVmLmRlZiB8fCBkZWY7IC8vIHVud3JhcFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKG1zZykpe1xyXG4gICAgICAgICAgd3JhcHBlciA9IHtkZWY6IGRlZiwgZG9uZTogZmFsc2V9OyAvLyB3cmFwXHJcbiAgICAgICAgICB0aGVuLmNhbGwobXNnLCBjdHgocmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eChyZWplY3QsIHdyYXBwZXIsIDEpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGVmLm1zZyA9IG1zZztcclxuICAgICAgICAgIGRlZi5zdGF0ZSA9IDE7XHJcbiAgICAgICAgICBub3RpZnkoZGVmKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICByZWplY3QuY2FsbCh3cmFwcGVyIHx8IHtkZWY6IGRlZiwgZG9uZTogZmFsc2V9LCBlcnIpOyAvLyB3cmFwXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdChtc2cpe1xyXG4gICAgICB2YXIgZGVmID0gdGhpcztcclxuICAgICAgaWYoZGVmLmRvbmUpcmV0dXJuO1xyXG4gICAgICBkZWYuZG9uZSA9IHRydWU7XHJcbiAgICAgIGRlZiA9IGRlZi5kZWYgfHwgZGVmOyAvLyB1bndyYXBcclxuICAgICAgZGVmLm1zZyA9IG1zZztcclxuICAgICAgZGVmLnN0YXRlID0gMjtcclxuICAgICAgbm90aWZ5KGRlZik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihDKXtcclxuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoQylbU1lNQk9MX1NQRUNJRVNdO1xyXG4gICAgICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcclxuICAgIH1cclxuICAgIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXHJcbiAgICBQcm9taXNlID0gZnVuY3Rpb24oZXhlY3V0b3Ipe1xyXG4gICAgICBhc3NlcnRGdW5jdGlvbihleGVjdXRvcik7XHJcbiAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIFByb21pc2UsIFBST01JU0UpO1xyXG4gICAgICB2YXIgZGVmID0ge2NoYWluOiBbXSwgc3RhdGU6IDAsIGRvbmU6IGZhbHNlLCBtc2c6IHVuZGVmaW5lZH07XHJcbiAgICAgIGhpZGRlbih0aGlzLCBERUYsIGRlZik7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY3V0b3IoY3R4KHJlc29sdmUsIGRlZiwgMSksIGN0eChyZWplY3QsIGRlZiwgMSkpO1xyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwoZGVmLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NpZ25IaWRkZW4oUHJvbWlzZVtQUk9UT1RZUEVdLCB7XHJcbiAgICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcclxuICAgICAgICB2YXIgUyA9IGFzc2VydE9iamVjdChhc3NlcnRPYmplY3QodGhpcylbQ09OU1RSVUNUT1JdKVtTWU1CT0xfU1BFQ0lFU107XHJcbiAgICAgICAgdmFyIHJlYWN0ID0ge1xyXG4gICAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXHJcbiAgICAgICAgICBmYWlsOiBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcclxuICAgICAgICB9ICwgUCA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXNvbHZlKTtcclxuICAgICAgICAgIHJlYWN0LnJlaiA9IGFzc2VydEZ1bmN0aW9uKHJlamVjdCk7XHJcbiAgICAgICAgfSksIGRlZiA9IHRoaXNbREVGXTtcclxuICAgICAgICBkZWYuY2hhaW4ucHVzaChyZWFjdCk7XHJcbiAgICAgICAgZGVmLnN0YXRlICYmIG5vdGlmeShkZWYpO1xyXG4gICAgICAgIHJldHVybiBQO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxyXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgYXNzaWduSGlkZGVuKFByb21pc2UsIHtcclxuICAgICAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXHJcbiAgICAgIGFsbDogZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgIHZhciBQcm9taXNlID0gZ2V0Q29uc3RydWN0b3IodGhpcylcclxuICAgICAgICAgICwgdmFsdWVzICA9IFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBwdXNoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xyXG4gICAgICAgICAgaWYocmVtYWluaW5nKWZvckVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXHJcbiAgICAgIHJhY2U6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICB2YXIgUHJvbWlzZSA9IGdldENvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxyXG4gICAgICByZWplY3Q6IGZ1bmN0aW9uKHIpe1xyXG4gICAgICAgIHJldHVybiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgcmVqZWN0KHIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcclxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24oeCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIERFRiBpbiB4ICYmIGdldFByb3RvdHlwZU9mKHgpID09PSB0aGlzW1BST1RPVFlQRV1cclxuICAgICAgICAgID8geCA6IG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICAgIHJlc29sdmUoeCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfShuZXh0VGljayB8fCBzZXRJbW1lZGlhdGUsIHNhZmVTeW1ib2woJ2RlZicpKTtcclxuICBzZXRUb1N0cmluZ1RhZyhQcm9taXNlLCBQUk9NSVNFKTtcclxuICBzZXRTcGVjaWVzKFByb21pc2UpO1xyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VEICogIWlzTmF0aXZlKFByb21pc2UpLCB7UHJvbWlzZTogUHJvbWlzZX0pO1xyXG59KGdsb2JhbFtQUk9NSVNFXSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5jb2xsZWN0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVDTUFTY3JpcHQgNiBjb2xsZWN0aW9ucyBzaGltXHJcbiFmdW5jdGlvbigpe1xyXG4gIHZhciBVSUQgICA9IHNhZmVTeW1ib2woJ3VpZCcpXHJcbiAgICAsIE8xICAgID0gc2FmZVN5bWJvbCgnTzEnKVxyXG4gICAgLCBXRUFLICA9IHNhZmVTeW1ib2woJ3dlYWsnKVxyXG4gICAgLCBMRUFLICA9IHNhZmVTeW1ib2woJ2xlYWsnKVxyXG4gICAgLCBMQVNUICA9IHNhZmVTeW1ib2woJ2xhc3QnKVxyXG4gICAgLCBGSVJTVCA9IHNhZmVTeW1ib2woJ2ZpcnN0JylcclxuICAgICwgU0laRSAgPSBERVNDID8gc2FmZVN5bWJvbCgnc2l6ZScpIDogJ3NpemUnXHJcbiAgICAsIHVpZCAgID0gMFxyXG4gICAgLCB0bXAgICA9IHt9O1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldENvbGxlY3Rpb24oQywgTkFNRSwgbWV0aG9kcywgY29tbW9uTWV0aG9kcywgaXNNYXAsIGlzV2Vhayl7XHJcbiAgICB2YXIgQURERVIgPSBpc01hcCA/ICdzZXQnIDogJ2FkZCdcclxuICAgICAgLCBwcm90byA9IEMgJiYgQ1tQUk9UT1RZUEVdXHJcbiAgICAgICwgTyAgICAgPSB7fTtcclxuICAgIGZ1bmN0aW9uIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpe1xyXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIGlzTWFwLCB0aGF0W0FEREVSXSwgdGhhdCk7XHJcbiAgICAgIHJldHVybiB0aGF0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZml4U1ZaKGtleSwgY2hhaW4pe1xyXG4gICAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcclxuICAgICAgaWYoZnJhbWV3b3JrKXByb3RvW2tleV0gPSBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTtcclxuICAgICAgICByZXR1cm4gY2hhaW4gPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYoIWlzTmF0aXZlKEMpIHx8ICEoaXNXZWFrIHx8ICghQlVHR1lfSVRFUkFUT1JTICYmIGhhcyhwcm90bywgRk9SX0VBQ0gpICYmIGhhcyhwcm90bywgJ2VudHJpZXMnKSkpKXtcclxuICAgICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcclxuICAgICAgQyA9IGlzV2Vha1xyXG4gICAgICAgID8gZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoaXMsIFVJRCwgdWlkKyspO1xyXG4gICAgICAgICAgICBpbml0RnJvbUl0ZXJhYmxlKHRoaXMsIGl0ZXJhYmxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICA6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGF0LCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIE8xLCBjcmVhdGUobnVsbCkpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgU0laRSwgMCk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBMQVNULCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgRklSU1QsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgYXNzaWduSGlkZGVuKGFzc2lnbkhpZGRlbihDW1BST1RPVFlQRV0sIG1ldGhvZHMpLCBjb21tb25NZXRob2RzKTtcclxuICAgICAgaXNXZWFrIHx8IGRlZmluZVByb3BlcnR5KENbUFJPVE9UWVBFXSwgJ3NpemUnLCB7Z2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBhc3NlcnREZWZpbmVkKHRoaXNbU0laRV0pO1xyXG4gICAgICB9fSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgTmF0aXZlID0gQ1xyXG4gICAgICAgICwgaW5zdCAgID0gbmV3IENcclxuICAgICAgICAsIGNoYWluICA9IGluc3RbQURERVJdKGlzV2VhayA/IHt9IDogLTAsIDEpXHJcbiAgICAgICAgLCBidWdneVplcm87XHJcbiAgICAgIC8vIHdyYXAgdG8gaW5pdCBjb2xsZWN0aW9ucyBmcm9tIGl0ZXJhYmxlXHJcbiAgICAgIGlmKCFOQVRJVkVfSVRFUkFUT1JTIHx8ICFDLmxlbmd0aCl7XHJcbiAgICAgICAgQyA9IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgcmV0dXJuIGluaXRGcm9tSXRlcmFibGUobmV3IE5hdGl2ZSwgaXRlcmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDW1BST1RPVFlQRV0gPSBwcm90bztcclxuICAgICAgICBpZihmcmFtZXdvcmspcHJvdG9bQ09OU1RSVUNUT1JdID0gQztcclxuICAgICAgfVxyXG4gICAgICBpc1dlYWsgfHwgaW5zdFtGT1JfRUFDSF0oZnVuY3Rpb24odmFsLCBrZXkpe1xyXG4gICAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxyXG4gICAgICBpZihidWdneVplcm8pe1xyXG4gICAgICAgIGZpeFNWWignZGVsZXRlJyk7XHJcbiAgICAgICAgZml4U1ZaKCdoYXMnKTtcclxuICAgICAgICBpc01hcCAmJiBmaXhTVlooJ2dldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vICsgZml4IC5hZGQgJiAuc2V0IGZvciBjaGFpbmluZ1xyXG4gICAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4U1ZaKEFEREVSLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xyXG4gICAgc2V0U3BlY2llcyhDKTtcclxuICAgIFxyXG4gICAgT1tOQU1FXSA9IEM7XHJcbiAgICAkZGVmaW5lKEdMT0JBTCArIFdSQVAgKyBGT1JDRUQgKiAhaXNOYXRpdmUoQyksIE8pO1xyXG4gICAgXHJcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cclxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcclxuICAgIGlzV2VhayB8fCBkZWZpbmVTdGRJdGVyYXRvcnMoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBrOiBraW5kfSk7XHJcbiAgICB9LCBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAgICwgZW50cnkgPSBpdGVyLmw7XHJcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcclxuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcclxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xyXG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXHJcbiAgICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcclxuICAgICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS5rKTtcclxuICAgICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS52KTtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbZW50cnkuaywgZW50cnkudl0pOyAgIFxyXG4gICAgfSwgaXNNYXAgPyBLRVkrVkFMVUUgOiBWQUxVRSwgIWlzTWFwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIEM7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGZhc3RLZXkoaXQsIGNyZWF0ZSl7XHJcbiAgICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XHJcbiAgICBpZighaXNPYmplY3QoaXQpKXJldHVybiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xyXG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcclxuICAgIGlmKGlzRnJvemVuKGl0KSlyZXR1cm4gJ0YnO1xyXG4gICAgaWYoIWhhcyhpdCwgVUlEKSl7XHJcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXHJcbiAgICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcclxuICAgICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXHJcbiAgICAgIGhpZGRlbihpdCwgVUlELCArK3VpZCk7XHJcbiAgICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XHJcbiAgICB9IHJldHVybiAnTycgKyBpdFtVSURdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xyXG4gICAgLy8gZmFzdCBjYXNlXHJcbiAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xyXG4gICAgaWYoaW5kZXggIT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcclxuICAgIGZvcihlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcclxuICAgICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZWYodGhhdCwga2V5LCB2YWx1ZSl7XHJcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXHJcbiAgICAgICwgcHJldiwgaW5kZXg7XHJcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcclxuICAgIGlmKGVudHJ5KWVudHJ5LnYgPSB2YWx1ZTtcclxuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XHJcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XHJcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxyXG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxyXG4gICAgICAgIHA6IHByZXYgPSB0aGF0W0xBU1RdLCAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxyXG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XHJcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcclxuICAgICAgfTtcclxuICAgICAgaWYoIXRoYXRbRklSU1RdKXRoYXRbRklSU1RdID0gZW50cnk7XHJcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XHJcbiAgICAgIHRoYXRbU0laRV0rKztcclxuICAgICAgLy8gYWRkIHRvIGluZGV4XHJcbiAgICAgIGlmKGluZGV4ICE9ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcclxuICAgIH0gcmV0dXJuIHRoYXQ7XHJcbiAgfVxyXG5cclxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcclxuICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0W08xXSwgZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XHJcbiAgICAgICAgZW50cnkuciA9IHRydWU7XHJcbiAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xyXG4gICAgICB9XHJcbiAgICAgIHRoYXRbRklSU1RdID0gdGhhdFtMQVNUXSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhhdFtTSVpFXSA9IDA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXHJcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIHRoYXQgID0gdGhpc1xyXG4gICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xyXG4gICAgICBpZihlbnRyeSl7XHJcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXHJcbiAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xyXG4gICAgICAgIGRlbGV0ZSB0aGF0W08xXVtlbnRyeS5pXTtcclxuICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcclxuICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XHJcbiAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xyXG4gICAgICAgIGlmKHRoYXRbRklSU1RdID09IGVudHJ5KXRoYXRbRklSU1RdID0gbmV4dDtcclxuICAgICAgICBpZih0aGF0W0xBU1RdID09IGVudHJ5KXRoYXRbTEFTVF0gPSBwcmV2O1xyXG4gICAgICAgIHRoYXRbU0laRV0tLTtcclxuICAgICAgfSByZXR1cm4gISFlbnRyeTtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSwgMylcclxuICAgICAgICAsIGVudHJ5O1xyXG4gICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXNbRklSU1RdKXtcclxuICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xyXG4gICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjEgTWFwIE9iamVjdHNcclxuICBNYXAgPSBnZXRDb2xsZWN0aW9uKE1hcCwgTUFQLCB7XHJcbiAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCBjb2xsZWN0aW9uTWV0aG9kcywgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gMjMuMiBTZXQgT2JqZWN0c1xyXG4gIFNldCA9IGdldENvbGxlY3Rpb24oU2V0LCBTRVQsIHtcclxuICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIGNvbGxlY3Rpb25NZXRob2RzKTtcclxuICBcclxuICBmdW5jdGlvbiBkZWZXZWFrKHRoYXQsIGtleSwgdmFsdWUpe1xyXG4gICAgaWYoaXNGcm96ZW4oYXNzZXJ0T2JqZWN0KGtleSkpKWxlYWtTdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaGFzKGtleSwgV0VBSykgfHwgaGlkZGVuKGtleSwgV0VBSywge30pO1xyXG4gICAgICBrZXlbV0VBS11bdGhhdFtVSURdXSA9IHZhbHVlO1xyXG4gICAgfSByZXR1cm4gdGhhdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbGVha1N0b3JlKHRoYXQpe1xyXG4gICAgcmV0dXJuIHRoYXRbTEVBS10gfHwgaGlkZGVuKHRoYXQsIExFQUssIG5ldyBNYXApW0xFQUtdO1xyXG4gIH1cclxuICBcclxuICB2YXIgd2Vha01ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxyXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcclxuICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xyXG4gICAgICByZXR1cm4gaGFzKGtleSwgV0VBSykgJiYgaGFzKGtleVtXRUFLXSwgdGhpc1tVSURdKSAmJiBkZWxldGUga2V5W1dFQUtdW3RoaXNbVUlEXV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcclxuICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcclxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XHJcbiAgICAgIHJldHVybiBoYXMoa2V5LCBXRUFLKSAmJiBoYXMoa2V5W1dFQUtdLCB0aGlzW1VJRF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcclxuICBXZWFrTWFwID0gZ2V0Q29sbGVjdGlvbihXZWFrTWFwLCBXRUFLTUFQLCB7XHJcbiAgICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihpc09iamVjdChrZXkpKXtcclxuICAgICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoaGFzKGtleSwgV0VBSykpcmV0dXJuIGtleVtXRUFLXVt0aGlzW1VJRF1dO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmV2Vhayh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgdHJ1ZSwgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxyXG4gIGlmKGZyYW1ld29yayAmJiBuZXcgV2Vha01hcCgpLnNldChPYmplY3QuZnJlZXplKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdkZWxldGUsaGFzLGdldCxzZXQnKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIG1ldGhvZCA9IFdlYWtNYXBbUFJPVE9UWVBFXVtrZXldO1xyXG4gICAgICBXZWFrTWFwW1BST1RPVFlQRV1ba2V5XSA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxyXG4gICAgICAgIGlmKGlzT2JqZWN0KGEpICYmIGlzRnJvemVuKGEpKXtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxyXG4gICAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXHJcbiAgV2Vha1NldCA9IGdldENvbGxlY3Rpb24oV2Vha1NldCwgV0VBS1NFVCwge1xyXG4gICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWZXZWFrKHRoaXMsIHZhbHVlLCB0cnVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgZmFsc2UsIHRydWUpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5yZWZsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XHJcbiAgICB2YXIga2V5cyA9IFtdLCBrZXk7XHJcbiAgICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgYToga2V5cywgaTogMH0pO1xyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihFbnVtZXJhdGUsIE9CSkVDVCwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIGtleXMgPSBpdGVyLmFcclxuICAgICAgLCBrZXk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH0gd2hpbGUoISgoa2V5ID0ga2V5c1tpdGVyLmkrK10pIGluIGl0ZXIubykpO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwga2V5KTtcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiB3cmFwKGZuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIGFzc2VydE9iamVjdChpdCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSwgdHJ1ZTtcclxuICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gcmVmbGVjdEdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xyXG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cclxuICAgICAgLCBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpLCBwcm90bztcclxuICAgIGlmKGRlc2MpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxyXG4gICAgICA/IGRlc2MudmFsdWVcclxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICA6IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcclxuICAgICAgPyByZWZsZWN0R2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZWZsZWN0U2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XHJcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxyXG4gICAgICAsIG93bkRlc2MgID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXHJcbiAgICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcclxuICAgIGlmKCFvd25EZXNjKXtcclxuICAgICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XHJcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RTZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XHJcbiAgICAgIH1cclxuICAgICAgb3duRGVzYyA9IGRlc2NyaXB0b3IoMCk7XHJcbiAgICB9XHJcbiAgICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xyXG4gICAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcclxuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ2V0T3duRGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGRlc2NyaXB0b3IoMCk7XHJcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XHJcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvciksIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZFxyXG4gICAgICA/IGZhbHNlXHJcbiAgICAgIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcclxuICB9XHJcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgcmV0dXJuSXQ7XHJcbiAgXHJcbiAgdmFyIHJlZmxlY3QgPSB7XHJcbiAgICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcclxuICAgIGFwcGx5OiBjdHgoY2FsbCwgYXBwbHksIDMpLFxyXG4gICAgLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxyXG4gICAgY29uc3RydWN0OiBjb25zdHJ1Y3QsXHJcbiAgICAvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxyXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXAoZGVmaW5lUHJvcGVydHkpLFxyXG4gICAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgdmFyIGRlc2MgPSBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcclxuICAgIGVudW1lcmF0ZTogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcclxuICAgIGdldDogcmVmbGVjdEdldCxcclxuICAgIC8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXHJcbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGhhczogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXHJcbiAgICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiAhIWlzRXh0ZW5zaWJsZShhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxyXG4gICAgb3duS2V5czogb3duS2V5cyxcclxuICAgIC8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXHJcbiAgICBwcmV2ZW50RXh0ZW5zaW9uczogd3JhcChPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHwgcmV0dXJuSXQpLFxyXG4gICAgLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcclxuICAgIHNldDogcmVmbGVjdFNldFxyXG4gIH1cclxuICAvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcclxuICBpZihzZXRQcm90b3R5cGVPZilyZWZsZWN0LnNldFByb3RvdHlwZU9mID0gZnVuY3Rpb24odGFyZ2V0LCBwcm90byl7XHJcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3RvKSwgdHJ1ZTtcclxuICB9O1xyXG4gIFxyXG4gICRkZWZpbmUoR0xPQkFMLCB7UmVmbGVjdDoge319KTtcclxuICAkZGVmaW5lKFNUQVRJQywgJ1JlZmxlY3QnLCByZWZsZWN0KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcucHJvcG9zYWxzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFBST1RPLCBBUlJBWSwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvbWVuaWMvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXHJcbiAgICBpbmNsdWRlczogY3JlYXRlQXJyYXlDb250YWlucyh0cnVlKVxyXG4gIH0pO1xyXG4gICRkZWZpbmUoUFJPVE8sIFNUUklORywge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxyXG4gICAgYXQ6IGNyZWF0ZVBvaW50QXQodHJ1ZSlcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RUb0FycmF5KGlzRW50cmllcyl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIGtleXMgICA9IGdldEtleXMob2JqZWN0KVxyXG4gICAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICAgICAsIGkgICAgICA9IDBcclxuICAgICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcclxuICAgICAgICAsIGtleTtcclxuICAgICAgaWYoaXNFbnRyaWVzKXdoaWxlKGxlbmd0aCA+IGkpcmVzdWx0W2ldID0gW2tleSA9IGtleXNbaSsrXSwgT1trZXldXTtcclxuICAgICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbiAgJGRlZmluZShTVEFUSUMsIE9CSkVDVCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDQvYXByLTkubWQjNTEtb2JqZWN0ZW50cmllcy1vYmplY3R2YWx1ZXNcclxuICAgIHZhbHVlczogY3JlYXRlT2JqZWN0VG9BcnJheShmYWxzZSksXHJcbiAgICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXHJcbiAgfSk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFJFR0VYUCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2FuZ2F4Lzk2OTgxMDBcclxuICAgIGVzY2FwZTogY3JlYXRlUmVwbGFjZXIoLyhbXFxcXFxcLVtcXF17fSgpKis/LixeJHxdKS9nLCAnXFxcXCQxJywgdHJ1ZSlcclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcuYWJzdHJhY3QtcmVmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1hYnN0cmFjdC1yZWZzXHJcbiFmdW5jdGlvbihSRUZFUkVOQ0Upe1xyXG4gIFJFRkVSRU5DRV9HRVQgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFKydHZXQnLCB0cnVlKTtcclxuICB2YXIgUkVGRVJFTkNFX1NFVCA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrU0VULCB0cnVlKVxyXG4gICAgLCBSRUZFUkVOQ0VfREVMRVRFID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRSsnRGVsZXRlJywgdHJ1ZSk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwge1xyXG4gICAgcmVmZXJlbmNlR2V0OiBSRUZFUkVOQ0VfR0VULFxyXG4gICAgcmVmZXJlbmNlU2V0OiBSRUZFUkVOQ0VfU0VULFxyXG4gICAgcmVmZXJlbmNlRGVsZXRlOiBSRUZFUkVOQ0VfREVMRVRFXHJcbiAgfSk7XHJcbiAgXHJcbiAgaGlkZGVuKEZ1bmN0aW9uUHJvdG8sIFJFRkVSRU5DRV9HRVQsIHJldHVyblRoaXMpO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHNldE1hcE1ldGhvZHMoQ29uc3RydWN0b3Ipe1xyXG4gICAgaWYoQ29uc3RydWN0b3Ipe1xyXG4gICAgICB2YXIgTWFwUHJvdG8gPSBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9HRVQsIE1hcFByb3RvLmdldCk7XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX1NFVCwgTWFwUHJvdG8uc2V0KTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfREVMRVRFLCBNYXBQcm90b1snZGVsZXRlJ10pO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRNYXBNZXRob2RzKE1hcCk7XHJcbiAgc2V0TWFwTWV0aG9kcyhXZWFrTWFwKTtcclxufSgncmVmZXJlbmNlJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGpzLmFycmF5LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEphdmFTY3JpcHQgMS42IC8gU3RyYXdtYW4gYXJyYXkgc3RhdGljcyBzaGltXHJcbiFmdW5jdGlvbihhcnJheVN0YXRpY3Mpe1xyXG4gIGZ1bmN0aW9uIHNldEFycmF5U3RhdGljcyhrZXlzLCBsZW5ndGgpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KGtleXMpLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihrZXkgaW4gQXJyYXlQcm90bylhcnJheVN0YXRpY3Nba2V5XSA9IGN0eChjYWxsLCBBcnJheVByb3RvW2tleV0sIGxlbmd0aCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzJywgMSk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzJywgMyk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YsJyArXHJcbiAgICAgICAgICAgICAgICAgICdyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsLHR1cm4nKTtcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIGFycmF5U3RhdGljcyk7XHJcbn0oe30pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiB3ZWIuZG9tLml0YXJhYmxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oTm9kZUxpc3Qpe1xyXG4gIGlmKGZyYW1ld29yayAmJiBOb2RlTGlzdCAmJiAhKFNZTUJPTF9JVEVSQVRPUiBpbiBOb2RlTGlzdFtQUk9UT1RZUEVdKSl7XHJcbiAgICBoaWRkZW4oTm9kZUxpc3RbUFJPVE9UWVBFXSwgU1lNQk9MX0lURVJBVE9SLCBJdGVyYXRvcnNbQVJSQVldKTtcclxuICB9XHJcbiAgSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzW0FSUkFZXTtcclxufShnbG9iYWwuTm9kZUxpc3QpO1xufSh0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKSwgdHJ1ZSk7IiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbi8qKlxuICogVGhlIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0aGUgYGRlYnVnKClgIGNhbGxzIHRvLlxuICogU2V0IHRoZSBgREVCVUdfRkRgIGVudiB2YXJpYWJsZSB0byBvdmVycmlkZSB3aXRoIGFub3RoZXIgdmFsdWUuIGkuZS46XG4gKlxuICogICAkIERFQlVHX0ZEPTMgbm9kZSBzY3JpcHQuanMgMz5kZWJ1Zy5sb2dcbiAqL1xuXG52YXIgZmQgPSBwYXJzZUludChwcm9jZXNzLmVudi5ERUJVR19GRCwgMTApIHx8IDI7XG52YXIgc3RyZWFtID0gMSA9PT0gZmQgPyBwcm9jZXNzLnN0ZG91dCA6XG4gICAgICAgICAgICAgMiA9PT0gZmQgPyBwcm9jZXNzLnN0ZGVyciA6XG4gICAgICAgICAgICAgY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbShmZCk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgdmFyIGRlYnVnQ29sb3JzID0gKHByb2Nlc3MuZW52LkRFQlVHX0NPTE9SUyB8fCAnJykudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICgwID09PSBkZWJ1Z0NvbG9ycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcwJyAhPT0gZGVidWdDb2xvcnNcbiAgICAgICAgJiYgJ25vJyAhPT0gZGVidWdDb2xvcnNcbiAgICAgICAgJiYgJ2ZhbHNlJyAhPT0gZGVidWdDb2xvcnNcbiAgICAgICAgJiYgJ2Rpc2FibGVkJyAhPT0gZGVidWdDb2xvcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgc2luY2UgTm9kZSBkb2Vzbid0IGRvIHRoYXQgb3V0IG9mIHRoZSBib3guXG4gKi9cblxudmFyIGluc3BlY3QgPSAoNCA9PT0gdXRpbC5pbnNwZWN0Lmxlbmd0aCA/XG4gIC8vIG5vZGUgPD0gMC44LnhcbiAgZnVuY3Rpb24gKHYsIGNvbG9ycykge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qodiwgdm9pZCAwLCB2b2lkIDAsIGNvbG9ycyk7XG4gIH0gOlxuICAvLyBub2RlID4gMC44LnhcbiAgZnVuY3Rpb24gKHYsIGNvbG9ycykge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3QodiwgeyBjb2xvcnM6IGNvbG9ycyB9KTtcbiAgfVxuKTtcblxuZXhwb3J0cy5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpbnNwZWN0KHYsIHRoaXMudXNlQ29sb3JzKVxuICAgIC5yZXBsYWNlKC9cXHMqXFxuXFxzKi9nLCAnICcpO1xufTtcblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlO1xuXG4gIGlmICh1c2VDb2xvcnMpIHtcbiAgICB2YXIgYyA9IHRoaXMuY29sb3I7XG5cbiAgICBhcmdzWzBdID0gJyAgXFx1MDAxYls5JyArIGMgKyAnbScgKyBuYW1lICsgJyAnXG4gICAgICArICdcXHUwMDFiWzBtJ1xuICAgICAgKyBhcmdzWzBdICsgJ1xcdTAwMWJbMycgKyBjICsgJ20nXG4gICAgICArICcgKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxYlswbSc7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKVxuICAgICAgKyAnICcgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmVycm9yKClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIENvcGllZCBmcm9tIGBub2RlL3NyYy9ub2RlLmpzYC5cbiAqXG4gKiBYWFg6IEl0J3MgbGFtZSB0aGF0IG5vZGUgZG9lc24ndCBleHBvc2UgdGhpcyBBUEkgb3V0LW9mLXRoZS1ib3guIEl0IGFsc29cbiAqIHJlbGllcyBvbiB0aGUgdW5kb2N1bWVudGVkIGB0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoKWAgd2hpY2ggaXMgYWxzbyBsYW1lLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0gKGZkKSB7XG4gIHZhciBzdHJlYW07XG4gIHZhciB0dHlfd3JhcCA9IHByb2Nlc3MuYmluZGluZygndHR5X3dyYXAnKTtcblxuICAvLyBOb3RlIHN0cmVhbS5fdHlwZSBpcyB1c2VkIGZvciB0ZXN0LW1vZHVsZS1sb2FkLWxpc3QuanNcblxuICBzd2l0Y2ggKHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZShmZCkpIHtcbiAgICBjYXNlICdUVFknOlxuICAgICAgc3RyZWFtID0gbmV3IHR0eS5Xcml0ZVN0cmVhbShmZCk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAndHR5JztcblxuICAgICAgLy8gSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdGSUxFJzpcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICBzdHJlYW0gPSBuZXcgZnMuU3luY1dyaXRlU3RyZWFtKGZkLCB7IGF1dG9DbG9zZTogZmFsc2UgfSk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAnZnMnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQSVBFJzpcbiAgICBjYXNlICdUQ1AnOlxuICAgICAgdmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuICAgICAgc3RyZWFtID0gbmV3IG5ldC5Tb2NrZXQoe1xuICAgICAgICBmZDogZmQsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGSVhNRSBTaG91bGQgcHJvYmFibHkgaGF2ZSBhbiBvcHRpb24gaW4gbmV0LlNvY2tldCB0byBjcmVhdGUgYVxuICAgICAgLy8gc3RyZWFtIGZyb20gYW4gZXhpc3RpbmcgZmQgd2hpY2ggaXMgd3JpdGFibGUgb25seS4gQnV0IGZvciBub3dcbiAgICAgIC8vIHdlJ2xsIGp1c3QgYWRkIHRoaXMgaGFjayBhbmQgc2V0IHRoZSBgcmVhZGFibGVgIG1lbWJlciB0byBmYWxzZS5cbiAgICAgIC8vIFRlc3Q6IC4vbm9kZSB0ZXN0L2ZpeHR1cmVzL2VjaG8uanMgPCAvZXRjL3Bhc3N3ZFxuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVhZCA9IG51bGw7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAncGlwZSc7XG5cbiAgICAgIC8vIEZJWE1FIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFByb2JhYmx5IGFuIGVycm9yIG9uIGluIHV2X2d1ZXNzX2hhbmRsZSgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcGxlbWVudCBtZS4gVW5rbm93biBzdHJlYW0gZmlsZSB0eXBlIScpO1xuICB9XG5cbiAgLy8gRm9yIHN1cHBvcnRpbmcgbGVnYWN5IEFQSSB3ZSBwdXQgdGhlIEZEIGhlcmUuXG4gIHN0cmVhbS5mZCA9IGZkO1xuXG4gIHN0cmVhbS5faXNTdGRpbyA9IHRydWU7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYHByb2Nlc3MuZW52LkRFQlVHYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZXBlYXRpbmcgPSByZXF1aXJlKCdyZXBlYXRpbmcnKTtcblxuLy8gZGV0ZWN0IGVpdGhlciBzcGFjZXMgb3IgdGFicyBidXQgbm90IGJvdGggdG8gcHJvcGVybHkgaGFuZGxlIHRhYnNcbi8vIGZvciBpbmRlbnRhdGlvbiBhbmQgc3BhY2VzIGZvciBhbGlnbm1lbnRcbnZhciBJTkRFTlRfUkUgPSAvXig/OiggKSt8XFx0KykvO1xuXG5mdW5jdGlvbiBnZXRNb3N0VXNlZChpbmRlbnRzKSB7XG5cdHZhciByZXN1bHQgPSAwO1xuXHR2YXIgbWF4VXNlZCA9IDA7XG5cdHZhciBtYXhXZWlnaHQgPSAwO1xuXG5cdGZvciAodmFyIG4gaW4gaW5kZW50cykge1xuXHRcdHZhciBpbmRlbnQgPSBpbmRlbnRzW25dO1xuXHRcdHZhciB1ID0gaW5kZW50WzBdO1xuXHRcdHZhciB3ID0gaW5kZW50WzFdO1xuXG5cdFx0aWYgKHUgPiBtYXhVc2VkIHx8IHUgPT09IG1heFVzZWQgJiYgdyA+IG1heFdlaWdodCkge1xuXHRcdFx0bWF4VXNlZCA9IHU7XG5cdFx0XHRtYXhXZWlnaHQgPSB3O1xuXHRcdFx0cmVzdWx0ID0gK247XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyB1c2VkIHRvIHNlZSBpZiB0YWJzIG9yIHNwYWNlcyBhcmUgdGhlIG1vc3QgdXNlZFxuXHR2YXIgdGFicyA9IDA7XG5cdHZhciBzcGFjZXMgPSAwO1xuXG5cdC8vIHJlbWVtYmVyIHRoZSBzaXplIG9mIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvblxuXHR2YXIgcHJldiA9IDA7XG5cblx0Ly8gcmVtZW1iZXIgaG93IG1hbnkgaW5kZW50cy91bmluZGVudHMgYXMgb2NjdXJyZWQgZm9yIGEgZ2l2ZW4gc2l6ZVxuXHQvLyBhbmQgaG93IG11Y2ggbGluZXMgZm9sbG93IGEgZ2l2ZW4gaW5kZW50YXRpb25cblx0Ly9cblx0Ly8gaW5kZW50cyA9IHtcblx0Ly8gICAgMzogWzEsIDBdLFxuXHQvLyAgICA0OiBbMSwgNV0sXG5cdC8vICAgIDU6IFsxLCAwXSxcblx0Ly8gICAxMjogWzEsIDBdLFxuXHQvLyB9XG5cdHZhciBpbmRlbnRzID0ge307XG5cblx0Ly8gcG9pbnRlciB0byB0aGUgYXJyYXkgb2YgbGFzdCB1c2VkIGluZGVudFxuXHR2YXIgY3VycmVudDtcblxuXHQvLyB3aGV0aGVyIHRoZSBsYXN0IGFjdGlvbiB3YXMgYW4gaW5kZW50IChvcHBvc2VkIHRvIGFuIHVuaW5kZW50KVxuXHR2YXIgaXNJbmRlbnQ7XG5cblx0c3RyLnNwbGl0KC9cXG4vZykuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuXHRcdGlmICghbGluZSkge1xuXHRcdFx0Ly8gaWdub3JlIGVtcHR5IGxpbmVzXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluZGVudDtcblx0XHR2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goSU5ERU5UX1JFKTtcblxuXHRcdGlmICghbWF0Y2hlcykge1xuXHRcdFx0aW5kZW50ID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZW50ID0gbWF0Y2hlc1swXS5sZW5ndGg7XG5cblx0XHRcdGlmIChtYXRjaGVzWzFdKSB7XG5cdFx0XHRcdHNwYWNlcysrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFicysrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBkaWZmID0gaW5kZW50IC0gcHJldjtcblx0XHRwcmV2ID0gaW5kZW50O1xuXG5cdFx0aWYgKGRpZmYpIHtcblx0XHRcdC8vIGFuIGluZGVudCBvciB1bmluZGVudCBoYXMgYmVlbiBkZXRlY3RlZFxuXG5cdFx0XHRpc0luZGVudCA9IGRpZmYgPiAwO1xuXG5cdFx0XHRjdXJyZW50ID0gaW5kZW50c1tpc0luZGVudCA/IGRpZmYgOiAtZGlmZl07XG5cblx0XHRcdGlmIChjdXJyZW50KSB7XG5cdFx0XHRcdGN1cnJlbnRbMF0rKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBpbmRlbnRzW2RpZmZdID0gWzEsIDBdO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY3VycmVudCkge1xuXHRcdFx0Ly8gaWYgdGhlIGxhc3QgYWN0aW9uIHdhcyBhbiBpbmRlbnQsIGluY3JlbWVudCB0aGUgd2VpZ2h0XG5cdFx0XHRjdXJyZW50WzFdICs9ICtpc0luZGVudDtcblx0XHR9XG5cdH0pO1xuXG5cdHZhciBhbW91bnQgPSBnZXRNb3N0VXNlZChpbmRlbnRzKTtcblxuXHR2YXIgdHlwZTtcblx0dmFyIGFjdHVhbDtcblx0aWYgKCFhbW91bnQpIHtcblx0XHR0eXBlID0gbnVsbDtcblx0XHRhY3R1YWwgPSAnJztcblx0fSBlbHNlIGlmIChzcGFjZXMgPj0gdGFicykge1xuXHRcdHR5cGUgPSAnc3BhY2UnO1xuXHRcdGFjdHVhbCA9IHJlcGVhdGluZygnICcsIGFtb3VudCk7XG5cdH0gZWxzZSB7XG5cdFx0dHlwZSA9ICd0YWInO1xuXHRcdGFjdHVhbCA9IHJlcGVhdGluZygnXFx0JywgYW1vdW50KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0YW1vdW50OiBhbW91bnQsXG5cdFx0dHlwZTogdHlwZSxcblx0XHRpbmRlbnQ6IGFjdHVhbFxuXHR9O1xufTtcbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlLCBkZWZpbmU6dHJ1ZSovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZyxcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzdHJhdmVyc2UgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gY2xvbmUoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIGlzQXJyYXksXG4gICAgICAgIFZpc2l0b3JPcHRpb24sXG4gICAgICAgIFZpc2l0b3JLZXlzLFxuICAgICAgICBvYmplY3RDcmVhdGUsXG4gICAgICAgIG9iamVjdEtleXMsXG4gICAgICAgIEJSRUFLLFxuICAgICAgICBTS0lQLFxuICAgICAgICBSRU1PVkU7XG5cbiAgICBmdW5jdGlvbiBpZ25vcmVKU0hpbnRFcnJvcigpIHsgfVxuXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXksIHZhbDtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZGVlcENvcHkodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihzaGFsbG93Q29weSk7XG5cbiAgICAvLyBiYXNlZCBvbiBMTFZNIGxpYmMrKyB1cHBlcl9ib3VuZCAvIGxvd2VyX2JvdW5kXG4gICAgLy8gTUlUIExpY2Vuc2VcblxuICAgIGZ1bmN0aW9uIHVwcGVyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvd2VyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihsb3dlckJvdW5kKTtcblxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHsgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIga2V5cyA9IFtdLCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG8pIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgICAgICAgb2JqZWN0S2V5cyhmcm9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogJ0V4cG9ydEJhdGNoU3BlY2lmaWVyJyxcbiAgICAgICAgRXhwb3J0RGVjbGFyYXRpb246ICdFeHBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246ICdHZW5lcmF0b3JFeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6ICdNb2R1bGVTcGVjaWZpZXInLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xuICAgIH07XG5cbiAgICBWaXNpdG9yS2V5cyA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdkZWZhdWx0cycsICdyZXN0JywgJ2JvZHknXSxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogWydib2R5J10sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NCb2R5OiBbJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogWydpZCcsICdib2R5JywgJ3N1cGVyQ2xhc3MnXSxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBbJ2lkJywgJ2JvZHknLCAnc3VwZXJDbGFzcyddLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IFsnbGVmdCcsICdyaWdodCddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWydib2R5JywgJ3Rlc3QnXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogW10sXG4gICAgICAgIEV4cG9ydERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydpZCcsICduYW1lJ10sXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IFsnZXhwcmVzc2lvbiddLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IFsnaW5pdCcsICd0ZXN0JywgJ3VwZGF0ZScsICdib2R5J10sXG4gICAgICAgIEZvckluU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydpZCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnaWQnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2lkJywgJ25hbWUnXSxcbiAgICAgICAgTGl0ZXJhbDogW10sXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IFsnbGFiZWwnLCAnYm9keSddLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IFsnb2JqZWN0JywgJ3Byb3BlcnR5J10sXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogW10sXG4gICAgICAgIE5ld0V4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgICAgICBQcm9wZXJ0eTogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogWydkaXNjcmltaW5hbnQnLCAnY2FzZXMnXSxcbiAgICAgICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IFtdLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IFsncXVhc2lzJywgJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXJzJywgJ2hhbmRsZXInLCAnZ3VhcmRlZEhhbmRsZXJzJywgJ2ZpbmFsaXplciddLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFsnaWQnLCAnaW5pdCddLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogWyd0ZXN0JywgJ2JvZHknXSxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogWydvYmplY3QnLCAnYm9keSddLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IFsnYXJndW1lbnQnXVxuICAgIH07XG5cbiAgICAvLyB1bmlxdWUgaWRcbiAgICBCUkVBSyA9IHt9O1xuICAgIFNLSVAgPSB7fTtcbiAgICBSRU1PVkUgPSB7fTtcblxuICAgIFZpc2l0b3JPcHRpb24gPSB7XG4gICAgICAgIEJyZWFrOiBCUkVBSyxcbiAgICAgICAgU2tpcDogU0tJUCxcbiAgICAgICAgUmVtb3ZlOiBSRU1PVkVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHBhcmVudCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbdGhpcy5rZXldID0gbm9kZTtcbiAgICB9O1xuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMucGFyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQobm9kZSwgcGF0aCwgd3JhcCwgcmVmKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMud3JhcCA9IHdyYXA7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7IH1cblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gcHJvcGVydHkgcGF0aCBhcnJheSBmcm9tIHJvb3QgdG8gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgaiwganosIHJlc3VsdCwgZWxlbWVudDtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb1BhdGgocmVzdWx0LCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGp6ID0gcGF0aC5sZW5ndGg7IGogPCBqejsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGhbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb290IG5vZGVcbiAgICAgICAgaWYgKCF0aGlzLl9fY3VycmVudC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWwsIHNlY29uZCBub2RlIGlzIHJvb3QgZWxlbWVudFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMiwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLl9fbGVhdmVsaXN0W2ldO1xuICAgICAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgZWxlbWVudC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCB0aGlzLl9fY3VycmVudC5wYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiB0eXBlIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgfHwgdGhpcy5fX2N1cnJlbnQud3JhcDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBhcnJheSBvZiBwYXJlbnQgZWxlbWVudHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gcGFyZW50cygpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX19sZWF2ZWxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnQubm9kZTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19leGVjdXRlID0gZnVuY3Rpb24gX19leGVjdXRlKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmV2aW91cywgcmVzdWx0O1xuXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBwcmV2aW91cyAgPSB0aGlzLl9fY3VycmVudDtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwodGhpcywgZWxlbWVudC5ub2RlLCB0aGlzLl9fbGVhdmVsaXN0W3RoaXMuX19sZWF2ZWxpc3QubGVuZ3RoIC0gMV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBwcmV2aW91cztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gbm90aWZ5IGNvbnRyb2wgc2tpcCAvIGJyZWFrXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KGZsYWcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gZmxhZztcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHNraXAgY2hpbGQgbm9kZXMgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoU0tJUCk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBicmVhayB0cmF2ZXJzYWxzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGVbJ2JyZWFrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KEJSRUFLKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJlbW92ZSBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShSRU1PVkUpO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2luaXRpYWxpemUgPSBmdW5jdGlvbihyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRvciA9IHZpc2l0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX193b3JrbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fbGVhdmVsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gdmlzaXRvci5mYWxsYmFjayA9PT0gJ2l0ZXJhdGlvbic7XG4gICAgICAgIHRoaXMuX19rZXlzID0gVmlzaXRvcktleXM7XG4gICAgICAgIGlmICh2aXNpdG9yLmtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuX19rZXlzID0gZXh0ZW5kKG9iamVjdENyZWF0ZSh0aGlzLl9fa2V5cyksIHZpc2l0b3Iua2V5cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlVHlwZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBrZXk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IG9iamVjdEtleXMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50MiA9IGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgb3V0ZXIgPSB7XG4gICAgICAgICAgICByb290OiByb290XG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBuZXcgUmVmZXJlbmNlKG91dGVyLCAncm9vdCcpKTtcbiAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgbnVsbFxuICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHRhcmdldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2tleXNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gb2JqZWN0S2V5cyhub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG5ldyBSZWZlcmVuY2Uobm9kZSwga2V5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudHJhdmVyc2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVwbGFjZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRDb21tZW50UmFuZ2UoY29tbWVudCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgdGFyZ2V0ID0gdXBwZXJCb3VuZCh0b2tlbnMsIGZ1bmN0aW9uIHNlYXJjaCh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJhbmdlWzBdID4gY29tbWVudC5yYW5nZVswXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gW2NvbW1lbnQucmFuZ2VbMF0sIGNvbW1lbnQucmFuZ2VbMV1dO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0IC09IDE7XG4gICAgICAgIGlmICh0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBwcm92aWRlZENvbW1lbnRzLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gQXQgZmlyc3QsIHdlIHNob3VsZCBjYWxjdWxhdGUgZXh0ZW5kZWQgY29tbWVudCByYW5nZXMuXG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdLCBjb21tZW50LCBsZW4sIGksIGN1cnNvcjtcblxuICAgICAgICBpZiAoIXRyZWUucmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0YWNoQ29tbWVudHMgbmVlZHMgcmFuZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VucyBhcnJheSBpcyBlbXB0eSwgd2UgYXR0YWNoIGNvbW1lbnRzIHRvIHRyZWUgYXMgJ2xlYWRpbmdDb21tZW50cydcbiAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gWzAsIHRyZWUucmFuZ2VbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGV4dGVuZENvbW1lbnRSYW5nZShkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIEpvaG4gRnJlZW1hbidzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPiBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPT09IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdIDwgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdID09PSBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSAnMS44LjEtZGV2JztcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbiAgICBleHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG4gICAgZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5WaXNpdG9yS2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgIGV4cG9ydHMuVmlzaXRvck9wdGlvbiA9IFZpc2l0b3JPcHRpb247XG4gICAgZXhwb3J0cy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcbiAgICBleHBvcnRzLmNsb25lRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9uZSh7fSk7IH07XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn0pKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgJ0FTIElTJ1xuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ05ld0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGlvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1RyeVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NvdXJjZUVsZW1lbnQobm9kZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGVtZW50KG5vZGUpIHx8IG5vZGUgIT0gbnVsbCAmJiBub2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFpbGluZ1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uc2VxdWVudDtcblxuICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgY3VycmVudDtcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbm9kZS5jb25zZXF1ZW50O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09IG51bGwpICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSB0cmFpbGluZ1N0YXRlbWVudChjdXJyZW50KTtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcbiAgICAgICAgaXNTdGF0ZW1lbnQ6IGlzU3RhdGVtZW50LFxuICAgICAgICBpc0l0ZXJhdGlvblN0YXRlbWVudDogaXNJdGVyYXRpb25TdGF0ZW1lbnQsXG4gICAgICAgIGlzU291cmNlRWxlbWVudDogaXNTb3VyY2VFbGVtZW50LFxuICAgICAgICBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ6IGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudCxcblxuICAgICAgICB0cmFpbGluZ1N0YXRlbWVudDogdHJhaWxpbmdTdGF0ZW1lbnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUmVnZXgsIE5PTl9BU0NJSV9XSElURVNQQUNFUztcblxuICAgIC8vIFNlZSBgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyksXG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOEU0LVxcdTA4RkVcXHUwOTAwLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N0ZcXHUwOTgxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMS1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODJcXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAyXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjBcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxRDAwLVxcdTFERTZcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjk3XFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdCXFx1QUE4MC1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyNlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gaXNEZWNpbWFsRGlnaXQoY2gpIHx8ICAgIC8vIDAuLjlcbiAgICAgICAgICAgICg5NyA8PSBjaCAmJiBjaCA8PSAxMDIpIHx8ICAvLyBhLi5mXG4gICAgICAgICAgICAoNjUgPD0gY2ggJiYgY2ggPD0gNzApOyAgICAgLy8gQS4uRlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU1KTsgICAvLyAwLi43XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBOT05fQVNDSUlfV0hJVEVTUEFDRVMgPSBbXG4gICAgICAgIDB4MTY4MCwgMHgxODBFLFxuICAgICAgICAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSxcbiAgICAgICAgMHgyMDJGLCAweDIwNUYsXG4gICAgICAgIDB4MzAwMCxcbiAgICAgICAgMHhGRUZGXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIE5PTl9BU0NJSV9XSElURVNQQUNFUy5pbmRleE9mKGNoKSA+PSAwKTtcbiAgICB9XG5cbiAgICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAgICAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA9PT0gOTIpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gNDggJiYgY2ggPD0gNTcpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgICAgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPT09IDkyKSB8fCAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRGVjaW1hbERpZ2l0OiBpc0RlY2ltYWxEaWdpdCxcbiAgICAgICAgaXNIZXhEaWdpdDogaXNIZXhEaWdpdCxcbiAgICAgICAgaXNPY3RhbERpZ2l0OiBpc09jdGFsRGlnaXQsXG4gICAgICAgIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICAgICAgICBpc0xpbmVUZXJtaW5hdG9yOiBpc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnQ6IGlzSWRlbnRpZmllclBhcnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIC8vIHlpZWxkIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBrZXl3b3JkIHVuZGVyIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgaWQgPT09ICd5aWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fCAoaWQgPT09ICd0cnknKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdudWxsJyB8fCBpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnIHx8IGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaDtcblxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2ggPT09IDkyKSB7ICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgaXogPSBpZC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUuaXNJZGVudGlmaWVyUGFydChjaCkgfHwgY2ggPT09IDkyKSB7ICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyTmFtZShpZCkgJiYgIWlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lKGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzS2V5d29yZEVTNTogaXNLZXl3b3JkRVM1LFxuICAgICAgICBpc0tleXdvcmRFUzY6IGlzS2V5d29yZEVTNixcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzU6IGlzUmVzZXJ2ZWRXb3JkRVM1LFxuICAgICAgICBpc1Jlc2VydmVkV29yZEVTNjogaXNSZXNlcnZlZFdvcmRFUzYsXG4gICAgICAgIGlzUmVzdHJpY3RlZFdvcmQ6IGlzUmVzdHJpY3RlZFdvcmQsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWU6IGlzSWRlbnRpZmllck5hbWUsXG4gICAgICAgIGlzSWRlbnRpZmllckVTNTogaXNJZGVudGlmaWVyRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzY6IGlzSWRlbnRpZmllckVTNlxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGV4cG9ydHMuYXN0ID0gcmVxdWlyZSgnLi9hc3QnKTtcbiAgICBleHBvcnRzLmNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcbiAgICBleHBvcnRzLmtleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcImJ1aWx0aW5cIjoge1xuXHRcdFwiQXJyYXlcIjogZmFsc2UsXG5cdFx0XCJBcnJheUJ1ZmZlclwiOiBmYWxzZSxcblx0XHRcIkJvb2xlYW5cIjogZmFsc2UsXG5cdFx0XCJjb25zdHJ1Y3RvclwiOiBmYWxzZSxcblx0XHRcIkRhdGVcIjogZmFsc2UsXG5cdFx0XCJkZWNvZGVVUklcIjogZmFsc2UsXG5cdFx0XCJkZWNvZGVVUklDb21wb25lbnRcIjogZmFsc2UsXG5cdFx0XCJlbmNvZGVVUklcIjogZmFsc2UsXG5cdFx0XCJlbmNvZGVVUklDb21wb25lbnRcIjogZmFsc2UsXG5cdFx0XCJFcnJvclwiOiBmYWxzZSxcblx0XHRcImV2YWxcIjogZmFsc2UsXG5cdFx0XCJFdmFsRXJyb3JcIjogZmFsc2UsXG5cdFx0XCJGbG9hdDMyQXJyYXlcIjogZmFsc2UsXG5cdFx0XCJGbG9hdDY0QXJyYXlcIjogZmFsc2UsXG5cdFx0XCJGdW5jdGlvblwiOiBmYWxzZSxcblx0XHRcImhhc093blByb3BlcnR5XCI6IGZhbHNlLFxuXHRcdFwiSW5maW5pdHlcIjogZmFsc2UsXG5cdFx0XCJJbnQxNkFycmF5XCI6IGZhbHNlLFxuXHRcdFwiSW50MzJBcnJheVwiOiBmYWxzZSxcblx0XHRcIkludDhBcnJheVwiOiBmYWxzZSxcblx0XHRcImlzRmluaXRlXCI6IGZhbHNlLFxuXHRcdFwiaXNOYU5cIjogZmFsc2UsXG5cdFx0XCJpc1Byb3RvdHlwZU9mXCI6IGZhbHNlLFxuXHRcdFwiSlNPTlwiOiBmYWxzZSxcblx0XHRcIk1hcFwiOiBmYWxzZSxcblx0XHRcIk1hdGhcIjogZmFsc2UsXG5cdFx0XCJOYU5cIjogZmFsc2UsXG5cdFx0XCJOdW1iZXJcIjogZmFsc2UsXG5cdFx0XCJPYmplY3RcIjogZmFsc2UsXG5cdFx0XCJwYXJzZUZsb2F0XCI6IGZhbHNlLFxuXHRcdFwicGFyc2VJbnRcIjogZmFsc2UsXG5cdFx0XCJQcm9taXNlXCI6IGZhbHNlLFxuXHRcdFwicHJvcGVydHlJc0VudW1lcmFibGVcIjogZmFsc2UsXG5cdFx0XCJQcm94eVwiOiBmYWxzZSxcblx0XHRcIlJhbmdlRXJyb3JcIjogZmFsc2UsXG5cdFx0XCJSZWZlcmVuY2VFcnJvclwiOiBmYWxzZSxcblx0XHRcIlJlZmxlY3RcIjogZmFsc2UsXG5cdFx0XCJSZWdFeHBcIjogZmFsc2UsXG5cdFx0XCJTZXRcIjogZmFsc2UsXG5cdFx0XCJTdHJpbmdcIjogZmFsc2UsXG5cdFx0XCJTeW1ib2xcIjogZmFsc2UsXG5cdFx0XCJTeW50YXhFcnJvclwiOiBmYWxzZSxcblx0XHRcIlN5c3RlbVwiOiBmYWxzZSxcblx0XHRcInRvTG9jYWxlU3RyaW5nXCI6IGZhbHNlLFxuXHRcdFwidG9TdHJpbmdcIjogZmFsc2UsXG5cdFx0XCJUeXBlRXJyb3JcIjogZmFsc2UsXG5cdFx0XCJVaW50MTZBcnJheVwiOiBmYWxzZSxcblx0XHRcIlVpbnQzMkFycmF5XCI6IGZhbHNlLFxuXHRcdFwiVWludDhBcnJheVwiOiBmYWxzZSxcblx0XHRcIlVpbnQ4Q2xhbXBlZEFycmF5XCI6IGZhbHNlLFxuXHRcdFwidW5kZWZpbmVkXCI6IGZhbHNlLFxuXHRcdFwiVVJJRXJyb3JcIjogZmFsc2UsXG5cdFx0XCJ2YWx1ZU9mXCI6IGZhbHNlLFxuXHRcdFwiV2Vha01hcFwiOiBmYWxzZSxcblx0XHRcIldlYWtTZXRcIjogZmFsc2Vcblx0fSxcblx0XCJub25zdGFuZGFyZFwiOiB7XG5cdFx0XCJlc2NhcGVcIjogZmFsc2UsXG5cdFx0XCJ1bmVzY2FwZVwiOiBmYWxzZVxuXHR9LFxuXHRcImJyb3dzZXJcIjoge1xuXHRcdFwiYWRkRXZlbnRMaXN0ZW5lclwiOiBmYWxzZSxcblx0XHRcImFsZXJ0XCI6IGZhbHNlLFxuXHRcdFwiYXBwbGljYXRpb25DYWNoZVwiOiBmYWxzZSxcblx0XHRcImF0b2JcIjogZmFsc2UsXG5cdFx0XCJBdWRpb1wiOiBmYWxzZSxcblx0XHRcIkF1ZGlvUHJvY2Vzc2luZ0V2ZW50XCI6IGZhbHNlLFxuXHRcdFwiQmVmb3JlVW5sb2FkRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJCbG9iXCI6IGZhbHNlLFxuXHRcdFwiYmx1clwiOiBmYWxzZSxcblx0XHRcImJ0b2FcIjogZmFsc2UsXG5cdFx0XCJjYW5jZWxBbmltYXRpb25GcmFtZVwiOiBmYWxzZSxcblx0XHRcIkNhbnZhc0dyYWRpZW50XCI6IGZhbHNlLFxuXHRcdFwiQ2FudmFzUGF0dGVyblwiOiBmYWxzZSxcblx0XHRcIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFwiOiBmYWxzZSxcblx0XHRcImNsZWFySW50ZXJ2YWxcIjogZmFsc2UsXG5cdFx0XCJjbGVhclRpbWVvdXRcIjogZmFsc2UsXG5cdFx0XCJjbG9zZVwiOiBmYWxzZSxcblx0XHRcImNsb3NlZFwiOiBmYWxzZSxcblx0XHRcIkNsb3NlRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJDb21tZW50XCI6IGZhbHNlLFxuXHRcdFwiQ29tcG9zaXRpb25FdmVudFwiOiBmYWxzZSxcblx0XHRcImNvbmZpcm1cIjogZmFsc2UsXG5cdFx0XCJjb25zb2xlXCI6IGZhbHNlLFxuXHRcdFwiY3J5cHRvXCI6IGZhbHNlLFxuXHRcdFwiQ1NTXCI6IGZhbHNlLFxuXHRcdFwiQ3VzdG9tRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJEYXRhVmlld1wiOiBmYWxzZSxcblx0XHRcIkRlYnVnXCI6IGZhbHNlLFxuXHRcdFwiZGVmYXVsdFN0YXR1c1wiOiBmYWxzZSxcblx0XHRcImRldmljZVBpeGVsUmF0aW9cIjogZmFsc2UsXG5cdFx0XCJkaXNwYXRjaEV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiZG9jdW1lbnRcIjogZmFsc2UsXG5cdFx0XCJEb2N1bWVudFwiOiBmYWxzZSxcblx0XHRcIkRvY3VtZW50RnJhZ21lbnRcIjogZmFsc2UsXG5cdFx0XCJET01QYXJzZXJcIjogZmFsc2UsXG5cdFx0XCJEcmFnRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiRWxlbWVudFRpbWVDb250cm9sXCI6IGZhbHNlLFxuXHRcdFwiRXJyb3JFdmVudFwiOiBmYWxzZSxcblx0XHRcImV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJGaWxlUmVhZGVyXCI6IGZhbHNlLFxuXHRcdFwiZmluZFwiOiBmYWxzZSxcblx0XHRcImZvY3VzXCI6IGZhbHNlLFxuXHRcdFwiRm9jdXNFdmVudFwiOiBmYWxzZSxcblx0XHRcIkZvcm1EYXRhXCI6IGZhbHNlLFxuXHRcdFwiZnJhbWVFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiZnJhbWVzXCI6IGZhbHNlLFxuXHRcdFwiR2FtZXBhZEV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiZ2V0Q29tcHV0ZWRTdHlsZVwiOiBmYWxzZSxcblx0XHRcImdldFNlbGVjdGlvblwiOiBmYWxzZSxcblx0XHRcIkhhc2hDaGFuZ2VFdmVudFwiOiBmYWxzZSxcblx0XHRcImhpc3RvcnlcIjogZmFsc2UsXG5cdFx0XCJIVE1MQW5jaG9yRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxCYXNlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxCbG9ja3F1b3RlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxCb2R5RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxCUkVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MQnV0dG9uRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxDYW52YXNFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTERpcmVjdG9yeUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MRGl2RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxETGlzdEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxGaWVsZFNldEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MRm9udEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MRm9ybUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MRnJhbWVFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTEZyYW1lU2V0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxIZWFkRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxIZWFkaW5nRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxIUkVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MSHRtbEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MSUZyYW1lRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxJbWFnZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MSW5wdXRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTElzSW5kZXhFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTExhYmVsRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxMYXllckVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MTGVnZW5kRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxMSUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MTGlua0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MTWFwRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxNZW51RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxNZXRhRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxNb2RFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTE9iamVjdEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MT0xpc3RFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTE9wdEdyb3VwRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxPcHRpb25FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFBhcmFncmFwaEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MUGFyYW1FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFByZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MUXVvdGVFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFNjcmlwdEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MU2VsZWN0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxTdHlsZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxUYWJsZUNlbGxFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFRhYmxlQ29sRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxUYWJsZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MVGFibGVSb3dFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MVGV4dEFyZWFFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSFRNTFRpdGxlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkhUTUxVTGlzdEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJIVE1MVmlkZW9FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiSURCQ3Vyc29yXCI6IGZhbHNlLFxuXHRcdFwiSURCQ3Vyc29yV2l0aFZhbHVlXCI6IGZhbHNlLFxuXHRcdFwiSURCRGF0YWJhc2VcIjogZmFsc2UsXG5cdFx0XCJJREJFbnZpcm9ubWVudFwiOiBmYWxzZSxcblx0XHRcIklEQkZhY3RvcnlcIjogZmFsc2UsXG5cdFx0XCJJREJJbmRleFwiOiBmYWxzZSxcblx0XHRcIklEQktleVJhbmdlXCI6IGZhbHNlLFxuXHRcdFwiSURCT2JqZWN0U3RvcmVcIjogZmFsc2UsXG5cdFx0XCJJREJPcGVuREJSZXF1ZXN0XCI6IGZhbHNlLFxuXHRcdFwiSURCUmVxdWVzdFwiOiBmYWxzZSxcblx0XHRcIklEQlRyYW5zYWN0aW9uXCI6IGZhbHNlLFxuXHRcdFwiSURCVmVyc2lvbkNoYW5nZUV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiSW1hZ2VcIjogZmFsc2UsXG5cdFx0XCJpbmRleGVkREJcIjogZmFsc2UsXG5cdFx0XCJpbm5lckhlaWdodFwiOiBmYWxzZSxcblx0XHRcImlubmVyV2lkdGhcIjogZmFsc2UsXG5cdFx0XCJJbnB1dEV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiSW50bFwiOiBmYWxzZSxcblx0XHRcIktleWJvYXJkRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJsZW5ndGhcIjogZmFsc2UsXG5cdFx0XCJsb2NhbFN0b3JhZ2VcIjogZmFsc2UsXG5cdFx0XCJsb2NhdGlvblwiOiBmYWxzZSxcblx0XHRcIm1hdGNoTWVkaWFcIjogZmFsc2UsXG5cdFx0XCJNZXNzYWdlQ2hhbm5lbFwiOiBmYWxzZSxcblx0XHRcIk1lc3NhZ2VFdmVudFwiOiBmYWxzZSxcblx0XHRcIk1lc3NhZ2VQb3J0XCI6IGZhbHNlLFxuXHRcdFwiTW91c2VFdmVudFwiOiBmYWxzZSxcblx0XHRcIm1vdmVCeVwiOiBmYWxzZSxcblx0XHRcIm1vdmVUb1wiOiBmYWxzZSxcblx0XHRcIk11dGF0aW9uT2JzZXJ2ZXJcIjogZmFsc2UsXG5cdFx0XCJuYW1lXCI6IGZhbHNlLFxuXHRcdFwibmF2aWdhdG9yXCI6IGZhbHNlLFxuXHRcdFwiTm9kZVwiOiBmYWxzZSxcblx0XHRcIk5vZGVGaWx0ZXJcIjogZmFsc2UsXG5cdFx0XCJOb2RlTGlzdFwiOiBmYWxzZSxcblx0XHRcIk5vdGlmaWNhdGlvblwiOiBmYWxzZSxcblx0XHRcIk9mZmxpbmVBdWRpb0NvbXBsZXRpb25FdmVudFwiOiBmYWxzZSxcblx0XHRcIm9uYmVmb3JldW5sb2FkXCI6IHRydWUsXG5cdFx0XCJvbmJsdXJcIjogdHJ1ZSxcblx0XHRcIm9uZXJyb3JcIjogdHJ1ZSxcblx0XHRcIm9uZm9jdXNcIjogdHJ1ZSxcblx0XHRcIm9ubG9hZFwiOiB0cnVlLFxuXHRcdFwib25yZXNpemVcIjogdHJ1ZSxcblx0XHRcIm9udW5sb2FkXCI6IHRydWUsXG5cdFx0XCJvcGVuXCI6IGZhbHNlLFxuXHRcdFwib3BlbkRhdGFiYXNlXCI6IGZhbHNlLFxuXHRcdFwib3BlbmVyXCI6IGZhbHNlLFxuXHRcdFwib3BlcmFcIjogZmFsc2UsXG5cdFx0XCJPcHRpb25cIjogZmFsc2UsXG5cdFx0XCJvdXRlckhlaWdodFwiOiBmYWxzZSxcblx0XHRcIm91dGVyV2lkdGhcIjogZmFsc2UsXG5cdFx0XCJQYWdlVHJhbnNpdGlvbkV2ZW50XCI6IGZhbHNlLFxuXHRcdFwicGFnZVhPZmZzZXRcIjogZmFsc2UsXG5cdFx0XCJwYWdlWU9mZnNldFwiOiBmYWxzZSxcblx0XHRcInBhcmVudFwiOiBmYWxzZSxcblx0XHRcIlBvcFN0YXRlRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJwb3N0TWVzc2FnZVwiOiBmYWxzZSxcblx0XHRcInByaW50XCI6IGZhbHNlLFxuXHRcdFwiUHJvZ3Jlc3NFdmVudFwiOiBmYWxzZSxcblx0XHRcInByb21wdFwiOiBmYWxzZSxcblx0XHRcIlJhbmdlXCI6IGZhbHNlLFxuXHRcdFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiOiBmYWxzZSxcblx0XHRcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiOiBmYWxzZSxcblx0XHRcInJlc2l6ZUJ5XCI6IGZhbHNlLFxuXHRcdFwicmVzaXplVG9cIjogZmFsc2UsXG5cdFx0XCJzY3JlZW5cIjogZmFsc2UsXG5cdFx0XCJzY3JlZW5YXCI6IGZhbHNlLFxuXHRcdFwic2NyZWVuWVwiOiBmYWxzZSxcblx0XHRcInNjcm9sbFwiOiBmYWxzZSxcblx0XHRcInNjcm9sbGJhcnNcIjogZmFsc2UsXG5cdFx0XCJzY3JvbGxCeVwiOiBmYWxzZSxcblx0XHRcInNjcm9sbFRvXCI6IGZhbHNlLFxuXHRcdFwic2Nyb2xsWFwiOiBmYWxzZSxcblx0XHRcInNjcm9sbFlcIjogZmFsc2UsXG5cdFx0XCJzZWxmXCI6IGZhbHNlLFxuXHRcdFwic2Vzc2lvblN0b3JhZ2VcIjogZmFsc2UsXG5cdFx0XCJzZXRJbnRlcnZhbFwiOiBmYWxzZSxcblx0XHRcInNldFRpbWVvdXRcIjogZmFsc2UsXG5cdFx0XCJTaGFyZWRXb3JrZXJcIjogZmFsc2UsXG5cdFx0XCJzaG93TW9kYWxEaWFsb2dcIjogZmFsc2UsXG5cdFx0XCJzdGF0dXNcIjogZmFsc2UsXG5cdFx0XCJzdG9wXCI6IGZhbHNlLFxuXHRcdFwiU3RvcmFnZUV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdBbHRHbHlwaERlZkVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdBbHRHbHlwaEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdBbHRHbHlwaEl0ZW1FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5nbGVcIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRlQ29sb3JFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWRBbmdsZVwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVkQm9vbGVhblwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVkRW51bWVyYXRpb25cIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRlZEludGVnZXJcIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRlZExlbmd0aFwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVkTGVuZ3RoTGlzdFwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVkTnVtYmVyXCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWROdW1iZXJMaXN0XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWRQYXRoRGF0YVwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVkUG9pbnRzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvXCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWRSZWN0XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZWRTdHJpbmdcIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3RcIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0FuaW1hdGVNb3Rpb25FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdBbmltYXRpb25FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHQ2lyY2xlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0NsaXBQYXRoRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0NvbG9yXCI6IGZhbHNlLFxuXHRcdFwiU1ZHQ29sb3JQcm9maWxlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0NvbG9yUHJvZmlsZVJ1bGVcIjogZmFsc2UsXG5cdFx0XCJTVkdDb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0NTU1J1bGVcIjogZmFsc2UsXG5cdFx0XCJTVkdDdXJzb3JFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRGVmc0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdEZXNjRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0RvY3VtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0VsZW1lbnRJbnN0YW5jZVwiOiBmYWxzZSxcblx0XHRcIlNWR0VsZW1lbnRJbnN0YW5jZUxpc3RcIjogZmFsc2UsXG5cdFx0XCJTVkdFbGxpcHNlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0V2ZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFQmxlbmRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRUNvbXBvbmVudFRyYW5zZmVyRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFQ29tcG9zaXRlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVEaWZmdXNlTGlnaHRpbmdFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVEaXNwbGFjZW1lbnRNYXBFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVGbG9vZEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRUZ1bmNBRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFRnVuY0JFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVGdW5jR0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRUZ1bmNSRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFSW1hZ2VFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVNZXJnZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRU1lcmdlTm9kZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRU1vcnBob2xvZ3lFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVPZmZzZXRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVQb2ludExpZ2h0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZFU3BlY3VsYXJMaWdodGluZ0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRVNwb3RMaWdodEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGRVRpbGVFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHRkVUdXJidWxlbmNlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZpbHRlckVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXNcIjogZmFsc2UsXG5cdFx0XCJTVkdGaXRUb1ZpZXdCb3hcIjogZmFsc2UsXG5cdFx0XCJTVkdGb250RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZvbnRGYWNlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZvbnRGYWNlRm9ybWF0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0ZvbnRGYWNlTmFtZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGb250RmFjZVNyY0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGb250RmFjZVVyaUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdGb3JlaWduT2JqZWN0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR0dFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHR2x5cGhFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHR2x5cGhSZWZFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHR3JhZGllbnRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHSEtlcm5FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHSUNDQ29sb3JcIjogZmFsc2UsXG5cdFx0XCJTVkdJbWFnZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdMYW5nU3BhY2VcIjogZmFsc2UsXG5cdFx0XCJTVkdMZW5ndGhcIjogZmFsc2UsXG5cdFx0XCJTVkdMZW5ndGhMaXN0XCI6IGZhbHNlLFxuXHRcdFwiU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHTGluZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdMb2NhdGFibGVcIjogZmFsc2UsXG5cdFx0XCJTVkdNYXJrZXJFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHTWFza0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdNYXRyaXhcIjogZmFsc2UsXG5cdFx0XCJTVkdNZXRhZGF0YUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdNaXNzaW5nR2x5cGhFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHTVBhdGhFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHTnVtYmVyXCI6IGZhbHNlLFxuXHRcdFwiU1ZHTnVtYmVyTGlzdFwiOiBmYWxzZSxcblx0XHRcIlNWR1BhaW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0FyY0Fic1wiOiBmYWxzZSxcblx0XHRcIlNWR1BhdGhTZWdBcmNSZWxcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnQ2xvc2VQYXRoXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Fic1wiOiBmYWxzZSxcblx0XHRcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWxcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbFwiOiBmYWxzZSxcblx0XHRcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWxcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFic1wiOiBmYWxzZSxcblx0XHRcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0xpbmV0b0Fic1wiOiBmYWxzZSxcblx0XHRcIlNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWxcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnTGluZXRvUmVsXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsUmVsXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ0xpc3RcIjogZmFsc2UsXG5cdFx0XCJTVkdQYXRoU2VnTW92ZXRvQWJzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHUGF0aFNlZ01vdmV0b1JlbFwiOiBmYWxzZSxcblx0XHRcIlNWR1BhdHRlcm5FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHUG9pbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdQb2ludExpc3RcIjogZmFsc2UsXG5cdFx0XCJTVkdQb2x5Z29uRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1BvbHlsaW5lRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1ByZXNlcnZlQXNwZWN0UmF0aW9cIjogZmFsc2UsXG5cdFx0XCJTVkdSYWRpYWxHcmFkaWVudEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdSZWN0XCI6IGZhbHNlLFxuXHRcdFwiU1ZHUmVjdEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdSZW5kZXJpbmdJbnRlbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdTY3JpcHRFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHU2V0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1N0b3BFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHU3RyaW5nTGlzdFwiOiBmYWxzZSxcblx0XHRcIlNWR1N0eWxhYmxlXCI6IGZhbHNlLFxuXHRcdFwiU1ZHU3R5bGVFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHU1ZHRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1N3aXRjaEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdTeW1ib2xFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHVGVzdHNcIjogZmFsc2UsXG5cdFx0XCJTVkdUZXh0Q29udGVudEVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdUZXh0RWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1RleHRQYXRoRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1RleHRQb3NpdGlvbmluZ0VsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdUaXRsZUVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdUcmFuc2Zvcm1cIjogZmFsc2UsXG5cdFx0XCJTVkdUcmFuc2Zvcm1hYmxlXCI6IGZhbHNlLFxuXHRcdFwiU1ZHVHJhbnNmb3JtTGlzdFwiOiBmYWxzZSxcblx0XHRcIlNWR1RSZWZFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHVFNwYW5FbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHVW5pdFR5cGVzXCI6IGZhbHNlLFxuXHRcdFwiU1ZHVVJJUmVmZXJlbmNlXCI6IGZhbHNlLFxuXHRcdFwiU1ZHVXNlRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIlNWR1ZpZXdFbGVtZW50XCI6IGZhbHNlLFxuXHRcdFwiU1ZHVmlld1NwZWNcIjogZmFsc2UsXG5cdFx0XCJTVkdWS2VybkVsZW1lbnRcIjogZmFsc2UsXG5cdFx0XCJTVkdab29tQW5kUGFuXCI6IGZhbHNlLFxuXHRcdFwiVGV4dFwiOiBmYWxzZSxcblx0XHRcIlRleHREZWNvZGVyXCI6IGZhbHNlLFxuXHRcdFwiVGV4dEVuY29kZXJcIjogZmFsc2UsXG5cdFx0XCJUaW1lRXZlbnRcIjogZmFsc2UsXG5cdFx0XCJ0b3BcIjogZmFsc2UsXG5cdFx0XCJUb3VjaEV2ZW50XCI6IGZhbHNlLFxuXHRcdFwiVUlFdmVudFwiOiBmYWxzZSxcblx0XHRcIlVSTFwiOiBmYWxzZSxcblx0XHRcIldlYkdMQWN0aXZlSW5mb1wiOiBmYWxzZSxcblx0XHRcIldlYkdMQnVmZmVyXCI6IGZhbHNlLFxuXHRcdFwiV2ViR0xDb250ZXh0RXZlbnRcIjogZmFsc2UsXG5cdFx0XCJXZWJHTEZyYW1lYnVmZmVyXCI6IGZhbHNlLFxuXHRcdFwiV2ViR0xQcm9ncmFtXCI6IGZhbHNlLFxuXHRcdFwiV2ViR0xSZW5kZXJidWZmZXJcIjogZmFsc2UsXG5cdFx0XCJXZWJHTFJlbmRlcmluZ0NvbnRleHRcIjogZmFsc2UsXG5cdFx0XCJXZWJHTFNoYWRlclwiOiBmYWxzZSxcblx0XHRcIldlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0XCI6IGZhbHNlLFxuXHRcdFwiV2ViR0xUZXh0dXJlXCI6IGZhbHNlLFxuXHRcdFwiV2ViR0xVbmlmb3JtTG9jYXRpb25cIjogZmFsc2UsXG5cdFx0XCJXZWJTb2NrZXRcIjogZmFsc2UsXG5cdFx0XCJXaGVlbEV2ZW50XCI6IGZhbHNlLFxuXHRcdFwid2luZG93XCI6IGZhbHNlLFxuXHRcdFwiV2luZG93XCI6IGZhbHNlLFxuXHRcdFwiV29ya2VyXCI6IGZhbHNlLFxuXHRcdFwiWERvbWFpblJlcXVlc3RcIjogZmFsc2UsXG5cdFx0XCJYTUxIdHRwUmVxdWVzdFwiOiBmYWxzZSxcblx0XHRcIlhNTFNlcmlhbGl6ZXJcIjogZmFsc2UsXG5cdFx0XCJYUGF0aEV2YWx1YXRvclwiOiBmYWxzZSxcblx0XHRcIlhQYXRoRXhjZXB0aW9uXCI6IGZhbHNlLFxuXHRcdFwiWFBhdGhFeHByZXNzaW9uXCI6IGZhbHNlLFxuXHRcdFwiWFBhdGhOYW1lc3BhY2VcIjogZmFsc2UsXG5cdFx0XCJYUGF0aE5TUmVzb2x2ZXJcIjogZmFsc2UsXG5cdFx0XCJYUGF0aFJlc3VsdFwiOiBmYWxzZVxuXHR9LFxuXHRcIndvcmtlclwiOiB7XG5cdFx0XCJpbXBvcnRTY3JpcHRzXCI6IHRydWUsXG5cdFx0XCJwb3N0TWVzc2FnZVwiOiB0cnVlLFxuXHRcdFwic2VsZlwiOiB0cnVlXG5cdH0sXG5cdFwibm9kZVwiOiB7XG5cdFx0XCJfX2Rpcm5hbWVcIjogZmFsc2UsXG5cdFx0XCJfX2ZpbGVuYW1lXCI6IGZhbHNlLFxuXHRcdFwiYXJndW1lbnRzXCI6IGZhbHNlLFxuXHRcdFwiQnVmZmVyXCI6IGZhbHNlLFxuXHRcdFwiY2xlYXJJbW1lZGlhdGVcIjogZmFsc2UsXG5cdFx0XCJjbGVhckludGVydmFsXCI6IGZhbHNlLFxuXHRcdFwiY2xlYXJUaW1lb3V0XCI6IGZhbHNlLFxuXHRcdFwiY29uc29sZVwiOiBmYWxzZSxcblx0XHRcIkRhdGFWaWV3XCI6IGZhbHNlLFxuXHRcdFwiZXhwb3J0c1wiOiB0cnVlLFxuXHRcdFwiR0xPQkFMXCI6IGZhbHNlLFxuXHRcdFwiZ2xvYmFsXCI6IGZhbHNlLFxuXHRcdFwibW9kdWxlXCI6IGZhbHNlLFxuXHRcdFwicHJvY2Vzc1wiOiBmYWxzZSxcblx0XHRcInJlcXVpcmVcIjogZmFsc2UsXG5cdFx0XCJzZXRJbW1lZGlhdGVcIjogZmFsc2UsXG5cdFx0XCJzZXRJbnRlcnZhbFwiOiBmYWxzZSxcblx0XHRcInNldFRpbWVvdXRcIjogZmFsc2Vcblx0fSxcblx0XCJhbWRcIjoge1xuXHRcdFwiZGVmaW5lXCI6IGZhbHNlLFxuXHRcdFwicmVxdWlyZVwiOiBmYWxzZVxuXHR9LFxuXHRcIm1vY2hhXCI6IHtcblx0XHRcImFmdGVyXCI6IGZhbHNlLFxuXHRcdFwiYWZ0ZXJFYWNoXCI6IGZhbHNlLFxuXHRcdFwiYmVmb3JlXCI6IGZhbHNlLFxuXHRcdFwiYmVmb3JlRWFjaFwiOiBmYWxzZSxcblx0XHRcImNvbnRleHRcIjogZmFsc2UsXG5cdFx0XCJkZXNjcmliZVwiOiBmYWxzZSxcblx0XHRcIml0XCI6IGZhbHNlLFxuXHRcdFwic2V0dXBcIjogZmFsc2UsXG5cdFx0XCJzcGVjaWZ5XCI6IGZhbHNlLFxuXHRcdFwic3VpdGVcIjogZmFsc2UsXG5cdFx0XCJzdWl0ZVNldHVwXCI6IGZhbHNlLFxuXHRcdFwic3VpdGVUZWFyZG93blwiOiBmYWxzZSxcblx0XHRcInRlYXJkb3duXCI6IGZhbHNlLFxuXHRcdFwidGVzdFwiOiBmYWxzZSxcblx0XHRcInhjb250ZXh0XCI6IGZhbHNlLFxuXHRcdFwieGRlc2NyaWJlXCI6IGZhbHNlLFxuXHRcdFwieGl0XCI6IGZhbHNlLFxuXHRcdFwieHNwZWNpZnlcIjogZmFsc2Vcblx0fSxcblx0XCJqYXNtaW5lXCI6IHtcblx0XHRcImFmdGVyQWxsXCI6IGZhbHNlLFxuXHRcdFwiYWZ0ZXJFYWNoXCI6IGZhbHNlLFxuXHRcdFwiYmVmb3JlQWxsXCI6IGZhbHNlLFxuXHRcdFwiYmVmb3JlRWFjaFwiOiBmYWxzZSxcblx0XHRcImRlc2NyaWJlXCI6IGZhbHNlLFxuXHRcdFwiZXhwZWN0XCI6IGZhbHNlLFxuXHRcdFwiZmFpbFwiOiBmYWxzZSxcblx0XHRcImZkZXNjcmliZVwiOiBmYWxzZSxcblx0XHRcImZpdFwiOiBmYWxzZSxcblx0XHRcIml0XCI6IGZhbHNlLFxuXHRcdFwiamFzbWluZVwiOiBmYWxzZSxcblx0XHRcInBlbmRpbmdcIjogZmFsc2UsXG5cdFx0XCJydW5zXCI6IGZhbHNlLFxuXHRcdFwic3B5T25cIjogZmFsc2UsXG5cdFx0XCJ3YWl0c1wiOiBmYWxzZSxcblx0XHRcIndhaXRzRm9yXCI6IGZhbHNlLFxuXHRcdFwieGRlc2NyaWJlXCI6IGZhbHNlLFxuXHRcdFwieGl0XCI6IGZhbHNlXG5cdH0sXG5cdFwicXVuaXRcIjoge1xuXHRcdFwiYXN5bmNUZXN0XCI6IGZhbHNlLFxuXHRcdFwiZGVlcEVxdWFsXCI6IGZhbHNlLFxuXHRcdFwiZXF1YWxcIjogZmFsc2UsXG5cdFx0XCJleHBlY3RcIjogZmFsc2UsXG5cdFx0XCJtb2R1bGVcIjogZmFsc2UsXG5cdFx0XCJub3REZWVwRXF1YWxcIjogZmFsc2UsXG5cdFx0XCJub3RFcXVhbFwiOiBmYWxzZSxcblx0XHRcIm5vdFByb3BFcXVhbFwiOiBmYWxzZSxcblx0XHRcIm5vdFN0cmljdEVxdWFsXCI6IGZhbHNlLFxuXHRcdFwib2tcIjogZmFsc2UsXG5cdFx0XCJwcm9wRXF1YWxcIjogZmFsc2UsXG5cdFx0XCJRVW5pdFwiOiBmYWxzZSxcblx0XHRcInJhaXNlc1wiOiBmYWxzZSxcblx0XHRcInN0YXJ0XCI6IGZhbHNlLFxuXHRcdFwic3RvcFwiOiBmYWxzZSxcblx0XHRcInN0cmljdEVxdWFsXCI6IGZhbHNlLFxuXHRcdFwidGVzdFwiOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiBmYWxzZVxuXHR9LFxuXHRcInBoYW50b21qc1wiOiB7XG5cdFx0XCJjb25zb2xlXCI6IHRydWUsXG5cdFx0XCJleHBvcnRzXCI6IHRydWUsXG5cdFx0XCJwaGFudG9tXCI6IHRydWUsXG5cdFx0XCJyZXF1aXJlXCI6IHRydWUsXG5cdFx0XCJXZWJQYWdlXCI6IHRydWVcblx0fSxcblx0XCJjb3VjaFwiOiB7XG5cdFx0XCJlbWl0XCI6IGZhbHNlLFxuXHRcdFwiZXhwb3J0c1wiOiBmYWxzZSxcblx0XHRcImdldFJvd1wiOiBmYWxzZSxcblx0XHRcImxvZ1wiOiBmYWxzZSxcblx0XHRcIm1vZHVsZVwiOiBmYWxzZSxcblx0XHRcInByb3ZpZGVzXCI6IGZhbHNlLFxuXHRcdFwicmVxdWlyZVwiOiBmYWxzZSxcblx0XHRcInJlc3BvbmRcIjogZmFsc2UsXG5cdFx0XCJzZW5kXCI6IGZhbHNlLFxuXHRcdFwic3RhcnRcIjogZmFsc2UsXG5cdFx0XCJzdW1cIjogZmFsc2Vcblx0fSxcblx0XCJyaGlub1wiOiB7XG5cdFx0XCJkZWZpbmVDbGFzc1wiOiBmYWxzZSxcblx0XHRcImRlc2VyaWFsaXplXCI6IGZhbHNlLFxuXHRcdFwiZ2NcIjogZmFsc2UsXG5cdFx0XCJoZWxwXCI6IGZhbHNlLFxuXHRcdFwiaW1wb3J0Q2xhc3NcIjogZmFsc2UsXG5cdFx0XCJpbXBvcnRQYWNrYWdlXCI6IGZhbHNlLFxuXHRcdFwiamF2YVwiOiBmYWxzZSxcblx0XHRcImxvYWRcIjogZmFsc2UsXG5cdFx0XCJsb2FkQ2xhc3NcIjogZmFsc2UsXG5cdFx0XCJQYWNrYWdlc1wiOiBmYWxzZSxcblx0XHRcInByaW50XCI6IGZhbHNlLFxuXHRcdFwicXVpdFwiOiBmYWxzZSxcblx0XHRcInJlYWRGaWxlXCI6IGZhbHNlLFxuXHRcdFwicmVhZFVybFwiOiBmYWxzZSxcblx0XHRcInJ1bkNvbW1hbmRcIjogZmFsc2UsXG5cdFx0XCJzZWFsXCI6IGZhbHNlLFxuXHRcdFwic2VyaWFsaXplXCI6IGZhbHNlLFxuXHRcdFwic3Bhd25cIjogZmFsc2UsXG5cdFx0XCJzeW5jXCI6IGZhbHNlLFxuXHRcdFwidG9pbnQzMlwiOiBmYWxzZSxcblx0XHRcInZlcnNpb25cIjogZmFsc2Vcblx0fSxcblx0XCJ3c2hcIjoge1xuXHRcdFwiQWN0aXZlWE9iamVjdFwiOiB0cnVlLFxuXHRcdFwiRW51bWVyYXRvclwiOiB0cnVlLFxuXHRcdFwiR2V0T2JqZWN0XCI6IHRydWUsXG5cdFx0XCJTY3JpcHRFbmdpbmVcIjogdHJ1ZSxcblx0XHRcIlNjcmlwdEVuZ2luZUJ1aWxkVmVyc2lvblwiOiB0cnVlLFxuXHRcdFwiU2NyaXB0RW5naW5lTWFqb3JWZXJzaW9uXCI6IHRydWUsXG5cdFx0XCJTY3JpcHRFbmdpbmVNaW5vclZlcnNpb25cIjogdHJ1ZSxcblx0XHRcIlZCQXJyYXlcIjogdHJ1ZSxcblx0XHRcIldTY3JpcHRcIjogdHJ1ZSxcblx0XHRcIldTSFwiOiB0cnVlLFxuXHRcdFwiWERvbWFpblJlcXVlc3RcIjogdHJ1ZVxuXHR9LFxuXHRcImpxdWVyeVwiOiB7XG5cdFx0XCIkXCI6IGZhbHNlLFxuXHRcdFwialF1ZXJ5XCI6IGZhbHNlXG5cdH0sXG5cdFwieXVpXCI6IHtcblx0XHRcIllcIjogZmFsc2UsXG5cdFx0XCJZVUlcIjogZmFsc2UsXG5cdFx0XCJZVUlfY29uZmlnXCI6IGZhbHNlXG5cdH0sXG5cdFwic2hlbGxqc1wiOiB7XG5cdFx0XCJjYXRcIjogZmFsc2UsXG5cdFx0XCJjZFwiOiBmYWxzZSxcblx0XHRcImNobW9kXCI6IGZhbHNlLFxuXHRcdFwiY29uZmlnXCI6IGZhbHNlLFxuXHRcdFwiY3BcIjogZmFsc2UsXG5cdFx0XCJkaXJzXCI6IGZhbHNlLFxuXHRcdFwiZWNob1wiOiBmYWxzZSxcblx0XHRcImVudlwiOiBmYWxzZSxcblx0XHRcImVycm9yXCI6IGZhbHNlLFxuXHRcdFwiZXhlY1wiOiBmYWxzZSxcblx0XHRcImV4aXRcIjogZmFsc2UsXG5cdFx0XCJmaW5kXCI6IGZhbHNlLFxuXHRcdFwiZ3JlcFwiOiBmYWxzZSxcblx0XHRcImxzXCI6IGZhbHNlLFxuXHRcdFwibWtkaXJcIjogZmFsc2UsXG5cdFx0XCJtdlwiOiBmYWxzZSxcblx0XHRcInBvcGRcIjogZmFsc2UsXG5cdFx0XCJwdXNoZFwiOiBmYWxzZSxcblx0XHRcInB3ZFwiOiBmYWxzZSxcblx0XHRcInJtXCI6IGZhbHNlLFxuXHRcdFwic2VkXCI6IGZhbHNlLFxuXHRcdFwidGFyZ2V0XCI6IGZhbHNlLFxuXHRcdFwidGVtcGRpclwiOiBmYWxzZSxcblx0XHRcInRlc3RcIjogZmFsc2UsXG5cdFx0XCJ3aGljaFwiOiBmYWxzZVxuXHR9LFxuXHRcInByb3RvdHlwZWpzXCI6IHtcblx0XHRcIiRcIjogZmFsc2UsXG5cdFx0XCIkJFwiOiBmYWxzZSxcblx0XHRcIiRBXCI6IGZhbHNlLFxuXHRcdFwiJGJyZWFrXCI6IGZhbHNlLFxuXHRcdFwiJGNvbnRpbnVlXCI6IGZhbHNlLFxuXHRcdFwiJEZcIjogZmFsc2UsXG5cdFx0XCIkSFwiOiBmYWxzZSxcblx0XHRcIiRSXCI6IGZhbHNlLFxuXHRcdFwiJHdcIjogZmFsc2UsXG5cdFx0XCJBYnN0cmFjdFwiOiBmYWxzZSxcblx0XHRcIkFqYXhcIjogZmFsc2UsXG5cdFx0XCJBdXRvY29tcGxldGVyXCI6IGZhbHNlLFxuXHRcdFwiQnVpbGRlclwiOiBmYWxzZSxcblx0XHRcIkNsYXNzXCI6IGZhbHNlLFxuXHRcdFwiQ29udHJvbFwiOiBmYWxzZSxcblx0XHRcIkRyYWdnYWJsZVwiOiBmYWxzZSxcblx0XHRcIkRyYWdnYWJsZXNcIjogZmFsc2UsXG5cdFx0XCJEcm9wcGFibGVzXCI6IGZhbHNlLFxuXHRcdFwiRWZmZWN0XCI6IGZhbHNlLFxuXHRcdFwiRWxlbWVudFwiOiBmYWxzZSxcblx0XHRcIkVudW1lcmFibGVcIjogZmFsc2UsXG5cdFx0XCJFdmVudFwiOiBmYWxzZSxcblx0XHRcIkZpZWxkXCI6IGZhbHNlLFxuXHRcdFwiRm9ybVwiOiBmYWxzZSxcblx0XHRcIkhhc2hcIjogZmFsc2UsXG5cdFx0XCJJbnNlcnRpb25cIjogZmFsc2UsXG5cdFx0XCJPYmplY3RSYW5nZVwiOiBmYWxzZSxcblx0XHRcIlBlcmlvZGljYWxFeGVjdXRlclwiOiBmYWxzZSxcblx0XHRcIlBvc2l0aW9uXCI6IGZhbHNlLFxuXHRcdFwiUHJvdG90eXBlXCI6IGZhbHNlLFxuXHRcdFwiU2NyaXB0YWN1bG91c1wiOiBmYWxzZSxcblx0XHRcIlNlbGVjdG9yXCI6IGZhbHNlLFxuXHRcdFwiU29ydGFibGVcIjogZmFsc2UsXG5cdFx0XCJTb3J0YWJsZU9ic2VydmVyXCI6IGZhbHNlLFxuXHRcdFwiU291bmRcIjogZmFsc2UsXG5cdFx0XCJUZW1wbGF0ZVwiOiBmYWxzZSxcblx0XHRcIlRvZ2dsZVwiOiBmYWxzZSxcblx0XHRcIlRyeVwiOiBmYWxzZVxuXHR9LFxuXHRcIm1ldGVvclwiOiB7XG5cdFx0XCIkXCI6IGZhbHNlLFxuXHRcdFwiX1wiOiBmYWxzZSxcblx0XHRcIkFjY291bnRzXCI6IGZhbHNlLFxuXHRcdFwiQXBwXCI6IGZhbHNlLFxuXHRcdFwiQXNzZXRzXCI6IGZhbHNlLFxuXHRcdFwiQmxhemVcIjogZmFsc2UsXG5cdFx0XCJjaGVja1wiOiBmYWxzZSxcblx0XHRcIkNvcmRvdmFcIjogZmFsc2UsXG5cdFx0XCJERFBcIjogZmFsc2UsXG5cdFx0XCJERFBTZXJ2ZXJcIjogZmFsc2UsXG5cdFx0XCJEZXBzXCI6IGZhbHNlLFxuXHRcdFwiRUpTT05cIjogZmFsc2UsXG5cdFx0XCJFbWFpbFwiOiBmYWxzZSxcblx0XHRcIkhUVFBcIjogZmFsc2UsXG5cdFx0XCJMb2dcIjogZmFsc2UsXG5cdFx0XCJNYXRjaFwiOiBmYWxzZSxcblx0XHRcIk1ldGVvclwiOiBmYWxzZSxcblx0XHRcIk1vbmdvXCI6IGZhbHNlLFxuXHRcdFwiTW9uZ29JbnRlcm5hbHNcIjogZmFsc2UsXG5cdFx0XCJOcG1cIjogZmFsc2UsXG5cdFx0XCJQYWNrYWdlXCI6IGZhbHNlLFxuXHRcdFwiUGx1Z2luXCI6IGZhbHNlLFxuXHRcdFwicHJvY2Vzc1wiOiBmYWxzZSxcblx0XHRcIlJhbmRvbVwiOiBmYWxzZSxcblx0XHRcIlJlYWN0aXZlRGljdFwiOiBmYWxzZSxcblx0XHRcIlJlYWN0aXZlVmFyXCI6IGZhbHNlLFxuXHRcdFwiUm91dGVyXCI6IGZhbHNlLFxuXHRcdFwiU2Vzc2lvblwiOiBmYWxzZSxcblx0XHRcInNoYXJlXCI6IGZhbHNlLFxuXHRcdFwiU3BhY2ViYXJzXCI6IGZhbHNlLFxuXHRcdFwiVGVtcGxhdGVcIjogZmFsc2UsXG5cdFx0XCJUaW55dGVzdFwiOiBmYWxzZSxcblx0XHRcIlRyYWNrZXJcIjogZmFsc2UsXG5cdFx0XCJVSVwiOiBmYWxzZSxcblx0XHRcIlV0aWxzXCI6IGZhbHNlLFxuXHRcdFwiV2ViQXBwXCI6IGZhbHNlLFxuXHRcdFwiV2ViQXBwSW50ZXJuYWxzXCI6IGZhbHNlXG5cdH0sXG5cdFwibW9uZ29cIjoge1xuXHRcdFwiX2lzV2luZG93c1wiOiBmYWxzZSxcblx0XHRcIl9yYW5kXCI6IGZhbHNlLFxuXHRcdFwiQnVsa1dyaXRlUmVzdWx0XCI6IGZhbHNlLFxuXHRcdFwiY2F0XCI6IGZhbHNlLFxuXHRcdFwiY2RcIjogZmFsc2UsXG5cdFx0XCJjb25uZWN0XCI6IGZhbHNlLFxuXHRcdFwiZGJcIjogZmFsc2UsXG5cdFx0XCJnZXRIb3N0TmFtZVwiOiBmYWxzZSxcblx0XHRcImdldE1lbUluZm9cIjogZmFsc2UsXG5cdFx0XCJob3N0bmFtZVwiOiBmYWxzZSxcblx0XHRcImxpc3RGaWxlc1wiOiBmYWxzZSxcblx0XHRcImxvYWRcIjogZmFsc2UsXG5cdFx0XCJsc1wiOiBmYWxzZSxcblx0XHRcIm1kNXN1bUZpbGVcIjogZmFsc2UsXG5cdFx0XCJta2RpclwiOiBmYWxzZSxcblx0XHRcIk1vbmdvXCI6IGZhbHNlLFxuXHRcdFwiT2JqZWN0SWRcIjogZmFsc2UsXG5cdFx0XCJQbGFuQ2FjaGVcIjogZmFsc2UsXG5cdFx0XCJwd2RcIjogZmFsc2UsXG5cdFx0XCJxdWl0XCI6IGZhbHNlLFxuXHRcdFwicmVtb3ZlRmlsZVwiOiBmYWxzZSxcblx0XHRcInJzXCI6IGZhbHNlLFxuXHRcdFwic2hcIjogZmFsc2UsXG5cdFx0XCJVVUlEXCI6IGZhbHNlLFxuXHRcdFwidmVyc2lvblwiOiBmYWxzZSxcblx0XHRcIldyaXRlUmVzdWx0XCI6IGZhbHNlXG5cdH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9nbG9iYWxzLmpzb24nKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvZXM2LXNoaW1cbi8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5pc2ludGVnZXJcbnZhciBpc05hTiA9IHJlcXVpcmUoXCJpcy1uYW5cIik7XG52YXIgaXNGaW5pdGUgPSByZXF1aXJlKFwiaXMtZmluaXRlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uKHZhbCkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJlxuXHRcdCEgaXNOYU4odmFsKSAmJlxuXHRcdGlzRmluaXRlKHZhbCkgJiZcblx0XHRwYXJzZUludCh2YWwsIDEwKSA9PT0gdmFsO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWwpIHtcblx0Ly8gTnVtYmVyLmlzTmFOKCkgPT4gdmFsICE9PSB2YWxcblx0aWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInIHx8IHZhbCAhPT0gdmFsIHx8IHZhbCA9PT0gSW5maW5pdHkgfHwgdmFsID09PSAtSW5maW5pdHkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG4iLCJmdW5jdGlvbiBjb21iaW5lICgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJygnK1tdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZSA9IGUudG9TdHJpbmcoKVxuICAgIHJldHVybiAnKD86JyArIGUuc3Vic3RyaW5nKDEsIGUubGVuZ3RoIC0gMSkgKyAnKSdcbiAgfSkuam9pbignfCcpKycpJylcbn1cblxuZnVuY3Rpb24gbWFrZVRlc3RlciAocngpIHtcbiAgdmFyIHMgPSByeC50b1N0cmluZygpXG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHMuc3Vic3RyaW5nKDEsIHMubGVuZ3RoIC0xKSArICckJylcbi8vICByZXR1cm4gbmV3IFJlZ0V4cCgnKCcrW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChmdW5jdGlvbiAoZSkge1xuLy8gICAgdmFyIGUgPSBlLnRvU3RyaW5nKClcbi8vICAgIHJldHVybiAnKD86JyArIGUuc3Vic3RyaW5nKDEsIGUubGVuZ3RoIC0gMSkgKyAnKSdcbi8vICB9KS5qb2luKCd8JykrJyknKSAgXG59XG5cbnZhciBwYXR0ZXJuID0ge1xuICBzdHJpbmcxICAgIDogL1wiKD86KD86XFxcXFxcbnxcXFxcXCJ8W15cIlxcbl0pKSo/XCIvXG4sIHN0cmluZzIgICAgOiAvJyg/Oig/OlxcXFxcXG58XFxcXCd8W14nXFxuXSkpKj8nL1xuLy8sIHN0cmluZzIgICAgOiAvJyg/Oig/OlxcXFwnfFteJ10pKSo/Jy9cbiwgY29tbWVudDEgICA6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL1xuLCBjb21tZW50MiAgIDogL1xcL1xcLy4qP1xcbi9cbiwgd2hpdGVzcGFjZSA6IC9cXHMrL1xuLCBrZXl3b3JkICAgIDogL1xcYig/OnZhcnxsZXR8Zm9yfGlmfGVsc2V8aW58Y2xhc3N8ZnVuY3Rpb258cmV0dXJufHdpdGh8Y2FzZXxicmVha3xzd2l0Y2h8ZXhwb3J0fG5ld3x3aGlsZXxkb3x0aHJvd3xjYXRjaClcXGIvXG4sIHJlZ2V4cCAgICAgOiAvXFwvKD86KD86XFxcXFxcL3xbXlxcblxcL10pKSo/XFwvL1xuLCBuYW1lICAgICAgIDogL1thLXpBLVpfXFwkXVthLXpBLVpfXFwkMC05XSovXG4sIG51bWJlciAgICAgOiAvXFxkKyg/OlxcLlxcZCspPyg/OmVbKy1dP1xcZCspPy9cbiwgcGFyZW5zICAgICA6IC9bXFwoXFwpXS9cbiwgY3VybHkgICAgICA6IC9be31dL1xuLCBzcXVhcmUgICAgIDogL1tcXFtcXF1dL1xuLCBwdW5jdCAgICAgIDogL1s7LjpcXD9cXF4lPD49ISZ8K1xcLSx+XS9cbn1cblxudmFyIG1hdGNoID0gY29tYmluZShcbiAgcGF0dGVybi5zdHJpbmcxXG4sIHBhdHRlcm4uc3RyaW5nMlxuLCBwYXR0ZXJuLmNvbW1lbnQxXG4sIHBhdHRlcm4uY29tbWVudDJcbiwgcGF0dGVybi5yZWdleHBcbiwgcGF0dGVybi53aGl0ZXNwYWNlXG4sIHBhdHRlcm4ubmFtZVxuLCBwYXR0ZXJuLm51bWJlclxuLCBwYXR0ZXJuLnBhcmVuc1xuLCBwYXR0ZXJuLmN1cmx5XG4sIHBhdHRlcm4uc3F1YXJlXG4sIHBhdHRlcm4ucHVuY3RcbilcblxudmFyIHRlc3RlciA9IHt9XG5cbmZvcih2YXIgayBpbiBwYXR0ZXJuKSB7XG4gIHRlc3RlcltrXSA9IG1ha2VUZXN0ZXIocGF0dGVybltrXSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBkb05vdFRocm93KSB7XG4gIHJldHVybiBzdHIuc3BsaXQobWF0Y2gpLmZpbHRlcihmdW5jdGlvbiAoZSwgaSkge1xuICAgIGlmKGkgJSAyKVxuICAgICAgcmV0dXJuIHRydWVcblxuICAgIGlmKGUgIT09ICcnKSB7XG4gICAgICBpZighZG9Ob3RUaHJvdylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRva2VuOicrSlNPTi5zdHJpbmdpZnkoZSkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChlKSB7XG4gIGZvciAodmFyIHR5cGUgaW4gcGF0dGVybilcbiAgICBpZih0ZXN0ZXJbdHlwZV0udGVzdChlKSlcbiAgICAgIHJldHVybiB0eXBlXG4gIHJldHVybiAnaW52YWxpZCdcbn1cbiIsIi8vIGludGVudGlvbmFsbHkgY29tbWVudGVkIG91dCBhcyBpdCBtYWtlcyBpdCBzbG93ZXIuLi5cbi8vJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXJyID0gW107XG52YXIgY2hhckNvZGVDYWNoZSA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHR2YXIgYUxlbiA9IGEubGVuZ3RoO1xuXHR2YXIgYkxlbiA9IGIubGVuZ3RoO1xuXG5cdGlmIChhTGVuID09PSAwKSB7XG5cdFx0cmV0dXJuIGJMZW47XG5cdH1cblxuXHRpZiAoYkxlbiA9PT0gMCkge1xuXHRcdHJldHVybiBhTGVuO1xuXHR9XG5cblx0dmFyIGJDaGFyQ29kZTtcblx0dmFyIHJldDtcblx0dmFyIHRtcDtcblx0dmFyIHRtcDI7XG5cdHZhciBpID0gMDtcblx0dmFyIGogPSAwO1xuXG5cdHdoaWxlIChpIDwgYUxlbikge1xuXHRcdGNoYXJDb2RlQ2FjaGVbaV0gPSBhLmNoYXJDb2RlQXQoaSk7XG5cdFx0YXJyW2ldID0gKytpO1xuXHR9XG5cblx0d2hpbGUgKGogPCBiTGVuKSB7XG5cdFx0YkNoYXJDb2RlID0gYi5jaGFyQ29kZUF0KGopO1xuXHRcdHRtcCA9IGorKztcblx0XHRyZXQgPSBqO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFMZW47IGkrKykge1xuXHRcdFx0dG1wMiA9IGJDaGFyQ29kZSA9PT0gY2hhckNvZGVDYWNoZVtpXSA/IHRtcCA6IHRtcCArIDE7XG5cdFx0XHR0bXAgPSBhcnJbaV07XG5cdFx0XHRyZXQgPSBhcnJbaV0gPSB0bXAgPiByZXQgPyB0bXAyID4gcmV0ID8gcmV0ICsgMSA6IHRtcDIgOiB0bXAyID4gdG1wID8gdG1wICsgMSA6IHRtcDI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCIvKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gKiAvLyA9PiBbMSwgMiwgM11cbiAqL1xuZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3Q7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlRmxhdHRlbicpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheS4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIHRoZSBhcnJheSBpcyByZWN1cnNpdmVseVxuICogZmxhdHRlbmVkLCBvdGhlcndpc2UgaXQgaXMgb25seSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gKlxuICogLy8gdXNpbmcgYGlzRGVlcGBcbiAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgZ3VhcmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc0RlZXAsIGd1YXJkKSkge1xuICAgIGlzRGVlcCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucy5cbiAqXG4gKiAqKk5vdGVzOioqXG4gKiAgLSBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAqICAtIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsXG4gKiAgICBleGNlcHQgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gLiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAqICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxLCAxXVxuICovXG5mdW5jdGlvbiBwdWxsKCkge1xuICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbMF07XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGluZGV4T2YgPSBiYXNlSW5kZXhPZixcbiAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwdWxsO1xuIiwidmFyIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDYWxsYmFjaycpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVVuaXEnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgc29ydGVkVW5pcSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3NvcnRlZFVuaXEnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBgU2FtZVZhbHVlWmVyb2BcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gUHJvdmlkaW5nIGB0cnVlYCBmb3IgYGlzU29ydGVkYCBwZXJmb3JtcyBhIGZhc3RlclxuICogc2VhcmNoIGFsZ29yaXRobSBmb3Igc29ydGVkIGFycmF5cy4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXRcbiAqIGlzIGludm9rZWQgZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5IHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAqXG4gKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBJZiB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNQcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsXG4gKiBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgdW5pcXVlXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIlxuICogIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsxLCAyLCAxXSk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gKiBfLnVuaXEoWzEsIDEsIDJdLCB0cnVlKTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gKiBfLnVuaXEoWzEsIDIuNSwgMS41LCAyXSwgZnVuY3Rpb24obikgeyByZXR1cm4gdGhpcy5mbG9vcihuKTsgfSwgTWF0aCk7XG4gKiAvLyA9PiBbMSwgMi41XVxuICpcbiAqIC8vIHVzaW5nIHRoZSBcIl8ucHJvcGVydHlcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIEp1Z2dsZSBhcmd1bWVudHMuXG4gIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICB0aGlzQXJnID0gaXRlcmF0ZWU7XG4gICAgaXRlcmF0ZWUgPSBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNTb3J0ZWQsIHRoaXNBcmcpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgIGlzU29ydGVkID0gZmFsc2U7XG4gIH1cbiAgaXRlcmF0ZWUgPSBpdGVyYXRlZSA9PSBudWxsID8gaXRlcmF0ZWUgOiBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICByZXR1cm4gKGlzU29ydGVkKVxuICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG4gICAgOiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXE7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5jbHVkZXMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlRWFjaCcpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2JpbmRDYWxsYmFjaycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHlcbiAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7IGNvbnNvbGUubG9nKG4pOyB9KS52YWx1ZSgpO1xuICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlIGZyb20gbGVmdCB0byByaWdodCBhbmQgcmV0dXJucyB0aGUgYXJyYXlcbiAqXG4gKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obiwga2V5KSB7IGNvbnNvbGUubG9nKG4sIGtleSk7IH0pO1xuICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlLWtleSBwYWlyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgPyBhcnJheUVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG4gICAgOiBiYXNlRWFjaChjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGNyZWF0ZUFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jcmVhdGVBZ2dyZWdhdG9yJyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBJZiB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNQcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5mbG9vcihuKTsgfSk7XG4gKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gKlxuICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikgeyByZXR1cm4gdGhpcy5mbG9vcihuKTsgfSwgTWF0aCk7XG4gKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gKlxuICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAqL1xudmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdyb3VwQnk7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlSW5kZXhPZicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuLi9sYW5nL2lzU3RyaW5nJyksXG4gICAgdmFsdWVzID0gcmVxdWlyZSgnLi4vb2JqZWN0L3ZhbHVlcycpO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldCBmcm9tXG4gKiB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAqXG4gKiAqKk5vdGU6KiogYFNhbWVWYWx1ZVplcm9gIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucyxcbiAqIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0IGBOYU5gIG1hdGNoZXMgYE5hTmAuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBjb250YWlucywgaW5jbHVkZVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKCdwZWJibGVzJywgJ2ViJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogKGZyb21JbmRleCB8fCAwKTtcbiAgfSBlbHNlIHtcbiAgICBmcm9tSW5kZXggPSAwO1xuICB9XG4gIHJldHVybiAodHlwZW9mIGNvbGxlY3Rpb24gPT0gJ3N0cmluZycgfHwgIWlzQXJyYXkoY29sbGVjdGlvbikgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgPyAoZnJvbUluZGV4IDwgbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICA6IChiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5jbHVkZXM7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9hcnJheU1hcCcpLFxuICAgIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDYWxsYmFjaycpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gKiBgaXRlcmF0ZWVgLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogSWYgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzUHJvcGVydHlcIlxuICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpbnRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjYWxsYmFja2AsIGBjaHVua2AsIGBjbG9uZWAsIGBjcmVhdGVgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCxcbiAqIGBkcm9wUmlnaHRgLCBgZmlsbGAsIGBmbGF0dGVuYCwgYGludmVydGAsIGBtYXhgLCBgbWluYCwgYHBhcnNlSW50YCwgYHNsaWNlYCxcbiAqIGBzb3J0QnlgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltTGVmdGAsIGB0cmltUmlnaHRgLFxuICogYHRydW5jYCwgYHJhbmRvbWAsIGByYW5nZWAsIGBzYW1wbGVgLCBgdW5pcWAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBjb2xsZWN0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogMzsgfSk7XG4gKiAvLyA9PiBbMywgNiwgOV1cbiAqXG4gKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogMzsgfSk7XG4gKiAvLyA9PiBbMywgNiwgOV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgaXRlcmF0ZWUgPSBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIGFycmF5UmVkdWNlUmlnaHQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9hcnJheVJlZHVjZVJpZ2h0JyksXG4gICAgYmFzZUNhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUNhbGxiYWNrJyksXG4gICAgYmFzZUVhY2hSaWdodCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VFYWNoUmlnaHQnKSxcbiAgICBiYXNlUmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVJlZHVjZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGZvbGRyXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHsgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpOyB9LCBbXSk7XG4gKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAqL1xuZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpLCBhY2N1bXVsYXRvciwgYXJndW1lbnRzLmxlbmd0aCA8IDMsIGJhc2VFYWNoUmlnaHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZVJpZ2h0O1xuIiwidmFyIGFycmF5U29tZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2FycmF5U29tZScpLFxuICAgIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDYWxsYmFjaycpLFxuICAgIGJhc2VTb21lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVNvbWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcbiAqIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBJZiB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNQcm9wZXJ0eVwiXG4gKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBhbnlcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiAvLyB1c2luZyB0aGUgXCJfLm1hdGNoZXNcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAqIF8uc29tZSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1Byb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzQXJnICE9ICd1bmRlZmluZWQnKSB7XG4gICAgcHJlZGljYXRlID0gYmFzZUNhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuIiwidmFyIGJhc2VDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDYWxsYmFjaycpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUVhY2gnKSxcbiAgICBiYXNlU29ydEJ5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVNvcnRCeScpLFxuICAgIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9jb21wYXJlQXNjZW5kaW5nJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGlzIG1ldGhvZCBwZXJmb3Jtc1xuICogYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIElmIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1Byb3BlcnR5XCJcbiAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb25cbiAqICBpbnZva2VkIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBhbiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXNcbiAqICB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5zaW4obik7IH0pO1xuICogLy8gPT4gWzMsIDEsIDJdXG4gKlxuICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7IHJldHVybiB0aGlzLnNpbihuKTsgfSwgTWF0aCk7XG4gKiAvLyA9PiBbMywgMSwgMl1cbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJyB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICogXTtcbiAqXG4gKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgIHJlc3VsdCA9IGlzTGVuZ3RoKGxlbmd0aCkgPyBBcnJheShsZW5ndGgpIDogW107XG5cbiAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgaXRlcmF0ZWUgPSBudWxsO1xuICB9XG4gIGl0ZXJhdGVlID0gYmFzZUNhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6IGluZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBjb21wYXJlQXNjZW5kaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG4iLCJ2YXIgY2FjaGVQdXNoID0gcmVxdWlyZSgnLi9jYWNoZVB1c2gnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBTZXQgPSBpc05hdGl2ZShTZXQgPSBnbG9iYWwuU2V0KSAmJiBTZXQ7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdGhpcy5wdXNoKHZhbHVlc1tsZW5ndGhdKTtcbiAgfVxufVxuXG4vLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU2V0YCBjYWNoZS5cblNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gY2FjaGVQdXNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlDb3B5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogY2FsbGJhY2sgc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gIH1cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlUmlnaHQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3RWYWx1ZSA9PSAndW5kZWZpbmVkJyA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduRGVmYXVsdHM7XG4iLCJ2YXIgYmFzZUNvcHkgPSByZXF1aXJlKCcuL2Jhc2VDb3B5JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgaWYgKCFjdXN0b21pemVyKSB7XG4gICAgcmV0dXJuIGJhc2VDb3B5KHNvdXJjZSwgb2JqZWN0LCBwcm9wcyk7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gcmVzdWx0ICE9PSB2YWx1ZSA6IHZhbHVlID09PSB2YWx1ZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9iYXNlUHJvcGVydHknKSxcbiAgICBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2JpbmRDYWxsYmFjaycpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vdXRpbGl0eS9pZGVudGl0eScpLFxuICAgIGlzQmluZGFibGUgPSByZXF1aXJlKCcuL2lzQmluZGFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJyAmJiBpc0JpbmRhYmxlKGZ1bmMpKVxuICAgICAgPyBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpXG4gICAgICA6IGZ1bmM7XG4gIH1cbiAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGJhc2VQcm9wZXJ0eShmdW5jICsgJycpXG4gICAgOiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGZ1bmMgKyAnJywgdGhpc0FyZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNhbGxiYWNrO1xuIiwidmFyIGFycmF5Q29weSA9IHJlcXVpcmUoJy4vYXJyYXlDb3B5JyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9hcnJheUVhY2gnKSxcbiAgICBiYXNlQ29weSA9IHJlcXVpcmUoJy4vYmFzZUNvcHknKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbmNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZztcblxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwgcmVzdWx0LCBrZXlzKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbG9uZWFibGVUYWdzW3RhZ11cbiAgICAgICAgPyBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApXG4gICAgICAgIDogKG9iamVjdCA/IHZhbHVlIDoge30pO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgfVxuICB9XG4gIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lLlxuICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNvbXBhcmVBc2NlbmRpbmdgIHdoaWNoIGNvbXBhcmVzIHZhbHVlcyBhbmRcbiAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gYHZhbHVlYC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cbiAgICBpZiAodmFsdWUgPiBvdGhlciB8fCAhdmFsSXNSZWZsZXhpdmUgfHwgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyAmJiBvdGhJc1JlZmxleGl2ZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBvdGhlciB8fCAhb3RoSXNSZWZsZXhpdmUgfHwgKHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJyAmJiB2YWxJc1JlZmxleGl2ZSkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNvbXBhcmVBc2NlbmRpbmc7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIG9iamVjdCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gb2JqZWN0O1xuICAgIG9iamVjdCA9IHt9O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNvcHk7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vYmFzZUZvck93bicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi90b09iamVjdCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgIHJldHVybiBiYXNlRm9yT3duKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3QoY29sbGVjdGlvbik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3JPd25SaWdodCA9IHJlcXVpcmUoJy4vYmFzZUZvck93blJpZ2h0JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9PYmplY3QgPSByZXF1aXJlKCcuL3RvT2JqZWN0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgIHJldHVybiBiYXNlRm9yT3duUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICB9XG4gIHZhciBpdGVyYWJsZSA9IHRvT2JqZWN0KGNvbGxlY3Rpb24pO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbbGVuZ3RoXSwgbGVuZ3RoLCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2hSaWdodDtcbiIsInZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG4gKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgaXNTdHJpY3QsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgdmFsdWUgPSBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIHJlc3VsdC5sZW5ndGggKz0gdmFsTGVuZ3RoO1xuICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0b3IgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9iYXNlRm9yJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckluYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JJbjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBiYXNlRm9yUmlnaHQgPSByZXF1aXJlKCcuL2Jhc2VGb3JSaWdodCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd25SaWdodDtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vdG9PYmplY3QnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yUmlnaHQ7XG4iLCJ2YXIgaW5kZXhPZk5hTiA9IHJlcXVpcmUoJy4vaW5kZXhPZk5hTicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4KTtcbiAgfVxuICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL2Jhc2VJc0VxdWFsRGVlcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNgIGJpbmRpbmdcbiAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3IgaWRlbnRpY2FsIHZhbHVlcy5cbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIC8vIFRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsLlxuICAgIHJldHVybiB2YWx1ZSAhPT0gMCB8fCAoMSAvIHZhbHVlID09IDEgLyBvdGhlcik7XG4gIH1cbiAgdmFyIHZhbFR5cGUgPSB0eXBlb2YgdmFsdWUsXG4gICAgICBvdGhUeXBlID0gdHlwZW9mIG90aGVyO1xuXG4gIC8vIEV4aXQgZWFybHkgZm9yIHVubGlrZSBwcmltaXRpdmUgdmFsdWVzLlxuICBpZiAoKHZhbFR5cGUgIT0gJ2Z1bmN0aW9uJyAmJiB2YWxUeXBlICE9ICdvYmplY3QnICYmIG90aFR5cGUgIT0gJ2Z1bmN0aW9uJyAmJiBvdGhUeXBlICE9ICdvYmplY3QnKSB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsKSB7XG4gICAgLy8gUmV0dXJuIGBmYWxzZWAgdW5sZXNzIGJvdGggdmFsdWVzIGFyZSBgTmFOYC5cbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9lcXVhbE9iamVjdHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc1R5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNXaGVyZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgaWYgKG9ialRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgfSBlbHNlIGlmIChvYmpUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICBvYmpJc0FyciA9IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgIH1cbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgaWYgKG90aFRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICBvdGhUYWcgPSBvYmplY3RUYWc7XG4gICAgfSBlbHNlIGlmIChvdGhUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICBvdGhJc0FyciA9IGlzVHlwZWRBcnJheShvdGhlcik7XG4gICAgfVxuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICByZXR1cm4gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcpO1xuICB9XG4gIHZhciB2YWxXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgb3RoV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gIGlmICh2YWxXcmFwcGVkIHx8IG90aFdyYXBwZWQpIHtcbiAgICByZXR1cm4gZXF1YWxGdW5jKHZhbFdyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgY3VzdG9taXplciwgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICBzdGFja0EucHVzaChvYmplY3QpO1xuICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcblxuICBzdGFja0EucG9wKCk7XG4gIHN0YWNrQi5wb3AoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICogc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgc291cmNlIHByb3BlcnR5IG5hbWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBzb3VyY2UgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gc3RyaWN0Q29tcGFyZUZsYWdzIFN0cmljdCBjb21wYXJpc29uIGZsYWdzIGZvciBzb3VyY2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHByb3BzLCB2YWx1ZXMsIHN0cmljdENvbXBhcmVGbGFncywgY3VzdG9taXplcikge1xuICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgc3RyaWN0Q29tcGFyZUZsYWdzW2luZGV4XSlcbiAgICAgICAgICA/IHZhbHVlc1tpbmRleF0gIT09IG9iamVjdFtwcm9wc1tpbmRleF1dXG4gICAgICAgICAgOiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BzW2luZGV4XSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAobm9DdXN0b21pemVyICYmIHN0cmljdENvbXBhcmVGbGFnc1tpbmRleF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgc3JjVmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXG4gICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXN1bHQgPSBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICogb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vYmFzZUlzTWF0Y2gnKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT0gMSkge1xuICAgIHZhciBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSA9PT0gb2JqZWN0W2tleV0gJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHN0cmljdENvbXBhcmVGbGFncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFsdWUgPSBzb3VyY2VbcHJvcHNbbGVuZ3RoXV07XG4gICAgdmFsdWVzW2xlbmd0aF0gPSB2YWx1ZTtcbiAgICBzdHJpY3RDb21wYXJlRmxhZ3NbbGVuZ3RoXSA9IGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHByb3BzLCB2YWx1ZXMsIHN0cmljdENvbXBhcmVGbGFncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL2Jhc2VJc0VxdWFsJyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9pc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNvZXJjZSBga2V5YFxuICogdG8gYSBzdHJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgb2JqZWN0W2tleV0gPT09IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBiYXNlSXNFcXVhbCh2YWx1ZSwgb2JqZWN0W2tleV0sIG51bGwsIHRydWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9hcnJheUVhY2gnKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9iYXNlRm9yT3duJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNUeXBlZEFycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgdmFyIGlzU3JjQXJyID0gaXNMZW5ndGgoc291cmNlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSk7XG5cbiAgKGlzU3JjQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikoc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5LCBzb3VyY2UpIHtcbiAgICBpZiAoaXNPYmplY3RMaWtlKHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcbiAgICAgIHJldHVybiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNDb21tb24gPSB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnO1xuXG4gICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICB9XG4gICAgaWYgKChpc1NyY0FyciB8fCB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gcmVzdWx0ICE9PSB2YWx1ZSA6IHZhbHVlID09PSB2YWx1ZSkpKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhcnJheUNvcHkgPSByZXF1aXJlKCcuL2FycmF5Q29weScpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc1R5cGVkQXJyYXknKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgIG9iamVjdFtrZXldID0gc3RhY2tCW2xlbmd0aF07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgIGlzQ29tbW9uID0gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJztcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNMZW5ndGgoc3JjVmFsdWUubGVuZ3RoKSAmJiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkpIHtcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXkodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiAodmFsdWUgPyBhcnJheUNvcHkodmFsdWUpIDogW10pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIHJlc3VsdCA9IGlzQXJndW1lbnRzKHZhbHVlKVxuICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGVcbiAgLy8gaXQgd2l0aCBpdHMgbWVyZ2VkIHZhbHVlLlxuICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gcmVzdWx0ID8gcmVzdWx0ICE9PSB2YWx1ZSA6IHZhbHVlID09PSB2YWx1ZSkge1xuICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNvZXJjZSBga2V5YCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAqIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRGcm9tQ29sbGVjdGlvbiBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnRcbiAqICBvZiBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQ29sbGVjdGlvbiwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0RnJvbUNvbGxlY3Rpb25cbiAgICAgID8gKGluaXRGcm9tQ29sbGVjdGlvbiA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlZHVjZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvaWRlbnRpdHknKSxcbiAgICBtZXRhTWFwID0gcmVxdWlyZSgnLi9tZXRhTWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3AgZGV0ZWN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXREYXRhO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICogb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0O1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiAhcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuICEhcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb21lO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIGFuZCBgXy5zb3J0QnlBbGxgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYFxuICogdG8gZGVmaW5lIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICogY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0IGlzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiAodmFsdWUgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9iYXNlSW5kZXhPZicpLFxuICAgIGNhY2hlSW5kZXhPZiA9IHJlcXVpcmUoJy4vY2FjaGVJbmRleE9mJyksXG4gICAgY3JlYXRlQ2FjaGUgPSByZXF1aXJlKCcuL2NyZWF0ZUNhY2hlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4T2YgPSBiYXNlSW5kZXhPZixcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGlzTGFyZ2UgPSBpc0NvbW1vbiAmJiBsZW5ndGggPj0gMjAwLFxuICAgICAgc2VlbiA9IGlzTGFyZ2UgJiYgY3JlYXRlQ2FjaGUoKSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGlmIChzZWVuKSB7XG4gICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDApIHtcbiAgICAgIGlmIChpdGVyYXRlZSB8fCBpc0xhcmdlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi91dGlsaXR5L2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kQ2FsbGJhY2s7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuLi91dGlsaXR5L2NvbnN0YW50JyksXG4gICAgaXNOYXRpdmUgPSByZXF1aXJlKCcuLi9sYW5nL2lzTmF0aXZlJyk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgQXJyYXlCdWZmZXIgPSBpc05hdGl2ZShBcnJheUJ1ZmZlciA9IGdsb2JhbC5BcnJheUJ1ZmZlcikgJiYgQXJyYXlCdWZmZXIsXG4gICAgYnVmZmVyU2xpY2UgPSBpc05hdGl2ZShidWZmZXJTbGljZSA9IEFycmF5QnVmZmVyICYmIG5ldyBBcnJheUJ1ZmZlcigwKS5zbGljZSkgJiYgYnVmZmVyU2xpY2UsXG4gICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkpICYmIFVpbnQ4QXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNsb25lIGFycmF5IGJ1ZmZlcnMuICovXG52YXIgRmxvYXQ2NEFycmF5ID0gKGZ1bmN0aW9uKCkge1xuICAvLyBTYWZhcmkgNSBlcnJvcnMgd2hlbiB1c2luZyBhbiBhcnJheSBidWZmZXIgdG8gaW5pdGlhbGl6ZSBhIHR5cGVkIGFycmF5XG4gIC8vIHdoZXJlIHRoZSBhcnJheSBidWZmZXIncyBgYnl0ZUxlbmd0aGAgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIHR5cGVkXG4gIC8vIGFycmF5J3MgYEJZVEVTX1BFUl9FTEVNRU5UYC5cbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBnbG9iYWwuRmxvYXQ2NEFycmF5KSAmJiBmdW5jLFxuICAgICAgICByZXN1bHQgPSBuZXcgZnVuYyhuZXcgQXJyYXlCdWZmZXIoMTApLCAwLCAxKSAmJiBmdW5jO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByZXN1bHQ7XG59KCkpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGVhY2ggYEZsb2F0NjRBcnJheWAgZWxlbWVudC4gKi9cbnZhciBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5UID0gRmxvYXQ2NEFycmF5ID8gRmxvYXQ2NEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyU2xpY2UuY2FsbChidWZmZXIsIDApO1xufVxuaWYgKCFidWZmZXJTbGljZSkge1xuICAvLyBQaGFudG9tSlMgaGFzIGBBcnJheUJ1ZmZlcmAgYW5kIGBVaW50OEFycmF5YCBidXQgbm90IGBGbG9hdDY0QXJyYXlgLlxuICBidWZmZXJDbG9uZSA9ICEoQXJyYXlCdWZmZXIgJiYgVWludDhBcnJheSkgPyBjb25zdGFudChudWxsKSA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBieXRlTGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIGZsb2F0TGVuZ3RoID0gRmxvYXQ2NEFycmF5ID8gZmxvb3IoYnl0ZUxlbmd0aCAvIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQpIDogMCxcbiAgICAgICAgb2Zmc2V0ID0gZmxvYXRMZW5ndGggKiBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG5cbiAgICBpZiAoZmxvYXRMZW5ndGgpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IEZsb2F0NjRBcnJheShyZXN1bHQsIDAsIGZsb2F0TGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLCAwLCBmbG9hdExlbmd0aCkpO1xuICAgIH1cbiAgICBpZiAoYnl0ZUxlbmd0aCAhPSBvZmZzZXQpIHtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQsIG9mZnNldCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlckNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cbiAgcmV0dXJuIHJlc3VsdCA/IDAgOiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUluZGV4T2Y7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgcHVzaFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGRhdGEuc2V0LmFkZCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZVB1c2g7XG4iLCJ2YXIgYmFzZUNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL2Jhc2VDb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5zb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uIGFuZCBzdGFibGVcbiAqIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvYmplY3RgLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKG9iamVjdCwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iamVjdC5jcml0ZXJpYSwgb3RoZXIuY3JpdGVyaWEpIHx8IChvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFzY2VuZGluZztcbiIsInZhciBiYXNlQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2Jhc2VDYWxsYmFjaycpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gYWNjdW11bGF0b3JcbiAqIG9iamVjdCBjb21wb3NlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gKiB0aHJvdWdoIGFuIGl0ZXJhdGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgaXRlcmF0ZWUgPSBiYXNlQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBZ2dyZWdhdG9yO1xuIiwidmFyIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4vYmluZENhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gYSBnaXZlblxuICogZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIG9iamVjdCA9IGFyZ3VtZW50c1swXTtcblxuICAgIGlmIChsZW5ndGggPCAyIHx8IG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID4gMyAmJiBpc0l0ZXJhdGVlQ2FsbChhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKSkge1xuICAgICAgbGVuZ3RoID0gMjtcbiAgICB9XG4gICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cbiAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGFyZ3VtZW50c1stLWxlbmd0aCAtIDFdLCBhcmd1bWVudHNbbGVuZ3RoLS1dLCA1KTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXN0b21pemVyID0gYXJndW1lbnRzWy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vU2V0Q2FjaGUnKSxcbiAgICBjb25zdGFudCA9IHJlcXVpcmUoJy4uL3V0aWxpdHkvY29uc3RhbnQnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBTZXQgPSBpc05hdGl2ZShTZXQgPSBnbG9iYWwuU2V0KSAmJiBTZXQ7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICovXG52YXIgY3JlYXRlQ2FjaGUgPSAhKG5hdGl2ZUNyZWF0ZSAmJiBTZXQpID8gY29uc3RhbnQobnVsbCkgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYWNoZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIGFycmF5cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1doZXJlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgd2hpbGUgKHJlc3VsdCAmJiArK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgcmVzdWx0ID0gaXNXaGVyZVxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleClcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIGlmIChpc1doZXJlKSB7XG4gICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW290aEluZGV4XTtcbiAgICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAhIXJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsIi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgcmV0dXJuICtvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgID8gb3RoZXIgIT0gK290aGVyXG4gICAgICAgIC8vIEJ1dCwgdHJlYXQgYC0wYCB2cy4gYCswYCBhcyBub3QgZXF1YWwuXG4gICAgICAgIDogKG9iamVjdCA9PSAwID8gKCgxIC8gb2JqZWN0KSA9PSAoMSAvIG90aGVyKSkgOiBvYmplY3QgPT0gK290aGVyKTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgIC8vIG9iamVjdHMgYXMgZXF1YWwuIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGtleXMgPSByZXF1aXJlKCcuLi9vYmplY3Qva2V5cycpO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNXaGVyZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzV2hlcmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhhc0N0b3IsXG4gICAgICBpbmRleCA9IC0xO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XSxcbiAgICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gaXNXaGVyZVxuICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSlcbiAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJlc3VsdCA9IChvYmpWYWx1ZSAmJiBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzQ3RvciB8fCAoaGFzQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoIWhhc0N0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYE5hTmAgaXMgZm91bmQgaW4gYGFycmF5YC5cbiAqIElmIGBmcm9tUmlnaHRgIGlzIHByb3ZpZGVkIGVsZW1lbnRzIG9mIGBhcnJheWAgYXJlIGl0ZXJhdGVkIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4XSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21SaWdodCA/IChmcm9tSW5kZXggfHwgbGVuZ3RoKSA6ICgoZnJvbUluZGV4IHx8IDApIC0gMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk5hTjtcbiIsIi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGJ1ZmZlckNsb25lID0gcmVxdWlyZSgnLi9idWZmZXJDbG9uZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwiLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgIEN0b3IgPSBPYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG5ldyBDdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vYmFzZVNldERhdGEnKSxcbiAgICBpc05hdGl2ZSA9IHJlcXVpcmUoJy4uL2xhbmcvaXNOYXRpdmUnKSxcbiAgICBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbmFtZWQgZnVuY3Rpb25zLiAqL1xudmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlLiAqL1xudmFyIHJlVGhpcyA9IC9cXGJ0aGlzXFxiLztcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBlbGlnaWJsZSBmb3IgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBlbGlnaWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0JpbmRhYmxlKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9ICEoc3VwcG9ydC5mdW5jTmFtZXMgPyBmdW5jLm5hbWUgOiBzdXBwb3J0LmZ1bmNEZWNvbXApO1xuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdmFyIHNvdXJjZSA9IGZuVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICByZXN1bHQgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAvLyBDaGVjayBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICByZXN1bHQgPSByZVRoaXMudGVzdChzb3VyY2UpIHx8IGlzTmF0aXZlKGZ1bmMpO1xuICAgICAgYmFzZVNldERhdGEoZnVuYywgcmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0JpbmRhYmxlO1xuIiwiLyoqXG4gKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzSW5kZXggPSByZXF1aXJlKCcuL2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2xhbmcvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgcHJlcmVxID0gaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGluZGV4LCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHByZXJlcSA9IHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0O1xuICB9XG4gIHJldHVybiBwcmVyZXEgJiYgb2JqZWN0W2luZGV4XSA9PT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKipcbiAqIFVzZWQgYXMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBFUyBgVG9MZW5ndGhgLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgKHZhbHVlID09PSAwID8gKCgxIC8gdmFsdWUpID4gMCkgOiAhaXNPYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgaXNOYXRpdmUgPSByZXF1aXJlKCcuLi9sYW5nL2lzTmF0aXZlJyk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgV2Vha01hcCA9IGlzTmF0aXZlKFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcCkgJiYgV2Vha01hcDtcblxuLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0YU1hcDtcbiIsInZhciBiYXNlRm9ySW4gPSByZXF1aXJlKCcuL2Jhc2VGb3JJbicpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAqIFNlZSB0aGUgW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIGhhcyBhIGBbW1Byb3RvdHlwZV1dYFxuICogb2YgYG51bGxgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHZhciBDdG9yO1xuXG4gIC8vIEV4aXQgZWFybHkgZm9yIG5vbiBgT2JqZWN0YCBvYmplY3RzLlxuICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykgfHxcbiAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiZcbiAgICAgICAgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAvLyBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QncyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkXG4gIC8vIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgdmFyIHJlc3VsdDtcbiAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHQgPSBrZXk7XG4gIH0pO1xuICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoaW1Jc1BsYWluT2JqZWN0O1xuIiwidmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9sYW5nL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXNJbicpLFxuICAgIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICogb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSBsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoaW1LZXlzO1xuIiwiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBzZWVuLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICBpZiAoIWluZGV4IHx8IHNlZW4gIT09IGNvbXB1dGVkKSB7XG4gICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0ZWRVbmlxO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0IGlzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9PYmplY3Q7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZUNsb25lJyksXG4gICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmluZENhbGxiYWNrJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uXG4gKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy4gU2VlIHRoZSBbSFRNTDUgc3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUodXNlcnMpO1xuICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBib2R5ID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAqIH0pO1xuICpcbiAqIGJvZHkgPT09IGRvY3VtZW50LmJvZHlcbiAqIC8vID0+IGZhbHNlXG4gKiBib2R5Lm5vZGVOYW1lXG4gKiAvLyA9PiBCT0RZXG4gKiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoO1xuICogLy8gPT4gMFxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gIC8vIEp1Z2dsZSBhcmd1bWVudHMuXG4gIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgIHRoaXNBcmcgPSBjdXN0b21pemVyO1xuICAgIGN1c3RvbWl6ZXIgPSBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaXNEZWVwLCB0aGlzQXJnKSA/IG51bGwgOiBpc0RlZXA7XG4gICAgaXNEZWVwID0gZmFsc2U7XG4gIH1cbiAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpO1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDbG9uZScpLFxuICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2JpbmRDYWxsYmFjaycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gKiB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nXG4gKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAqIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uXG4gKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy4gU2VlIHRoZSBbSFRNTDUgc3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKHVzZXJzKTtcbiAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gKiB9KTtcbiAqXG4gKiBib2R5ID09PSBkb2N1bWVudC5ib2R5XG4gKiAvLyA9PiBmYWxzZVxuICogYm9keS5ub2RlTmFtZVxuICogLy8gPT4gQk9EWVxuICogYm9keS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAqIC8vID0+IDIwXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIGN1c3RvbWl6ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsInZhciBpc0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGlzT2JqZWN0TGlrZSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAoaXNMZW5ndGgobGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsInZhciBpc0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNOYXRpdmUgPSByZXF1aXJlKCcuL2lzTmF0aXZlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZykgfHwgZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG4iLCJ2YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4uL29iamVjdC9rZXlzJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgZW1wdHkuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eSB1bmxlc3MgaXQgaXMgYW5cbiAqIGBhcmd1bWVudHNgIG9iamVjdCwgYXJyYXksIHN0cmluZywgb3IgalF1ZXJ5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGEgbGVuZ3RoXG4gKiBncmVhdGVyIHRoYW4gYDBgIG9yIGFuIG9iamVjdCB3aXRoIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBpZiAoaXNMZW5ndGgobGVuZ3RoKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICByZXR1cm4gIWtleXModmFsdWUpLmxlbmd0aDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5O1xuIiwidmFyIGlzTmF0aXZlID0gcmVxdWlyZSgnLi9pc05hdGl2ZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkpICYmIFVpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBDaGFrcmEgSklUIGJ1ZyBpbiBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDExLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2lzc3Vlcy8xNjIxIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbn1cbi8vIEZhbGxiYWNrIGZvciBlbnZpcm9ubWVudHMgdGhhdCByZXR1cm4gaW5jb3JyZWN0IGB0eXBlb2ZgIG9wZXJhdG9yIHJlc3VsdHMuXG5pZiAoaXNGdW5jdGlvbigveC8pIHx8IChVaW50OEFycmF5ICYmICFpc0Z1bmN0aW9uKFVpbnQ4QXJyYXkpKSkge1xuICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAgIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGVzY2FwZVJlZ0V4cCA9IHJlcXVpcmUoJy4uL3N0cmluZy9lc2NhcGVSZWdFeHAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAqIFNlZSB0aGUgW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZXNjYXBlUmVnRXhwKG9ialRvU3RyaW5nKVxuICAucmVwbGFjZSgvdG9TdHJpbmd8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZykge1xuICAgIHJldHVybiByZU5hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUhvc3RDdG9yLnRlc3QodmFsdWUpKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05hdGl2ZTtcbiIsInZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICogYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDguNCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzguNCcpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqICoqTm90ZToqKiBTZWUgdGhlIFtFUzUgc3BlY10oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICh2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKSB8fCBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsInZhciBpc05hdGl2ZSA9IHJlcXVpcmUoJy4vaXNOYXRpdmUnKSxcbiAgICBzaGltSXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3NoaW1Jc1BsYWluT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAqIFNlZSB0aGUgW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xudmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghKHZhbHVlICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gIHJldHVybiBvYmpQcm90b1xuICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgdmFsdWVzLlxuICogU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZykgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZWdFeHA7XG4iLCJ2YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAqIFNlZSB0aGUgW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZykgfHwgZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG50eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgYHRvU3RyaW5nVGFnYCBvZiB2YWx1ZXMuXG4gKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiB0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV0pIHx8IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlQ29weSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VDb3B5JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi4vb2JqZWN0L2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZVxuICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VBc3NpZ24nKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAqIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM7XG4gKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAqICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyA/IG90aGVyIDogdmFsdWU7XG4gKiB9KTtcbiAqXG4gKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VBc3NpZ24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsInZhciBhcnJheUNvcHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9hcnJheUNvcHknKSxcbiAgICBhc3NpZ24gPSByZXF1aXJlKCcuL2Fzc2lnbicpLFxuICAgIGFzc2lnbkRlZmF1bHRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYXNzaWduRGVmYXVsdHMnKTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICovXG5mdW5jdGlvbiBkZWZhdWx0cyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICB2YXIgYXJncyA9IGFycmF5Q29weShhcmd1bWVudHMpO1xuICBhcmdzLnB1c2goYXNzaWduRGVmYXVsdHMpO1xuICByZXR1cm4gYXNzaWduLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXNzaWduJyk7XG4iLCIvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGtleWAgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgIGluc3RlYWQgb2YgYW5cbiAqIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5oYXMoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sICdiJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXM7XG4iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pc0xlbmd0aCcpLFxuICAgIGlzTmF0aXZlID0gcmVxdWlyZSgnLi4vbGFuZy9pc05hdGl2ZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vbGFuZy9pc09iamVjdCcpLFxuICAgIHNoaW1LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc2hpbUtleXMnKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG52YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCkge1xuICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICB9XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAodHlwZW9mIG9iamVjdCAhPSAnZnVuY3Rpb24nICYmIChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSkpKSB7XG4gICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBuYXRpdmVLZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2xhbmcvaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi4vbGFuZy9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9sYW5nL2lzT2JqZWN0JyksXG4gICAgc3VwcG9ydCA9IHJlcXVpcmUoJy4uL3N1cHBvcnQnKTtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGlzUHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICogb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGBjdXN0b21pemVyYCBpc1xuICogcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmRcbiAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAqIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAqIHdpdGggZml2ZSBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gKiB9O1xuICpcbiAqIHZhciBhZ2VzID0ge1xuICogICAnZGF0YSc6IFt7ICdhZ2UnOiAzNiB9LCB7ICdhZ2UnOiA0MCB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAqIC8vID0+IHsgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gKiB9KTtcbiAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoYmFzZU1lcmdlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gKiBTZWUgdGhpcyBbYXJ0aWNsZSBvbiBgUmVnRXhwYCBjaGFyYWN0ZXJzXShodHRwOi8vd3d3LnJlZ3VsYXItZXhwcmVzc2lvbnMuaW5mby9jaGFyYWN0ZXJzLmh0bWwjc3BlY2lhbClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhcnMgPSBSZWdFeHAocmVSZWdFeHBDaGFycy5zb3VyY2UpO1xuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIiwgXCIqXCIsXG4gKiBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCJ2YXIgaXNOYXRpdmUgPSByZXF1aXJlKCcuL2xhbmcvaXNOYXRpdmUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZS4gKi9cbnZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgRE9NIHN1cHBvcnQuICovXG52YXIgZG9jdW1lbnQgPSAoZG9jdW1lbnQgPSBnbG9iYWwud2luZG93KSAmJiBkb2N1bWVudC5kb2N1bWVudDtcblxuLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xudmFyIHN1cHBvcnQgPSB7fTtcblxuKGZ1bmN0aW9uKHgpIHtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAqIChhbGwgYnV0IEZpcmVmb3ggT1MgY2VydGlmaWVkIGFwcHMsIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycywgYW5kXG4gICAqIHRoZSBQbGF5U3RhdGlvbiAzOyBmb3JjZWQgYGZhbHNlYCBmb3IgV2luZG93cyA4IGFwcHMpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQuZnVuY0RlY29tcCA9ICFpc05hdGl2ZShnbG9iYWwuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KTtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiB0aGUgRE9NIGlzIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICB0cnkge1xuICAgIHN1cHBvcnQuZG9tID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLm5vZGVUeXBlID09PSAxMTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3VwcG9ydC5kb20gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiBJbiBGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIGFuZCBTYWZhcmkgPCA1LjEgYGFyZ3VtZW50c2Agb2JqZWN0XG4gICAqIGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLiBDaHJvbWUgPCAyNSBhbmQgTm9kZS5qcyA8IDAuMTEuMCB0cmVhdFxuICAgKiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcyBub24tZW51bWVyYWJsZSBhbmQgZmFpbCBgaGFzT3duUHJvcGVydHlgXG4gICAqIGNoZWNrcyBmb3IgaW5kZXhlcyB0aGF0IGV4Y2VlZCB0aGVpciBmdW5jdGlvbidzIGZvcm1hbCBwYXJhbWV0ZXJzIHdpdGhcbiAgICogYXNzb2NpYXRlZCB2YWx1ZXMgb2YgYDBgLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAqIEB0eXBlIGJvb2xlYW5cbiAgICovXG4gIHRyeSB7XG4gICAgc3VwcG9ydC5ub25FbnVtQXJncyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSB0cnVlO1xuICB9XG59KDAsIDApKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvcmlnaW5hbE9iamVjdCA9IE9iamVjdDtcbnZhciBvcmlnaW5hbERlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgb3JpZ2luYWxDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG5mdW5jdGlvbiBkZWZQcm9wKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG9yaWdpbmFsRGVmUHJvcCkgdHJ5IHtcbiAgICBvcmlnaW5hbERlZlByb3AuY2FsbChvcmlnaW5hbE9iamVjdCwgb2JqLCBuYW1lLCB7IHZhbHVlOiB2YWx1ZSB9KTtcbiAgfSBjYXRjaCAoZGVmaW5lUHJvcGVydHlJc0Jyb2tlbkluSUU4KSB7XG4gICAgb2JqW25hbWVdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgb2JqW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuLy8gRm9yIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgaW52b2tlZCB1c2luZyAuY2FsbCBvciAuYXBwbHksIHdlIG5lZWQgdG9cbi8vIGRlZmluZSB0aG9zZSBtZXRob2RzIG9uIHRoZSBmdW5jdGlvbiBvYmplY3RzIHRoZW1zZWx2ZXMsIHJhdGhlciB0aGFuXG4vLyBpbmhlcml0aW5nIHRoZW0gZnJvbSBGdW5jdGlvbi5wcm90b3R5cGUsIHNvIHRoYXQgYSBtYWxpY2lvdXMgb3IgY2x1bXN5XG4vLyB0aGlyZCBwYXJ0eSBjYW5ub3QgaW50ZXJmZXJlIHdpdGggdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBtb2R1bGUgYnlcbi8vIHJlZGVmaW5pbmcgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwgb3IgLmFwcGx5LlxuZnVuY3Rpb24gbWFrZVNhZmVUb0NhbGwoZnVuKSB7XG4gIGlmIChmdW4pIHtcbiAgICBkZWZQcm9wKGZ1biwgXCJjYWxsXCIsIGZ1bi5jYWxsKTtcbiAgICBkZWZQcm9wKGZ1biwgXCJhcHBseVwiLCBmdW4uYXBwbHkpO1xuICB9XG4gIHJldHVybiBmdW47XG59XG5cbm1ha2VTYWZlVG9DYWxsKG9yaWdpbmFsRGVmUHJvcCk7XG5tYWtlU2FmZVRvQ2FsbChvcmlnaW5hbENyZWF0ZSk7XG5cbnZhciBoYXNPd24gPSBtYWtlU2FmZVRvQ2FsbChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBudW1Ub1N0ciA9IG1ha2VTYWZlVG9DYWxsKE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcpO1xudmFyIHN0clNsaWNlID0gbWFrZVNhZmVUb0NhbGwoU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBjbG9uZXIgPSBmdW5jdGlvbigpe307XG5mdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlKSB7XG4gIGlmIChvcmlnaW5hbENyZWF0ZSkge1xuICAgIHJldHVybiBvcmlnaW5hbENyZWF0ZS5jYWxsKG9yaWdpbmFsT2JqZWN0LCBwcm90b3R5cGUpO1xuICB9XG4gIGNsb25lci5wcm90b3R5cGUgPSBwcm90b3R5cGUgfHwgbnVsbDtcbiAgcmV0dXJuIG5ldyBjbG9uZXI7XG59XG5cbnZhciByYW5kID0gTWF0aC5yYW5kb207XG52YXIgdW5pcXVlS2V5cyA9IGNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbWFrZVVuaXF1ZUtleSgpIHtcbiAgLy8gQ29sbGlzaW9ucyBhcmUgaGlnaGx5IHVubGlrZWx5LCBidXQgdGhpcyBtb2R1bGUgaXMgaW4gdGhlIGJ1c2luZXNzIG9mXG4gIC8vIG1ha2luZyBndWFyYW50ZWVzIHJhdGhlciB0aGFuIHNhZmUgYmV0cy5cbiAgZG8gdmFyIHVuaXF1ZUtleSA9IGludGVyblN0cmluZyhzdHJTbGljZS5jYWxsKG51bVRvU3RyLmNhbGwocmFuZCgpLCAzNiksIDIpKTtcbiAgd2hpbGUgKGhhc093bi5jYWxsKHVuaXF1ZUtleXMsIHVuaXF1ZUtleSkpO1xuICByZXR1cm4gdW5pcXVlS2V5c1t1bmlxdWVLZXldID0gdW5pcXVlS2V5O1xufVxuXG5mdW5jdGlvbiBpbnRlcm5TdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgb2JqW3N0cl0gPSB0cnVlO1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVswXTtcbn1cblxuLy8gRXh0ZXJuYWwgdXNlcnMgbWlnaHQgZmluZCB0aGlzIGZ1bmN0aW9uIHVzZWZ1bCwgYnV0IGl0IGlzIG5vdCBuZWNlc3Nhcnlcbi8vIGZvciB0aGUgdHlwaWNhbCB1c2Ugb2YgdGhpcyBtb2R1bGUuXG5kZWZQcm9wKGV4cG9ydHMsIFwibWFrZVVuaXF1ZUtleVwiLCBtYWtlVW5pcXVlS2V5KTtcblxuLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgaXMgdGhlIG9ubHkgd2F5IHRvIGVudW1lcmF0ZSBub24tZW51bWVyYWJsZVxuLy8gcHJvcGVydGllcywgc28gaWYgd2Ugd3JhcCBpdCB0byBpZ25vcmUgb3VyIHNlY3JldCBrZXlzLCB0aGVyZSBzaG91bGQgYmVcbi8vIG5vIHdheSAoZXhjZXB0IGd1ZXNzaW5nKSB0byBhY2Nlc3MgdGhvc2UgcHJvcGVydGllcy5cbnZhciBvcmlnaW5hbEdldE9QTnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgZm9yICh2YXIgbmFtZXMgPSBvcmlnaW5hbEdldE9QTnMob2JqZWN0KSxcbiAgICAgICAgICAgc3JjID0gMCxcbiAgICAgICAgICAgZHN0ID0gMCxcbiAgICAgICAgICAgbGVuID0gbmFtZXMubGVuZ3RoO1xuICAgICAgIHNyYyA8IGxlbjtcbiAgICAgICArK3NyYykge1xuICAgIGlmICghaGFzT3duLmNhbGwodW5pcXVlS2V5cywgbmFtZXNbc3JjXSkpIHtcbiAgICAgIGlmIChzcmMgPiBkc3QpIHtcbiAgICAgICAgbmFtZXNbZHN0XSA9IG5hbWVzW3NyY107XG4gICAgICB9XG4gICAgICArK2RzdDtcbiAgICB9XG4gIH1cbiAgbmFtZXMubGVuZ3RoID0gZHN0O1xuICByZXR1cm4gbmFtZXM7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0Q3JlYXRvckZuKG9iamVjdCkge1xuICByZXR1cm4gY3JlYXRlKG51bGwpO1xufVxuXG5mdW5jdGlvbiBtYWtlQWNjZXNzb3Ioc2VjcmV0Q3JlYXRvckZuKSB7XG4gIHZhciBicmFuZCA9IG1ha2VVbmlxdWVLZXkoKTtcbiAgdmFyIHBhc3NrZXkgPSBjcmVhdGUobnVsbCk7XG5cbiAgc2VjcmV0Q3JlYXRvckZuID0gc2VjcmV0Q3JlYXRvckZuIHx8IGRlZmF1bHRDcmVhdG9yRm47XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIob2JqZWN0KSB7XG4gICAgdmFyIHNlY3JldDsgLy8gQ3JlYXRlZCBsYXppbHkuXG5cbiAgICBmdW5jdGlvbiB2YXVsdChrZXksIGZvcmdldCkge1xuICAgICAgLy8gT25seSBjb2RlIHRoYXQgaGFzIGFjY2VzcyB0byB0aGUgcGFzc2tleSBjYW4gcmV0cmlldmUgKG9yIGZvcmdldClcbiAgICAgIC8vIHRoZSBzZWNyZXQgb2JqZWN0LlxuICAgICAgaWYgKGtleSA9PT0gcGFzc2tleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2V0XG4gICAgICAgICAgPyBzZWNyZXQgPSBudWxsXG4gICAgICAgICAgOiBzZWNyZXQgfHwgKHNlY3JldCA9IHNlY3JldENyZWF0b3JGbihvYmplY3QpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZQcm9wKG9iamVjdCwgYnJhbmQsIHZhdWx0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2Vzc29yKG9iamVjdCkge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqZWN0LCBicmFuZCkpXG4gICAgICByZWdpc3RlcihvYmplY3QpO1xuICAgIHJldHVybiBvYmplY3RbYnJhbmRdKHBhc3NrZXkpO1xuICB9XG5cbiAgYWNjZXNzb3IuZm9yZ2V0ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iamVjdCwgYnJhbmQpKVxuICAgICAgb2JqZWN0W2JyYW5kXShwYXNza2V5LCB0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gYWNjZXNzb3I7XG59XG5cbmRlZlByb3AoZXhwb3J0cywgXCJtYWtlQWNjZXNzb3JcIiwgbWFrZUFjY2Vzc29yKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcImFzdC10eXBlc1wiKTtcbnZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xudmFyIGIgPSB0eXBlcy5idWlsZGVycztcbnZhciBuID0gdHlwZXMubmFtZWRUeXBlcztcbnZhciBsZWFwID0gcmVxdWlyZShcIi4vbGVhcFwiKTtcbnZhciBtZXRhID0gcmVxdWlyZShcIi4vbWV0YVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBFbWl0dGVyKGNvbnRleHRJZCkge1xuICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIEVtaXR0ZXIpO1xuICBuLklkZW50aWZpZXIuYXNzZXJ0KGNvbnRleHRJZCk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIC8vIEluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGUgY29udGV4dCBvYmplY3QgZG9lcyBub3QgY29sbGlkZSB3aXRoXG4gICAgLy8gYW55dGhpbmcgaW4gdGhlIGxvY2FsIHNjb3BlLCB3ZSBtaWdodCBoYXZlIHRvIHJlbmFtZSBpdCwgc28gd2VcbiAgICAvLyByZWZlciB0byBpdCBzeW1ib2xpY2FsbHkgaW5zdGVhZCBvZiBqdXN0IGFzc3VtaW5nIHRoYXQgaXQgd2lsbCBiZVxuICAgIC8vIGNhbGxlZCBcImNvbnRleHRcIi5cbiAgICBjb250ZXh0SWQ6IHsgdmFsdWU6IGNvbnRleHRJZCB9LFxuXG4gICAgLy8gQW4gYXBwZW5kLW9ubHkgbGlzdCBvZiBTdGF0ZW1lbnRzIHRoYXQgZ3Jvd3MgZWFjaCB0aW1lIHRoaXMuZW1pdCBpc1xuICAgIC8vIGNhbGxlZC5cbiAgICBsaXN0aW5nOiB7IHZhbHVlOiBbXSB9LFxuXG4gICAgLy8gQSBzcGFyc2UgYXJyYXkgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIGxvY2F0aW9ucyBpbiB0aGlzLmxpc3RpbmdcbiAgICAvLyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgYnJhbmNoL2p1bXAgdGFyZ2V0cy5cbiAgICBtYXJrZWQ6IHsgdmFsdWU6IFt0cnVlXSB9LFxuXG4gICAgLy8gVGhlIGxhc3QgbG9jYXRpb24gd2lsbCBiZSBtYXJrZWQgd2hlbiB0aGlzLmdldERpc3BhdGNoTG9vcCBpc1xuICAgIC8vIGNhbGxlZC5cbiAgICBmaW5hbExvYzogeyB2YWx1ZTogbG9jKCkgfSxcblxuICAgIC8vIEEgbGlzdCBvZiBhbGwgbGVhcC5UcnlFbnRyeSBzdGF0ZW1lbnRzIGVtaXR0ZWQuXG4gICAgdHJ5RW50cmllczogeyB2YWx1ZTogW10gfVxuICB9KTtcblxuICAvLyBUaGUgLmxlYXBNYW5hZ2VyIHByb3BlcnR5IG5lZWRzIHRvIGJlIGRlZmluZWQgYnkgYSBzZXBhcmF0ZVxuICAvLyBkZWZpbmVQcm9wZXJ0aWVzIGNhbGwgc28gdGhhdCAuZmluYWxMb2Mgd2lsbCBiZSB2aXNpYmxlIHRvIHRoZVxuICAvLyBsZWFwLkxlYXBNYW5hZ2VyIGNvbnN0cnVjdG9yLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgLy8gRWFjaCB0aW1lIHdlIGV2YWx1YXRlIHRoZSBib2R5IG9mIGEgbG9vcCwgd2UgdGVsbCB0aGlzLmxlYXBNYW5hZ2VyXG4gICAgLy8gdG8gZW50ZXIgYSBuZXN0ZWQgbG9vcCBjb250ZXh0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgbWVhbmluZyBvZiBicmVha1xuICAgIC8vIGFuZCBjb250aW51ZSBzdGF0ZW1lbnRzIHRoZXJlaW4uXG4gICAgbGVhcE1hbmFnZXI6IHsgdmFsdWU6IG5ldyBsZWFwLkxlYXBNYW5hZ2VyKHRoaXMpIH1cbiAgfSk7XG59XG5cbnZhciBFcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcblxuLy8gT2Zmc2V0cyBpbnRvIHRoaXMubGlzdGluZyB0aGF0IGNvdWxkIGJlIHVzZWQgYXMgdGFyZ2V0cyBmb3IgYnJhbmNoZXMgb3Jcbi8vIGp1bXBzIGFyZSByZXByZXNlbnRlZCBhcyBudW1lcmljIExpdGVyYWwgbm9kZXMuIFRoaXMgcmVwcmVzZW50YXRpb24gaGFzXG4vLyB0aGUgYW1hemluZ2x5IGNvbnZlbmllbnQgYmVuZWZpdCBvZiBhbGxvd2luZyB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlXG4vLyBsb2NhdGlvbiB0byBiZSBkZXRlcm1pbmVkIGF0IGFueSB0aW1lLCBldmVuIGFmdGVyIGdlbmVyYXRpbmcgY29kZSB0aGF0XG4vLyByZWZlcnMgdG8gdGhlIGxvY2F0aW9uLlxuZnVuY3Rpb24gbG9jKCkge1xuICByZXR1cm4gYi5saXRlcmFsKC0xKTtcbn1cblxuLy8gU2V0cyB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGdpdmVuIGxvY2F0aW9uIHRvIHRoZSBvZmZzZXQgb2YgdGhlIG5leHRcbi8vIFN0YXRlbWVudCBlbWl0dGVkLlxuRXAubWFyayA9IGZ1bmN0aW9uKGxvYykge1xuICBuLkxpdGVyYWwuYXNzZXJ0KGxvYyk7XG4gIHZhciBpbmRleCA9IHRoaXMubGlzdGluZy5sZW5ndGg7XG4gIGlmIChsb2MudmFsdWUgPT09IC0xKSB7XG4gICAgbG9jLnZhbHVlID0gaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9jYXRpb25zIGNhbiBiZSBtYXJrZWQgcmVkdW5kYW50bHksIGJ1dCB0aGVpciB2YWx1ZXMgY2Fubm90IGNoYW5nZVxuICAgIC8vIG9uY2Ugc2V0IHRoZSBmaXJzdCB0aW1lLlxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChsb2MudmFsdWUsIGluZGV4KTtcbiAgfVxuICB0aGlzLm1hcmtlZFtpbmRleF0gPSB0cnVlO1xuICByZXR1cm4gbG9jO1xufTtcblxuRXAuZW1pdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKG4uRXhwcmVzc2lvbi5jaGVjayhub2RlKSlcbiAgICBub2RlID0gYi5leHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICBuLlN0YXRlbWVudC5hc3NlcnQobm9kZSk7XG4gIHRoaXMubGlzdGluZy5wdXNoKG5vZGUpO1xufTtcblxuLy8gU2hvcnRoYW5kIGZvciBlbWl0dGluZyBhc3NpZ25tZW50IHN0YXRlbWVudHMuIFRoaXMgd2lsbCBjb21lIGluIGhhbmR5XG4vLyBmb3IgYXNzaWdubWVudHMgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbkVwLmVtaXRBc3NpZ24gPSBmdW5jdGlvbihsaHMsIHJocykge1xuICB0aGlzLmVtaXQodGhpcy5hc3NpZ24obGhzLCByaHMpKTtcbiAgcmV0dXJuIGxocztcbn07XG5cbi8vIFNob3J0aGFuZCBmb3IgYW4gYXNzaWdubWVudCBzdGF0ZW1lbnQuXG5FcC5hc3NpZ24gPSBmdW5jdGlvbihsaHMsIHJocykge1xuICByZXR1cm4gYi5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgIGIuYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGxocywgcmhzKSk7XG59O1xuXG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBleHByZXNzaW9ucyBsaWtlIGNvbnRleHQubmV4dCxcbi8vIGNvbnRleHQuc2VudCwgYW5kIGNvbnRleHQucnZhbC5cbkVwLmNvbnRleHRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIGNvbXB1dGVkKSB7XG4gIHJldHVybiBiLm1lbWJlckV4cHJlc3Npb24oXG4gICAgdGhpcy5jb250ZXh0SWQsXG4gICAgY29tcHV0ZWQgPyBiLmxpdGVyYWwobmFtZSkgOiBiLmlkZW50aWZpZXIobmFtZSksXG4gICAgISFjb21wdXRlZFxuICApO1xufTtcblxudmFyIHZvbGF0aWxlQ29udGV4dFByb3BlcnR5TmFtZXMgPSB7XG4gIHByZXY6IHRydWUsXG4gIG5leHQ6IHRydWUsXG4gIHNlbnQ6IHRydWUsXG4gIHJ2YWw6IHRydWVcbn07XG5cbi8vIEEgXCJ2b2xhdGlsZVwiIGNvbnRleHQgcHJvcGVydHkgaXMgYSBNZW1iZXJFeHByZXNzaW9uIGxpa2UgY29udGV4dC5zZW50XG4vLyB0aGF0IHNob3VsZCBwcm9iYWJseSBiZSBzdG9yZWQgaW4gYSB0ZW1wb3JhcnkgdmFyaWFibGUgd2hlbiB0aGVyZSdzIGFcbi8vIHBvc3NpYmlsaXR5IHRoZSBwcm9wZXJ0eSB3aWxsIGdldCBvdmVyd3JpdHRlbi5cbkVwLmlzVm9sYXRpbGVDb250ZXh0UHJvcGVydHkgPSBmdW5jdGlvbihleHByKSB7XG4gIGlmIChuLk1lbWJlckV4cHJlc3Npb24uY2hlY2soZXhwcikpIHtcbiAgICBpZiAoZXhwci5jb21wdXRlZCkge1xuICAgICAgLy8gSWYgaXQncyBhIGNvbXB1dGVkIHByb3BlcnR5IHN1Y2ggYXMgY29udGV4dFtjb3VsZEJlQW55dGhpbmddLFxuICAgICAgLy8gYXNzdW1lIHRoZSB3b3JzdCBpbiB0ZXJtcyBvZiB2b2xhdGlsaXR5LlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG4uSWRlbnRpZmllci5jaGVjayhleHByLm9iamVjdCkgJiZcbiAgICAgICAgbi5JZGVudGlmaWVyLmNoZWNrKGV4cHIucHJvcGVydHkpICYmXG4gICAgICAgIGV4cHIub2JqZWN0Lm5hbWUgPT09IHRoaXMuY29udGV4dElkLm5hbWUgJiZcbiAgICAgICAgaGFzT3duLmNhbGwodm9sYXRpbGVDb250ZXh0UHJvcGVydHlOYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwci5wcm9wZXJ0eS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gU2hvcnRoYW5kIGZvciBzZXR0aW5nIGNvbnRleHQucnZhbCBhbmQganVtcGluZyB0byBgY29udGV4dC5zdG9wKClgLlxuRXAuc3RvcCA9IGZ1bmN0aW9uKHJ2YWwpIHtcbiAgaWYgKHJ2YWwpIHtcbiAgICB0aGlzLnNldFJldHVyblZhbHVlKHJ2YWwpO1xuICB9XG5cbiAgdGhpcy5qdW1wKHRoaXMuZmluYWxMb2MpO1xufTtcblxuRXAuc2V0UmV0dXJuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZVBhdGgpIHtcbiAgbi5FeHByZXNzaW9uLmFzc2VydCh2YWx1ZVBhdGgudmFsdWUpO1xuXG4gIHRoaXMuZW1pdEFzc2lnbihcbiAgICB0aGlzLmNvbnRleHRQcm9wZXJ0eShcInJ2YWxcIiksXG4gICAgdGhpcy5leHBsb2RlRXhwcmVzc2lvbih2YWx1ZVBhdGgpXG4gICk7XG59O1xuXG5FcC5jbGVhclBlbmRpbmdFeGNlcHRpb24gPSBmdW5jdGlvbih0cnlMb2MsIGFzc2lnbmVlKSB7XG4gIG4uTGl0ZXJhbC5hc3NlcnQodHJ5TG9jKTtcblxuICB2YXIgY2F0Y2hDYWxsID0gYi5jYWxsRXhwcmVzc2lvbihcbiAgICB0aGlzLmNvbnRleHRQcm9wZXJ0eShcImNhdGNoXCIsIHRydWUpLFxuICAgIFt0cnlMb2NdXG4gICk7XG5cbiAgaWYgKGFzc2lnbmVlKSB7XG4gICAgdGhpcy5lbWl0QXNzaWduKGFzc2lnbmVlLCBjYXRjaENhbGwpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdChjYXRjaENhbGwpO1xuICB9XG59O1xuXG4vLyBFbWl0cyBjb2RlIGZvciBhbiB1bmNvbmRpdGlvbmFsIGp1bXAgdG8gdGhlIGdpdmVuIGxvY2F0aW9uLCBldmVuIGlmIHRoZVxuLy8gZXhhY3QgdmFsdWUgb2YgdGhlIGxvY2F0aW9uIGlzIG5vdCB5ZXQga25vd24uXG5FcC5qdW1wID0gZnVuY3Rpb24odG9Mb2MpIHtcbiAgdGhpcy5lbWl0QXNzaWduKHRoaXMuY29udGV4dFByb3BlcnR5KFwibmV4dFwiKSwgdG9Mb2MpO1xuICB0aGlzLmVtaXQoYi5icmVha1N0YXRlbWVudCgpKTtcbn07XG5cbi8vIENvbmRpdGlvbmFsIGp1bXAuXG5FcC5qdW1wSWYgPSBmdW5jdGlvbih0ZXN0LCB0b0xvYykge1xuICBuLkV4cHJlc3Npb24uYXNzZXJ0KHRlc3QpO1xuICBuLkxpdGVyYWwuYXNzZXJ0KHRvTG9jKTtcblxuICB0aGlzLmVtaXQoYi5pZlN0YXRlbWVudChcbiAgICB0ZXN0LFxuICAgIGIuYmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgdGhpcy5hc3NpZ24odGhpcy5jb250ZXh0UHJvcGVydHkoXCJuZXh0XCIpLCB0b0xvYyksXG4gICAgICBiLmJyZWFrU3RhdGVtZW50KClcbiAgICBdKVxuICApKTtcbn07XG5cbi8vIENvbmRpdGlvbmFsIGp1bXAsIHdpdGggdGhlIGNvbmRpdGlvbiBuZWdhdGVkLlxuRXAuanVtcElmTm90ID0gZnVuY3Rpb24odGVzdCwgdG9Mb2MpIHtcbiAgbi5FeHByZXNzaW9uLmFzc2VydCh0ZXN0KTtcbiAgbi5MaXRlcmFsLmFzc2VydCh0b0xvYyk7XG5cbiAgdmFyIG5lZ2F0ZWRUZXN0O1xuICBpZiAobi5VbmFyeUV4cHJlc3Npb24uY2hlY2sodGVzdCkgJiZcbiAgICAgIHRlc3Qub3BlcmF0b3IgPT09IFwiIVwiKSB7XG4gICAgLy8gQXZvaWQgZG91YmxlIG5lZ2F0aW9uLlxuICAgIG5lZ2F0ZWRUZXN0ID0gdGVzdC5hcmd1bWVudDtcbiAgfSBlbHNlIHtcbiAgICBuZWdhdGVkVGVzdCA9IGIudW5hcnlFeHByZXNzaW9uKFwiIVwiLCB0ZXN0KTtcbiAgfVxuXG4gIHRoaXMuZW1pdChiLmlmU3RhdGVtZW50KFxuICAgIG5lZ2F0ZWRUZXN0LFxuICAgIGIuYmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgdGhpcy5hc3NpZ24odGhpcy5jb250ZXh0UHJvcGVydHkoXCJuZXh0XCIpLCB0b0xvYyksXG4gICAgICBiLmJyZWFrU3RhdGVtZW50KClcbiAgICBdKVxuICApKTtcbn07XG5cbi8vIFJldHVybnMgYSB1bmlxdWUgTWVtYmVyRXhwcmVzc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFuZFxuLy8gcmV0cmlldmUgdGVtcG9yYXJ5IHZhbHVlcy4gU2luY2UgdGhlIG9iamVjdCBvZiB0aGUgbWVtYmVyIGV4cHJlc3Npb24gaXNcbi8vIHRoZSBjb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgcHJlc3VtZWQgdG8gY29leGlzdCBwZWFjZWZ1bGx5IHdpdGggYWxsXG4vLyBvdGhlciBsb2NhbCB2YXJpYWJsZXMsIGFuZCBzaW5jZSB3ZSBqdXN0IGluY3JlbWVudCBgbmV4dFRlbXBJZGBcbi8vIG1vbm90b25pY2FsbHksIHVuaXF1ZW5lc3MgaXMgYXNzdXJlZC5cbnZhciBuZXh0VGVtcElkID0gMDtcbkVwLm1ha2VUZW1wVmFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRQcm9wZXJ0eShcInRcIiArIG5leHRUZW1wSWQrKyk7XG59O1xuXG5FcC5nZXRDb250ZXh0RnVuY3Rpb24gPSBmdW5jdGlvbihpZCkge1xuICB2YXIgZnVuYyA9IGIuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIGlkIHx8IG51bGwvKkFub255bW91cyovLFxuICAgIFt0aGlzLmNvbnRleHRJZF0sXG4gICAgYi5ibG9ja1N0YXRlbWVudChbdGhpcy5nZXREaXNwYXRjaExvb3AoKV0pLFxuICAgIGZhbHNlLCAvLyBOb3QgYSBnZW5lcmF0b3IgYW55bW9yZSFcbiAgICBmYWxzZSAvLyBOb3IgYW4gZXhwcmVzc2lvbi5cbiAgKTtcbiAgZnVuYy5fYWxpYXNGdW5jdGlvbiA9IHRydWU7XG4gIHJldHVybiBmdW5jO1xufTtcblxuLy8gVHVybnMgdGhpcy5saXN0aW5nIGludG8gYSBsb29wIG9mIHRoZSBmb3JtXG4vL1xuLy8gICB3aGlsZSAoMSkgc3dpdGNoIChjb250ZXh0Lm5leHQpIHtcbi8vICAgY2FzZSAwOlxuLy8gICAuLi5cbi8vICAgY2FzZSBuOlxuLy8gICAgIHJldHVybiBjb250ZXh0LnN0b3AoKTtcbi8vICAgfVxuLy9cbi8vIEVhY2ggbWFya2VkIGxvY2F0aW9uIGluIHRoaXMubGlzdGluZyB3aWxsIGNvcnJlc3BvbmQgdG8gb25lIGdlbmVyYXRlZFxuLy8gY2FzZSBzdGF0ZW1lbnQuXG5FcC5nZXREaXNwYXRjaExvb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FzZXMgPSBbXTtcbiAgdmFyIGN1cnJlbnQ7XG5cbiAgLy8gSWYgd2UgZW5jb3VudGVyIGEgYnJlYWssIGNvbnRpbnVlLCBvciByZXR1cm4gc3RhdGVtZW50IGluIGEgc3dpdGNoXG4gIC8vIGNhc2UsIHdlIGNhbiBza2lwIHRoZSByZXN0IG9mIHRoZSBzdGF0ZW1lbnRzIHVudGlsIHRoZSBuZXh0IGNhc2UuXG4gIHZhciBhbHJlYWR5RW5kZWQgPSBmYWxzZTtcblxuICBzZWxmLmxpc3RpbmcuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKSB7XG4gICAgaWYgKHNlbGYubWFya2VkLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBjYXNlcy5wdXNoKGIuc3dpdGNoQ2FzZShcbiAgICAgICAgYi5saXRlcmFsKGkpLFxuICAgICAgICBjdXJyZW50ID0gW10pKTtcbiAgICAgIGFscmVhZHlFbmRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghYWxyZWFkeUVuZGVkKSB7XG4gICAgICBjdXJyZW50LnB1c2goc3RtdCk7XG4gICAgICBpZiAoaXNTd2l0Y2hDYXNlRW5kZXIoc3RtdCkpXG4gICAgICAgIGFscmVhZHlFbmRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBOb3cgdGhhdCB3ZSBrbm93IGhvdyBtYW55IHN0YXRlbWVudHMgdGhlcmUgd2lsbCBiZSBpbiB0aGlzLmxpc3RpbmcsXG4gIC8vIHdlIGNhbiBmaW5hbGx5IHJlc29sdmUgdGhpcy5maW5hbExvYy52YWx1ZS5cbiAgdGhpcy5maW5hbExvYy52YWx1ZSA9IHRoaXMubGlzdGluZy5sZW5ndGg7XG5cbiAgY2FzZXMucHVzaChcbiAgICBiLnN3aXRjaENhc2UodGhpcy5maW5hbExvYywgW1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIFwiZW5kXCIgY2FzZS4uLlxuICAgIF0pLFxuXG4gICAgLy8gU28gdGhhdCB0aGUgcnVudGltZSBjYW4ganVtcCB0byB0aGUgZmluYWwgbG9jYXRpb24gd2l0aG91dCBoYXZpbmdcbiAgICAvLyB0byBrbm93IGl0cyBvZmZzZXQsIHdlIHByb3ZpZGUgdGhlIFwiZW5kXCIgY2FzZSBhcyBhIHN5bm9ueW0uXG4gICAgYi5zd2l0Y2hDYXNlKGIubGl0ZXJhbChcImVuZFwiKSwgW1xuICAgICAgLy8gVGhpcyB3aWxsIGNoZWNrL2NsZWFyIGJvdGggY29udGV4dC50aHJvd24gYW5kIGNvbnRleHQucnZhbC5cbiAgICAgIGIucmV0dXJuU3RhdGVtZW50KFxuICAgICAgICBiLmNhbGxFeHByZXNzaW9uKHRoaXMuY29udGV4dFByb3BlcnR5KFwic3RvcFwiKSwgW10pXG4gICAgICApXG4gICAgXSlcbiAgKTtcblxuICByZXR1cm4gYi53aGlsZVN0YXRlbWVudChcbiAgICBiLmxpdGVyYWwoMSksXG4gICAgYi5zd2l0Y2hTdGF0ZW1lbnQoXG4gICAgICBiLmFzc2lnbm1lbnRFeHByZXNzaW9uKFxuICAgICAgICBcIj1cIixcbiAgICAgICAgdGhpcy5jb250ZXh0UHJvcGVydHkoXCJwcmV2XCIpLFxuICAgICAgICB0aGlzLmNvbnRleHRQcm9wZXJ0eShcIm5leHRcIilcbiAgICAgICksXG4gICAgICBjYXNlc1xuICAgIClcbiAgKTtcbn07XG5cbi8vIFNlZSBjb21tZW50IGFib3ZlIHJlOiBhbHJlYWR5RW5kZWQuXG5mdW5jdGlvbiBpc1N3aXRjaENhc2VFbmRlcihzdG10KSB7XG4gIHJldHVybiBuLkJyZWFrU3RhdGVtZW50LmNoZWNrKHN0bXQpXG4gICAgICB8fCBuLkNvbnRpbnVlU3RhdGVtZW50LmNoZWNrKHN0bXQpXG4gICAgICB8fCBuLlJldHVyblN0YXRlbWVudC5jaGVjayhzdG10KVxuICAgICAgfHwgbi5UaHJvd1N0YXRlbWVudC5jaGVjayhzdG10KTtcbn1cblxuRXAuZ2V0VHJ5TG9jc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudHJ5RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBUbyBhdm9pZCBhZGRpbmcgYSBuZWVkbGVzcyBbXSB0byB0aGUgbWFqb3JpdHkgb2YgcnVudGltZS53cmFwXG4gICAgLy8gYXJndW1lbnQgbGlzdHMsIGZvcmNlIHRoZSBjYWxsZXIgdG8gaGFuZGxlIHRoaXMgY2FzZSBzcGVjaWFsbHkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGFzdExvY1ZhbHVlID0gMDtcblxuICByZXR1cm4gYi5hcnJheUV4cHJlc3Npb24oXG4gICAgdGhpcy50cnlFbnRyaWVzLm1hcChmdW5jdGlvbih0cnlFbnRyeSkge1xuICAgICAgdmFyIHRoaXNMb2NWYWx1ZSA9IHRyeUVudHJ5LmZpcnN0TG9jLnZhbHVlO1xuICAgICAgYXNzZXJ0Lm9rKHRoaXNMb2NWYWx1ZSA+PSBsYXN0TG9jVmFsdWUsIFwidHJ5IGVudHJpZXMgb3V0IG9mIG9yZGVyXCIpO1xuICAgICAgbGFzdExvY1ZhbHVlID0gdGhpc0xvY1ZhbHVlO1xuXG4gICAgICB2YXIgY2UgPSB0cnlFbnRyeS5jYXRjaEVudHJ5O1xuICAgICAgdmFyIGZlID0gdHJ5RW50cnkuZmluYWxseUVudHJ5O1xuXG4gICAgICB2YXIgbG9jcyA9IFtcbiAgICAgICAgdHJ5RW50cnkuZmlyc3RMb2MsXG4gICAgICAgIC8vIFRoZSBudWxsIGhlcmUgbWFrZXMgYSBob2xlIGluIHRoZSBhcnJheS5cbiAgICAgICAgY2UgPyBjZS5maXJzdExvYyA6IG51bGxcbiAgICAgIF07XG5cbiAgICAgIGlmIChmZSkge1xuICAgICAgICBsb2NzWzJdID0gZmUuZmlyc3RMb2M7XG4gICAgICAgIGxvY3NbM10gPSBmZS5hZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGIuYXJyYXlFeHByZXNzaW9uKGxvY3MpO1xuICAgIH0pXG4gICk7XG59O1xuXG4vLyBBbGwgc2lkZSBlZmZlY3RzIG11c3QgYmUgcmVhbGl6ZWQgaW4gb3JkZXIuXG5cbi8vIElmIGFueSBzdWJleHByZXNzaW9uIGhhcmJvcnMgYSBsZWFwLCBhbGwgc3ViZXhwcmVzc2lvbnMgbXVzdCBiZVxuLy8gbmV1dGVyZWQgb2Ygc2lkZSBlZmZlY3RzLlxuXG4vLyBObyBkZXN0cnVjdGl2ZSBtb2RpZmljYXRpb24gb2YgQVNUIG5vZGVzLlxuXG5FcC5leHBsb2RlID0gZnVuY3Rpb24ocGF0aCwgaWdub3JlUmVzdWx0KSB7XG4gIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgdHlwZXMuTm9kZVBhdGgpO1xuXG4gIHZhciBub2RlID0gcGF0aC52YWx1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG4uTm9kZS5hc3NlcnQobm9kZSk7XG5cbiAgaWYgKG4uU3RhdGVtZW50LmNoZWNrKG5vZGUpKVxuICAgIHJldHVybiBzZWxmLmV4cGxvZGVTdGF0ZW1lbnQocGF0aCk7XG5cbiAgaWYgKG4uRXhwcmVzc2lvbi5jaGVjayhub2RlKSlcbiAgICByZXR1cm4gc2VsZi5leHBsb2RlRXhwcmVzc2lvbihwYXRoLCBpZ25vcmVSZXN1bHQpO1xuXG4gIGlmIChuLkRlY2xhcmF0aW9uLmNoZWNrKG5vZGUpKVxuICAgIHRocm93IGdldERlY2xFcnJvcihub2RlKTtcblxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgIHJldHVybiBwYXRoLmdldChcImJvZHlcIikubWFwKFxuICAgICAgc2VsZi5leHBsb2RlU3RhdGVtZW50LFxuICAgICAgc2VsZlxuICAgICk7XG5cbiAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgIHRocm93IGdldERlY2xFcnJvcihub2RlKTtcblxuICAvLyBUaGVzZSBub2RlIHR5cGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZWlyIHBhcmVudCBub2Rlc1xuICAvLyAoT2JqZWN0RXhwcmVzc2lvbiwgU3dpdGNoU3RhdGVtZW50LCBhbmQgVHJ5U3RhdGVtZW50LCByZXNwZWN0aXZlbHkpLlxuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgY2FzZSBcIlN3aXRjaENhc2VcIjpcbiAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbm9kZS50eXBlICsgXCIgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlaXIgcGFyZW50c1wiKTtcblxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwidW5rbm93biBOb2RlIG9mIHR5cGUgXCIgK1xuICAgICAgICBKU09OLnN0cmluZ2lmeShub2RlLnR5cGUpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0RGVjbEVycm9yKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBcImFsbCBkZWNsYXJhdGlvbnMgc2hvdWxkIGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCBpbnRvIFwiICtcbiAgICBcImFzc2lnbm1lbnRzIGJlZm9yZSB0aGUgRXhwbG9kZXIgYmVnYW4gaXRzIHdvcms6IFwiICtcbiAgICBKU09OLnN0cmluZ2lmeShub2RlKSk7XG59XG5cbkVwLmV4cGxvZGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihwYXRoLCBsYWJlbElkKSB7XG4gIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgdHlwZXMuTm9kZVBhdGgpO1xuXG4gIHZhciBzdG10ID0gcGF0aC52YWx1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIG4uU3RhdGVtZW50LmFzc2VydChzdG10KTtcblxuICBpZiAobGFiZWxJZCkge1xuICAgIG4uSWRlbnRpZmllci5hc3NlcnQobGFiZWxJZCk7XG4gIH0gZWxzZSB7XG4gICAgbGFiZWxJZCA9IG51bGw7XG4gIH1cblxuICAvLyBFeHBsb2RlIEJsb2NrU3RhdGVtZW50IG5vZGVzIGV2ZW4gaWYgdGhleSBkbyBub3QgY29udGFpbiBhIHlpZWxkLFxuICAvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgb3IgbmVlZCB0aGUgY3VybHkgYnJhY2VzLlxuICBpZiAobi5CbG9ja1N0YXRlbWVudC5jaGVjayhzdG10KSkge1xuICAgIHJldHVybiBwYXRoLmdldChcImJvZHlcIikuZWFjaChcbiAgICAgIHNlbGYuZXhwbG9kZVN0YXRlbWVudCxcbiAgICAgIHNlbGZcbiAgICApO1xuICB9XG5cbiAgaWYgKCFtZXRhLmNvbnRhaW5zTGVhcChzdG10KSkge1xuICAgIC8vIFRlY2huaWNhbGx5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGF2b2lkIGVtaXR0aW5nIHRoZSBzdGF0ZW1lbnRcbiAgICAvLyBhbHRvZ2V0aGVyIGlmICFtZXRhLmhhc1NpZGVFZmZlY3RzKHN0bXQpLCBidXQgdGhhdCBsZWFkcyB0b1xuICAgIC8vIGNvbmZ1c2luZyBnZW5lcmF0ZWQgY29kZSAoZm9yIGluc3RhbmNlLCBgd2hpbGUgKHRydWUpIHt9YCBqdXN0XG4gICAgLy8gZGlzYXBwZWFycykgYW5kIGlzIHByb2JhYmx5IGEgbW9yZSBhcHByb3ByaWF0ZSBqb2IgZm9yIGEgZGVkaWNhdGVkXG4gICAgLy8gZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHBhc3MuXG4gICAgc2VsZi5lbWl0KHN0bXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoc3RtdC50eXBlKSB7XG4gIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgc2VsZi5leHBsb2RlRXhwcmVzc2lvbihwYXRoLmdldChcImV4cHJlc3Npb25cIiksIHRydWUpO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG5cbiAgICAvLyBEaWQgeW91IGtub3cgeW91IGNhbiBicmVhayBmcm9tIGFueSBsYWJlbGVkIGJsb2NrIHN0YXRlbWVudCBvclxuICAgIC8vIGNvbnRyb2wgc3RydWN0dXJlPyBXZWxsLCB5b3UgY2FuISBOb3RlOiB3aGVuIGEgbGFiZWxlZCBsb29wIGlzXG4gICAgLy8gZW5jb3VudGVyZWQsIHRoZSBsZWFwLkxhYmVsZWRFbnRyeSBjcmVhdGVkIGhlcmUgd2lsbCBpbW1lZGlhdGVseVxuICAgIC8vIGVuY2xvc2UgYSBsZWFwLkxvb3BFbnRyeSBvbiB0aGUgbGVhcCBtYW5hZ2VyJ3Mgc3RhY2ssIGFuZCBib3RoXG4gICAgLy8gZW50cmllcyB3aWxsIGhhdmUgdGhlIHNhbWUgbGFiZWwuIFRob3VnaCB0aGlzIHdvcmtzIGp1c3QgZmluZSwgaXRcbiAgICAvLyBtYXkgc2VlbSBhIGJpdCByZWR1bmRhbnQuIEluIHRoZW9yeSwgd2UgY291bGQgY2hlY2sgaGVyZSB0b1xuICAgIC8vIGRldGVybWluZSBpZiBzdG10IGtub3dzIGhvdyB0byBoYW5kbGUgaXRzIG93biBsYWJlbDsgZm9yIGV4YW1wbGUsXG4gICAgLy8gc3RtdCBoYXBwZW5zIHRvIGJlIGEgV2hpbGVTdGF0ZW1lbnQgYW5kIHNvIHdlIGtub3cgaXQncyBnb2luZyB0b1xuICAgIC8vIGVzdGFibGlzaCBpdHMgb3duIExvb3BFbnRyeSB3aGVuIHdlIGV4cGxvZGUgaXQgKGJlbG93KS4gVGhlbiB0aGlzXG4gICAgLy8gTGFiZWxlZEVudHJ5IHdvdWxkIGJlIHVubmVjZXNzYXJ5LiBBbHRlcm5hdGl2ZWx5LCB3ZSBtaWdodCBiZVxuICAgIC8vIHRlbXB0ZWQgbm90IHRvIHBhc3Mgc3RtdC5sYWJlbCBkb3duIGludG8gc2VsZi5leHBsb2RlU3RhdGVtZW50LFxuICAgIC8vIGJlY2F1c2Ugd2UndmUgaGFuZGxlZCB0aGUgbGFiZWwgaGVyZSwgYnV0IHRoYXQncyBhIG1pc3Rha2UgYmVjYXVzZVxuICAgIC8vIGxhYmVsZWQgbG9vcHMgbWF5IGNvbnRhaW4gbGFiZWxlZCBjb250aW51ZSBzdGF0ZW1lbnRzLCB3aGljaCBpcyBub3RcbiAgICAvLyBzb21ldGhpbmcgd2UgY2FuIGhhbmRsZSBpbiB0aGlzIGdlbmVyaWMgY2FzZS4gQWxsIGluIGFsbCwgSSB0aGluayBhXG4gICAgLy8gbGl0dGxlIHJlZHVuZGFuY3kgZ3JlYXRseSBzaW1wbGlmaWVzIHRoZSBsb2dpYyBvZiB0aGlzIGNhc2UsIHNpbmNlXG4gICAgLy8gaXQncyBjbGVhciB0aGF0IHdlIGhhbmRsZSBhbGwgcG9zc2libGUgTGFiZWxlZFN0YXRlbWVudHMgY29ycmVjdGx5XG4gICAgLy8gaGVyZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgaW50ZXJhY3Qgd2l0aCB0aGUgbGVhcCBtYW5hZ2VyXG4gICAgLy8gdGhlbXNlbHZlcy4gQWxzbyByZW1lbWJlciB0aGF0IGxhYmVscyBhbmQgYnJlYWsvY29udGludWUtdG8tbGFiZWxcbiAgICAvLyBzdGF0ZW1lbnRzIGFyZSByYXJlLCBhbmQgYWxsIG9mIHRoaXMgbG9naWMgaGFwcGVucyBhdCB0cmFuc2Zvcm1cbiAgICAvLyB0aW1lLCBzbyBpdCBoYXMgbm8gYWRkaXRpb25hbCBydW50aW1lIGNvc3QuXG4gICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoXG4gICAgICBuZXcgbGVhcC5MYWJlbGVkRW50cnkoYWZ0ZXIsIHN0bXQubGFiZWwpLFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZXhwbG9kZVN0YXRlbWVudChwYXRoLmdldChcImJvZHlcIiksIHN0bXQubGFiZWwpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBzZWxmLm1hcmsoYWZ0ZXIpO1xuXG4gICAgYnJlYWs7XG5cbiAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgdmFyIGJlZm9yZSA9IGxvYygpO1xuICAgIHZhciBhZnRlciA9IGxvYygpO1xuXG4gICAgc2VsZi5tYXJrKGJlZm9yZSk7XG4gICAgc2VsZi5qdW1wSWZOb3Qoc2VsZi5leHBsb2RlRXhwcmVzc2lvbihwYXRoLmdldChcInRlc3RcIikpLCBhZnRlcik7XG4gICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoXG4gICAgICBuZXcgbGVhcC5Mb29wRW50cnkoYWZ0ZXIsIGJlZm9yZSwgbGFiZWxJZCksXG4gICAgICBmdW5jdGlvbigpIHsgc2VsZi5leHBsb2RlU3RhdGVtZW50KHBhdGguZ2V0KFwiYm9keVwiKSk7IH1cbiAgICApO1xuICAgIHNlbGYuanVtcChiZWZvcmUpO1xuICAgIHNlbGYubWFyayhhZnRlcik7XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiRG9XaGlsZVN0YXRlbWVudFwiOlxuICAgIHZhciBmaXJzdCA9IGxvYygpO1xuICAgIHZhciB0ZXN0ID0gbG9jKCk7XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG5cbiAgICBzZWxmLm1hcmsoZmlyc3QpO1xuICAgIHNlbGYubGVhcE1hbmFnZXIud2l0aEVudHJ5KFxuICAgICAgbmV3IGxlYXAuTG9vcEVudHJ5KGFmdGVyLCB0ZXN0LCBsYWJlbElkKSxcbiAgICAgIGZ1bmN0aW9uKCkgeyBzZWxmLmV4cGxvZGUocGF0aC5nZXQoXCJib2R5XCIpKTsgfVxuICAgICk7XG4gICAgc2VsZi5tYXJrKHRlc3QpO1xuICAgIHNlbGYuanVtcElmKHNlbGYuZXhwbG9kZUV4cHJlc3Npb24ocGF0aC5nZXQoXCJ0ZXN0XCIpKSwgZmlyc3QpO1xuICAgIHNlbGYubWFyayhhZnRlcik7XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgdmFyIGhlYWQgPSBsb2MoKTtcbiAgICB2YXIgdXBkYXRlID0gbG9jKCk7XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG5cbiAgICBpZiAoc3RtdC5pbml0KSB7XG4gICAgICAvLyBXZSBwYXNzIHRydWUgaGVyZSB0byBpbmRpY2F0ZSB0aGF0IGlmIHN0bXQuaW5pdCBpcyBhbiBleHByZXNzaW9uXG4gICAgICAvLyB0aGVuIHdlIGRvIG5vdCBjYXJlIGFib3V0IGl0cyByZXN1bHQuXG4gICAgICBzZWxmLmV4cGxvZGUocGF0aC5nZXQoXCJpbml0XCIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZWxmLm1hcmsoaGVhZCk7XG5cbiAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICBzZWxmLmp1bXBJZk5vdChzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwidGVzdFwiKSksIGFmdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gdGVzdCBtZWFucyBjb250aW51ZSB1bmNvbmRpdGlvbmFsbHkuXG4gICAgfVxuXG4gICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoXG4gICAgICBuZXcgbGVhcC5Mb29wRW50cnkoYWZ0ZXIsIHVwZGF0ZSwgbGFiZWxJZCksXG4gICAgICBmdW5jdGlvbigpIHsgc2VsZi5leHBsb2RlU3RhdGVtZW50KHBhdGguZ2V0KFwiYm9keVwiKSk7IH1cbiAgICApO1xuXG4gICAgc2VsZi5tYXJrKHVwZGF0ZSk7XG5cbiAgICBpZiAoc3RtdC51cGRhdGUpIHtcbiAgICAgIC8vIFdlIHBhc3MgdHJ1ZSBoZXJlIHRvIGluZGljYXRlIHRoYXQgaWYgc3RtdC51cGRhdGUgaXMgYW5cbiAgICAgIC8vIGV4cHJlc3Npb24gdGhlbiB3ZSBkbyBub3QgY2FyZSBhYm91dCBpdHMgcmVzdWx0LlxuICAgICAgc2VsZi5leHBsb2RlKHBhdGguZ2V0KFwidXBkYXRlXCIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZWxmLmp1bXAoaGVhZCk7XG5cbiAgICBzZWxmLm1hcmsoYWZ0ZXIpO1xuXG4gICAgYnJlYWs7XG5cbiAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgbi5JZGVudGlmaWVyLmFzc2VydChzdG10LmxlZnQpO1xuXG4gICAgdmFyIGhlYWQgPSBsb2MoKTtcbiAgICB2YXIgYWZ0ZXIgPSBsb2MoKTtcblxuICAgIHZhciBrZXlJdGVyTmV4dEZuID0gc2VsZi5tYWtlVGVtcFZhcigpO1xuICAgIHNlbGYuZW1pdEFzc2lnbihcbiAgICAgIGtleUl0ZXJOZXh0Rm4sXG4gICAgICBiLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB1dGlsLnJ1bnRpbWVQcm9wZXJ0eShcImtleXNcIiksXG4gICAgICAgIFtzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwicmlnaHRcIikpXVxuICAgICAgKVxuICAgICk7XG5cbiAgICBzZWxmLm1hcmsoaGVhZCk7XG5cbiAgICB2YXIga2V5SW5mb1RtcFZhciA9IHNlbGYubWFrZVRlbXBWYXIoKTtcbiAgICBzZWxmLmp1bXBJZihcbiAgICAgIGIubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgYi5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgICBcIj1cIixcbiAgICAgICAgICBrZXlJbmZvVG1wVmFyLFxuICAgICAgICAgIGIuY2FsbEV4cHJlc3Npb24oa2V5SXRlck5leHRGbiwgW10pXG4gICAgICAgICksXG4gICAgICAgIGIuaWRlbnRpZmllcihcImRvbmVcIiksXG4gICAgICAgIGZhbHNlXG4gICAgICApLFxuICAgICAgYWZ0ZXJcbiAgICApO1xuXG4gICAgc2VsZi5lbWl0QXNzaWduKFxuICAgICAgc3RtdC5sZWZ0LFxuICAgICAgYi5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICBrZXlJbmZvVG1wVmFyLFxuICAgICAgICBiLmlkZW50aWZpZXIoXCJ2YWx1ZVwiKSxcbiAgICAgICAgZmFsc2VcbiAgICAgIClcbiAgICApO1xuXG4gICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoXG4gICAgICBuZXcgbGVhcC5Mb29wRW50cnkoYWZ0ZXIsIGhlYWQsIGxhYmVsSWQpLFxuICAgICAgZnVuY3Rpb24oKSB7IHNlbGYuZXhwbG9kZVN0YXRlbWVudChwYXRoLmdldChcImJvZHlcIikpOyB9XG4gICAgKTtcblxuICAgIHNlbGYuanVtcChoZWFkKTtcblxuICAgIHNlbGYubWFyayhhZnRlcik7XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICBzZWxmLmVtaXRBYnJ1cHRDb21wbGV0aW9uKHtcbiAgICAgIHR5cGU6IFwiYnJlYWtcIixcbiAgICAgIHRhcmdldDogc2VsZi5sZWFwTWFuYWdlci5nZXRCcmVha0xvYyhzdG10LmxhYmVsKVxuICAgIH0pO1xuXG4gICAgYnJlYWs7XG5cbiAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgc2VsZi5lbWl0QWJydXB0Q29tcGxldGlvbih7XG4gICAgICB0eXBlOiBcImNvbnRpbnVlXCIsXG4gICAgICB0YXJnZXQ6IHNlbGYubGVhcE1hbmFnZXIuZ2V0Q29udGludWVMb2Moc3RtdC5sYWJlbClcbiAgICB9KTtcblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgXCJTd2l0Y2hTdGF0ZW1lbnRcIjpcbiAgICAvLyBBbHdheXMgc2F2ZSB0aGUgZGlzY3JpbWluYW50IGludG8gYSB0ZW1wb3JhcnkgdmFyaWFibGUgaW4gY2FzZSB0aGVcbiAgICAvLyB0ZXN0IGV4cHJlc3Npb25zIG92ZXJ3cml0ZSB2YWx1ZXMgbGlrZSBjb250ZXh0LnNlbnQuXG4gICAgdmFyIGRpc2MgPSBzZWxmLmVtaXRBc3NpZ24oXG4gICAgICBzZWxmLm1ha2VUZW1wVmFyKCksXG4gICAgICBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwiZGlzY3JpbWluYW50XCIpKVxuICAgICk7XG5cbiAgICB2YXIgYWZ0ZXIgPSBsb2MoKTtcbiAgICB2YXIgZGVmYXVsdExvYyA9IGxvYygpO1xuICAgIHZhciBjb25kaXRpb24gPSBkZWZhdWx0TG9jO1xuICAgIHZhciBjYXNlTG9jcyA9IFtdO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNhc2VzLCAuY2FzZXMgbWlnaHQgYmUgdW5kZWZpbmVkLlxuICAgIHZhciBjYXNlcyA9IHN0bXQuY2FzZXMgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gY2FzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjID0gY2FzZXNbaV07XG4gICAgICBuLlN3aXRjaENhc2UuYXNzZXJ0KGMpO1xuXG4gICAgICBpZiAoYy50ZXN0KSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGIuY29uZGl0aW9uYWxFeHByZXNzaW9uKFxuICAgICAgICAgIGIuYmluYXJ5RXhwcmVzc2lvbihcIj09PVwiLCBkaXNjLCBjLnRlc3QpLFxuICAgICAgICAgIGNhc2VMb2NzW2ldID0gbG9jKCksXG4gICAgICAgICAgY29uZGl0aW9uXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXNlTG9jc1tpXSA9IGRlZmF1bHRMb2M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5qdW1wKHNlbGYuZXhwbG9kZUV4cHJlc3Npb24oXG4gICAgICBuZXcgdHlwZXMuTm9kZVBhdGgoY29uZGl0aW9uLCBwYXRoLCBcImRpc2NyaW1pbmFudFwiKVxuICAgICkpO1xuXG4gICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoXG4gICAgICBuZXcgbGVhcC5Td2l0Y2hFbnRyeShhZnRlciksXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcGF0aC5nZXQoXCJjYXNlc1wiKS5lYWNoKGZ1bmN0aW9uKGNhc2VQYXRoKSB7XG4gICAgICAgICAgdmFyIGMgPSBjYXNlUGF0aC52YWx1ZTtcbiAgICAgICAgICB2YXIgaSA9IGNhc2VQYXRoLm5hbWU7XG5cbiAgICAgICAgICBzZWxmLm1hcmsoY2FzZUxvY3NbaV0pO1xuXG4gICAgICAgICAgY2FzZVBhdGguZ2V0KFwiY29uc2VxdWVudFwiKS5lYWNoKFxuICAgICAgICAgICAgc2VsZi5leHBsb2RlU3RhdGVtZW50LFxuICAgICAgICAgICAgc2VsZlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBzZWxmLm1hcmsoYWZ0ZXIpO1xuICAgIGlmIChkZWZhdWx0TG9jLnZhbHVlID09PSAtMSkge1xuICAgICAgc2VsZi5tYXJrKGRlZmF1bHRMb2MpO1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGFmdGVyLnZhbHVlLCBkZWZhdWx0TG9jLnZhbHVlKTtcbiAgICB9XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICB2YXIgZWxzZUxvYyA9IHN0bXQuYWx0ZXJuYXRlICYmIGxvYygpO1xuICAgIHZhciBhZnRlciA9IGxvYygpO1xuXG4gICAgc2VsZi5qdW1wSWZOb3QoXG4gICAgICBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwidGVzdFwiKSksXG4gICAgICBlbHNlTG9jIHx8IGFmdGVyXG4gICAgKTtcblxuICAgIHNlbGYuZXhwbG9kZVN0YXRlbWVudChwYXRoLmdldChcImNvbnNlcXVlbnRcIikpO1xuXG4gICAgaWYgKGVsc2VMb2MpIHtcbiAgICAgIHNlbGYuanVtcChhZnRlcik7XG4gICAgICBzZWxmLm1hcmsoZWxzZUxvYyk7XG4gICAgICBzZWxmLmV4cGxvZGVTdGF0ZW1lbnQocGF0aC5nZXQoXCJhbHRlcm5hdGVcIikpO1xuICAgIH1cblxuICAgIHNlbGYubWFyayhhZnRlcik7XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgc2VsZi5lbWl0QWJydXB0Q29tcGxldGlvbih7XG4gICAgICB0eXBlOiBcInJldHVyblwiLFxuICAgICAgdmFsdWU6IHNlbGYuZXhwbG9kZUV4cHJlc3Npb24ocGF0aC5nZXQoXCJhcmd1bWVudFwiKSlcbiAgICB9KTtcblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgXCJXaXRoU3RhdGVtZW50XCI6XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgbm9kZS50eXBlICsgXCIgbm90IHN1cHBvcnRlZCBpbiBnZW5lcmF0b3IgZnVuY3Rpb25zLlwiKTtcblxuICBjYXNlIFwiVHJ5U3RhdGVtZW50XCI6XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IHN0bXQuaGFuZGxlcjtcbiAgICBpZiAoIWhhbmRsZXIgJiYgc3RtdC5oYW5kbGVycykge1xuICAgICAgaGFuZGxlciA9IHN0bXQuaGFuZGxlcnNbMF0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2F0Y2hMb2MgPSBoYW5kbGVyICYmIGxvYygpO1xuICAgIHZhciBjYXRjaEVudHJ5ID0gY2F0Y2hMb2MgJiYgbmV3IGxlYXAuQ2F0Y2hFbnRyeShcbiAgICAgIGNhdGNoTG9jLFxuICAgICAgaGFuZGxlci5wYXJhbVxuICAgICk7XG5cbiAgICB2YXIgZmluYWxseUxvYyA9IHN0bXQuZmluYWxpemVyICYmIGxvYygpO1xuICAgIHZhciBmaW5hbGx5RW50cnkgPSBmaW5hbGx5TG9jICYmXG4gICAgICBuZXcgbGVhcC5GaW5hbGx5RW50cnkoZmluYWxseUxvYywgYWZ0ZXIpO1xuXG4gICAgdmFyIHRyeUVudHJ5ID0gbmV3IGxlYXAuVHJ5RW50cnkoXG4gICAgICBzZWxmLmdldFVubWFya2VkQ3VycmVudExvYygpLFxuICAgICAgY2F0Y2hFbnRyeSxcbiAgICAgIGZpbmFsbHlFbnRyeVxuICAgICk7XG5cbiAgICBzZWxmLnRyeUVudHJpZXMucHVzaCh0cnlFbnRyeSk7XG4gICAgc2VsZi51cGRhdGVDb250ZXh0UHJldkxvYyh0cnlFbnRyeS5maXJzdExvYyk7XG5cbiAgICBzZWxmLmxlYXBNYW5hZ2VyLndpdGhFbnRyeSh0cnlFbnRyeSwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmV4cGxvZGVTdGF0ZW1lbnQocGF0aC5nZXQoXCJibG9ja1wiKSk7XG5cbiAgICAgIGlmIChjYXRjaExvYykge1xuICAgICAgICBpZiAoZmluYWxseUxvYykge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYm90aCBhIGNhdGNoIGJsb2NrIGFuZCBhIGZpbmFsbHkgYmxvY2ssIHRoZW5cbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGVtaXQgdGhlIGNhdGNoIGJsb2NrIGZpcnN0LCB3ZSBuZWVkIHRvIGp1bXAgb3ZlclxuICAgICAgICAgIC8vIGl0IHRvIHRoZSBmaW5hbGx5IGJsb2NrLlxuICAgICAgICAgIHNlbGYuanVtcChmaW5hbGx5TG9jKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZpbmFsbHkgYmxvY2ssIHRoZW4gd2UgbmVlZCB0byBqdW1wIG92ZXIgdGhlXG4gICAgICAgICAgLy8gY2F0Y2ggYmxvY2sgdG8gdGhlIGZhbGwtdGhyb3VnaCBsb2NhdGlvbi5cbiAgICAgICAgICBzZWxmLmp1bXAoYWZ0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi51cGRhdGVDb250ZXh0UHJldkxvYyhzZWxmLm1hcmsoY2F0Y2hMb2MpKTtcblxuICAgICAgICB2YXIgYm9keVBhdGggPSBwYXRoLmdldChcImhhbmRsZXJcIiwgXCJib2R5XCIpO1xuICAgICAgICB2YXIgc2FmZVBhcmFtID0gc2VsZi5tYWtlVGVtcFZhcigpO1xuICAgICAgICBzZWxmLmNsZWFyUGVuZGluZ0V4Y2VwdGlvbih0cnlFbnRyeS5maXJzdExvYywgc2FmZVBhcmFtKTtcblxuICAgICAgICB2YXIgY2F0Y2hTY29wZSA9IGJvZHlQYXRoLnNjb3BlO1xuICAgICAgICB2YXIgY2F0Y2hQYXJhbU5hbWUgPSBoYW5kbGVyLnBhcmFtLm5hbWU7XG4gICAgICAgIG4uQ2F0Y2hDbGF1c2UuYXNzZXJ0KGNhdGNoU2NvcGUubm9kZSk7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjYXRjaFNjb3BlLmxvb2t1cChjYXRjaFBhcmFtTmFtZSksIGNhdGNoU2NvcGUpO1xuXG4gICAgICAgIHR5cGVzLnZpc2l0KGJvZHlQYXRoLCB7XG4gICAgICAgICAgdmlzaXRJZGVudGlmaWVyOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1JlZmVyZW5jZShwYXRoLCBjYXRjaFBhcmFtTmFtZSkgJiZcbiAgICAgICAgICAgICAgICBwYXRoLnNjb3BlLmxvb2t1cChjYXRjaFBhcmFtTmFtZSkgPT09IGNhdGNoU2NvcGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNhZmVQYXJhbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZShwYXRoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdmlzaXRGdW5jdGlvbjogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGguc2NvcGUuZGVjbGFyZXMoY2F0Y2hQYXJhbU5hbWUpKSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgc2NvcGVzIHRoYXQgc2hhZG93IHRoZSBjYXRjaFxuICAgICAgICAgICAgICAvLyBwYXJhbWV0ZXIgd2l0aCB0aGVpciBvd24gZGVjbGFyYXRpb25zLiBUaGlzIGlzbid0XG4gICAgICAgICAgICAgIC8vIGxvZ2ljYWxseSBuZWNlc3NhcnkgYmVjYXVzZSBvZiB0aGUgcGF0aC5zY29wZS5sb29rdXAgd2VcbiAgICAgICAgICAgICAgLy8gZG8gaW4gdmlzaXRJZGVudGlmaWVyLCBidXQgaXQgc2F2ZXMgdGltZS5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5sZWFwTWFuYWdlci53aXRoRW50cnkoY2F0Y2hFbnRyeSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5leHBsb2RlU3RhdGVtZW50KGJvZHlQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5TG9jKSB7XG4gICAgICAgIHNlbGYudXBkYXRlQ29udGV4dFByZXZMb2Moc2VsZi5tYXJrKGZpbmFsbHlMb2MpKTtcblxuICAgICAgICBzZWxmLmxlYXBNYW5hZ2VyLndpdGhFbnRyeShmaW5hbGx5RW50cnksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuZXhwbG9kZVN0YXRlbWVudChwYXRoLmdldChcImZpbmFsaXplclwiKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuZW1pdChiLnJldHVyblN0YXRlbWVudChiLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIHNlbGYuY29udGV4dFByb3BlcnR5KFwiZmluaXNoXCIpLFxuICAgICAgICAgIFtmaW5hbGx5RW50cnkuZmlyc3RMb2NdXG4gICAgICAgICkpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNlbGYubWFyayhhZnRlcik7XG5cbiAgICBicmVhaztcblxuICBjYXNlIFwiVGhyb3dTdGF0ZW1lbnRcIjpcbiAgICBzZWxmLmVtaXQoYi50aHJvd1N0YXRlbWVudChcbiAgICAgIHNlbGYuZXhwbG9kZUV4cHJlc3Npb24ocGF0aC5nZXQoXCJhcmd1bWVudFwiKSlcbiAgICApKTtcblxuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ1bmtub3duIFN0YXRlbWVudCBvZiB0eXBlIFwiICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoc3RtdC50eXBlKSk7XG4gIH1cbn07XG5cbkVwLmVtaXRBYnJ1cHRDb21wbGV0aW9uID0gZnVuY3Rpb24ocmVjb3JkKSB7XG4gIGlmICghaXNWYWxpZENvbXBsZXRpb24ocmVjb3JkKSkge1xuICAgIGFzc2VydC5vayhcbiAgICAgIGZhbHNlLFxuICAgICAgXCJpbnZhbGlkIGNvbXBsZXRpb24gcmVjb3JkOiBcIiArXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHJlY29yZClcbiAgICApO1xuICB9XG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKFxuICAgIHJlY29yZC50eXBlLCBcIm5vcm1hbFwiLFxuICAgIFwibm9ybWFsIGNvbXBsZXRpb25zIGFyZSBub3QgYWJydXB0XCJcbiAgKTtcblxuICB2YXIgYWJydXB0QXJncyA9IFtiLmxpdGVyYWwocmVjb3JkLnR5cGUpXTtcblxuICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgIG4uTGl0ZXJhbC5hc3NlcnQocmVjb3JkLnRhcmdldCk7XG4gICAgYWJydXB0QXJnc1sxXSA9IHJlY29yZC50YXJnZXQ7XG4gIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgaWYgKHJlY29yZC52YWx1ZSkge1xuICAgICAgbi5FeHByZXNzaW9uLmFzc2VydChyZWNvcmQudmFsdWUpO1xuICAgICAgYWJydXB0QXJnc1sxXSA9IHJlY29yZC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXQoXG4gICAgYi5yZXR1cm5TdGF0ZW1lbnQoXG4gICAgICBiLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0aGlzLmNvbnRleHRQcm9wZXJ0eShcImFicnVwdFwiKSxcbiAgICAgICAgYWJydXB0QXJnc1xuICAgICAgKVxuICAgIClcbiAgKTtcbn07XG5cbmZ1bmN0aW9uIGlzVmFsaWRDb21wbGV0aW9uKHJlY29yZCkge1xuICB2YXIgdHlwZSA9IHJlY29yZC50eXBlO1xuXG4gIGlmICh0eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgcmV0dXJuICFoYXNPd24uY2FsbChyZWNvcmQsIFwidGFyZ2V0XCIpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgcmV0dXJuICFoYXNPd24uY2FsbChyZWNvcmQsIFwidmFsdWVcIilcbiAgICAgICAgJiYgbi5MaXRlcmFsLmNoZWNrKHJlY29yZC50YXJnZXQpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgIHR5cGUgPT09IFwidGhyb3dcIikge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChyZWNvcmQsIFwidmFsdWVcIilcbiAgICAgICAgJiYgIWhhc093bi5jYWxsKHJlY29yZCwgXCJ0YXJnZXRcIik7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gTm90IGFsbCBvZmZzZXRzIGludG8gZW1pdHRlci5saXN0aW5nIGFyZSBwb3RlbnRpYWwganVtcCB0YXJnZXRzLiBGb3Jcbi8vIGV4YW1wbGUsIGV4ZWN1dGlvbiB0eXBpY2FsbHkgZmFsbHMgaW50byB0aGUgYmVnaW5uaW5nIG9mIGEgdHJ5IGJsb2NrXG4vLyB3aXRob3V0IGp1bXBpbmcgZGlyZWN0bHkgdGhlcmUuIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGN1cnJlbnQgb2Zmc2V0XG4vLyB3aXRob3V0IG1hcmtpbmcgaXQsIHNvIHRoYXQgYSBzd2l0Y2ggY2FzZSB3aWxsIG5vdCBuZWNlc3NhcmlseSBiZVxuLy8gZ2VuZXJhdGVkIGZvciB0aGlzIG9mZnNldCAoSSBzYXkgXCJub3QgbmVjZXNzYXJpbHlcIiBiZWNhdXNlIHRoZSBzYW1lXG4vLyBsb2NhdGlvbiBtaWdodCBlbmQgdXAgYmVpbmcgbWFya2VkIGluIHRoZSBwcm9jZXNzIG9mIGVtaXR0aW5nIG90aGVyXG4vLyBzdGF0ZW1lbnRzKS4gVGhlcmUncyBubyBsb2dpY2FsIGhhcm0gaW4gbWFya2luZyBzdWNoIGxvY2F0aW9ucyBhcyBqdW1wXG4vLyB0YXJnZXRzLCBidXQgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mIHN3aXRjaCBjYXNlcyBrZWVwcyB0aGUgZ2VuZXJhdGVkXG4vLyBjb2RlIHNob3J0ZXIuXG5FcC5nZXRVbm1hcmtlZEN1cnJlbnRMb2MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGIubGl0ZXJhbCh0aGlzLmxpc3RpbmcubGVuZ3RoKTtcbn07XG5cbi8vIFRoZSBjb250ZXh0LnByZXYgcHJvcGVydHkgdGFrZXMgdGhlIHZhbHVlIG9mIGNvbnRleHQubmV4dCB3aGVuZXZlciB3ZVxuLy8gZXZhbHVhdGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnQgZGlzY3JpbWluYW50LCB3aGljaCBpcyBnZW5lcmFsbHkgZ29vZFxuLy8gZW5vdWdoIGZvciB0cmFja2luZyB0aGUgbGFzdCBsb2NhdGlvbiB3ZSBqdW1wZWQgdG8sIGJ1dCBzb21ldGltZXNcbi8vIGNvbnRleHQucHJldiBuZWVkcyB0byBiZSBtb3JlIHByZWNpc2UsIHN1Y2ggYXMgd2hlbiB3ZSBmYWxsXG4vLyBzdWNjZXNzZnVsbHkgb3V0IG9mIGEgdHJ5IGJsb2NrIGFuZCBpbnRvIGEgZmluYWxseSBibG9jayB3aXRob3V0XG4vLyBqdW1waW5nLiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gdXBkYXRlIGNvbnRleHQucHJldiB0byB0aGUgZnJlc2hlc3Rcbi8vIGF2YWlsYWJsZSBsb2NhdGlvbi4gSWYgd2Ugd2VyZSBpbXBsZW1lbnRpbmcgYSBmdWxsIGludGVycHJldGVyLCB3ZVxuLy8gd291bGQga25vdyB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gd2l0aCBjb21wbGV0ZVxuLy8gcHJlY2lzaW9uIGF0IGFsbCB0aW1lcywgYnV0IHdlIGRvbid0IGhhdmUgdGhhdCBsdXh1cnkgaGVyZSwgYXMgaXQgd291bGRcbi8vIGJlIGNvc3RseSBhbmQgdmVyYm9zZSB0byBzZXQgY29udGV4dC5wcmV2IGJlZm9yZSBldmVyeSBzdGF0ZW1lbnQuXG5FcC51cGRhdGVDb250ZXh0UHJldkxvYyA9IGZ1bmN0aW9uKGxvYykge1xuICBpZiAobG9jKSB7XG4gICAgbi5MaXRlcmFsLmFzc2VydChsb2MpO1xuXG4gICAgaWYgKGxvYy52YWx1ZSA9PT0gLTEpIHtcbiAgICAgIC8vIElmIGFuIHVuaW5pdGlhbGl6ZWQgbG9jYXRpb24gbGl0ZXJhbCB3YXMgcGFzc2VkIGluLCBzZXQgaXRzIHZhbHVlXG4gICAgICAvLyB0byB0aGUgY3VycmVudCB0aGlzLmxpc3RpbmcubGVuZ3RoLlxuICAgICAgbG9jLnZhbHVlID0gdGhpcy5saXN0aW5nLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGFzc2VydCB0aGF0IHRoZSBsb2NhdGlvbiBtYXRjaGVzIHRoZSBjdXJyZW50IG9mZnNldC5cbiAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChsb2MudmFsdWUsIHRoaXMubGlzdGluZy5sZW5ndGgpO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGxvYyA9IHRoaXMuZ2V0VW5tYXJrZWRDdXJyZW50TG9jKCk7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgY29udGV4dC5wcmV2IGlzIHVwIHRvIGRhdGUgaW4gY2FzZSB3ZSBmZWxsIGludG8gdGhpcyB0cnlcbiAgLy8gc3RhdGVtZW50IHdpdGhvdXQganVtcGluZyB0byBpdC4gVE9ETyBDb25zaWRlciBhdm9pZGluZyB0aGlzXG4gIC8vIGFzc2lnbm1lbnQgd2hlbiB3ZSBrbm93IGNvbnRyb2wgbXVzdCBoYXZlIGp1bXBlZCBoZXJlLlxuICB0aGlzLmVtaXRBc3NpZ24odGhpcy5jb250ZXh0UHJvcGVydHkoXCJwcmV2XCIpLCBsb2MpO1xufTtcblxuRXAuZXhwbG9kZUV4cHJlc3Npb24gPSBmdW5jdGlvbihwYXRoLCBpZ25vcmVSZXN1bHQpIHtcbiAgYXNzZXJ0Lm9rKHBhdGggaW5zdGFuY2VvZiB0eXBlcy5Ob2RlUGF0aCk7XG5cbiAgdmFyIGV4cHIgPSBwYXRoLnZhbHVlO1xuICBpZiAoZXhwcikge1xuICAgIG4uRXhwcmVzc2lvbi5hc3NlcnQoZXhwcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXN1bHQ7IC8vIFVzZWQgb3B0aW9uYWxseSBieSBzZXZlcmFsIGNhc2VzIGJlbG93LlxuXG4gIGZ1bmN0aW9uIGZpbmlzaChleHByKSB7XG4gICAgbi5FeHByZXNzaW9uLmFzc2VydChleHByKTtcbiAgICBpZiAoaWdub3JlUmVzdWx0KSB7XG4gICAgICBzZWxmLmVtaXQoZXhwcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBleHByZXNzaW9uIGRvZXMgbm90IGNvbnRhaW4gYSBsZWFwLCB0aGVuIHdlIGVpdGhlciBlbWl0IHRoZVxuICAvLyBleHByZXNzaW9uIGFzIGEgc3RhbmRhbG9uZSBzdGF0ZW1lbnQgb3IgcmV0dXJuIGl0IHdob2xlLlxuICBpZiAoIW1ldGEuY29udGFpbnNMZWFwKGV4cHIpKSB7XG4gICAgcmV0dXJuIGZpbmlzaChleHByKTtcbiAgfVxuXG4gIC8vIElmIGFueSBjaGlsZCBjb250YWlucyBhIGxlYXAgKHN1Y2ggYXMgYSB5aWVsZCBvciBsYWJlbGVkIGNvbnRpbnVlIG9yXG4gIC8vIGJyZWFrIHN0YXRlbWVudCksIHRoZW4gYW55IHNpYmxpbmcgc3ViZXhwcmVzc2lvbnMgd2lsbCBhbG1vc3RcbiAgLy8gY2VydGFpbmx5IGhhdmUgdG8gYmUgZXhwbG9kZWQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIG9yZGVyIG9mIHRoZWlyXG4gIC8vIHNpZGUgZWZmZWN0cyByZWxhdGl2ZSB0byB0aGUgbGVhcGluZyBjaGlsZChyZW4pLlxuICB2YXIgaGFzTGVhcGluZ0NoaWxkcmVuID0gbWV0YS5jb250YWluc0xlYXAub25seUNoaWxkcmVuKGV4cHIpO1xuXG4gIC8vIEluIG9yZGVyIHRvIHNhdmUgdGhlIHJlc3Qgb2YgZXhwbG9kZUV4cHJlc3Npb24gZnJvbSBhIGNvbWJpbmF0b3JpYWxcbiAgLy8gdHJhaW53cmVjayBvZiBzcGVjaWFsIGNhc2VzLCBleHBsb2RlVmlhVGVtcFZhciBpcyByZXNwb25zaWJsZSBmb3JcbiAgLy8gZGVjaWRpbmcgd2hlbiBhIHN1YmV4cHJlc3Npb24gbmVlZHMgdG8gYmUgXCJleHBsb2RlZCxcIiB3aGljaCBpcyBteVxuICAvLyB2ZXJ5IHRlY2huaWNhbCB0ZXJtIGZvciBlbWl0dGluZyB0aGUgc3ViZXhwcmVzc2lvbiBhcyBhbiBhc3NpZ25tZW50XG4gIC8vIHRvIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIGFuZCB0aGUgc3Vic3RpdHV0aW5nIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGVcbiAgLy8gZm9yIHRoZSBvcmlnaW5hbCBzdWJleHByZXNzaW9uLiBUaGluayBvZiBleHBsb2RlZCB2aWV3IGRpYWdyYW1zLCBub3RcbiAgLy8gTWljaGFlbCBCYXkgbW92aWVzLiBUaGUgcG9pbnQgb2YgZXhwbG9kaW5nIHN1YmV4cHJlc3Npb25zIGlzIHRvXG4gIC8vIGNvbnRyb2wgdGhlIHByZWNpc2Ugb3JkZXIgaW4gd2hpY2ggdGhlIGdlbmVyYXRlZCBjb2RlIHJlYWxpemVzIHRoZVxuICAvLyBzaWRlIGVmZmVjdHMgb2YgdGhvc2Ugc3ViZXhwcmVzc2lvbnMuXG4gIGZ1bmN0aW9uIGV4cGxvZGVWaWFUZW1wVmFyKHRlbXBWYXIsIGNoaWxkUGF0aCwgaWdub3JlQ2hpbGRSZXN1bHQpIHtcbiAgICBhc3NlcnQub2soY2hpbGRQYXRoIGluc3RhbmNlb2YgdHlwZXMuTm9kZVBhdGgpO1xuXG4gICAgYXNzZXJ0Lm9rKFxuICAgICAgIWlnbm9yZUNoaWxkUmVzdWx0IHx8ICF0ZW1wVmFyLFxuICAgICAgXCJJZ25vcmluZyB0aGUgcmVzdWx0IG9mIGEgY2hpbGQgZXhwcmVzc2lvbiBidXQgZm9yY2luZyBpdCB0byBcIiArXG4gICAgICAgIFwiYmUgYXNzaWduZWQgdG8gYSB0ZW1wb3JhcnkgdmFyaWFibGU/XCJcbiAgICApO1xuXG4gICAgdmFyIHJlc3VsdCA9IHNlbGYuZXhwbG9kZUV4cHJlc3Npb24oY2hpbGRQYXRoLCBpZ25vcmVDaGlsZFJlc3VsdCk7XG5cbiAgICBpZiAoaWdub3JlQ2hpbGRSZXN1bHQpIHtcbiAgICAgIC8vIFNpZGUgZWZmZWN0cyBhbHJlYWR5IGVtaXR0ZWQgYWJvdmUuXG5cbiAgICB9IGVsc2UgaWYgKHRlbXBWYXIgfHwgKGhhc0xlYXBpbmdDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYuaXNWb2xhdGlsZUNvbnRleHRQcm9wZXJ0eShyZXN1bHQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YS5oYXNTaWRlRWZmZWN0cyhyZXN1bHQpKSkpIHtcbiAgICAgIC8vIElmIHRlbXBWYXIgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYXNzaWduZWRcbiAgICAgIC8vIHRvIGl0LCBldmVuIGlmIHRoZSByZXN1bHQgZG9lcyBub3Qgb3RoZXJ3aXNlIG5lZWQgdG8gYmUgYXNzaWduZWRcbiAgICAgIC8vIHRvIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLiAgV2hlbiBubyB0ZW1wVmFyIGlzIHByb3ZpZGVkLCB3ZSBoYXZlXG4gICAgICAvLyB0aGUgZmxleGliaWxpdHkgdG8gZGVjaWRlIHdoZXRoZXIgYSB0ZW1wb3JhcnkgdmFyaWFibGUgaXMgcmVhbGx5XG4gICAgICAvLyBuZWNlc3NhcnkuICBJbiBnZW5lcmFsLCB0ZW1wb3JhcnkgYXNzaWdubWVudCBpcyByZXF1aXJlZCBvbmx5XG4gICAgICAvLyB3aGVuIHNvbWUgb3RoZXIgY2hpbGQgY29udGFpbnMgYSBsZWFwIGFuZCB0aGUgY2hpbGQgaW4gcXVlc3Rpb25cbiAgICAgIC8vIGlzIGEgY29udGV4dCBwcm9wZXJ0eSBsaWtlICRjdHguc2VudCB0aGF0IG1pZ2h0IGdldCBvdmVyd3JpdHRlblxuICAgICAgLy8gb3IgYW4gZXhwcmVzc2lvbiB3aXRoIHNpZGUgZWZmZWN0cyB0aGF0IG5lZWQgdG8gb2NjdXIgaW4gcHJvcGVyXG4gICAgICAvLyBzZXF1ZW5jZSByZWxhdGl2ZSB0byB0aGUgbGVhcC5cbiAgICAgIHJlc3VsdCA9IHNlbGYuZW1pdEFzc2lnbihcbiAgICAgICAgdGVtcFZhciB8fCBzZWxmLm1ha2VUZW1wVmFyKCksXG4gICAgICAgIHJlc3VsdFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIElmIGlnbm9yZVJlc3VsdCBpcyB0cnVlLCB0aGVuIHdlIG11c3QgdGFrZSBmdWxsIHJlc3BvbnNpYmlsaXR5IGZvclxuICAvLyBlbWl0dGluZyB0aGUgZXhwcmVzc2lvbiB3aXRoIGFsbCBpdHMgc2lkZSBlZmZlY3RzLCBhbmQgd2Ugc2hvdWxkIG5vdFxuICAvLyByZXR1cm4gYSByZXN1bHQuXG5cbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICByZXR1cm4gZmluaXNoKGIubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgIHNlbGYuZXhwbG9kZUV4cHJlc3Npb24ocGF0aC5nZXQoXCJvYmplY3RcIikpLFxuICAgICAgZXhwci5jb21wdXRlZFxuICAgICAgICA/IGV4cGxvZGVWaWFUZW1wVmFyKG51bGwsIHBhdGguZ2V0KFwicHJvcGVydHlcIikpXG4gICAgICAgIDogZXhwci5wcm9wZXJ0eSxcbiAgICAgIGV4cHIuY29tcHV0ZWRcbiAgICApKTtcblxuICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICB2YXIgb2xkQ2FsbGVlUGF0aCA9IHBhdGguZ2V0KFwiY2FsbGVlXCIpO1xuICAgIHZhciBuZXdDYWxsZWUgPSBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKG9sZENhbGxlZVBhdGgpO1xuXG4gICAgLy8gSWYgdGhlIGNhbGxlZSB3YXMgbm90IHByZXZpb3VzbHkgYSBNZW1iZXJFeHByZXNzaW9uLCB0aGVuIHRoZVxuICAgIC8vIENhbGxFeHByZXNzaW9uIHdhcyBcInVucXVhbGlmaWVkLFwiIG1lYW5pbmcgaXRzIGB0aGlzYCBvYmplY3Qgc2hvdWxkXG4gICAgLy8gYmUgdGhlIGdsb2JhbCBvYmplY3QuIElmIHRoZSBleHBsb2RlZCBleHByZXNzaW9uIGhhcyBiZWNvbWUgYVxuICAgIC8vIE1lbWJlckV4cHJlc3Npb24sIHRoZW4gd2UgbmVlZCB0byBmb3JjZSBpdCB0byBiZSB1bnF1YWxpZmllZCBieVxuICAgIC8vIHVzaW5nIHRoZSAoMCwgb2JqZWN0LnByb3BlcnR5KSguLi4pIHRyaWNrOyBvdGhlcndpc2UsIGl0IHdpbGxcbiAgICAvLyByZWNlaXZlIHRoZSBvYmplY3Qgb2YgdGhlIE1lbWJlckV4cHJlc3Npb24gYXMgaXRzIGB0aGlzYCBvYmplY3QuXG4gICAgaWYgKCFuLk1lbWJlckV4cHJlc3Npb24uY2hlY2sob2xkQ2FsbGVlUGF0aC5ub2RlKSAmJlxuICAgICAgICBuLk1lbWJlckV4cHJlc3Npb24uY2hlY2sobmV3Q2FsbGVlKSkge1xuICAgICAgbmV3Q2FsbGVlID0gYi5zZXF1ZW5jZUV4cHJlc3Npb24oW1xuICAgICAgICBiLmxpdGVyYWwoMCksXG4gICAgICAgIG5ld0NhbGxlZVxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaChiLmNhbGxFeHByZXNzaW9uKFxuICAgICAgbmV3Q2FsbGVlLFxuICAgICAgcGF0aC5nZXQoXCJhcmd1bWVudHNcIikubWFwKGZ1bmN0aW9uKGFyZ1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIGV4cGxvZGVWaWFUZW1wVmFyKG51bGwsIGFyZ1BhdGgpO1xuICAgICAgfSlcbiAgICApKTtcblxuICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi5uZXdFeHByZXNzaW9uKFxuICAgICAgZXhwbG9kZVZpYVRlbXBWYXIobnVsbCwgcGF0aC5nZXQoXCJjYWxsZWVcIikpLFxuICAgICAgcGF0aC5nZXQoXCJhcmd1bWVudHNcIikubWFwKGZ1bmN0aW9uKGFyZ1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIGV4cGxvZGVWaWFUZW1wVmFyKG51bGwsIGFyZ1BhdGgpO1xuICAgICAgfSlcbiAgICApKTtcblxuICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgcGF0aC5nZXQoXCJwcm9wZXJ0aWVzXCIpLm1hcChmdW5jdGlvbihwcm9wUGF0aCkge1xuICAgICAgICByZXR1cm4gYi5wcm9wZXJ0eShcbiAgICAgICAgICBwcm9wUGF0aC52YWx1ZS5raW5kLFxuICAgICAgICAgIHByb3BQYXRoLnZhbHVlLmtleSxcbiAgICAgICAgICBleHBsb2RlVmlhVGVtcFZhcihudWxsLCBwcm9wUGF0aC5nZXQoXCJ2YWx1ZVwiKSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKSk7XG5cbiAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi5hcnJheUV4cHJlc3Npb24oXG4gICAgICBwYXRoLmdldChcImVsZW1lbnRzXCIpLm1hcChmdW5jdGlvbihlbGVtUGF0aCkge1xuICAgICAgICByZXR1cm4gZXhwbG9kZVZpYVRlbXBWYXIobnVsbCwgZWxlbVBhdGgpO1xuICAgICAgfSlcbiAgICApKTtcblxuICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgdmFyIGxhc3RJbmRleCA9IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMTtcblxuICAgIHBhdGguZ2V0KFwiZXhwcmVzc2lvbnNcIikuZWFjaChmdW5jdGlvbihleHByUGF0aCkge1xuICAgICAgaWYgKGV4cHJQYXRoLm5hbWUgPT09IGxhc3RJbmRleCkge1xuICAgICAgICByZXN1bHQgPSBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKGV4cHJQYXRoLCBpZ25vcmVSZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5leHBsb2RlRXhwcmVzc2lvbihleHByUGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgIHZhciBhZnRlciA9IGxvYygpO1xuXG4gICAgaWYgKCFpZ25vcmVSZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IHNlbGYubWFrZVRlbXBWYXIoKTtcbiAgICB9XG5cbiAgICB2YXIgbGVmdCA9IGV4cGxvZGVWaWFUZW1wVmFyKHJlc3VsdCwgcGF0aC5nZXQoXCJsZWZ0XCIpKTtcblxuICAgIGlmIChleHByLm9wZXJhdG9yID09PSBcIiYmXCIpIHtcbiAgICAgIHNlbGYuanVtcElmTm90KGxlZnQsIGFmdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGV4cHIub3BlcmF0b3IsIFwifHxcIik7XG4gICAgICBzZWxmLmp1bXBJZihsZWZ0LCBhZnRlcik7XG4gICAgfVxuXG4gICAgZXhwbG9kZVZpYVRlbXBWYXIocmVzdWx0LCBwYXRoLmdldChcInJpZ2h0XCIpLCBpZ25vcmVSZXN1bHQpO1xuXG4gICAgc2VsZi5tYXJrKGFmdGVyKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgIHZhciBlbHNlTG9jID0gbG9jKCk7XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG4gICAgdmFyIHRlc3QgPSBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwidGVzdFwiKSk7XG5cbiAgICBzZWxmLmp1bXBJZk5vdCh0ZXN0LCBlbHNlTG9jKTtcblxuICAgIGlmICghaWdub3JlUmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBzZWxmLm1ha2VUZW1wVmFyKCk7XG4gICAgfVxuXG4gICAgZXhwbG9kZVZpYVRlbXBWYXIocmVzdWx0LCBwYXRoLmdldChcImNvbnNlcXVlbnRcIiksIGlnbm9yZVJlc3VsdCk7XG4gICAgc2VsZi5qdW1wKGFmdGVyKTtcblxuICAgIHNlbGYubWFyayhlbHNlTG9jKTtcbiAgICBleHBsb2RlVmlhVGVtcFZhcihyZXN1bHQsIHBhdGguZ2V0KFwiYWx0ZXJuYXRlXCIpLCBpZ25vcmVSZXN1bHQpO1xuXG4gICAgc2VsZi5tYXJrKGFmdGVyKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi51bmFyeUV4cHJlc3Npb24oXG4gICAgICBleHByLm9wZXJhdG9yLFxuICAgICAgLy8gQ2FuJ3QgKGFuZCBkb24ndCBuZWVkIHRvKSBicmVhayB1cCB0aGUgc3ludGF4IG9mIHRoZSBhcmd1bWVudC5cbiAgICAgIC8vIFRoaW5rIGFib3V0IGRlbGV0ZSBhW2JdLlxuICAgICAgc2VsZi5leHBsb2RlRXhwcmVzc2lvbihwYXRoLmdldChcImFyZ3VtZW50XCIpKSxcbiAgICAgICEhZXhwci5wcmVmaXhcbiAgICApKTtcblxuICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi5iaW5hcnlFeHByZXNzaW9uKFxuICAgICAgZXhwci5vcGVyYXRvcixcbiAgICAgIGV4cGxvZGVWaWFUZW1wVmFyKG51bGwsIHBhdGguZ2V0KFwibGVmdFwiKSksXG4gICAgICBleHBsb2RlVmlhVGVtcFZhcihudWxsLCBwYXRoLmdldChcInJpZ2h0XCIpKVxuICAgICkpO1xuXG4gIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBmaW5pc2goYi5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgIGV4cHIub3BlcmF0b3IsXG4gICAgICBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwibGVmdFwiKSksXG4gICAgICBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwicmlnaHRcIikpXG4gICAgKSk7XG5cbiAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICByZXR1cm4gZmluaXNoKGIudXBkYXRlRXhwcmVzc2lvbihcbiAgICAgIGV4cHIub3BlcmF0b3IsXG4gICAgICBzZWxmLmV4cGxvZGVFeHByZXNzaW9uKHBhdGguZ2V0KFwiYXJndW1lbnRcIikpLFxuICAgICAgZXhwci5wcmVmaXhcbiAgICApKTtcblxuICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgdmFyIGFmdGVyID0gbG9jKCk7XG4gICAgdmFyIGFyZyA9IGV4cHIuYXJndW1lbnQgJiYgc2VsZi5leHBsb2RlRXhwcmVzc2lvbihwYXRoLmdldChcImFyZ3VtZW50XCIpKTtcblxuICAgIGlmIChhcmcgJiYgZXhwci5kZWxlZ2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHNlbGYubWFrZVRlbXBWYXIoKTtcblxuICAgICAgc2VsZi5lbWl0KGIucmV0dXJuU3RhdGVtZW50KGIuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgIHNlbGYuY29udGV4dFByb3BlcnR5KFwiZGVsZWdhdGVZaWVsZFwiKSwgW1xuICAgICAgICAgIGFyZyxcbiAgICAgICAgICBiLmxpdGVyYWwocmVzdWx0LnByb3BlcnR5Lm5hbWUpLFxuICAgICAgICAgIGFmdGVyXG4gICAgICAgIF1cbiAgICAgICkpKTtcblxuICAgICAgc2VsZi5tYXJrKGFmdGVyKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXRBc3NpZ24oc2VsZi5jb250ZXh0UHJvcGVydHkoXCJuZXh0XCIpLCBhZnRlcik7XG4gICAgc2VsZi5lbWl0KGIucmV0dXJuU3RhdGVtZW50KGFyZyB8fCBudWxsKSk7XG4gICAgc2VsZi5tYXJrKGFmdGVyKTtcblxuICAgIHJldHVybiBzZWxmLmNvbnRleHRQcm9wZXJ0eShcInNlbnRcIik7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInVua25vd24gRXhwcmVzc2lvbiBvZiB0eXBlIFwiICtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZXhwci50eXBlKSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCJhc3QtdHlwZXNcIik7XG52YXIgbiA9IHR5cGVzLm5hbWVkVHlwZXM7XG52YXIgYiA9IHR5cGVzLmJ1aWxkZXJzO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIFRoZSBob2lzdCBmdW5jdGlvbiB0YWtlcyBhIEZ1bmN0aW9uRXhwcmVzc2lvbiBvciBGdW5jdGlvbkRlY2xhcmF0aW9uXG4vLyBhbmQgcmVwbGFjZXMgYW55IERlY2xhcmF0aW9uIG5vZGVzIGluIGl0cyBib2R5IHdpdGggYXNzaWdubWVudHMsIHRoZW5cbi8vIHJldHVybnMgYSBWYXJpYWJsZURlY2xhcmF0aW9uIGNvbnRhaW5pbmcganVzdCB0aGUgbmFtZXMgb2YgdGhlIHJlbW92ZWRcbi8vIGRlY2xhcmF0aW9ucy5cbmV4cG9ydHMuaG9pc3QgPSBmdW5jdGlvbihmdW5QYXRoKSB7XG4gIGFzc2VydC5vayhmdW5QYXRoIGluc3RhbmNlb2YgdHlwZXMuTm9kZVBhdGgpO1xuICBuLkZ1bmN0aW9uLmFzc2VydChmdW5QYXRoLnZhbHVlKTtcblxuICB2YXIgdmFycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHZhckRlY2xUb0V4cHIodmRlYywgaW5jbHVkZUlkZW50aWZpZXJzKSB7XG4gICAgbi5WYXJpYWJsZURlY2xhcmF0aW9uLmFzc2VydCh2ZGVjKTtcbiAgICB2YXIgZXhwcnMgPSBbXTtcblxuICAgIHZkZWMuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVjKSB7XG4gICAgICB2YXJzW2RlYy5pZC5uYW1lXSA9IGRlYy5pZDtcblxuICAgICAgaWYgKGRlYy5pbml0KSB7XG4gICAgICAgIGV4cHJzLnB1c2goYi5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgICBcIj1cIiwgZGVjLmlkLCBkZWMuaW5pdFxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIGV4cHJzLnB1c2goZGVjLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChleHBycy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChleHBycy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gZXhwcnNbMF07XG5cbiAgICByZXR1cm4gYi5zZXF1ZW5jZUV4cHJlc3Npb24oZXhwcnMpO1xuICB9XG5cbiAgdHlwZXMudmlzaXQoZnVuUGF0aC5nZXQoXCJib2R5XCIpLCB7XG4gICAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgZXhwciA9IHZhckRlY2xUb0V4cHIocGF0aC52YWx1ZSwgZmFsc2UpO1xuICAgICAgaWYgKGV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgcGF0aC5yZXBsYWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoaXMgZXhwcmVzc2lvbiBhbnkgZnVydGhlciBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXJlIGNhbid0IGJlIGFueSBuZXcgZGVjbGFyYXRpb25zIGluc2lkZSBhbiBleHByZXNzaW9uLlxuICAgICAgICByZXR1cm4gYi5leHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSB0aGUgb3JpZ2luYWwgbm9kZSBoYXMgYmVlbiBlaXRoZXIgcmVtb3ZlZCBvciByZXBsYWNlZCxcbiAgICAgIC8vIGF2b2lkIHRyYXZlcnNpbmcgaXQgYW55IGZ1cnRoZXIuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHZpc2l0Rm9yU3RhdGVtZW50OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgaW5pdCA9IHBhdGgudmFsdWUuaW5pdDtcbiAgICAgIGlmIChuLlZhcmlhYmxlRGVjbGFyYXRpb24uY2hlY2soaW5pdCkpIHtcbiAgICAgICAgcGF0aC5nZXQoXCJpbml0XCIpLnJlcGxhY2UodmFyRGVjbFRvRXhwcihpbml0LCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmF2ZXJzZShwYXRoKTtcbiAgICB9LFxuXG4gICAgdmlzaXRGb3JJblN0YXRlbWVudDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGxlZnQgPSBwYXRoLnZhbHVlLmxlZnQ7XG4gICAgICBpZiAobi5WYXJpYWJsZURlY2xhcmF0aW9uLmNoZWNrKGxlZnQpKSB7XG4gICAgICAgIHBhdGguZ2V0KFwibGVmdFwiKS5yZXBsYWNlKHZhckRlY2xUb0V4cHIobGVmdCwgdHJ1ZSkpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmF2ZXJzZShwYXRoKTtcbiAgICB9LFxuXG4gICAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhdGgudmFsdWU7XG4gICAgICB2YXJzW25vZGUuaWQubmFtZV0gPSBub2RlLmlkO1xuXG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhdGgucGFyZW50Lm5vZGU7XG4gICAgICB2YXIgYXNzaWdubWVudCA9IGIuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgYi5hc3NpZ25tZW50RXhwcmVzc2lvbihcbiAgICAgICAgICBcIj1cIixcbiAgICAgICAgICBub2RlLmlkLFxuICAgICAgICAgIGIuZnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgbm9kZS5pZCxcbiAgICAgICAgICAgIG5vZGUucGFyYW1zLFxuICAgICAgICAgICAgbm9kZS5ib2R5LFxuICAgICAgICAgICAgbm9kZS5nZW5lcmF0b3IsXG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb25cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIGlmIChuLkJsb2NrU3RhdGVtZW50LmNoZWNrKHBhdGgucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgIC8vIEluc2VydCB0aGUgYXNzaWdubWVudCBmb3JtIGJlZm9yZSB0aGUgZmlyc3Qgc3RhdGVtZW50IGluIHRoZVxuICAgICAgICAvLyBlbmNsb3NpbmcgYmxvY2suXG4gICAgICAgIHBhdGgucGFyZW50LmdldChcImJvZHlcIikudW5zaGlmdChhc3NpZ25tZW50KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG5vdyB0aGF0IHdlJ3ZlIGluc2VydGVkIHRoZVxuICAgICAgICAvLyBlcXVpdmFsZW50IGFzc2lnbm1lbnQgZm9ybSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBibG9jay5cbiAgICAgICAgcGF0aC5yZXBsYWNlKCk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgYSBibG9jayBzdGF0ZW1lbnQsIHRoZW4gd2UgY2FuIGp1c3RcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgZGVjbGFyYXRpb24gd2l0aCB0aGUgZXF1aXZhbGVudCBhc3NpZ25tZW50IGZvcm1cbiAgICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCBob2lzdGluZyBpdC5cbiAgICAgICAgcGF0aC5yZXBsYWNlKGFzc2lnbm1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBob2lzdCB2YXJpYWJsZXMgb3V0IG9mIGlubmVyIGZ1bmN0aW9ucy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdmlzaXRGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb24gZXhwcmVzc2lvbnMuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGFyYW1OYW1lcyA9IHt9O1xuICBmdW5QYXRoLmdldChcInBhcmFtc1wiKS5lYWNoKGZ1bmN0aW9uKHBhcmFtUGF0aCkge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtUGF0aC52YWx1ZTtcbiAgICBpZiAobi5JZGVudGlmaWVyLmNoZWNrKHBhcmFtKSkge1xuICAgICAgcGFyYW1OYW1lc1twYXJhbS5uYW1lXSA9IHBhcmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYXJpYWJsZXMgZGVjbGFyZWQgYnkgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIgcGF0dGVybnMgd2lsbCBiZVxuICAgICAgLy8gaGFybWxlc3NseSByZS1kZWNsYXJlZC5cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBkZWNsYXJhdGlvbnMgPSBbXTtcblxuICBPYmplY3Qua2V5cyh2YXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKHBhcmFtTmFtZXMsIG5hbWUpKSB7XG4gICAgICBkZWNsYXJhdGlvbnMucHVzaChiLnZhcmlhYmxlRGVjbGFyYXRvcih2YXJzW25hbWVdLCBudWxsKSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsOyAvLyBCZSBzdXJlIHRvIGhhbmRsZSB0aGlzIGNhc2UhXG4gIH1cblxuICByZXR1cm4gYi52YXJpYWJsZURlY2xhcmF0aW9uKFwidmFyXCIsIGRlY2xhcmF0aW9ucyk7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiYXN0LXR5cGVzXCIpO1xudmFyIG4gPSB0eXBlcy5uYW1lZFR5cGVzO1xudmFyIGIgPSB0eXBlcy5idWlsZGVycztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpLmluaGVyaXRzO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEVudHJ5KCkge1xuICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIEVudHJ5KTtcbn1cblxuZnVuY3Rpb24gRnVuY3Rpb25FbnRyeShyZXR1cm5Mb2MpIHtcbiAgRW50cnkuY2FsbCh0aGlzKTtcbiAgbi5MaXRlcmFsLmFzc2VydChyZXR1cm5Mb2MpO1xuICB0aGlzLnJldHVybkxvYyA9IHJldHVybkxvYztcbn1cblxuaW5oZXJpdHMoRnVuY3Rpb25FbnRyeSwgRW50cnkpO1xuZXhwb3J0cy5GdW5jdGlvbkVudHJ5ID0gRnVuY3Rpb25FbnRyeTtcblxuZnVuY3Rpb24gTG9vcEVudHJ5KGJyZWFrTG9jLCBjb250aW51ZUxvYywgbGFiZWwpIHtcbiAgRW50cnkuY2FsbCh0aGlzKTtcblxuICBuLkxpdGVyYWwuYXNzZXJ0KGJyZWFrTG9jKTtcbiAgbi5MaXRlcmFsLmFzc2VydChjb250aW51ZUxvYyk7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgbi5JZGVudGlmaWVyLmFzc2VydChsYWJlbCk7XG4gIH0gZWxzZSB7XG4gICAgbGFiZWwgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5icmVha0xvYyA9IGJyZWFrTG9jO1xuICB0aGlzLmNvbnRpbnVlTG9jID0gY29udGludWVMb2M7XG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuaW5oZXJpdHMoTG9vcEVudHJ5LCBFbnRyeSk7XG5leHBvcnRzLkxvb3BFbnRyeSA9IExvb3BFbnRyeTtcblxuZnVuY3Rpb24gU3dpdGNoRW50cnkoYnJlYWtMb2MpIHtcbiAgRW50cnkuY2FsbCh0aGlzKTtcbiAgbi5MaXRlcmFsLmFzc2VydChicmVha0xvYyk7XG4gIHRoaXMuYnJlYWtMb2MgPSBicmVha0xvYztcbn1cblxuaW5oZXJpdHMoU3dpdGNoRW50cnksIEVudHJ5KTtcbmV4cG9ydHMuU3dpdGNoRW50cnkgPSBTd2l0Y2hFbnRyeTtcblxuZnVuY3Rpb24gVHJ5RW50cnkoZmlyc3RMb2MsIGNhdGNoRW50cnksIGZpbmFsbHlFbnRyeSkge1xuICBFbnRyeS5jYWxsKHRoaXMpO1xuXG4gIG4uTGl0ZXJhbC5hc3NlcnQoZmlyc3RMb2MpO1xuXG4gIGlmIChjYXRjaEVudHJ5KSB7XG4gICAgYXNzZXJ0Lm9rKGNhdGNoRW50cnkgaW5zdGFuY2VvZiBDYXRjaEVudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBjYXRjaEVudHJ5ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICBhc3NlcnQub2soZmluYWxseUVudHJ5IGluc3RhbmNlb2YgRmluYWxseUVudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICB9XG5cbiAgLy8gSGF2ZSB0byBoYXZlIG9uZSBvciB0aGUgb3RoZXIgKG9yIGJvdGgpLlxuICBhc3NlcnQub2soY2F0Y2hFbnRyeSB8fCBmaW5hbGx5RW50cnkpO1xuXG4gIHRoaXMuZmlyc3RMb2MgPSBmaXJzdExvYztcbiAgdGhpcy5jYXRjaEVudHJ5ID0gY2F0Y2hFbnRyeTtcbiAgdGhpcy5maW5hbGx5RW50cnkgPSBmaW5hbGx5RW50cnk7XG59XG5cbmluaGVyaXRzKFRyeUVudHJ5LCBFbnRyeSk7XG5leHBvcnRzLlRyeUVudHJ5ID0gVHJ5RW50cnk7XG5cbmZ1bmN0aW9uIENhdGNoRW50cnkoZmlyc3RMb2MsIHBhcmFtSWQpIHtcbiAgRW50cnkuY2FsbCh0aGlzKTtcblxuICBuLkxpdGVyYWwuYXNzZXJ0KGZpcnN0TG9jKTtcbiAgbi5JZGVudGlmaWVyLmFzc2VydChwYXJhbUlkKTtcblxuICB0aGlzLmZpcnN0TG9jID0gZmlyc3RMb2M7XG4gIHRoaXMucGFyYW1JZCA9IHBhcmFtSWQ7XG59XG5cbmluaGVyaXRzKENhdGNoRW50cnksIEVudHJ5KTtcbmV4cG9ydHMuQ2F0Y2hFbnRyeSA9IENhdGNoRW50cnk7XG5cbmZ1bmN0aW9uIEZpbmFsbHlFbnRyeShmaXJzdExvYywgYWZ0ZXJMb2MpIHtcbiAgRW50cnkuY2FsbCh0aGlzKTtcbiAgbi5MaXRlcmFsLmFzc2VydChmaXJzdExvYyk7XG4gIG4uTGl0ZXJhbC5hc3NlcnQoYWZ0ZXJMb2MpO1xuICB0aGlzLmZpcnN0TG9jID0gZmlyc3RMb2M7XG4gIHRoaXMuYWZ0ZXJMb2MgPSBhZnRlckxvYztcbn1cblxuaW5oZXJpdHMoRmluYWxseUVudHJ5LCBFbnRyeSk7XG5leHBvcnRzLkZpbmFsbHlFbnRyeSA9IEZpbmFsbHlFbnRyeTtcblxuZnVuY3Rpb24gTGFiZWxlZEVudHJ5KGJyZWFrTG9jLCBsYWJlbCkge1xuICBFbnRyeS5jYWxsKHRoaXMpO1xuXG4gIG4uTGl0ZXJhbC5hc3NlcnQoYnJlYWtMb2MpO1xuICBuLklkZW50aWZpZXIuYXNzZXJ0KGxhYmVsKTtcblxuICB0aGlzLmJyZWFrTG9jID0gYnJlYWtMb2M7XG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuaW5oZXJpdHMoTGFiZWxlZEVudHJ5LCBFbnRyeSk7XG5leHBvcnRzLkxhYmVsZWRFbnRyeSA9IExhYmVsZWRFbnRyeTtcblxuZnVuY3Rpb24gTGVhcE1hbmFnZXIoZW1pdHRlcikge1xuICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIExlYXBNYW5hZ2VyKTtcblxuICB2YXIgRW1pdHRlciA9IHJlcXVpcmUoXCIuL2VtaXRcIikuRW1pdHRlcjtcbiAgYXNzZXJ0Lm9rKGVtaXR0ZXIgaW5zdGFuY2VvZiBFbWl0dGVyKTtcblxuICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICB0aGlzLmVudHJ5U3RhY2sgPSBbbmV3IEZ1bmN0aW9uRW50cnkoZW1pdHRlci5maW5hbExvYyldO1xufVxuXG52YXIgTE1wID0gTGVhcE1hbmFnZXIucHJvdG90eXBlO1xuZXhwb3J0cy5MZWFwTWFuYWdlciA9IExlYXBNYW5hZ2VyO1xuXG5MTXAud2l0aEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGNhbGxiYWNrKSB7XG4gIGFzc2VydC5vayhlbnRyeSBpbnN0YW5jZW9mIEVudHJ5KTtcbiAgdGhpcy5lbnRyeVN0YWNrLnB1c2goZW50cnkpO1xuICB0cnkge1xuICAgIGNhbGxiYWNrLmNhbGwodGhpcy5lbWl0dGVyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB2YXIgcG9wcGVkID0gdGhpcy5lbnRyeVN0YWNrLnBvcCgpO1xuICAgIGFzc2VydC5zdHJpY3RFcXVhbChwb3BwZWQsIGVudHJ5KTtcbiAgfVxufTtcblxuTE1wLl9maW5kTGVhcExvY2F0aW9uID0gZnVuY3Rpb24ocHJvcGVydHksIGxhYmVsKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmVudHJ5U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJ5U3RhY2tbaV07XG4gICAgdmFyIGxvYyA9IGVudHJ5W3Byb3BlcnR5XTtcbiAgICBpZiAobG9jKSB7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgaWYgKGVudHJ5LmxhYmVsICYmXG4gICAgICAgICAgICBlbnRyeS5sYWJlbC5uYW1lID09PSBsYWJlbC5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbnRyeSBpbnN0YW5jZW9mIExhYmVsZWRFbnRyeSkge1xuICAgICAgICAvLyBJZ25vcmUgTGFiZWxlZEVudHJ5IGVudHJpZXMgdW5sZXNzIHdlIGFyZSBhY3R1YWxseSBicmVha2luZyB0b1xuICAgICAgICAvLyBhIGxhYmVsLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbkxNcC5nZXRCcmVha0xvYyA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gIHJldHVybiB0aGlzLl9maW5kTGVhcExvY2F0aW9uKFwiYnJlYWtMb2NcIiwgbGFiZWwpO1xufTtcblxuTE1wLmdldENvbnRpbnVlTG9jID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgcmV0dXJuIHRoaXMuX2ZpbmRMZWFwTG9jYXRpb24oXCJjb250aW51ZUxvY1wiLCBsYWJlbCk7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgbSA9IHJlcXVpcmUoXCJwcml2YXRlXCIpLm1ha2VBY2Nlc3NvcigpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcImFzdC10eXBlc1wiKTtcbnZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xudmFyIG4gPSB0eXBlcy5uYW1lZFR5cGVzO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUocHJvcGVydHlOYW1lLCBrbm93blR5cGVzKSB7XG4gIGZ1bmN0aW9uIG9ubHlDaGlsZHJlbihub2RlKSB7XG4gICAgbi5Ob2RlLmFzc2VydChub2RlKTtcblxuICAgIC8vIEFzc3VtZSBubyBzaWRlIGVmZmVjdHMgdW50aWwgd2UgZmluZCBvdXQgb3RoZXJ3aXNlLlxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrKGNoaWxkKSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkuY2hlY2soY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLnNvbWUoY2hlY2spO1xuICAgICAgfSBlbHNlIGlmIChuLk5vZGUuY2hlY2soY2hpbGQpKSB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdHlwZXMuZWFjaEZpZWxkKG5vZGUsIGZ1bmN0aW9uKG5hbWUsIGNoaWxkKSB7XG4gICAgICBjaGVjayhjaGlsZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZGljYXRlKG5vZGUpIHtcbiAgICBuLk5vZGUuYXNzZXJ0KG5vZGUpO1xuXG4gICAgdmFyIG1ldGEgPSBtKG5vZGUpO1xuICAgIGlmIChoYXNPd24uY2FsbChtZXRhLCBwcm9wZXJ0eU5hbWUpKVxuICAgICAgcmV0dXJuIG1ldGFbcHJvcGVydHlOYW1lXTtcblxuICAgIC8vIENlcnRhaW4gdHlwZXMgYXJlIFwib3BhcXVlLFwiIHdoaWNoIG1lYW5zIHRoZXkgaGF2ZSBubyBzaWRlXG4gICAgLy8gZWZmZWN0cyBvciBsZWFwcyBhbmQgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGVpciBzdWJleHByZXNzaW9ucy5cbiAgICBpZiAoaGFzT3duLmNhbGwob3BhcXVlVHlwZXMsIG5vZGUudHlwZSkpXG4gICAgICByZXR1cm4gbWV0YVtwcm9wZXJ0eU5hbWVdID0gZmFsc2U7XG5cbiAgICBpZiAoaGFzT3duLmNhbGwoa25vd25UeXBlcywgbm9kZS50eXBlKSlcbiAgICAgIHJldHVybiBtZXRhW3Byb3BlcnR5TmFtZV0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGFbcHJvcGVydHlOYW1lXSA9IG9ubHlDaGlsZHJlbihub2RlKTtcbiAgfVxuXG4gIHByZWRpY2F0ZS5vbmx5Q2hpbGRyZW4gPSBvbmx5Q2hpbGRyZW47XG5cbiAgcmV0dXJuIHByZWRpY2F0ZTtcbn1cblxudmFyIG9wYXF1ZVR5cGVzID0ge1xuICBGdW5jdGlvbkV4cHJlc3Npb246IHRydWVcbn07XG5cbi8vIFRoZXNlIHR5cGVzIHBvdGVudGlhbGx5IGhhdmUgc2lkZSBlZmZlY3RzIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBzaWRlXG4vLyBlZmZlY3RzIHRoZWlyIHN1YmV4cHJlc3Npb25zIGhhdmUuXG52YXIgc2lkZUVmZmVjdFR5cGVzID0ge1xuICBDYWxsRXhwcmVzc2lvbjogdHJ1ZSwgLy8gQW55dGhpbmcgY291bGQgaGFwcGVuIVxuICBGb3JJblN0YXRlbWVudDogdHJ1ZSwgLy8gTW9kaWZpZXMgdGhlIGtleSB2YXJpYWJsZS5cbiAgVW5hcnlFeHByZXNzaW9uOiB0cnVlLCAvLyBUaGluayBkZWxldGUuXG4gIEJpbmFyeUV4cHJlc3Npb246IHRydWUsIC8vIE1pZ2h0IGludm9rZSAudG9TdHJpbmcoKSBvciAudmFsdWVPZigpLlxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogdHJ1ZSwgLy8gU2lkZS1lZmZlY3RpbmcgYnkgZGVmaW5pdGlvbi5cbiAgVXBkYXRlRXhwcmVzc2lvbjogdHJ1ZSwgLy8gVXBkYXRlcyBhcmUgZXNzZW50aWFsbHkgYXNzaWdubWVudHMuXG4gIE5ld0V4cHJlc3Npb246IHRydWUgLy8gU2ltaWxhciB0byBDYWxsRXhwcmVzc2lvbi5cbn07XG5cbi8vIFRoZXNlIHR5cGVzIGFyZSB0aGUgZGlyZWN0IGNhdXNlIG9mIGFsbCBsZWFwcyBpbiBjb250cm9sIGZsb3cuXG52YXIgbGVhcFR5cGVzID0ge1xuICBZaWVsZEV4cHJlc3Npb246IHRydWUsXG4gIEJyZWFrU3RhdGVtZW50OiB0cnVlLFxuICBDb250aW51ZVN0YXRlbWVudDogdHJ1ZSxcbiAgUmV0dXJuU3RhdGVtZW50OiB0cnVlLFxuICBUaHJvd1N0YXRlbWVudDogdHJ1ZVxufTtcblxuLy8gQWxsIGxlYXAgdHlwZXMgYXJlIGFsc28gc2lkZSBlZmZlY3QgdHlwZXMuXG5mb3IgKHZhciB0eXBlIGluIGxlYXBUeXBlcykge1xuICBpZiAoaGFzT3duLmNhbGwobGVhcFR5cGVzLCB0eXBlKSkge1xuICAgIHNpZGVFZmZlY3RUeXBlc1t0eXBlXSA9IGxlYXBUeXBlc1t0eXBlXTtcbiAgfVxufVxuXG5leHBvcnRzLmhhc1NpZGVFZmZlY3RzID0gbWFrZVByZWRpY2F0ZShcImhhc1NpZGVFZmZlY3RzXCIsIHNpZGVFZmZlY3RUeXBlcyk7XG5leHBvcnRzLmNvbnRhaW5zTGVhcCA9IG1ha2VQcmVkaWNhdGUoXCJjb250YWluc0xlYXBcIiwgbGVhcFR5cGVzKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcImFzdC10eXBlc1wiKTtcbnZhciBuID0gdHlwZXMubmFtZWRUeXBlcztcbnZhciBiID0gdHlwZXMuYnVpbGRlcnM7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZXhwb3J0cy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGV4dGVuc2lvbjtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKChleHRlbnNpb24gPSBhcmd1bWVudHNbaV0pKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChleHRlbnNpb24sIGtleSkgJiYgIWhhc093bi5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5ydW50aW1lUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBiLm1lbWJlckV4cHJlc3Npb24oXG4gICAgYi5pZGVudGlmaWVyKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpLFxuICAgIGIuaWRlbnRpZmllcihuYW1lKSxcbiAgICBmYWxzZVxuICApO1xufTtcblxuLy8gSW5zcGlyZWQgYnkgdGhlIGlzUmVmZXJlbmNlIGZ1bmN0aW9uIGZyb20gYXN0LXV0aWw6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXZlbnR1YWxidWRkaGEvYXN0LXV0aWwvYmxvYi85YmY5MWM1Y2U4L2xpYi9pbmRleC5qcyNMNDY2LUw1MDZcbmV4cG9ydHMuaXNSZWZlcmVuY2UgPSBmdW5jdGlvbihwYXRoLCBuYW1lKSB7XG4gIHZhciBub2RlID0gcGF0aC52YWx1ZTtcblxuICBpZiAoIW4uSWRlbnRpZmllci5jaGVjayhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lICYmIG5vZGUubmFtZSAhPT0gbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBwYXRoLnBhcmVudC52YWx1ZTtcblxuICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICByZXR1cm4gcGF0aC5uYW1lID09PSBcImluaXRcIjtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBwYXRoLm5hbWUgPT09IFwib2JqZWN0XCIgfHwgKFxuICAgICAgcGFyZW50LmNvbXB1dGVkICYmIHBhdGgubmFtZSA9PT0gXCJwcm9wZXJ0eVwiXG4gICAgKTtcblxuICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGlmIChwYXRoLm5hbWUgPT09IFwiaWRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQucGFyYW1zID09PSBwYXRoLnBhcmVudFBhdGggJiZcbiAgICAgICAgcGFyZW50LnBhcmFtc1twYXRoLm5hbWVdID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBwYXRoLm5hbWUgIT09IFwiaWRcIjtcblxuICBjYXNlIFwiQ2F0Y2hDbGF1c2VcIjpcbiAgICByZXR1cm4gcGF0aC5uYW1lICE9PSBcInBhcmFtXCI7XG5cbiAgY2FzZSBcIlByb3BlcnR5XCI6XG4gIGNhc2UgXCJNZXRob2REZWZpbml0aW9uXCI6XG4gICAgcmV0dXJuIHBhdGgubmFtZSAhPT0gXCJrZXlcIjtcblxuICBjYXNlIFwiSW1wb3J0U3BlY2lmaWVyXCI6XG4gIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gIGNhc2UgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgY2FzZSBcIkxhYmVsZWRTdGF0ZW1lbnRcIjpcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcImFzdC10eXBlc1wiKTtcbnZhciBuID0gdHlwZXMubmFtZWRUeXBlcztcbnZhciBiID0gdHlwZXMuYnVpbGRlcnM7XG52YXIgaXNBcnJheSA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5hcnJheTtcbnZhciBpc09iamVjdCA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5vYmplY3Q7XG52YXIgTm9kZVBhdGggPSB0eXBlcy5Ob2RlUGF0aDtcbnZhciBob2lzdCA9IHJlcXVpcmUoXCIuL2hvaXN0XCIpLmhvaXN0O1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9lbWl0XCIpLkVtaXR0ZXI7XG52YXIgcnVudGltZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vdXRpbFwiKS5ydW50aW1lUHJvcGVydHk7XG5cbmV4cG9ydHMudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHBhdGggPSBub2RlIGluc3RhbmNlb2YgTm9kZVBhdGggPyBub2RlIDogbmV3IE5vZGVQYXRoKG5vZGUpO1xuICB2aXNpdG9yLnZpc2l0KHBhdGgsIG9wdGlvbnMpO1xuICBub2RlID0gcGF0aC52YWx1ZTtcblxuICBvcHRpb25zLm1hZGVDaGFuZ2VzID0gdmlzaXRvci53YXNDaGFuZ2VSZXBvcnRlZCgpO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIHZpc2l0b3IgPSB0eXBlcy5QYXRoVmlzaXRvci5mcm9tTWV0aG9kc09iamVjdCh7XG4gIHJlc2V0OiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICB2aXNpdEZ1bmN0aW9uOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gQ2FsbGluZyB0aGlzLnRyYXZlcnNlKHBhdGgpIGZpcnN0IG1ha2VzIGZvciBhIHBvc3Qtb3JkZXIgdHJhdmVyc2FsLlxuICAgIHRoaXMudHJhdmVyc2UocGF0aCk7XG5cbiAgICB2YXIgbm9kZSA9IHBhdGgudmFsdWU7XG4gICAgdmFyIHNob3VsZFRyYW5zZm9ybUFzeW5jID0gbm9kZS5hc3luYyAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVBc3luYztcblxuICAgIGlmICghbm9kZS5nZW5lcmF0b3IgJiYgIXNob3VsZFRyYW5zZm9ybUFzeW5jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuXG4gICAgaWYgKG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgLy8gVHJhbnNmb3JtIGV4cHJlc3Npb24gbGFtYmRhcyBpbnRvIG5vcm1hbCBmdW5jdGlvbnMuXG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIG5vZGUuYm9keSA9IGIuYmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgICBiLnJldHVyblN0YXRlbWVudChub2RlLmJvZHkpXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhbnNmb3JtQXN5bmMpIHtcbiAgICAgIGF3YWl0VmlzaXRvci52aXNpdChwYXRoLmdldChcImJvZHlcIikpO1xuICAgIH1cblxuICAgIHZhciBvdXRlckZuSWQgPSBub2RlLmlkIHx8IChcbiAgICAgIG5vZGUuaWQgPSBwYXRoLnNjb3BlLnBhcmVudC5kZWNsYXJlVGVtcG9yYXJ5KFwiY2FsbGVlJFwiKVxuICAgICk7XG5cbiAgICB2YXIgb3V0ZXJCb2R5ID0gW107XG4gICAgdmFyIGJvZHlCbG9jayA9IHBhdGgudmFsdWUuYm9keTtcbiAgICBib2R5QmxvY2suYm9keSA9IGJvZHlCbG9jay5ib2R5LmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5fYmxvY2tIb2lzdCAhPSBudWxsKSB7XG4gICAgICAgIG91dGVyQm9keS5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBpbm5lckZuSWQgPSBiLmlkZW50aWZpZXIobm9kZS5pZC5uYW1lICsgXCIkXCIpO1xuICAgIHZhciBjb250ZXh0SWQgPSBwYXRoLnNjb3BlLmRlY2xhcmVUZW1wb3JhcnkoXCJjb250ZXh0JFwiKTtcbiAgICB2YXIgdmFycyA9IGhvaXN0KHBhdGgpO1xuXG4gICAgdmFyIGVtaXR0ZXIgPSBuZXcgRW1pdHRlcihjb250ZXh0SWQpO1xuICAgIGVtaXR0ZXIuZXhwbG9kZShwYXRoLmdldChcImJvZHlcIikpO1xuXG4gICAgaWYgKHZhcnMgJiYgdmFycy5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgb3V0ZXJCb2R5LnB1c2godmFycyk7XG4gICAgfVxuXG4gICAgdmFyIHdyYXBBcmdzID0gW1xuICAgICAgZW1pdHRlci5nZXRDb250ZXh0RnVuY3Rpb24oaW5uZXJGbklkKSxcbiAgICAgIC8vIEFzeW5jIGZ1bmN0aW9ucyBkb24ndCBjYXJlIGFib3V0IHRoZSBvdXRlciBmdW5jdGlvbiBiZWNhdXNlIHRoZXlcbiAgICAgIC8vIGRvbid0IG5lZWQgaXQgdG8gYmUgbWFya2VkIGFuZCBkb24ndCBpbmhlcml0IGZyb20gaXRzIC5wcm90b3R5cGUuXG4gICAgICBzaG91bGRUcmFuc2Zvcm1Bc3luYyA/IGIubGl0ZXJhbChudWxsKSA6IG91dGVyRm5JZCxcbiAgICAgIGIudGhpc0V4cHJlc3Npb24oKVxuICAgIF07XG5cbiAgICB2YXIgdHJ5TG9jc0xpc3QgPSBlbWl0dGVyLmdldFRyeUxvY3NMaXN0KCk7XG4gICAgaWYgKHRyeUxvY3NMaXN0KSB7XG4gICAgICB3cmFwQXJncy5wdXNoKHRyeUxvY3NMaXN0KTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcENhbGwgPSBiLmNhbGxFeHByZXNzaW9uKFxuICAgICAgc2hvdWxkVHJhbnNmb3JtQXN5bmMgPyBydW50aW1lUHJvcGVydHkoXCJhc3luY1wiKSA6IHJ1bnRpbWVQcm9wZXJ0eShcIndyYXBcIiksXG4gICAgICB3cmFwQXJnc1xuICAgICk7XG5cbiAgICBvdXRlckJvZHkucHVzaChiLnJldHVyblN0YXRlbWVudCh3cmFwQ2FsbCkpO1xuICAgIG5vZGUuYm9keSA9IGIuYmxvY2tTdGF0ZW1lbnQob3V0ZXJCb2R5KTtcbiAgICBub2RlLmJvZHkuX2RlY2xhcmF0aW9ucyA9IGJvZHlCbG9jay5fZGVjbGFyYXRpb25zO1xuXG4gICAgaWYgKHNob3VsZFRyYW5zZm9ybUFzeW5jKSB7XG4gICAgICBub2RlLmFzeW5jID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG4uRnVuY3Rpb25EZWNsYXJhdGlvbi5jaGVjayhub2RlKSkge1xuICAgICAgdmFyIHBwID0gcGF0aC5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChwcCAmJiAhKG4uQmxvY2tTdGF0ZW1lbnQuY2hlY2socHAudmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICBuLlByb2dyYW0uY2hlY2socHAudmFsdWUpKSkge1xuICAgICAgICBwcCA9IHBwLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEhlcmUgd2UgdHVybiB0aGUgRnVuY3Rpb25EZWNsYXJhdGlvbiBpbnRvIGEgbmFtZWRcbiAgICAgIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSB2YXJpYWJsZSBvZiB0aGVcbiAgICAgIC8vIHNhbWUgbmFtZSBhdCB0aGUgdG9wIG9mIHRoZSBlbmNsb3NpbmcgYmxvY2suIFRoaXMgaXMgaW1wb3J0YW50XG4gICAgICAvLyBmb3IgYSB2ZXJ5IHN1YnRsZSByZWFzb246IG5hbWVkIGZ1bmN0aW9uIGV4cHJlc3Npb25zIGNhbiByZWZlciB0b1xuICAgICAgLy8gdGhlbXNlbHZlcyBieSBuYW1lIHdpdGhvdXQgZmVhciB0aGF0IHRoZSBiaW5kaW5nIG1heSBjaGFuZ2UgZHVlXG4gICAgICAvLyB0byBjb2RlIGV4ZWN1dGluZyBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgd2hlcmVhcyBmdW5jdGlvblxuICAgICAgLy8gZGVjbGFyYXRpb25zIGFyZSB2dWxuZXJhYmxlIHRvIHRoZSBmb2xsb3dpbmcgcmViaW5kaW5nOlxuICAgICAgLy9cbiAgICAgIC8vICAgZnVuY3Rpb24gZigpIHsgcmV0dXJuIGYgfVxuICAgICAgLy8gICB2YXIgZyA9IGY7XG4gICAgICAvLyAgIGYgPSBcImFzZGZcIjtcbiAgICAgIC8vICAgZygpOyAvLyBcImFzZGZcIlxuICAgICAgLy9cbiAgICAgIC8vIE9uZSB3YXkgdG8gcHJldmVudCB0aGUgcHJvYmxlbSBpbGx1c3RyYXRlZCBhYm92ZSBpcyB0byB0cmFuc2Zvcm1cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiB0aHVzOlxuICAgICAgLy9cbiAgICAgIC8vICAgdmFyIGYgPSBmdW5jdGlvbiBmKCkgeyByZXR1cm4gZiB9O1xuICAgICAgLy8gICB2YXIgZyA9IGY7XG4gICAgICAvLyAgIGYgPSBcImFzZGZcIjtcbiAgICAgIC8vICAgZygpOyAvLyBmXG4gICAgICAvLyAgIGcoKSgpKCkoKSgpOyAvLyBmXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGNvZGUgYmVsb3csIHdlIHRyYW5zZm9ybSBnZW5lcmF0b3IgZnVuY3Rpb24gZGVjbGFyYXRpb25zXG4gICAgICAvLyBpbiB0aGUgZm9sbG93aW5nIHdheTpcbiAgICAgIC8vXG4gICAgICAvLyAgIGdlbigpLm5leHQoKTsgLy8geyB2YWx1ZTogZ2VuLCBkb25lOiB0cnVlIH1cbiAgICAgIC8vICAgZnVuY3Rpb24gKmdlbigpIHtcbiAgICAgIC8vICAgICByZXR1cm4gZ2VuO1xuICAgICAgLy8gICB9XG4gICAgICAvL1xuICAgICAgLy8gYmVjb21lcyBzb21ldGhpbmcgbGlrZVxuICAgICAgLy9cbiAgICAgIC8vICAgdmFyIGdlbiA9IHJ1bnRpbWUubWFyayhmdW5jdGlvbiAqZ2VuKCkge1xuICAgICAgLy8gICAgIHJldHVybiBnZW47XG4gICAgICAvLyAgIH0pO1xuICAgICAgLy8gICBnZW4oKS5uZXh0KCk7IC8vIHsgdmFsdWU6IGdlbiwgZG9uZTogdHJ1ZSB9XG4gICAgICAvL1xuICAgICAgLy8gd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBnZW5lcmF0b3IgYm9keSBjYW4gYWx3YXlzIHJlbGlhYmx5IHJlZmVyXG4gICAgICAvLyB0byBnZW4gYnkgbmFtZS5cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBGdW5jdGlvbkRlY2xhcmF0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBpdCBiYWNrIGFzIGFcbiAgICAgIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbiBwYXNzZWQgdG8gcnVudGltZS5tYXJrLlxuICAgICAgcGF0aC5yZXBsYWNlKCk7XG5cbiAgICAgIC8vIENoYW5nZSB0aGUgdHlwZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgYW4gZXhwcmVzc2lvbiBpbnN0ZWFkIG9mIGFcbiAgICAgIC8vIGRlY2xhcmF0aW9uLiBOb3RlIHRoYXQgYWxsIHRoZSBvdGhlciBmaWVsZHMgYXJlIHRoZSBzYW1lLlxuICAgICAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcblxuICAgICAgdmFyIHZhckRlY2wgPSBiLnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW1xuICAgICAgICBiLnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgICBub2RlLmlkLFxuICAgICAgICAgIGIuY2FsbEV4cHJlc3Npb24ocnVudGltZVByb3BlcnR5KFwibWFya1wiKSwgW25vZGVdKVxuICAgICAgICApXG4gICAgICBdKTtcblxuICAgICAgaWYgKG5vZGUuY29tbWVudHMpIHtcbiAgICAgICAgLy8gQ29weSBhbnkgY29tbWVudHMgcHJlY2VkaW5nIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiB0byB0aGVcbiAgICAgICAgLy8gdmFyaWFibGUgZGVjbGFyYXRpb24sIHRvIGF2b2lkIHdlaXJkIGZvcm1hdHRpbmcgY29uc2VxdWVuY2VzLlxuICAgICAgICB2YXJEZWNsLmxlYWRpbmdDb21tZW50cyA9IG5vZGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICB2YXJEZWNsLnRyYWlsaW5nQ29tbWVudHMgPSBub2RlLnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyRGVjbC5fYmxvY2tIb2lzdCA9IDM7XG5cbiAgICAgIHZhciBib2R5UGF0aCA9IHBwLmdldChcImJvZHlcIik7XG4gICAgICB2YXIgYm9keUxlbiA9IGJvZHlQYXRoLnZhbHVlLmxlbmd0aDtcblxuICAgICAgYm9keVBhdGgucHVzaCh2YXJEZWNsKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBuLkZ1bmN0aW9uRXhwcmVzc2lvbi5hc3NlcnQobm9kZSk7XG4gICAgICByZXR1cm4gYi5jYWxsRXhwcmVzc2lvbihydW50aW1lUHJvcGVydHkoXCJtYXJrXCIpLCBbbm9kZV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHNob3VsZE5vdEhvaXN0QWJvdmUoc3RtdFBhdGgpIHtcbiAgdmFyIHZhbHVlID0gc3RtdFBhdGgudmFsdWU7XG4gIG4uU3RhdGVtZW50LmFzc2VydCh2YWx1ZSk7XG5cbiAgLy8gSWYgdGhlIGZpcnN0IHN0YXRlbWVudCBpcyBhIFwidXNlIHN0cmljdFwiIGRlY2xhcmF0aW9uLCBtYWtlIHN1cmUgdG9cbiAgLy8gaW5zZXJ0IGhvaXN0ZWQgZGVjbGFyYXRpb25zIGFmdGVyd2FyZHMuXG4gIGlmIChuLkV4cHJlc3Npb25TdGF0ZW1lbnQuY2hlY2sodmFsdWUpICYmXG4gICAgICBuLkxpdGVyYWwuY2hlY2sodmFsdWUuZXhwcmVzc2lvbikgJiZcbiAgICAgIHZhbHVlLmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobi5WYXJpYWJsZURlY2xhcmF0aW9uLmNoZWNrKHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuZGVjbGFyYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVjbCA9IHZhbHVlLmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGlmIChuLkNhbGxFeHByZXNzaW9uLmNoZWNrKGRlY2wuaW5pdCkgJiZcbiAgICAgICAgICB0eXBlcy5hc3ROb2Rlc0FyZUVxdWl2YWxlbnQoZGVjbC5pbml0LmNhbGxlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZVByb3BlcnR5KFwibWFya1wiKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgYXdhaXRWaXNpdG9yID0gdHlwZXMuUGF0aFZpc2l0b3IuZnJvbU1ldGhvZHNPYmplY3Qoe1xuICB2aXNpdEZ1bmN0aW9uOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uIHNjb3Blcy5cbiAgfSxcblxuICB2aXNpdEF3YWl0RXhwcmVzc2lvbjogZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENvbnZlcnQgYXdhaXQgYW5kIGF3YWl0KiBleHByZXNzaW9ucyB0byB5aWVsZCBleHByZXNzaW9ucy5cbiAgICB2YXIgYXJndW1lbnQgPSBwYXRoLnZhbHVlLmFyZ3VtZW50O1xuXG4gICAgLy8gSWYgdGhlIHBhcnNlciBzdXBwb3J0cyBhd2FpdCogc3ludGF4IHVzaW5nIGEgYm9vbGVhbiAuYWxsIHByb3BlcnR5XG4gICAgLy8gKCMxNzEpLCBkZXN1Z2FyIHRoYXQgc3ludGF4IHRvIHlpZWxkIFByb21pc2UuYWxsKGFyZ3VtZW50KS5cbiAgICBpZiAocGF0aC52YWx1ZS5hbGwpIHtcbiAgICAgIGFyZ3VtZW50ID0gYi5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgYi5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgIGIuaWRlbnRpZmllcihcIlByb21pc2VcIiksXG4gICAgICAgICAgYi5pZGVudGlmaWVyKFwiYWxsXCIpLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICksXG4gICAgICAgIFthcmd1bWVudF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIueWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xudmFyIHRocm91Z2ggPSByZXF1aXJlKFwidGhyb3VnaFwiKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9saWIvdmlzaXRcIikudHJhbnNmb3JtO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vbGliL3V0aWxcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiYXN0LXR5cGVzXCIpO1xudmFyIGdlbk9yQXN5bmNGdW5FeHAgPSAvXFxiZnVuY3Rpb25cXHMqXFwqfFxcYmFzeW5jXFxiLztcbnZhciBibG9ja0JpbmRpbmdFeHAgPSAvXFxiKGxldHxjb25zdClcXHMrLztcblxuZnVuY3Rpb24gZXhwb3J0cyhmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHJldHVybiB0aHJvdWdoKHdyaXRlLCBlbmQpO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGJ1Zikge1xuICAgIGRhdGEucHVzaChidWYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kKCkge1xuICAgIHRoaXMucXVldWUoY29tcGlsZShkYXRhLmpvaW4oXCJcIiksIG9wdGlvbnMpLmNvZGUpO1xuICAgIHRoaXMucXVldWUobnVsbCk7XG4gIH1cbn1cblxuLy8gVG8gZ2V0IGEgd3JpdGFibGUgc3RyZWFtIGZvciB1c2UgYXMgYSBicm93c2VyaWZ5IHRyYW5zZm9ybSwgY2FsbFxuLy8gcmVxdWlyZShcInJlZ2VuZXJhdG9yXCIpKCkuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cbi8vIFRvIGluY2x1ZGUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgaW4gdGhlIGN1cnJlbnQgbm9kZSBwcm9jZXNzLCBjYWxsXG4vLyByZXF1aXJlKFwicmVnZW5lcmF0b3JcIikucnVudGltZSgpLlxuZnVuY3Rpb24gcnVudGltZSgpIHtcbiAgcmVxdWlyZShcIi4vcnVudGltZVwiKTtcbn1cbmV4cG9ydHMucnVudGltZSA9IHJ1bnRpbWU7XG5ydW50aW1lLnBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcInJ1bnRpbWUuanNcIik7XG5cbi8vIFRvIG1vZGlmeSBhbiBBU1QgZGlyZWN0bHksIGNhbGwgcmVxdWlyZShcInJlZ2VuZXJhdG9yXCIpLnRyYW5zZm9ybShhc3QpLlxuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxuLy8gdGhyb3VnaFxuLy9cbi8vIGEgc3RyZWFtIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZS1lbWl0IHRoZSBpbnB1dC5cbi8vIHVzZWZ1bCBmb3IgYWdncmVnYXRpbmcgYSBzZXJpZXMgb2YgY2hhbmdpbmcgYnV0IG5vdCBlbmRpbmcgc3RyZWFtcyBpbnRvIG9uZSBzdHJlYW0pXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRocm91Z2hcbnRocm91Z2gudGhyb3VnaCA9IHRocm91Z2hcblxuLy9jcmVhdGUgYSByZWFkYWJsZSB3cml0YWJsZSBzdHJlYW0uXG5cbmZ1bmN0aW9uIHRocm91Z2ggKHdyaXRlLCBlbmQsIG9wdHMpIHtcbiAgd3JpdGUgPSB3cml0ZSB8fCBmdW5jdGlvbiAoZGF0YSkgeyB0aGlzLnF1ZXVlKGRhdGEpIH1cbiAgZW5kID0gZW5kIHx8IGZ1bmN0aW9uICgpIHsgdGhpcy5xdWV1ZShudWxsKSB9XG5cbiAgdmFyIGVuZGVkID0gZmFsc2UsIGRlc3Ryb3llZCA9IGZhbHNlLCBidWZmZXIgPSBbXSwgX2VuZGVkID0gZmFsc2VcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKVxuICBzdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0ud3JpdGFibGUgPSB0cnVlXG4gIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuXG4vLyAgc3RyZWFtLmF1dG9QYXVzZSAgID0gIShvcHRzICYmIG9wdHMuYXV0b1BhdXNlICAgPT09IGZhbHNlKVxuICBzdHJlYW0uYXV0b0Rlc3Ryb3kgPSAhKG9wdHMgJiYgb3B0cy5hdXRvRGVzdHJveSA9PT0gZmFsc2UpXG5cbiAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB3cml0ZS5jYWxsKHRoaXMsIGRhdGEpXG4gICAgcmV0dXJuICFzdHJlYW0ucGF1c2VkXG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICB3aGlsZShidWZmZXIubGVuZ3RoICYmICFzdHJlYW0ucGF1c2VkKSB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZihudWxsID09PSBkYXRhKVxuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBlbHNlXG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ucXVldWUgPSBzdHJlYW0ucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4vLyAgICBjb25zb2xlLmVycm9yKGVuZGVkKVxuICAgIGlmKF9lbmRlZCkgcmV0dXJuIHN0cmVhbVxuICAgIGlmKGRhdGEgPT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYgfHwgbnVsbCwgdHJ5TG9jc0xpc3QgfHwgW10pO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCk7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQoZ2VuZXJhdG9yLm5leHQpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3JbXCJ0aHJvd1wiXSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoYXJnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaCh0aGlzLCBudWxsLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKGluZm8udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpbmZvLnZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGdlbmVyYXRvciA9IG91dGVyRm4gPyBPYmplY3QuY3JlYXRlKG91dGVyRm4ucHJvdG90eXBlKSA6IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCk7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJhdHRlbXB0IHRvIHNlbmQgXCIgKyBKU09OLnN0cmluZ2lmeShhcmcpICsgXCIgdG8gbmV3Ym9ybiBnZW5lcmF0b3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQuc2VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihyZWNvcmQuYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0b3IubmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIGdlbmVyYXRvcltcInRocm93XCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIGdlbmVyYXRvcltcInJldHVyblwiXSA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICAvLyBQcmUtaW5pdGlhbGl6ZSBhdCBsZWFzdCAyMCB0ZW1wb3JhcnkgdmFyaWFibGVzIHRvIGVuYWJsZSBoaWRkZW5cbiAgICAgIC8vIGNsYXNzIG9wdGltaXphdGlvbnMgZm9yIHNpbXBsZSBnZW5lcmF0b3JzLlxuICAgICAgZm9yICh2YXIgdGVtcEluZGV4ID0gMCwgdGVtcE5hbWU7XG4gICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIHRlbXBOYW1lID0gXCJ0XCIgKyB0ZW1wSW5kZXgpIHx8IHRlbXBJbmRleCA8IDIwO1xuICAgICAgICAgICArK3RlbXBJbmRleCkge1xuICAgICAgICB0aGlzW3RlbXBOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmluZEZpbmFsbHlFbnRyeTogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIChcbiAgICAgICAgICAgICAgZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYyB8fFxuICAgICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSkge1xuICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fZmluZEZpbmFsbHlFbnRyeSgpO1xuICAgICAgdmFyIHJlY29yZCA9IGVudHJ5ID8gZW50cnkuY29tcGxldGlvbiA6IHt9O1xuXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2ZpbmRGaW5hbGx5RW50cnkoZmluYWxseUxvYyk7XG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdGhpc1xuKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBgL3NjcmlwdHMvY2hhcmFjdGVyLWNsYXNzLWVzY2FwZS1zZXRzLmpzYC4gRG8gbm90IGVkaXQuXG52YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoJ3JlZ2VuZXJhdGUnKTtcblxuZXhwb3J0cy5SRUdVTEFSID0ge1xuXHQnZCc6IHJlZ2VuZXJhdGUoKVxuXHRcdC5hZGRSYW5nZSgweDMwLCAweDM5KSxcblx0J0QnOiByZWdlbmVyYXRlKClcblx0XHQuYWRkUmFuZ2UoMHgwLCAweDJGKVxuXHRcdC5hZGRSYW5nZSgweDNBLCAweEZGRkYpLFxuXHQncyc6IHJlZ2VuZXJhdGUoMHgyMCwgMHhBMCwgMHgxNjgwLCAweDE4MEUsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRilcblx0XHQuYWRkUmFuZ2UoMHg5LCAweEQpXG5cdFx0LmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKVxuXHRcdC5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG5cdCdTJzogcmVnZW5lcmF0ZSgpXG5cdFx0LmFkZFJhbmdlKDB4MCwgMHg4KVxuXHRcdC5hZGRSYW5nZSgweEUsIDB4MUYpXG5cdFx0LmFkZFJhbmdlKDB4MjEsIDB4OUYpXG5cdFx0LmFkZFJhbmdlKDB4QTEsIDB4MTY3Rilcblx0XHQuYWRkUmFuZ2UoMHgxNjgxLCAweDE4MEQpXG5cdFx0LmFkZFJhbmdlKDB4MTgwRiwgMHgxRkZGKVxuXHRcdC5hZGRSYW5nZSgweDIwMEIsIDB4MjAyNylcblx0XHQuYWRkUmFuZ2UoMHgyMDJBLCAweDIwMkUpXG5cdFx0LmFkZFJhbmdlKDB4MjAzMCwgMHgyMDVFKVxuXHRcdC5hZGRSYW5nZSgweDIwNjAsIDB4MkZGRilcblx0XHQuYWRkUmFuZ2UoMHgzMDAxLCAweEZFRkUpXG5cdFx0LmFkZFJhbmdlKDB4RkYwMCwgMHhGRkZGKSxcblx0J3cnOiByZWdlbmVyYXRlKDB4NUYpXG5cdFx0LmFkZFJhbmdlKDB4MzAsIDB4MzkpXG5cdFx0LmFkZFJhbmdlKDB4NDEsIDB4NUEpXG5cdFx0LmFkZFJhbmdlKDB4NjEsIDB4N0EpLFxuXHQnVyc6IHJlZ2VuZXJhdGUoMHg2MClcblx0XHQuYWRkUmFuZ2UoMHgwLCAweDJGKVxuXHRcdC5hZGRSYW5nZSgweDNBLCAweDQwKVxuXHRcdC5hZGRSYW5nZSgweDVCLCAweDVFKVxuXHRcdC5hZGRSYW5nZSgweDdCLCAweEZGRkYpXG59O1xuXG5leHBvcnRzLlVOSUNPREUgPSB7XG5cdCdkJzogcmVnZW5lcmF0ZSgpXG5cdFx0LmFkZFJhbmdlKDB4MzAsIDB4MzkpLFxuXHQnRCc6IHJlZ2VuZXJhdGUoKVxuXHRcdC5hZGRSYW5nZSgweDAsIDB4MkYpXG5cdFx0LmFkZFJhbmdlKDB4M0EsIDB4MTBGRkZGKSxcblx0J3MnOiByZWdlbmVyYXRlKDB4MjAsIDB4QTAsIDB4MTY4MCwgMHgxODBFLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkYpXG5cdFx0LmFkZFJhbmdlKDB4OSwgMHhEKVxuXHRcdC5hZGRSYW5nZSgweDIwMDAsIDB4MjAwQSlcblx0XHQuYWRkUmFuZ2UoMHgyMDI4LCAweDIwMjkpLFxuXHQnUyc6IHJlZ2VuZXJhdGUoKVxuXHRcdC5hZGRSYW5nZSgweDAsIDB4OClcblx0XHQuYWRkUmFuZ2UoMHhFLCAweDFGKVxuXHRcdC5hZGRSYW5nZSgweDIxLCAweDlGKVxuXHRcdC5hZGRSYW5nZSgweEExLCAweDE2N0YpXG5cdFx0LmFkZFJhbmdlKDB4MTY4MSwgMHgxODBEKVxuXHRcdC5hZGRSYW5nZSgweDE4MEYsIDB4MUZGRilcblx0XHQuYWRkUmFuZ2UoMHgyMDBCLCAweDIwMjcpXG5cdFx0LmFkZFJhbmdlKDB4MjAyQSwgMHgyMDJFKVxuXHRcdC5hZGRSYW5nZSgweDIwMzAsIDB4MjA1RSlcblx0XHQuYWRkUmFuZ2UoMHgyMDYwLCAweDJGRkYpXG5cdFx0LmFkZFJhbmdlKDB4MzAwMSwgMHhGRUZFKVxuXHRcdC5hZGRSYW5nZSgweEZGMDAsIDB4MTBGRkZGKSxcblx0J3cnOiByZWdlbmVyYXRlKDB4NUYpXG5cdFx0LmFkZFJhbmdlKDB4MzAsIDB4MzkpXG5cdFx0LmFkZFJhbmdlKDB4NDEsIDB4NUEpXG5cdFx0LmFkZFJhbmdlKDB4NjEsIDB4N0EpLFxuXHQnVyc6IHJlZ2VuZXJhdGUoMHg2MClcblx0XHQuYWRkUmFuZ2UoMHgwLCAweDJGKVxuXHRcdC5hZGRSYW5nZSgweDNBLCAweDQwKVxuXHRcdC5hZGRSYW5nZSgweDVCLCAweDVFKVxuXHRcdC5hZGRSYW5nZSgweDdCLCAweDEwRkZGRilcbn07XG5cbmV4cG9ydHMuVU5JQ09ERV9JR05PUkVfQ0FTRSA9IHtcblx0J2QnOiByZWdlbmVyYXRlKClcblx0XHQuYWRkUmFuZ2UoMHgzMCwgMHgzOSksXG5cdCdEJzogcmVnZW5lcmF0ZSgpXG5cdFx0LmFkZFJhbmdlKDB4MCwgMHgyRilcblx0XHQuYWRkUmFuZ2UoMHgzQSwgMHgxMEZGRkYpLFxuXHQncyc6IHJlZ2VuZXJhdGUoMHgyMCwgMHhBMCwgMHgxNjgwLCAweDE4MEUsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRilcblx0XHQuYWRkUmFuZ2UoMHg5LCAweEQpXG5cdFx0LmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKVxuXHRcdC5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG5cdCdTJzogcmVnZW5lcmF0ZSgpXG5cdFx0LmFkZFJhbmdlKDB4MCwgMHg4KVxuXHRcdC5hZGRSYW5nZSgweEUsIDB4MUYpXG5cdFx0LmFkZFJhbmdlKDB4MjEsIDB4OUYpXG5cdFx0LmFkZFJhbmdlKDB4QTEsIDB4MTY3Rilcblx0XHQuYWRkUmFuZ2UoMHgxNjgxLCAweDE4MEQpXG5cdFx0LmFkZFJhbmdlKDB4MTgwRiwgMHgxRkZGKVxuXHRcdC5hZGRSYW5nZSgweDIwMEIsIDB4MjAyNylcblx0XHQuYWRkUmFuZ2UoMHgyMDJBLCAweDIwMkUpXG5cdFx0LmFkZFJhbmdlKDB4MjAzMCwgMHgyMDVFKVxuXHRcdC5hZGRSYW5nZSgweDIwNjAsIDB4MkZGRilcblx0XHQuYWRkUmFuZ2UoMHgzMDAxLCAweEZFRkUpXG5cdFx0LmFkZFJhbmdlKDB4RkYwMCwgMHgxMEZGRkYpLFxuXHQndyc6IHJlZ2VuZXJhdGUoMHg1RiwgMHgxN0YsIDB4MjEyQSlcblx0XHQuYWRkUmFuZ2UoMHgzMCwgMHgzOSlcblx0XHQuYWRkUmFuZ2UoMHg0MSwgMHg1QSlcblx0XHQuYWRkUmFuZ2UoMHg2MSwgMHg3QSksXG5cdCdXJzogcmVnZW5lcmF0ZSgweDRCLCAweDUzLCAweDYwKVxuXHRcdC5hZGRSYW5nZSgweDAsIDB4MkYpXG5cdFx0LmFkZFJhbmdlKDB4M0EsIDB4NDApXG5cdFx0LmFkZFJhbmdlKDB4NUIsIDB4NUUpXG5cdFx0LmFkZFJhbmdlKDB4N0IsIDB4MTBGRkZGKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCI3NVwiOiA4NDkwLFxuXHRcIjgzXCI6IDM4Myxcblx0XCIxMDdcIjogODQ5MCxcblx0XCIxMTVcIjogMzgzLFxuXHRcIjE4MVwiOiA5MjQsXG5cdFwiMTk3XCI6IDg0OTEsXG5cdFwiMzgzXCI6IDgzLFxuXHRcIjQ1MlwiOiA0NTMsXG5cdFwiNDUzXCI6IDQ1Mixcblx0XCI0NTVcIjogNDU2LFxuXHRcIjQ1NlwiOiA0NTUsXG5cdFwiNDU4XCI6IDQ1OSxcblx0XCI0NTlcIjogNDU4LFxuXHRcIjQ5N1wiOiA0OTgsXG5cdFwiNDk4XCI6IDQ5Nyxcblx0XCI4MzdcIjogODEyNixcblx0XCI5MTRcIjogOTc2LFxuXHRcIjkxN1wiOiAxMDEzLFxuXHRcIjkyMFwiOiAxMDEyLFxuXHRcIjkyMVwiOiA4MTI2LFxuXHRcIjkyMlwiOiAxMDA4LFxuXHRcIjkyNFwiOiAxODEsXG5cdFwiOTI4XCI6IDk4Mixcblx0XCI5MjlcIjogMTAwOSxcblx0XCI5MzFcIjogOTYyLFxuXHRcIjkzNFwiOiA5ODEsXG5cdFwiOTM3XCI6IDg0ODYsXG5cdFwiOTYyXCI6IDkzMSxcblx0XCI5NzZcIjogOTE0LFxuXHRcIjk3N1wiOiAxMDEyLFxuXHRcIjk4MVwiOiA5MzQsXG5cdFwiOTgyXCI6IDkyOCxcblx0XCIxMDA4XCI6IDkyMixcblx0XCIxMDA5XCI6IDkyOSxcblx0XCIxMDEyXCI6IFtcblx0XHQ5MjAsXG5cdFx0OTc3XG5cdF0sXG5cdFwiMTAxM1wiOiA5MTcsXG5cdFwiNzc3NlwiOiA3ODM1LFxuXHRcIjc4MzVcIjogNzc3Nixcblx0XCI4MTI2XCI6IFtcblx0XHQ4MzcsXG5cdFx0OTIxXG5cdF0sXG5cdFwiODQ4NlwiOiA5MzcsXG5cdFwiODQ5MFwiOiA3NSxcblx0XCI4NDkxXCI6IDE5Nyxcblx0XCI2NjU2MFwiOiA2NjYwMCxcblx0XCI2NjU2MVwiOiA2NjYwMSxcblx0XCI2NjU2MlwiOiA2NjYwMixcblx0XCI2NjU2M1wiOiA2NjYwMyxcblx0XCI2NjU2NFwiOiA2NjYwNCxcblx0XCI2NjU2NVwiOiA2NjYwNSxcblx0XCI2NjU2NlwiOiA2NjYwNixcblx0XCI2NjU2N1wiOiA2NjYwNyxcblx0XCI2NjU2OFwiOiA2NjYwOCxcblx0XCI2NjU2OVwiOiA2NjYwOSxcblx0XCI2NjU3MFwiOiA2NjYxMCxcblx0XCI2NjU3MVwiOiA2NjYxMSxcblx0XCI2NjU3MlwiOiA2NjYxMixcblx0XCI2NjU3M1wiOiA2NjYxMyxcblx0XCI2NjU3NFwiOiA2NjYxNCxcblx0XCI2NjU3NVwiOiA2NjYxNSxcblx0XCI2NjU3NlwiOiA2NjYxNixcblx0XCI2NjU3N1wiOiA2NjYxNyxcblx0XCI2NjU3OFwiOiA2NjYxOCxcblx0XCI2NjU3OVwiOiA2NjYxOSxcblx0XCI2NjU4MFwiOiA2NjYyMCxcblx0XCI2NjU4MVwiOiA2NjYyMSxcblx0XCI2NjU4MlwiOiA2NjYyMixcblx0XCI2NjU4M1wiOiA2NjYyMyxcblx0XCI2NjU4NFwiOiA2NjYyNCxcblx0XCI2NjU4NVwiOiA2NjYyNSxcblx0XCI2NjU4NlwiOiA2NjYyNixcblx0XCI2NjU4N1wiOiA2NjYyNyxcblx0XCI2NjU4OFwiOiA2NjYyOCxcblx0XCI2NjU4OVwiOiA2NjYyOSxcblx0XCI2NjU5MFwiOiA2NjYzMCxcblx0XCI2NjU5MVwiOiA2NjYzMSxcblx0XCI2NjU5MlwiOiA2NjYzMixcblx0XCI2NjU5M1wiOiA2NjYzMyxcblx0XCI2NjU5NFwiOiA2NjYzNCxcblx0XCI2NjU5NVwiOiA2NjYzNSxcblx0XCI2NjU5NlwiOiA2NjYzNixcblx0XCI2NjU5N1wiOiA2NjYzNyxcblx0XCI2NjU5OFwiOiA2NjYzOCxcblx0XCI2NjU5OVwiOiA2NjYzOSxcblx0XCI2NjYwMFwiOiA2NjU2MCxcblx0XCI2NjYwMVwiOiA2NjU2MSxcblx0XCI2NjYwMlwiOiA2NjU2Mixcblx0XCI2NjYwM1wiOiA2NjU2Myxcblx0XCI2NjYwNFwiOiA2NjU2NCxcblx0XCI2NjYwNVwiOiA2NjU2NSxcblx0XCI2NjYwNlwiOiA2NjU2Nixcblx0XCI2NjYwN1wiOiA2NjU2Nyxcblx0XCI2NjYwOFwiOiA2NjU2OCxcblx0XCI2NjYwOVwiOiA2NjU2OSxcblx0XCI2NjYxMFwiOiA2NjU3MCxcblx0XCI2NjYxMVwiOiA2NjU3MSxcblx0XCI2NjYxMlwiOiA2NjU3Mixcblx0XCI2NjYxM1wiOiA2NjU3Myxcblx0XCI2NjYxNFwiOiA2NjU3NCxcblx0XCI2NjYxNVwiOiA2NjU3NSxcblx0XCI2NjYxNlwiOiA2NjU3Nixcblx0XCI2NjYxN1wiOiA2NjU3Nyxcblx0XCI2NjYxOFwiOiA2NjU3OCxcblx0XCI2NjYxOVwiOiA2NjU3OSxcblx0XCI2NjYyMFwiOiA2NjU4MCxcblx0XCI2NjYyMVwiOiA2NjU4MSxcblx0XCI2NjYyMlwiOiA2NjU4Mixcblx0XCI2NjYyM1wiOiA2NjU4Myxcblx0XCI2NjYyNFwiOiA2NjU4NCxcblx0XCI2NjYyNVwiOiA2NjU4NSxcblx0XCI2NjYyNlwiOiA2NjU4Nixcblx0XCI2NjYyN1wiOiA2NjU4Nyxcblx0XCI2NjYyOFwiOiA2NjU4OCxcblx0XCI2NjYyOVwiOiA2NjU4OSxcblx0XCI2NjYzMFwiOiA2NjU5MCxcblx0XCI2NjYzMVwiOiA2NjU5MSxcblx0XCI2NjYzMlwiOiA2NjU5Mixcblx0XCI2NjYzM1wiOiA2NjU5Myxcblx0XCI2NjYzNFwiOiA2NjU5NCxcblx0XCI2NjYzNVwiOiA2NjU5NSxcblx0XCI2NjYzNlwiOiA2NjU5Nixcblx0XCI2NjYzN1wiOiA2NjU5Nyxcblx0XCI2NjYzOFwiOiA2NjU5OCxcblx0XCI2NjYzOVwiOiA2NjU5OSxcblx0XCI3MTg0MFwiOiA3MTg3Mixcblx0XCI3MTg0MVwiOiA3MTg3Myxcblx0XCI3MTg0MlwiOiA3MTg3NCxcblx0XCI3MTg0M1wiOiA3MTg3NSxcblx0XCI3MTg0NFwiOiA3MTg3Nixcblx0XCI3MTg0NVwiOiA3MTg3Nyxcblx0XCI3MTg0NlwiOiA3MTg3OCxcblx0XCI3MTg0N1wiOiA3MTg3OSxcblx0XCI3MTg0OFwiOiA3MTg4MCxcblx0XCI3MTg0OVwiOiA3MTg4MSxcblx0XCI3MTg1MFwiOiA3MTg4Mixcblx0XCI3MTg1MVwiOiA3MTg4Myxcblx0XCI3MTg1MlwiOiA3MTg4NCxcblx0XCI3MTg1M1wiOiA3MTg4NSxcblx0XCI3MTg1NFwiOiA3MTg4Nixcblx0XCI3MTg1NVwiOiA3MTg4Nyxcblx0XCI3MTg1NlwiOiA3MTg4OCxcblx0XCI3MTg1N1wiOiA3MTg4OSxcblx0XCI3MTg1OFwiOiA3MTg5MCxcblx0XCI3MTg1OVwiOiA3MTg5MSxcblx0XCI3MTg2MFwiOiA3MTg5Mixcblx0XCI3MTg2MVwiOiA3MTg5Myxcblx0XCI3MTg2MlwiOiA3MTg5NCxcblx0XCI3MTg2M1wiOiA3MTg5NSxcblx0XCI3MTg2NFwiOiA3MTg5Nixcblx0XCI3MTg2NVwiOiA3MTg5Nyxcblx0XCI3MTg2NlwiOiA3MTg5OCxcblx0XCI3MTg2N1wiOiA3MTg5OSxcblx0XCI3MTg2OFwiOiA3MTkwMCxcblx0XCI3MTg2OVwiOiA3MTkwMSxcblx0XCI3MTg3MFwiOiA3MTkwMixcblx0XCI3MTg3MVwiOiA3MTkwMyxcblx0XCI3MTg3MlwiOiA3MTg0MCxcblx0XCI3MTg3M1wiOiA3MTg0MSxcblx0XCI3MTg3NFwiOiA3MTg0Mixcblx0XCI3MTg3NVwiOiA3MTg0Myxcblx0XCI3MTg3NlwiOiA3MTg0NCxcblx0XCI3MTg3N1wiOiA3MTg0NSxcblx0XCI3MTg3OFwiOiA3MTg0Nixcblx0XCI3MTg3OVwiOiA3MTg0Nyxcblx0XCI3MTg4MFwiOiA3MTg0OCxcblx0XCI3MTg4MVwiOiA3MTg0OSxcblx0XCI3MTg4MlwiOiA3MTg1MCxcblx0XCI3MTg4M1wiOiA3MTg1MSxcblx0XCI3MTg4NFwiOiA3MTg1Mixcblx0XCI3MTg4NVwiOiA3MTg1Myxcblx0XCI3MTg4NlwiOiA3MTg1NCxcblx0XCI3MTg4N1wiOiA3MTg1NSxcblx0XCI3MTg4OFwiOiA3MTg1Nixcblx0XCI3MTg4OVwiOiA3MTg1Nyxcblx0XCI3MTg5MFwiOiA3MTg1OCxcblx0XCI3MTg5MVwiOiA3MTg1OSxcblx0XCI3MTg5MlwiOiA3MTg2MCxcblx0XCI3MTg5M1wiOiA3MTg2MSxcblx0XCI3MTg5NFwiOiA3MTg2Mixcblx0XCI3MTg5NVwiOiA3MTg2Myxcblx0XCI3MTg5NlwiOiA3MTg2NCxcblx0XCI3MTg5N1wiOiA3MTg2NSxcblx0XCI3MTg5OFwiOiA3MTg2Nixcblx0XCI3MTg5OVwiOiA3MTg2Nyxcblx0XCI3MTkwMFwiOiA3MTg2OCxcblx0XCI3MTkwMVwiOiA3MTg2OSxcblx0XCI3MTkwMlwiOiA3MTg3MCxcblx0XCI3MTkwM1wiOiA3MTg3MVxufVxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9yZWdlbmVyYXRlIHYxLjIuMCBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgLlxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBFUlJPUlMgPSB7XG5cdFx0J3JhbmdlT3JkZXInOiAnQSByYW5nZVxcdTIwMTlzIGBzdG9wYCB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCAnICtcblx0XHRcdCd0byB0aGUgYHN0YXJ0YCB2YWx1ZS4nLFxuXHRcdCdjb2RlUG9pbnRSYW5nZSc6ICdJbnZhbGlkIGNvZGUgcG9pbnQgdmFsdWUuIENvZGUgcG9pbnRzIHJhbmdlIGZyb20gJyArXG5cdFx0XHQnVSswMDAwMDAgdG8gVSsxMEZGRkYuJ1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1wYWlyc1xuXHR2YXIgSElHSF9TVVJST0dBVEVfTUlOID0gMHhEODAwO1xuXHR2YXIgSElHSF9TVVJST0dBVEVfTUFYID0gMHhEQkZGO1xuXHR2YXIgTE9XX1NVUlJPR0FURV9NSU4gPSAweERDMDA7XG5cdHZhciBMT1dfU1VSUk9HQVRFX01BWCA9IDB4REZGRjtcblxuXHQvLyBJbiBSZWdlbmVyYXRlIG91dHB1dCwgYFxcMGAgd2lsbCBuZXZlciBiZSBwcmVjZWRlZCBieSBgXFxgIGJlY2F1c2Ugd2Ugc29ydFxuXHQvLyBieSBjb2RlIHBvaW50IHZhbHVlLCBzbyBsZXTigJlzIGtlZXAgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gc2ltcGxlLlxuXHR2YXIgcmVnZXhOdWxsID0gL1xcXFx4MDAoW14wMTIzNDU2Nzg5XXwkKS9nO1xuXG5cdHZhciBvYmplY3QgPSB7fTtcblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0XHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdGluYXRpb247XG5cdH07XG5cblx0dmFyIGZvckVhY2ggPSBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2spIHtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4KTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHRvU3RyaW5nID0gb2JqZWN0LnRvU3RyaW5nO1xuXHR2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cdHZhciBpc051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cdH07XG5cblx0Ly8gVGhpcyBhc3N1bWVzIHRoYXQgYG51bWJlcmAgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyIHRoYXQgYHRvU3RyaW5nKClgcyBuaWNlbHlcblx0Ly8gKHdoaWNoIGlzIHRoZSBjYXNlIGZvciBhbGwgY29kZSBwb2ludCB2YWx1ZXMpLlxuXHR2YXIgemVyb2VzID0gJzAwMDAnO1xuXHR2YXIgcGFkID0gZnVuY3Rpb24obnVtYmVyLCB0b3RhbENoYXJhY3RlcnMpIHtcblx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKG51bWJlcik7XG5cdFx0cmV0dXJuIHN0cmluZy5sZW5ndGggPCB0b3RhbENoYXJhY3RlcnNcblx0XHRcdD8gKHplcm9lcyArIHN0cmluZykuc2xpY2UoLXRvdGFsQ2hhcmFjdGVycylcblx0XHRcdDogc3RyaW5nO1xuXHR9O1xuXG5cdHZhciBoZXggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0XHRyZXR1cm4gTnVtYmVyKG51bWJlcikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cblx0dmFyIHNsaWNlID0gW10uc2xpY2U7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIGRhdGFGcm9tQ29kZVBvaW50cyA9IGZ1bmN0aW9uKGNvZGVQb2ludHMpIHtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIG1heCA9IGxlbmd0aCAtIDE7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpc1N0YXJ0ID0gdHJ1ZTtcblx0XHR2YXIgdG1wO1xuXHRcdHZhciBwcmV2aW91cyA9IDA7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHRtcCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0aWYgKGlzU3RhcnQpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2godG1wKTtcblx0XHRcdFx0cHJldmlvdXMgPSB0bXA7XG5cdFx0XHRcdGlzU3RhcnQgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0bXAgPT0gcHJldmlvdXMgKyAxKSB7XG5cdFx0XHRcdFx0aWYgKGluZGV4ICE9IG1heCkge1xuXHRcdFx0XHRcdFx0cHJldmlvdXMgPSB0bXA7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXNTdGFydCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCh0bXAgKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRW5kIHRoZSBwcmV2aW91cyByYW5nZSBhbmQgc3RhcnQgYSBuZXcgb25lLlxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHByZXZpb3VzICsgMSwgdG1wKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWlzU3RhcnQpIHtcblx0XHRcdHJlc3VsdC5wdXNoKHRtcCArIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHZhciBkYXRhUmVtb3ZlID0gZnVuY3Rpb24oZGF0YSwgY29kZVBvaW50KSB7XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIHN0YXJ0O1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhW2luZGV4XTtcblx0XHRcdGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gc3RhcnQgJiYgY29kZVBvaW50IDwgZW5kKSB7XG5cdFx0XHRcdC8vIE1vZGlmeSB0aGlzIHBhaXIuXG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPT0gc3RhcnQpIHtcblx0XHRcdFx0XHRpZiAoZW5kID09IHN0YXJ0ICsgMSkge1xuXHRcdFx0XHRcdFx0Ly8gSnVzdCByZW1vdmUgYHN0YXJ0YCBhbmQgYGVuZGAuXG5cdFx0XHRcdFx0XHRkYXRhLnNwbGljZShpbmRleCwgMik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gSnVzdCByZXBsYWNlIGBzdGFydGAgd2l0aCBhIG5ldyB2YWx1ZS5cblx0XHRcdFx0XHRcdGRhdGFbaW5kZXhdID0gY29kZVBvaW50ICsgMTtcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjb2RlUG9pbnQgPT0gZW5kIC0gMSkge1xuXHRcdFx0XHRcdC8vIEp1c3QgcmVwbGFjZSBgZW5kYCB3aXRoIGEgbmV3IHZhbHVlLlxuXHRcdFx0XHRcdGRhdGFbaW5kZXggKyAxXSA9IGNvZGVQb2ludDtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBSZXBsYWNlIGBbc3RhcnQsIGVuZF1gIHdpdGggYFtzdGFydEEsIGVuZEEsIHN0YXJ0QiwgZW5kQl1gLlxuXHRcdFx0XHRcdGRhdGEuc3BsaWNlKGluZGV4LCAyLCBzdGFydCwgY29kZVBvaW50LCBjb2RlUG9pbnQgKyAxLCBlbmQpO1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbmRleCArPSAyO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fTtcblxuXHR2YXIgZGF0YVJlbW92ZVJhbmdlID0gZnVuY3Rpb24oZGF0YSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcblx0XHRpZiAocmFuZ2VFbmQgPCByYW5nZVN0YXJ0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihFUlJPUlMucmFuZ2VPcmRlcik7XG5cdFx0fVxuXHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBzdGFydDtcblx0XHR2YXIgZW5kO1xuXHRcdHdoaWxlIChpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRzdGFydCA9IGRhdGFbaW5kZXhdO1xuXHRcdFx0ZW5kID0gZGF0YVtpbmRleCArIDFdIC0gMTsgLy8gTm90ZTogdGhlIGAtIDFgIG1ha2VzIGBlbmRgIGluY2x1c2l2ZS5cblxuXHRcdFx0Ly8gRXhpdCBhcyBzb29uIGFzIG5vIG1vcmUgbWF0Y2hpbmcgcGFpcnMgY2FuIGJlIGZvdW5kLlxuXHRcdFx0aWYgKHN0YXJ0ID4gcmFuZ2VFbmQpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHRoaXMgcmFuZ2UgcGFpciBpcyBlcXVhbCB0bywgb3IgZm9ybXMgYSBzdWJzZXQgb2YsIHRoZSByYW5nZVxuXHRcdFx0Ly8gdG8gYmUgcmVtb3ZlZC5cblx0XHRcdC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExLCA0MCwgNTFdYCBhbmQgd2FudCB0byByZW1vdmUgMC0xMCDihpIgYFs0MCwgNTFdYC5cblx0XHRcdC8vIEUuZy4gd2UgaGF2ZSBgWzQwLCA1MV1gIGFuZCB3YW50IHRvIHJlbW92ZSAwLTEwMCDihpIgYFtdYC5cblx0XHRcdGlmIChyYW5nZVN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlRW5kID49IGVuZCkge1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhpcyBwYWlyLlxuXHRcdFx0XHRkYXRhLnNwbGljZShpbmRleCwgMik7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiBib3RoIGByYW5nZVN0YXJ0YCBhbmQgYHJhbmdlRW5kYCBhcmUgd2l0aGluIHRoZSBib3VuZHMgb2Zcblx0XHRcdC8vIHRoaXMgcGFpci5cblx0XHRcdC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtNiDihpIgYFswLCA0LCA3LCAxMV1gLlxuXHRcdFx0aWYgKHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VFbmQgPCBlbmQpIHtcblx0XHRcdFx0aWYgKHJhbmdlU3RhcnQgPT0gc3RhcnQpIHtcblx0XHRcdFx0XHQvLyBSZXBsYWNlIGBbc3RhcnQsIGVuZF1gIHdpdGggYFtzdGFydEIsIGVuZEJdYC5cblx0XHRcdFx0XHRkYXRhW2luZGV4XSA9IHJhbmdlRW5kICsgMTtcblx0XHRcdFx0XHRkYXRhW2luZGV4ICsgMV0gPSBlbmQgKyAxO1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFJlcGxhY2UgYFtzdGFydCwgZW5kXWAgd2l0aCBgW3N0YXJ0QSwgZW5kQSwgc3RhcnRCLCBlbmRCXWAuXG5cdFx0XHRcdGRhdGEuc3BsaWNlKGluZGV4LCAyLCBzdGFydCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQgKyAxLCBlbmQgKyAxKTtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIG9ubHkgYHJhbmdlU3RhcnRgIGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoaXMgcGFpci5cblx0XHRcdC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtMjAg4oaSIGBbMCwgNF1gLlxuXHRcdFx0aWYgKHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VTdGFydCA8PSBlbmQpIHtcblx0XHRcdFx0Ly8gUmVwbGFjZSBgZW5kYCB3aXRoIGByYW5nZVN0YXJ0YC5cblx0XHRcdFx0ZGF0YVtpbmRleCArIDFdID0gcmFuZ2VTdGFydDtcblx0XHRcdFx0Ly8gTm90ZTogd2UgY2Fubm90IGByZXR1cm5gIGp1c3QgeWV0LCBpbiBjYXNlIGFueSBmb2xsb3dpbmcgcGFpcnMgc3RpbGxcblx0XHRcdFx0Ly8gY29udGFpbiBtYXRjaGluZyBjb2RlIHBvaW50cy5cblx0XHRcdFx0Ly8gRS5nLiB3ZSBoYXZlIGBbMCwgMTEsIDE0LCAzMV1gIGFuZCB3YW50IHRvIHJlbW92ZSA0LTIwXG5cdFx0XHRcdC8vIOKGkiBgWzAsIDQsIDIxLCAzMV1gLlxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiBvbmx5IGByYW5nZUVuZGAgaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhpcyBwYWlyLlxuXHRcdFx0Ly8gRS5nLiB3ZSBoYXZlIGBbMTQsIDMxXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtMjAg4oaSIGBbMjEsIDMxXWAuXG5cdFx0XHRlbHNlIGlmIChyYW5nZUVuZCA+PSBzdGFydCAmJiByYW5nZUVuZCA8PSBlbmQpIHtcblx0XHRcdFx0Ly8gSnVzdCByZXBsYWNlIGBzdGFydGAuXG5cdFx0XHRcdGRhdGFbaW5kZXhdID0gcmFuZ2VFbmQgKyAxO1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0aW5kZXggKz0gMjtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cblx0IHZhciBkYXRhQWRkID0gZnVuY3Rpb24oZGF0YSwgY29kZVBvaW50KSB7XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIHN0YXJ0O1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIGxhc3RJbmRleCA9IG51bGw7XG5cdFx0dmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdGlmIChjb2RlUG9pbnQgPCAweDAgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoRVJST1JTLmNvZGVQb2ludFJhbmdlKTtcblx0XHR9XG5cdFx0d2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRzdGFydCA9IGRhdGFbaW5kZXhdO1xuXHRcdFx0ZW5kID0gZGF0YVtpbmRleCArIDFdO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgY29kZSBwb2ludCBpcyBhbHJlYWR5IGluIHRoZSBzZXQuXG5cdFx0XHRpZiAoY29kZVBvaW50ID49IHN0YXJ0ICYmIGNvZGVQb2ludCA8IGVuZCkge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvZGVQb2ludCA9PSBzdGFydCAtIDEpIHtcblx0XHRcdFx0Ly8gSnVzdCByZXBsYWNlIGBzdGFydGAgd2l0aCBhIG5ldyB2YWx1ZS5cblx0XHRcdFx0ZGF0YVtpbmRleF0gPSBjb2RlUG9pbnQ7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBpZiBgc3RhcnRgIGlzIGBncmVhdGVyYCB0aGFuIGBjb2RlUG9pbnRgLCBpbnNlcnQgYSBuZXdcblx0XHRcdC8vIGBbc3RhcnQsIGVuZF1gIHBhaXIgYmVmb3JlIHRoZSBjdXJyZW50IHBhaXIsIG9yIGFmdGVyIHRoZSBjdXJyZW50IHBhaXJcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga25vd24gYGxhc3RJbmRleGAuXG5cdFx0XHRpZiAoc3RhcnQgPiBjb2RlUG9pbnQpIHtcblx0XHRcdFx0ZGF0YS5zcGxpY2UoXG5cdFx0XHRcdFx0bGFzdEluZGV4ICE9IG51bGwgPyBsYXN0SW5kZXggKyAyIDogMCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdGNvZGVQb2ludCxcblx0XHRcdFx0XHRjb2RlUG9pbnQgKyAxXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29kZVBvaW50ID09IGVuZCkge1xuXHRcdFx0XHQvLyBDaGVjayBpZiBhZGRpbmcgdGhpcyBjb2RlIHBvaW50IGNhdXNlcyB0d28gc2VwYXJhdGUgcmFuZ2VzIHRvIGJlY29tZVxuXHRcdFx0XHQvLyBhIHNpbmdsZSByYW5nZSwgZS5nLiBgZGF0YUFkZChbMCwgNCwgNSwgMTBdLCA0KWAg4oaSIGBbMCwgMTBdYC5cblx0XHRcdFx0aWYgKGNvZGVQb2ludCArIDEgPT0gZGF0YVtpbmRleCArIDJdKSB7XG5cdFx0XHRcdFx0ZGF0YS5zcGxpY2UoaW5kZXgsIDQsIHN0YXJ0LCBkYXRhW2luZGV4ICsgM10pO1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEVsc2UsIGp1c3QgcmVwbGFjZSBgZW5kYCB3aXRoIGEgbmV3IHZhbHVlLlxuXHRcdFx0XHRkYXRhW2luZGV4ICsgMV0gPSBjb2RlUG9pbnQgKyAxO1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH1cblx0XHRcdGxhc3RJbmRleCA9IGluZGV4O1xuXHRcdFx0aW5kZXggKz0gMjtcblx0XHR9XG5cdFx0Ly8gVGhlIGxvb3AgaGFzIGZpbmlzaGVkOyBhZGQgdGhlIG5ldyBwYWlyIHRvIHRoZSBlbmQgb2YgdGhlIGRhdGEgc2V0LlxuXHRcdGRhdGEucHVzaChjb2RlUG9pbnQsIGNvZGVQb2ludCArIDEpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXG5cdHZhciBkYXRhQWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQikge1xuXHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBzdGFydDtcblx0XHR2YXIgZW5kO1xuXHRcdHZhciBkYXRhID0gZGF0YUEuc2xpY2UoKTtcblx0XHR2YXIgbGVuZ3RoID0gZGF0YUIubGVuZ3RoO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhQltpbmRleF07XG5cdFx0XHRlbmQgPSBkYXRhQltpbmRleCArIDFdIC0gMTtcblx0XHRcdGlmIChzdGFydCA9PSBlbmQpIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFBZGQoZGF0YSwgc3RhcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFBZGRSYW5nZShkYXRhLCBzdGFydCwgZW5kKTtcblx0XHRcdH1cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXG5cdHZhciBkYXRhUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQikge1xuXHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBzdGFydDtcblx0XHR2YXIgZW5kO1xuXHRcdHZhciBkYXRhID0gZGF0YUEuc2xpY2UoKTtcblx0XHR2YXIgbGVuZ3RoID0gZGF0YUIubGVuZ3RoO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhQltpbmRleF07XG5cdFx0XHRlbmQgPSBkYXRhQltpbmRleCArIDFdIC0gMTtcblx0XHRcdGlmIChzdGFydCA9PSBlbmQpIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFSZW1vdmUoZGF0YSwgc3RhcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFSZW1vdmVSYW5nZShkYXRhLCBzdGFydCwgZW5kKTtcblx0XHRcdH1cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXG5cdHZhciBkYXRhQWRkUmFuZ2UgPSBmdW5jdGlvbihkYXRhLCByYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuXHRcdGlmIChyYW5nZUVuZCA8IHJhbmdlU3RhcnQpIHtcblx0XHRcdHRocm93IEVycm9yKEVSUk9SUy5yYW5nZU9yZGVyKTtcblx0XHR9XG5cdFx0aWYgKFxuXHRcdFx0cmFuZ2VTdGFydCA8IDB4MCB8fCByYW5nZVN0YXJ0ID4gMHgxMEZGRkYgfHxcblx0XHRcdHJhbmdlRW5kIDwgMHgwIHx8IHJhbmdlRW5kID4gMHgxMEZGRkZcblx0XHQpIHtcblx0XHRcdHRocm93IFJhbmdlRXJyb3IoRVJST1JTLmNvZGVQb2ludFJhbmdlKTtcblx0XHR9XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIHN0YXJ0O1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIGFkZGVkID0gZmFsc2U7XG5cdFx0dmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhW2luZGV4XTtcblx0XHRcdGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcblxuXHRcdFx0aWYgKGFkZGVkKSB7XG5cdFx0XHRcdC8vIFRoZSByYW5nZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBzZXQ7IGF0IHRoaXMgcG9pbnQsIHdlIGp1c3Rcblx0XHRcdFx0Ly8gbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBmb2xsb3dpbmcgcmFuZ2VzIGluIGNhc2UgdGhleSBvdmVybGFwLlxuXG5cdFx0XHRcdC8vIENoZWNrIGlmIHRoaXMgcmFuZ2UgY2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIHByZXZpb3VzIHJhbmdlLlxuXHRcdFx0XHRpZiAoc3RhcnQgPT0gcmFuZ2VFbmQgKyAxKSB7XG5cdFx0XHRcdFx0ZGF0YS5zcGxpY2UoaW5kZXggLSAxLCAyKTtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEV4aXQgYXMgc29vbiBhcyBubyBtb3JlIHBvc3NpYmx5IG92ZXJsYXBwaW5nIHBhaXJzIGNhbiBiZSBmb3VuZC5cblx0XHRcdFx0aWYgKHN0YXJ0ID4gcmFuZ2VFbmQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEUuZy4gYFswLCAxMSwgMTIsIDE2XWAgYW5kIHdl4oCZdmUgYWRkZWQgNS0xNSwgc28gd2Ugbm93IGhhdmVcblx0XHRcdFx0Ly8gYFswLCAxNiwgMTIsIDE2XWAuIFJlbW92ZSB0aGUgYDEyLDE2YCBwYXJ0LCBhcyBpdCBsaWVzIHdpdGhpbiB0aGVcblx0XHRcdFx0Ly8gYDAsMTZgIHJhbmdlIHRoYXQgd2FzIHByZXZpb3VzbHkgYWRkZWQuXG5cdFx0XHRcdGlmIChzdGFydCA+PSByYW5nZVN0YXJ0ICYmIHN0YXJ0IDw9IHJhbmdlRW5kKSB7XG5cdFx0XHRcdFx0Ly8gYHN0YXJ0YCBsaWVzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCB3YXMgcHJldmlvdXNseSBhZGRlZC5cblxuXHRcdFx0XHRcdGlmIChlbmQgPiByYW5nZVN0YXJ0ICYmIGVuZCAtIDEgPD0gcmFuZ2VFbmQpIHtcblx0XHRcdFx0XHRcdC8vIGBlbmRgIGxpZXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IHdhcyBwcmV2aW91c2x5IGFkZGVkIGFzIHdlbGwsXG5cdFx0XHRcdFx0XHQvLyBzbyByZW1vdmUgdGhpcyBwYWlyLlxuXHRcdFx0XHRcdFx0ZGF0YS5zcGxpY2UoaW5kZXgsIDIpO1xuXHRcdFx0XHRcdFx0aW5kZXggLT0gMjtcblx0XHRcdFx0XHRcdC8vIE5vdGU6IHdlIGNhbm5vdCBgcmV0dXJuYCBqdXN0IHlldCwgYXMgdGhlcmUgbWF5IHN0aWxsIGJlIG90aGVyXG5cdFx0XHRcdFx0XHQvLyBvdmVybGFwcGluZyBwYWlycy5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gYHN0YXJ0YCBsaWVzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCB3YXMgcHJldmlvdXNseSBhZGRlZCwgYnV0XG5cdFx0XHRcdFx0XHQvLyBgZW5kYCBkb2VzbuKAmXQuIEUuZy4gYFswLCAxMSwgMTIsIDMxXWAgYW5kIHdl4oCZdmUgYWRkZWQgNS0xNSwgc29cblx0XHRcdFx0XHRcdC8vIG5vdyB3ZSBoYXZlIGBbMCwgMTYsIDEyLCAzMV1gLiBUaGlzIG11c3QgYmUgd3JpdHRlbiBhcyBgWzAsIDMxXWAuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIHByZXZpb3VzbHkgYWRkZWQgYGVuZGAgYW5kIHRoZSBjdXJyZW50IGBzdGFydGAuXG5cdFx0XHRcdFx0XHRkYXRhLnNwbGljZShpbmRleCAtIDEsIDIpO1xuXHRcdFx0XHRcdFx0aW5kZXggLT0gMjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOb3RlOiB3ZSBjYW5ub3QgcmV0dXJuIHlldC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGVsc2UgaWYgKHN0YXJ0ID09IHJhbmdlRW5kICsgMSkge1xuXHRcdFx0XHRkYXRhW2luZGV4XSA9IHJhbmdlU3RhcnQ7XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIG5ldyBwYWlyIG11c3QgYmUgaW5zZXJ0ZWQgKmJlZm9yZSogdGhlIGN1cnJlbnQgb25lLlxuXHRcdFx0ZWxzZSBpZiAoc3RhcnQgPiByYW5nZUVuZCkge1xuXHRcdFx0XHRkYXRhLnNwbGljZShpbmRleCwgMCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQgKyAxKTtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdGVsc2UgaWYgKHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VTdGFydCA8IGVuZCAmJiByYW5nZUVuZCArIDEgPD0gZW5kKSB7XG5cdFx0XHRcdC8vIFRoZSBuZXcgcmFuZ2UgbGllcyBlbnRpcmVseSB3aXRoaW4gYW4gZXhpc3RpbmcgcmFuZ2UgcGFpci4gTm8gYWN0aW9uXG5cdFx0XHRcdC8vIG5lZWRlZC5cblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdGVsc2UgaWYgKFxuXHRcdFx0XHQvLyBFLmcuIGBbMCwgMTFdYCBhbmQgeW91IGFkZCA1LTE1IOKGkiBgWzAsIDE2XWAuXG5cdFx0XHRcdChyYW5nZVN0YXJ0ID49IHN0YXJ0ICYmIHJhbmdlU3RhcnQgPCBlbmQpIHx8XG5cdFx0XHRcdC8vIEUuZy4gYFswLCAzXWAgYW5kIHlvdSBhZGQgMy02IOKGkiBgWzAsIDddYC5cblx0XHRcdFx0ZW5kID09IHJhbmdlU3RhcnRcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBSZXBsYWNlIGBlbmRgIHdpdGggdGhlIG5ldyB2YWx1ZS5cblx0XHRcdFx0ZGF0YVtpbmRleCArIDFdID0gcmFuZ2VFbmQgKyAxO1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIG5leHQgcmFuZ2UgcGFpciBkb2VzbuKAmXQgb3ZlcmxhcCwgZS5nLiBgWzAsIDExLCAxMiwgMTRdYFxuXHRcdFx0XHQvLyBhbmQgeW91IGFkZCA1LTE1IOKGkiBgWzAsIDE2XWAsIGkuZS4gcmVtb3ZlIHRoZSBgMTIsMTRgIHBhcnQuXG5cdFx0XHRcdGFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0Ly8gTm90ZTogd2UgY2Fubm90IGByZXR1cm5gIGp1c3QgeWV0LlxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmIChyYW5nZVN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlRW5kICsgMSA+PSBlbmQpIHtcblx0XHRcdFx0Ly8gVGhlIG5ldyByYW5nZSBpcyBhIHN1cGVyc2V0IG9mIHRoZSBvbGQgcmFuZ2UuXG5cdFx0XHRcdGRhdGFbaW5kZXhdID0gcmFuZ2VTdGFydDtcblx0XHRcdFx0ZGF0YVtpbmRleCArIDFdID0gcmFuZ2VFbmQgKyAxO1xuXHRcdFx0XHRhZGRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdC8vIFRoZSBsb29wIGhhcyBmaW5pc2hlZCB3aXRob3V0IGRvaW5nIGFueXRoaW5nOyBhZGQgdGhlIG5ldyBwYWlyIHRvIHRoZSBlbmRcblx0XHQvLyBvZiB0aGUgZGF0YSBzZXQuXG5cdFx0aWYgKCFhZGRlZCkge1xuXHRcdFx0ZGF0YS5wdXNoKHJhbmdlU3RhcnQsIHJhbmdlRW5kICsgMSk7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXG5cdHZhciBkYXRhQ29udGFpbnMgPSBmdW5jdGlvbihkYXRhLCBjb2RlUG9pbnQpIHtcblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIGBjb2RlUG9pbnRgIGlzIG5vdCB3aXRoaW4gYGRhdGFg4oCZcyBvdmVyYWxsIHJhbmdlLlxuXHRcdHZhciBzdGFydCA9IGRhdGFbaW5kZXhdO1xuXHRcdHZhciBlbmQgPSBkYXRhW2xlbmd0aCAtIDFdO1xuXHRcdGlmIChsZW5ndGggPj0gMikge1xuXHRcdFx0aWYgKGNvZGVQb2ludCA8IHN0YXJ0IHx8IGNvZGVQb2ludCA+IGVuZCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cblx0XHR3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHN0YXJ0ID0gZGF0YVtpbmRleF07XG5cdFx0XHRlbmQgPSBkYXRhW2luZGV4ICsgMV07XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IHN0YXJ0ICYmIGNvZGVQb2ludCA8IGVuZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR2YXIgZGF0YUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGRhdGEsIGNvZGVQb2ludHMpIHtcblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0aWYgKGRhdGFDb250YWlucyhkYXRhLCBjb2RlUG9pbnQpKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHQrK2luZGV4O1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YUZyb21Db2RlUG9pbnRzKHJlc3VsdCk7XG5cdH07XG5cblx0dmFyIGRhdGFJc0VtcHR5ID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdHJldHVybiAhZGF0YS5sZW5ndGg7XG5cdH07XG5cblx0dmFyIGRhdGFJc1NpbmdsZXRvbiA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgc2V0IG9ubHkgcmVwcmVzZW50cyBhIHNpbmdsZSBjb2RlIHBvaW50LlxuXHRcdHJldHVybiBkYXRhLmxlbmd0aCA9PSAyICYmIGRhdGFbMF0gKyAxID09IGRhdGFbMV07XG5cdH07XG5cblx0dmFyIGRhdGFUb0FycmF5ID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBzdGFydDtcblx0XHR2YXIgZW5kO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cdFx0d2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRzdGFydCA9IGRhdGFbaW5kZXhdO1xuXHRcdFx0ZW5kID0gZGF0YVtpbmRleCArIDFdO1xuXHRcdFx0d2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHN0YXJ0KTtcblx0XHRcdFx0KytzdGFydDtcblx0XHRcdH1cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdHZhciBoaWdoU3Vycm9nYXRlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdFx0cmV0dXJuIHBhcnNlSW50KFxuXHRcdFx0Zmxvb3IoKGNvZGVQb2ludCAtIDB4MTAwMDApIC8gMHg0MDApICsgSElHSF9TVVJST0dBVEVfTUlOLFxuXHRcdFx0MTBcblx0XHQpO1xuXHR9O1xuXG5cdHZhciBsb3dTdXJyb2dhdGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0XHRyZXR1cm4gcGFyc2VJbnQoXG5cdFx0XHQoY29kZVBvaW50IC0gMHgxMDAwMCkgJSAweDQwMCArIExPV19TVVJST0dBVEVfTUlOLFxuXHRcdFx0MTBcblx0XHQpO1xuXHR9O1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXHR2YXIgY29kZVBvaW50VG9TdHJpbmcgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0XHR2YXIgc3RyaW5nO1xuXHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG5cdFx0Ly8gTm90ZTogdGhlIGBcXGJgIGVzY2FwZSBzZXF1ZW5jZSBmb3IgVSswMDA4IEJBQ0tTUEFDRSBpbiBzdHJpbmdzIGhhcyBhXG5cdFx0Ly8gZGlmZmVyZW50IG1lYW5pbmcgaW4gcmVndWxhciBleHByZXNzaW9ucyAod29yZCBib3VuZGFyeSksIHNvIGl0IGNhbm5vdFxuXHRcdC8vIGJlIHVzZWQgaGVyZS5cblx0XHRpZiAoY29kZVBvaW50ID09IDB4MDkpIHtcblx0XHRcdHN0cmluZyA9ICdcXFxcdCc7XG5cdFx0fVxuXHRcdC8vIE5vdGU6IElFIDwgOSB0cmVhdHMgYCdcXHYnYCBhcyBgJ3YnYCwgc28gYXZvaWQgdXNpbmcgaXQuXG5cdFx0Ly8gZWxzZSBpZiAoY29kZVBvaW50ID09IDB4MEIpIHtcblx0XHQvLyBcdHN0cmluZyA9ICdcXFxcdic7XG5cdFx0Ly8gfVxuXHRcdGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBBKSB7XG5cdFx0XHRzdHJpbmcgPSAnXFxcXG4nO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjb2RlUG9pbnQgPT0gMHgwQykge1xuXHRcdFx0c3RyaW5nID0gJ1xcXFxmJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY29kZVBvaW50ID09IDB4MEQpIHtcblx0XHRcdHN0cmluZyA9ICdcXFxccic7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDVDKSB7XG5cdFx0XHRzdHJpbmcgPSAnXFxcXFxcXFwnO1xuXHRcdH1cblx0XHRlbHNlIGlmIChcblx0XHRcdGNvZGVQb2ludCA9PSAweDI0IHx8XG5cdFx0XHQoY29kZVBvaW50ID49IDB4MjggJiYgY29kZVBvaW50IDw9IDB4MkIpIHx8XG5cdFx0XHRjb2RlUG9pbnQgPT0gMHgyRCB8fCBjb2RlUG9pbnQgPT0gMHgyRSB8fCBjb2RlUG9pbnQgPT0gMHgzRiB8fFxuXHRcdFx0KGNvZGVQb2ludCA+PSAweDVCICYmIGNvZGVQb2ludCA8PSAweDVFKSB8fFxuXHRcdFx0KGNvZGVQb2ludCA+PSAweDdCICYmIGNvZGVQb2ludCA8PSAweDdEKVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGNvZGUgcG9pbnQgbWFwcyB0byBhbiB1bnNhZmUgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3Rlcjtcblx0XHRcdC8vIGJhY2tzbGFzaC1lc2NhcGUgaXQuIEhlcmXigJlzIHRoZSBsaXN0IG9mIHRob3NlIHN5bWJvbHM6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAgICQoKSorLS4/W1xcXV57fH1cblx0XHRcdC8vXG5cdFx0XHQvLyBTZWUgIzcgZm9yIG1vcmUgaW5mby5cblx0XHRcdHN0cmluZyA9ICdcXFxcJyArIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjb2RlUG9pbnQgPj0gMHgyMCAmJiBjb2RlUG9pbnQgPD0gMHg3RSkge1xuXHRcdFx0Ly8gVGhlIGNvZGUgcG9pbnQgbWFwcyB0byBvbmUgb2YgdGhlc2UgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHNcblx0XHRcdC8vIChpbmNsdWRpbmcgdGhlIHNwYWNlIGNoYXJhY3Rlcik6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAgICAhXCIjJSYnLC8wMTIzNDU2Nzg5Ojs8PT5AQUJDREVGR0hJSktMTU5PXG5cdFx0XHQvLyAgICAgUFFSU1RVVldYWVpfYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6flxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoZXNlIGNhbiBzYWZlbHkgYmUgdXNlZCBkaXJlY3RseS5cblx0XHRcdHN0cmluZyA9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhGRikge1xuXHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZXNjYXBlcyNoZXhhZGVjaW1hbFxuXHRcdFx0c3RyaW5nID0gJ1xcXFx4JyArIHBhZChoZXgoY29kZVBvaW50KSwgMik7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBgY29kZVBvaW50IDw9IDB4RkZGRmAgaG9sZHMgdHJ1ZS5cblx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjdW5pY29kZVxuXHRcdFx0c3RyaW5nID0gJ1xcXFx1JyArIHBhZChoZXgoY29kZVBvaW50KSwgNCk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlcmXigJlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgYXN0cmFsIHN5bWJvbHMgLyBzdXJyb2dhdGUgcGFpcnMgaGVyZSxcblx0XHQvLyBzaW5jZSBgY29kZVBvaW50VG9TdHJpbmdgIGlzIHByaXZhdGUgYW5kIG9ubHkgdXNlZCBmb3IgQk1QIGNvZGUgcG9pbnRzLlxuXHRcdC8vIEJ1dCBpZiB0aGF04oCZcyB3aGF0IHlvdSBuZWVkLCBqdXN0IGFkZCBhbiBgZWxzZWAgYmxvY2sgd2l0aCB0aGlzIGNvZGU6XG5cdFx0Ly9cblx0XHQvLyAgICAgc3RyaW5nID0gJ1xcXFx1JyArIHBhZChoZXgoaGlnaFN1cnJvZ2F0ZShjb2RlUG9pbnQpKSwgNClcblx0XHQvLyAgICAgXHQrICdcXFxcdScgKyBwYWQoaGV4KGxvd1N1cnJvZ2F0ZShjb2RlUG9pbnQpKSwgNCk7XG5cblx0XHRyZXR1cm4gc3RyaW5nO1xuXHR9O1xuXG5cdHZhciBzeW1ib2xUb0NvZGVQb2ludCA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHZhciBsZW5ndGggPSBzeW1ib2wubGVuZ3RoO1xuXHRcdHZhciBmaXJzdCA9IHN5bWJvbC5jaGFyQ29kZUF0KDApO1xuXHRcdHZhciBzZWNvbmQ7XG5cdFx0aWYgKFxuXHRcdFx0Zmlyc3QgPj0gSElHSF9TVVJST0dBVEVfTUlOICYmIGZpcnN0IDw9IEhJR0hfU1VSUk9HQVRFX01BWCAmJlxuXHRcdFx0bGVuZ3RoID4gMSAvLyBUaGVyZSBpcyBhIG5leHQgY29kZSB1bml0LlxuXHRcdCkge1xuXHRcdFx0Ly8gYGZpcnN0YCBpcyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci4gQXNzdW1lXG5cdFx0XHQvLyBpdOKAmXMgYSBsb3cgc3Vycm9nYXRlIChlbHNlIGl04oCZcyBpbnZhbGlkIHVzYWdlIG9mIFJlZ2VuZXJhdGUgYW55d2F5KS5cblx0XHRcdHNlY29uZCA9IHN5bWJvbC5jaGFyQ29kZUF0KDEpO1xuXHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRyZXR1cm4gKGZpcnN0IC0gSElHSF9TVVJST0dBVEVfTUlOKSAqIDB4NDAwICtcblx0XHRcdFx0c2Vjb25kIC0gTE9XX1NVUlJPR0FURV9NSU4gKyAweDEwMDAwO1xuXHRcdH1cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH07XG5cblx0dmFyIGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdHZhciBzdGFydDtcblx0XHR2YXIgZW5kO1xuXHRcdHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0XHRpZiAoZGF0YUlzU2luZ2xldG9uKGRhdGEpKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50VG9TdHJpbmcoZGF0YVswXSk7XG5cdFx0fVxuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhW2luZGV4XTtcblx0XHRcdGVuZCA9IGRhdGFbaW5kZXggKyAxXSAtIDE7IC8vIE5vdGU6IHRoZSBgLSAxYCBtYWtlcyBgZW5kYCBpbmNsdXNpdmUuXG5cdFx0XHRpZiAoc3RhcnQgPT0gZW5kKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGFydCk7XG5cdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ICsgMSA9PSBlbmQpIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXJ0KSArIGNvZGVQb2ludFRvU3RyaW5nKGVuZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhcnQpICsgJy0nICsgY29kZVBvaW50VG9TdHJpbmcoZW5kKTtcblx0XHRcdH1cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiAnWycgKyByZXN1bHQgKyAnXSc7XG5cdH07XG5cblx0dmFyIHNwbGl0QXRCTVAgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciBsb25lSGlnaFN1cnJvZ2F0ZXMgPSBbXTtcblx0XHR2YXIgbG9uZUxvd1N1cnJvZ2F0ZXMgPSBbXTtcblx0XHR2YXIgYm1wID0gW107XG5cdFx0dmFyIGFzdHJhbCA9IFtdO1xuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIHN0YXJ0O1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhW2luZGV4XTtcblx0XHRcdGVuZCA9IGRhdGFbaW5kZXggKyAxXSAtIDE7IC8vIE5vdGU6IHRoZSBgLSAxYCBtYWtlcyBgZW5kYCBpbmNsdXNpdmUuXG5cblx0XHRcdGlmIChzdGFydCA8IEhJR0hfU1VSUk9HQVRFX01JTikge1xuXG5cdFx0XHRcdC8vIFRoZSByYW5nZSBzdGFydHMgYW5kIGVuZHMgYmVmb3JlIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZS5cblx0XHRcdFx0Ly8gRS5nLiAoMCwgMHgxMCkuXG5cdFx0XHRcdGlmIChlbmQgPCBISUdIX1NVUlJPR0FURV9NSU4pIHtcblx0XHRcdFx0XHRibXAucHVzaChzdGFydCwgZW5kICsgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgcmFuZ2Ugc3RhcnRzIGJlZm9yZSB0aGUgaGlnaCBzdXJyb2dhdGUgcmFuZ2UgYW5kIGVuZHMgd2l0aGluIGl0LlxuXHRcdFx0XHQvLyBFLmcuICgwLCAweEQ4NTUpLlxuXHRcdFx0XHRpZiAoZW5kID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBlbmQgPD0gSElHSF9TVVJST0dBVEVfTUFYKSB7XG5cdFx0XHRcdFx0Ym1wLnB1c2goc3RhcnQsIEhJR0hfU1VSUk9HQVRFX01JTik7XG5cdFx0XHRcdFx0bG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goSElHSF9TVVJST0dBVEVfTUlOLCBlbmQgKyAxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoZSByYW5nZSBzdGFydHMgYmVmb3JlIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZSBhbmQgZW5kcyBpbiB0aGUgbG93XG5cdFx0XHRcdC8vIHN1cnJvZ2F0ZSByYW5nZS4gRS5nLiAoMCwgMHhEQ0ZGKS5cblx0XHRcdFx0aWYgKGVuZCA+PSBMT1dfU1VSUk9HQVRFX01JTiAmJiBlbmQgPD0gTE9XX1NVUlJPR0FURV9NQVgpIHtcblx0XHRcdFx0XHRibXAucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUlOKTtcblx0XHRcdFx0XHRsb25lSGlnaFN1cnJvZ2F0ZXMucHVzaChISUdIX1NVUlJPR0FURV9NSU4sIEhJR0hfU1VSUk9HQVRFX01BWCArIDEpO1xuXHRcdFx0XHRcdGxvbmVMb3dTdXJyb2dhdGVzLnB1c2goTE9XX1NVUlJPR0FURV9NSU4sIGVuZCArIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIHJhbmdlIHN0YXJ0cyBiZWZvcmUgdGhlIGhpZ2ggc3Vycm9nYXRlIHJhbmdlIGFuZCBlbmRzIGFmdGVyIHRoZVxuXHRcdFx0XHQvLyBsb3cgc3Vycm9nYXRlIHJhbmdlLiBFLmcuICgwLCAweDEwRkZGRikuXG5cdFx0XHRcdGlmIChlbmQgPiBMT1dfU1VSUk9HQVRFX01BWCkge1xuXHRcdFx0XHRcdGJtcC5wdXNoKHN0YXJ0LCBISUdIX1NVUlJPR0FURV9NSU4pO1xuXHRcdFx0XHRcdGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKEhJR0hfU1VSUk9HQVRFX01JTiwgSElHSF9TVVJST0dBVEVfTUFYICsgMSk7XG5cdFx0XHRcdFx0bG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChMT1dfU1VSUk9HQVRFX01JTiwgTE9XX1NVUlJPR0FURV9NQVggKyAxKTtcblx0XHRcdFx0XHRpZiAoZW5kIDw9IDB4RkZGRikge1xuXHRcdFx0XHRcdFx0Ym1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCBlbmQgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCAweEZGRkYgKyAxKTtcblx0XHRcdFx0XHRcdGFzdHJhbC5wdXNoKDB4RkZGRiArIDEsIGVuZCArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBzdGFydCA8PSBISUdIX1NVUlJPR0FURV9NQVgpIHtcblxuXHRcdFx0XHQvLyBUaGUgcmFuZ2Ugc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZS5cblx0XHRcdFx0Ly8gRS5nLiAoMHhEODU1LCAweEQ4NjYpLlxuXHRcdFx0XHRpZiAoZW5kID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBlbmQgPD0gSElHSF9TVVJST0dBVEVfTUFYKSB7XG5cdFx0XHRcdFx0bG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIHJhbmdlIHN0YXJ0cyBpbiB0aGUgaGlnaCBzdXJyb2dhdGUgcmFuZ2UgYW5kIGVuZHMgaW4gdGhlIGxvd1xuXHRcdFx0XHQvLyBzdXJyb2dhdGUgcmFuZ2UuIEUuZy4gKDB4RDg1NSwgMHhEQ0ZGKS5cblx0XHRcdFx0aWYgKGVuZCA+PSBMT1dfU1VSUk9HQVRFX01JTiAmJiBlbmQgPD0gTE9XX1NVUlJPR0FURV9NQVgpIHtcblx0XHRcdFx0XHRsb25lSGlnaFN1cnJvZ2F0ZXMucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUFYICsgMSk7XG5cdFx0XHRcdFx0bG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChMT1dfU1VSUk9HQVRFX01JTiwgZW5kICsgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgcmFuZ2Ugc3RhcnRzIGluIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZSBhbmQgZW5kcyBhZnRlciB0aGUgbG93XG5cdFx0XHRcdC8vIHN1cnJvZ2F0ZSByYW5nZS4gRS5nLiAoMHhEODU1LCAweDEwRkZGRikuXG5cdFx0XHRcdGlmIChlbmQgPiBMT1dfU1VSUk9HQVRFX01BWCkge1xuXHRcdFx0XHRcdGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKHN0YXJ0LCBISUdIX1NVUlJPR0FURV9NQVggKyAxKTtcblx0XHRcdFx0XHRsb25lTG93U3Vycm9nYXRlcy5wdXNoKExPV19TVVJST0dBVEVfTUlOLCBMT1dfU1VSUk9HQVRFX01BWCArIDEpO1xuXHRcdFx0XHRcdGlmIChlbmQgPD0gMHhGRkZGKSB7XG5cdFx0XHRcdFx0XHRibXAucHVzaChMT1dfU1VSUk9HQVRFX01BWCArIDEsIGVuZCArIDEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibXAucHVzaChMT1dfU1VSUk9HQVRFX01BWCArIDEsIDB4RkZGRiArIDEpO1xuXHRcdFx0XHRcdFx0YXN0cmFsLnB1c2goMHhGRkZGICsgMSwgZW5kICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoc3RhcnQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgc3RhcnQgPD0gTE9XX1NVUlJPR0FURV9NQVgpIHtcblxuXHRcdFx0XHQvLyBUaGUgcmFuZ2Ugc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBsb3cgc3Vycm9nYXRlIHJhbmdlLlxuXHRcdFx0XHQvLyBFLmcuICgweERDRkYsIDB4RERGRikuXG5cdFx0XHRcdGlmIChlbmQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IExPV19TVVJST0dBVEVfTUFYKSB7XG5cdFx0XHRcdFx0bG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgZW5kICsgMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgcmFuZ2Ugc3RhcnRzIGluIHRoZSBsb3cgc3Vycm9nYXRlIHJhbmdlIGFuZCBlbmRzIGFmdGVyIHRoZSBsb3dcblx0XHRcdFx0Ly8gc3Vycm9nYXRlIHJhbmdlLiBFLmcuICgweERDRkYsIDB4MTBGRkZGKS5cblx0XHRcdFx0aWYgKGVuZCA+IExPV19TVVJST0dBVEVfTUFYKSB7XG5cdFx0XHRcdFx0bG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgTE9XX1NVUlJPR0FURV9NQVggKyAxKTtcblx0XHRcdFx0XHRpZiAoZW5kIDw9IDB4RkZGRikge1xuXHRcdFx0XHRcdFx0Ym1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCBlbmQgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCAweEZGRkYgKyAxKTtcblx0XHRcdFx0XHRcdGFzdHJhbC5wdXNoKDB4RkZGRiArIDEsIGVuZCArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHN0YXJ0ID4gTE9XX1NVUlJPR0FURV9NQVggJiYgc3RhcnQgPD0gMHhGRkZGKSB7XG5cblx0XHRcdFx0Ly8gVGhlIHJhbmdlIHN0YXJ0cyBhbmQgZW5kcyBhZnRlciB0aGUgbG93IHN1cnJvZ2F0ZSByYW5nZS5cblx0XHRcdFx0Ly8gRS5nLiAoMHhGRkFBLCAweDEwRkZGRikuXG5cdFx0XHRcdGlmIChlbmQgPD0gMHhGRkZGKSB7XG5cdFx0XHRcdFx0Ym1wLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJtcC5wdXNoKHN0YXJ0LCAweEZGRkYgKyAxKTtcblx0XHRcdFx0XHRhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFRoZSByYW5nZSBzdGFydHMgYW5kIGVuZHMgaW4gdGhlIGFzdHJhbCByYW5nZS5cblx0XHRcdFx0YXN0cmFsLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZGV4ICs9IDI7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHQnbG9uZUhpZ2hTdXJyb2dhdGVzJzogbG9uZUhpZ2hTdXJyb2dhdGVzLFxuXHRcdFx0J2xvbmVMb3dTdXJyb2dhdGVzJzogbG9uZUxvd1N1cnJvZ2F0ZXMsXG5cdFx0XHQnYm1wJzogYm1wLFxuXHRcdFx0J2FzdHJhbCc6IGFzdHJhbFxuXHRcdH07XG5cdH07XG5cblx0dmFyIG9wdGltaXplU3Vycm9nYXRlTWFwcGluZ3MgPSBmdW5jdGlvbihzdXJyb2dhdGVNYXBwaW5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR2YXIgdG1wTG93ID0gW107XG5cdFx0dmFyIGFkZExvdyA9IGZhbHNlO1xuXHRcdHZhciBtYXBwaW5nO1xuXHRcdHZhciBuZXh0TWFwcGluZztcblx0XHR2YXIgaGlnaFN1cnJvZ2F0ZXM7XG5cdFx0dmFyIGxvd1N1cnJvZ2F0ZXM7XG5cdFx0dmFyIG5leHRIaWdoU3Vycm9nYXRlcztcblx0XHR2YXIgbmV4dExvd1N1cnJvZ2F0ZXM7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGxlbmd0aCA9IHN1cnJvZ2F0ZU1hcHBpbmdzLmxlbmd0aDtcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0bWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4XTtcblx0XHRcdG5leHRNYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5kZXggKyAxXTtcblx0XHRcdGlmICghbmV4dE1hcHBpbmcpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2gobWFwcGluZyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aGlnaFN1cnJvZ2F0ZXMgPSBtYXBwaW5nWzBdO1xuXHRcdFx0bG93U3Vycm9nYXRlcyA9IG1hcHBpbmdbMV07XG5cdFx0XHRuZXh0SGlnaFN1cnJvZ2F0ZXMgPSBuZXh0TWFwcGluZ1swXTtcblx0XHRcdG5leHRMb3dTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmdbMV07XG5cblx0XHRcdC8vIENoZWNrIGZvciBpZGVudGljYWwgaGlnaCBzdXJyb2dhdGUgcmFuZ2VzLlxuXHRcdFx0dG1wTG93ID0gbG93U3Vycm9nYXRlcztcblx0XHRcdHdoaWxlIChcblx0XHRcdFx0bmV4dEhpZ2hTdXJyb2dhdGVzICYmXG5cdFx0XHRcdGhpZ2hTdXJyb2dhdGVzWzBdID09IG5leHRIaWdoU3Vycm9nYXRlc1swXSAmJlxuXHRcdFx0XHRoaWdoU3Vycm9nYXRlc1sxXSA9PSBuZXh0SGlnaFN1cnJvZ2F0ZXNbMV1cblx0XHRcdCkge1xuXHRcdFx0XHQvLyBNZXJnZSB3aXRoIHRoZSBuZXh0IGl0ZW0uXG5cdFx0XHRcdGlmIChkYXRhSXNTaW5nbGV0b24obmV4dExvd1N1cnJvZ2F0ZXMpKSB7XG5cdFx0XHRcdFx0dG1wTG93ID0gZGF0YUFkZCh0bXBMb3csIG5leHRMb3dTdXJyb2dhdGVzWzBdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXBMb3cgPSBkYXRhQWRkUmFuZ2UoXG5cdFx0XHRcdFx0XHR0bXBMb3csXG5cdFx0XHRcdFx0XHRuZXh0TG93U3Vycm9nYXRlc1swXSxcblx0XHRcdFx0XHRcdG5leHRMb3dTdXJyb2dhdGVzWzFdIC0gMVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0KytpbmRleDtcblx0XHRcdFx0bWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4XTtcblx0XHRcdFx0aGlnaFN1cnJvZ2F0ZXMgPSBtYXBwaW5nWzBdO1xuXHRcdFx0XHRsb3dTdXJyb2dhdGVzID0gbWFwcGluZ1sxXTtcblx0XHRcdFx0bmV4dE1hcHBpbmcgPSBzdXJyb2dhdGVNYXBwaW5nc1tpbmRleCArIDFdO1xuXHRcdFx0XHRuZXh0SGlnaFN1cnJvZ2F0ZXMgPSBuZXh0TWFwcGluZyAmJiBuZXh0TWFwcGluZ1swXTtcblx0XHRcdFx0bmV4dExvd1N1cnJvZ2F0ZXMgPSBuZXh0TWFwcGluZyAmJiBuZXh0TWFwcGluZ1sxXTtcblx0XHRcdFx0YWRkTG93ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKFtcblx0XHRcdFx0aGlnaFN1cnJvZ2F0ZXMsXG5cdFx0XHRcdGFkZExvdyA/IHRtcExvdyA6IGxvd1N1cnJvZ2F0ZXNcblx0XHRcdF0pO1xuXHRcdFx0YWRkTG93ID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpbWl6ZUJ5TG93U3Vycm9nYXRlcyhyZXN1bHQpO1xuXHR9O1xuXG5cdHZhciBvcHRpbWl6ZUJ5TG93U3Vycm9nYXRlcyA9IGZ1bmN0aW9uKHN1cnJvZ2F0ZU1hcHBpbmdzKSB7XG5cdFx0aWYgKHN1cnJvZ2F0ZU1hcHBpbmdzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRyZXR1cm4gc3Vycm9nYXRlTWFwcGluZ3M7XG5cdFx0fVxuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBpbm5lckluZGV4ID0gLTE7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBzdXJyb2dhdGVNYXBwaW5ncy5sZW5ndGgpIHtcblx0XHRcdHZhciBtYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5kZXhdO1xuXHRcdFx0dmFyIGxvd1N1cnJvZ2F0ZXMgPSBtYXBwaW5nWzFdO1xuXHRcdFx0dmFyIGxvd1N1cnJvZ2F0ZVN0YXJ0ID0gbG93U3Vycm9nYXRlc1swXTtcblx0XHRcdHZhciBsb3dTdXJyb2dhdGVFbmQgPSBsb3dTdXJyb2dhdGVzWzFdO1xuXHRcdFx0aW5uZXJJbmRleCA9IGluZGV4OyAvLyBOb3RlOiB0aGUgbG9vcCBzdGFydHMgYXQgdGhlIG5leHQgaW5kZXguXG5cdFx0XHR3aGlsZSAoKytpbm5lckluZGV4IDwgc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBvdGhlck1hcHBpbmcgPSBzdXJyb2dhdGVNYXBwaW5nc1tpbm5lckluZGV4XTtcblx0XHRcdFx0dmFyIG90aGVyTG93U3Vycm9nYXRlcyA9IG90aGVyTWFwcGluZ1sxXTtcblx0XHRcdFx0dmFyIG90aGVyTG93U3Vycm9nYXRlU3RhcnQgPSBvdGhlckxvd1N1cnJvZ2F0ZXNbMF07XG5cdFx0XHRcdHZhciBvdGhlckxvd1N1cnJvZ2F0ZUVuZCA9IG90aGVyTG93U3Vycm9nYXRlc1sxXTtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGxvd1N1cnJvZ2F0ZVN0YXJ0ID09IG90aGVyTG93U3Vycm9nYXRlU3RhcnQgJiZcblx0XHRcdFx0XHRsb3dTdXJyb2dhdGVFbmQgPT0gb3RoZXJMb3dTdXJyb2dhdGVFbmRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gQWRkIHRoZSBjb2RlIHBvaW50cyBpbiB0aGUgb3RoZXIgaXRlbSB0byB0aGlzIG9uZS5cblx0XHRcdFx0XHRpZiAoZGF0YUlzU2luZ2xldG9uKG90aGVyTWFwcGluZ1swXSkpIHtcblx0XHRcdFx0XHRcdG1hcHBpbmdbMF0gPSBkYXRhQWRkKG1hcHBpbmdbMF0sIG90aGVyTWFwcGluZ1swXVswXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hcHBpbmdbMF0gPSBkYXRhQWRkUmFuZ2UoXG5cdFx0XHRcdFx0XHRcdG1hcHBpbmdbMF0sXG5cdFx0XHRcdFx0XHRcdG90aGVyTWFwcGluZ1swXVswXSxcblx0XHRcdFx0XHRcdFx0b3RoZXJNYXBwaW5nWzBdWzFdIC0gMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvdGhlciwgbm93IHJlZHVuZGFudCwgaXRlbS5cblx0XHRcdFx0XHRzdXJyb2dhdGVNYXBwaW5ncy5zcGxpY2UoaW5uZXJJbmRleCwgMSk7XG5cdFx0XHRcdFx0LS1pbm5lckluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBzdXJyb2dhdGVNYXBwaW5ncztcblx0fTtcblxuXHR2YXIgc3Vycm9nYXRlU2V0ID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgYGRhdGFgIGlzIGFuIGVtcHR5IHNldC5cblx0XHRpZiAoIWRhdGEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIHN0YXJ0O1xuXHRcdHZhciBlbmQ7XG5cdFx0dmFyIHN0YXJ0SGlnaDtcblx0XHR2YXIgc3RhcnRMb3c7XG5cdFx0dmFyIHByZXZTdGFydEhpZ2ggPSAwO1xuXHRcdHZhciBwcmV2RW5kSGlnaCA9IDA7XG5cdFx0dmFyIHRtcExvdyA9IFtdO1xuXHRcdHZhciBlbmRIaWdoO1xuXHRcdHZhciBlbmRMb3c7XG5cdFx0dmFyIHN1cnJvZ2F0ZU1hcHBpbmdzID0gW107XG5cdFx0dmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciBkYXRhSGlnaCA9IFtdO1xuXHRcdHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0c3RhcnQgPSBkYXRhW2luZGV4XTtcblx0XHRcdGVuZCA9IGRhdGFbaW5kZXggKyAxXSAtIDE7XG5cblx0XHRcdHN0YXJ0SGlnaCA9IGhpZ2hTdXJyb2dhdGUoc3RhcnQpO1xuXHRcdFx0c3RhcnRMb3cgPSBsb3dTdXJyb2dhdGUoc3RhcnQpO1xuXHRcdFx0ZW5kSGlnaCA9IGhpZ2hTdXJyb2dhdGUoZW5kKTtcblx0XHRcdGVuZExvdyA9IGxvd1N1cnJvZ2F0ZShlbmQpO1xuXG5cdFx0XHR2YXIgc3RhcnRzV2l0aExvd2VzdExvd1N1cnJvZ2F0ZSA9IHN0YXJ0TG93ID09IExPV19TVVJST0dBVEVfTUlOO1xuXHRcdFx0dmFyIGVuZHNXaXRoSGlnaGVzdExvd1N1cnJvZ2F0ZSA9IGVuZExvdyA9PSBMT1dfU1VSUk9HQVRFX01BWDtcblx0XHRcdHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuXG5cdFx0XHQvLyBBcHBlbmQgdGhlIHByZXZpb3VzIGhpZ2gtc3Vycm9nYXRlLXRvLWxvdy1zdXJyb2dhdGUgbWFwcGluZ3MuXG5cdFx0XHQvLyBTdGVwIDE6IGAoc3RhcnRIaWdoLCBzdGFydExvdylgIHRvIGAoc3RhcnRIaWdoLCBMT1dfU1VSUk9HQVRFX01BWClgLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzdGFydEhpZ2ggPT0gZW5kSGlnaCB8fFxuXHRcdFx0XHRzdGFydHNXaXRoTG93ZXN0TG93U3Vycm9nYXRlICYmIGVuZHNXaXRoSGlnaGVzdExvd1N1cnJvZ2F0ZVxuXHRcdFx0KSB7XG5cdFx0XHRcdHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1xuXHRcdFx0XHRcdFtzdGFydEhpZ2gsIGVuZEhpZ2ggKyAxXSxcblx0XHRcdFx0XHRbc3RhcnRMb3csIGVuZExvdyArIDFdXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRjb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdXJyb2dhdGVNYXBwaW5ncy5wdXNoKFtcblx0XHRcdFx0XHRbc3RhcnRIaWdoLCBzdGFydEhpZ2ggKyAxXSxcblx0XHRcdFx0XHRbc3RhcnRMb3csIExPV19TVVJST0dBVEVfTUFYICsgMV1cblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0ZXAgMjogYChzdGFydEhpZ2ggKyAxLCBMT1dfU1VSUk9HQVRFX01JTilgIHRvXG5cdFx0XHQvLyBgKGVuZEhpZ2ggLSAxLCBMT1dfU1VSUk9HQVRFX01BWClgLlxuXHRcdFx0aWYgKCFjb21wbGV0ZSAmJiBzdGFydEhpZ2ggKyAxIDwgZW5kSGlnaCkge1xuXHRcdFx0XHRpZiAoZW5kc1dpdGhIaWdoZXN0TG93U3Vycm9nYXRlKSB7XG5cdFx0XHRcdFx0Ly8gQ29tYmluZSBzdGVwIDIgYW5kIHN0ZXAgMy5cblx0XHRcdFx0XHRzdXJyb2dhdGVNYXBwaW5ncy5wdXNoKFtcblx0XHRcdFx0XHRcdFtzdGFydEhpZ2ggKyAxLCBlbmRIaWdoICsgMV0sXG5cdFx0XHRcdFx0XHRbTE9XX1NVUlJPR0FURV9NSU4sIGVuZExvdyArIDFdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0Y29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1xuXHRcdFx0XHRcdFx0W3N0YXJ0SGlnaCArIDEsIGVuZEhpZ2hdLFxuXHRcdFx0XHRcdFx0W0xPV19TVVJST0dBVEVfTUlOLCBMT1dfU1VSUk9HQVRFX01BWCArIDFdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RlcCAzLiBgKGVuZEhpZ2gsIExPV19TVVJST0dBVEVfTUlOKWAgdG8gYChlbmRIaWdoLCBlbmRMb3cpYC5cblx0XHRcdGlmICghY29tcGxldGUpIHtcblx0XHRcdFx0c3Vycm9nYXRlTWFwcGluZ3MucHVzaChbXG5cdFx0XHRcdFx0W2VuZEhpZ2gsIGVuZEhpZ2ggKyAxXSxcblx0XHRcdFx0XHRbTE9XX1NVUlJPR0FURV9NSU4sIGVuZExvdyArIDFdXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2U3RhcnRIaWdoID0gc3RhcnRIaWdoO1xuXHRcdFx0cHJldkVuZEhpZ2ggPSBlbmRIaWdoO1xuXG5cdFx0XHRpbmRleCArPSAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBmb3JtYXQgb2YgYHN1cnJvZ2F0ZU1hcHBpbmdzYCBpcyBhcyBmb2xsb3dzOlxuXHRcdC8vXG5cdFx0Ly8gICAgIFsgc3Vycm9nYXRlTWFwcGluZzEsIHN1cnJvZ2F0ZU1hcHBpbmcyIF1cblx0XHQvL1xuXHRcdC8vIGkuZS46XG5cdFx0Ly9cblx0XHQvLyAgICAgW1xuXHRcdC8vICAgICAgIFsgaGlnaFN1cnJvZ2F0ZXMxLCBsb3dTdXJyb2dhdGVzMSBdLFxuXHRcdC8vICAgICAgIFsgaGlnaFN1cnJvZ2F0ZXMyLCBsb3dTdXJyb2dhdGVzMiBdXG5cdFx0Ly8gICAgIF1cblx0XHRyZXR1cm4gb3B0aW1pemVTdXJyb2dhdGVNYXBwaW5ncyhzdXJyb2dhdGVNYXBwaW5ncyk7XG5cdH07XG5cblx0dmFyIGNyZWF0ZVN1cnJvZ2F0ZUNoYXJhY3RlckNsYXNzZXMgPSBmdW5jdGlvbihzdXJyb2dhdGVNYXBwaW5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3JFYWNoKHN1cnJvZ2F0ZU1hcHBpbmdzLCBmdW5jdGlvbihzdXJyb2dhdGVNYXBwaW5nKSB7XG5cdFx0XHR2YXIgaGlnaFN1cnJvZ2F0ZXMgPSBzdXJyb2dhdGVNYXBwaW5nWzBdO1xuXHRcdFx0dmFyIGxvd1N1cnJvZ2F0ZXMgPSBzdXJyb2dhdGVNYXBwaW5nWzFdO1xuXHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMoaGlnaFN1cnJvZ2F0ZXMpICtcblx0XHRcdFx0Y3JlYXRlQk1QQ2hhcmFjdGVyQ2xhc3Nlcyhsb3dTdXJyb2dhdGVzKVxuXHRcdFx0KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJ3wnKTtcblx0fTtcblxuXHR2YXIgY3JlYXRlQ2hhcmFjdGVyQ2xhc3Nlc0Zyb21EYXRhID0gZnVuY3Rpb24oZGF0YSwgYm1wT25seSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdHZhciBwYXJ0cyA9IHNwbGl0QXRCTVAoZGF0YSk7XG5cdFx0dmFyIGxvbmVIaWdoU3Vycm9nYXRlcyA9IHBhcnRzLmxvbmVIaWdoU3Vycm9nYXRlcztcblx0XHR2YXIgbG9uZUxvd1N1cnJvZ2F0ZXMgPSBwYXJ0cy5sb25lTG93U3Vycm9nYXRlcztcblx0XHR2YXIgYm1wID0gcGFydHMuYm1wO1xuXHRcdHZhciBhc3RyYWwgPSBwYXJ0cy5hc3RyYWw7XG5cdFx0dmFyIGhhc0FzdHJhbCA9ICFkYXRhSXNFbXB0eShwYXJ0cy5hc3RyYWwpO1xuXHRcdHZhciBoYXNMb25lSGlnaFN1cnJvZ2F0ZXMgPSAhZGF0YUlzRW1wdHkobG9uZUhpZ2hTdXJyb2dhdGVzKTtcblx0XHR2YXIgaGFzTG9uZUxvd1N1cnJvZ2F0ZXMgPSAhZGF0YUlzRW1wdHkobG9uZUxvd1N1cnJvZ2F0ZXMpO1xuXG5cdFx0dmFyIHN1cnJvZ2F0ZU1hcHBpbmdzID0gc3Vycm9nYXRlU2V0KGFzdHJhbCk7XG5cblx0XHRpZiAoYm1wT25seSkge1xuXHRcdFx0Ym1wID0gZGF0YUFkZERhdGEoYm1wLCBsb25lSGlnaFN1cnJvZ2F0ZXMpO1xuXHRcdFx0aGFzTG9uZUhpZ2hTdXJyb2dhdGVzID0gZmFsc2U7XG5cdFx0XHRibXAgPSBkYXRhQWRkRGF0YShibXAsIGxvbmVMb3dTdXJyb2dhdGVzKTtcblx0XHRcdGhhc0xvbmVMb3dTdXJyb2dhdGVzID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCFkYXRhSXNFbXB0eShibXApKSB7XG5cdFx0XHQvLyBUaGUgZGF0YSBzZXQgY29udGFpbnMgQk1QIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBoaWdoIHN1cnJvZ2F0ZXNcblx0XHRcdC8vIG5lZWRlZCBmb3IgYXN0cmFsIGNvZGUgcG9pbnRzIGluIHRoZSBzZXQuXG5cdFx0XHRyZXN1bHQucHVzaChjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzKGJtcCkpO1xuXHRcdH1cblx0XHRpZiAoc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoKSB7XG5cdFx0XHQvLyBUaGUgZGF0YSBzZXQgY29udGFpbnMgYXN0cmFsIGNvZGUgcG9pbnRzOyBhcHBlbmQgY2hhcmFjdGVyIGNsYXNzZXNcblx0XHRcdC8vIGJhc2VkIG9uIHRoZWlyIHN1cnJvZ2F0ZSBwYWlycy5cblx0XHRcdHJlc3VsdC5wdXNoKGNyZWF0ZVN1cnJvZ2F0ZUNoYXJhY3RlckNsYXNzZXMoc3Vycm9nYXRlTWFwcGluZ3MpKTtcblx0XHR9XG5cdFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9iYmU3Zjg3MDIwOGFiY2ZlYzg2MFxuXHRcdGlmIChoYXNMb25lSGlnaFN1cnJvZ2F0ZXMpIHtcblx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzKGxvbmVIaWdoU3Vycm9nYXRlcykgK1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhlIGhpZ2ggc3Vycm9nYXRlcyBhcmVu4oCZdCBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdCcoPyFbXFxcXHVEQzAwLVxcXFx1REZGRl0pJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0aWYgKGhhc0xvbmVMb3dTdXJyb2dhdGVzKSB7XG5cdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBsb3cgc3Vycm9nYXRlcyBhcmVu4oCZdCBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdCcoPzpbXlxcXFx1RDgwMC1cXFxcdURCRkZdfF4pJyArXG5cdFx0XHRcdGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMobG9uZUxvd1N1cnJvZ2F0ZXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oJ3wnKTtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvLyBgcmVnZW5lcmF0ZWAgY2FuIGJlIHVzZWQgYXMgYSBjb25zdHJ1Y3RvciAoYW5kIG5ldyBtZXRob2RzIGNhbiBiZSBhZGRlZCB0b1xuXHQvLyBpdHMgcHJvdG90eXBlKSBidXQgYWxzbyBhcyBhIHJlZ3VsYXIgZnVuY3Rpb24sIHRoZSBsYXR0ZXIgb2Ygd2hpY2ggaXMgdGhlXG5cdC8vIGRvY3VtZW50ZWQgYW5kIG1vc3QgY29tbW9uIHVzYWdlLiBGb3IgdGhhdCByZWFzb24sIGl04oCZcyBub3QgY2FwaXRhbGl6ZWQuXG5cdHZhciByZWdlbmVyYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIHJlZ2VuZXJhdGUpIHtcblx0XHRcdHRoaXMuZGF0YSA9IFtdO1xuXHRcdFx0cmV0dXJuIHZhbHVlID8gdGhpcy5hZGQodmFsdWUpIDogdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIChuZXcgcmVnZW5lcmF0ZSkuYWRkKHZhbHVlKTtcblx0fTtcblxuXHRyZWdlbmVyYXRlLnZlcnNpb24gPSAnMS4yLjAnO1xuXG5cdHZhciBwcm90byA9IHJlZ2VuZXJhdGUucHJvdG90eXBlO1xuXHRleHRlbmQocHJvdG8sIHtcblx0XHQnYWRkJzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciAkdGhpcyA9IHRoaXM7XG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiByZWdlbmVyYXRlKSB7XG5cdFx0XHRcdC8vIEFsbG93IHBhc3Npbmcgb3RoZXIgUmVnZW5lcmF0ZSBpbnN0YW5jZXMuXG5cdFx0XHRcdCR0aGlzLmRhdGEgPSBkYXRhQWRkRGF0YSgkdGhpcy5kYXRhLCB2YWx1ZS5kYXRhKTtcblx0XHRcdFx0cmV0dXJuICR0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHQkdGhpcy5hZGQoaXRlbSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0XHR9XG5cdFx0XHQkdGhpcy5kYXRhID0gZGF0YUFkZChcblx0XHRcdFx0JHRoaXMuZGF0YSxcblx0XHRcdFx0aXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBzeW1ib2xUb0NvZGVQb2ludCh2YWx1ZSlcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0fSxcblx0XHQncmVtb3ZlJzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciAkdGhpcyA9IHRoaXM7XG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiByZWdlbmVyYXRlKSB7XG5cdFx0XHRcdC8vIEFsbG93IHBhc3Npbmcgb3RoZXIgUmVnZW5lcmF0ZSBpbnN0YW5jZXMuXG5cdFx0XHRcdCR0aGlzLmRhdGEgPSBkYXRhUmVtb3ZlRGF0YSgkdGhpcy5kYXRhLCB2YWx1ZS5kYXRhKTtcblx0XHRcdFx0cmV0dXJuICR0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHQkdGhpcy5yZW1vdmUoaXRlbSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0XHR9XG5cdFx0XHQkdGhpcy5kYXRhID0gZGF0YVJlbW92ZShcblx0XHRcdFx0JHRoaXMuZGF0YSxcblx0XHRcdFx0aXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBzeW1ib2xUb0NvZGVQb2ludCh2YWx1ZSlcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0fSxcblx0XHQnYWRkUmFuZ2UnOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSB0aGlzO1xuXHRcdFx0JHRoaXMuZGF0YSA9IGRhdGFBZGRSYW5nZSgkdGhpcy5kYXRhLFxuXHRcdFx0XHRpc051bWJlcihzdGFydCkgPyBzdGFydCA6IHN5bWJvbFRvQ29kZVBvaW50KHN0YXJ0KSxcblx0XHRcdFx0aXNOdW1iZXIoZW5kKSA/IGVuZCA6IHN5bWJvbFRvQ29kZVBvaW50KGVuZClcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gJHRoaXM7XG5cdFx0fSxcblx0XHQncmVtb3ZlUmFuZ2UnOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSB0aGlzO1xuXHRcdFx0dmFyIHN0YXJ0Q29kZVBvaW50ID0gaXNOdW1iZXIoc3RhcnQpID8gc3RhcnQgOiBzeW1ib2xUb0NvZGVQb2ludChzdGFydCk7XG5cdFx0XHR2YXIgZW5kQ29kZVBvaW50ID0gaXNOdW1iZXIoZW5kKSA/IGVuZCA6IHN5bWJvbFRvQ29kZVBvaW50KGVuZCk7XG5cdFx0XHQkdGhpcy5kYXRhID0gZGF0YVJlbW92ZVJhbmdlKFxuXHRcdFx0XHQkdGhpcy5kYXRhLFxuXHRcdFx0XHRzdGFydENvZGVQb2ludCxcblx0XHRcdFx0ZW5kQ29kZVBvaW50XG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuICR0aGlzO1xuXHRcdH0sXG5cdFx0J2ludGVyc2VjdGlvbic6IGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG5cdFx0XHR2YXIgJHRoaXMgPSB0aGlzO1xuXHRcdFx0Ly8gQWxsb3cgcGFzc2luZyBvdGhlciBSZWdlbmVyYXRlIGluc3RhbmNlcy5cblx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMgYnkgd3JpdGluZyBhbmQgdXNpbmcgYGRhdGFJbnRlcnNlY3Rpb25EYXRhKClgLlxuXHRcdFx0dmFyIGFycmF5ID0gYXJndW1lbnQgaW5zdGFuY2VvZiByZWdlbmVyYXRlID9cblx0XHRcdFx0ZGF0YVRvQXJyYXkoYXJndW1lbnQuZGF0YSkgOlxuXHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdCR0aGlzLmRhdGEgPSBkYXRhSW50ZXJzZWN0aW9uKCR0aGlzLmRhdGEsIGFycmF5KTtcblx0XHRcdHJldHVybiAkdGhpcztcblx0XHR9LFxuXHRcdCdjb250YWlucyc6IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRcdFx0cmV0dXJuIGRhdGFDb250YWlucyhcblx0XHRcdFx0dGhpcy5kYXRhLFxuXHRcdFx0XHRpc051bWJlcihjb2RlUG9pbnQpID8gY29kZVBvaW50IDogc3ltYm9sVG9Db2RlUG9pbnQoY29kZVBvaW50KVxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdCdjbG9uZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNldCA9IG5ldyByZWdlbmVyYXRlO1xuXHRcdFx0c2V0LmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoMCk7XG5cdFx0XHRyZXR1cm4gc2V0O1xuXHRcdH0sXG5cdFx0J3RvU3RyaW5nJzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGNyZWF0ZUNoYXJhY3RlckNsYXNzZXNGcm9tRGF0YShcblx0XHRcdFx0dGhpcy5kYXRhLFxuXHRcdFx0XHRvcHRpb25zID8gb3B0aW9ucy5ibXBPbmx5IDogZmFsc2Vcblx0XHRcdCk7XG5cdFx0XHQvLyBVc2UgYFxcMGAgaW5zdGVhZCBvZiBgXFx4MDBgIHdoZXJlIHBvc3NpYmxlLlxuXHRcdFx0cmV0dXJuIHJlc3VsdC5yZXBsYWNlKHJlZ2V4TnVsbCwgJ1xcXFwwJDEnKTtcblx0XHR9LFxuXHRcdCd0b1JlZ0V4cCc6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0XHRyZXR1cm4gUmVnRXhwKHRoaXMudG9TdHJpbmcoKSwgZmxhZ3MgfHwgJycpO1xuXHRcdH0sXG5cdFx0J3ZhbHVlT2YnOiBmdW5jdGlvbigpIHsgLy8gTm90ZTogYHZhbHVlT2ZgIGlzIGFsaWFzZWQgYXMgYHRvQXJyYXlgLlxuXHRcdFx0cmV0dXJuIGRhdGFUb0FycmF5KHRoaXMuZGF0YSk7XG5cdFx0fVxuXHR9KTtcblxuXHRwcm90by50b0FycmF5ID0gcHJvdG8udmFsdWVPZjtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiByZWdlbmVyYXRlO1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSByZWdlbmVyYXRlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmcmVlRXhwb3J0cy5yZWdlbmVyYXRlID0gcmVnZW5lcmF0ZTtcblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnJlZ2VuZXJhdGUgPSByZWdlbmVyYXRlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLyohXG4gKiBSZWdKU0dlblxuICogQ29weXJpZ2h0IDIwMTQgQmVuamFtaW4gVGFuIDxodHRwczovL2QxMC5naXRodWIuaW8vPlxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vZDEwLm1pdC1saWNlbnNlLm9yZy8+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YCAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogQmFja3VwIHBvc3NpYmxlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIG9sZFJvb3QgPSByb290O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAgKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyohIEJhc2VkIG9uIGh0dHBzOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjIuMCBieSBAbWF0aGlhcyAqL1xuXG4gIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgdmFyIGhpZ2hTdXJyb2dhdGU7XG4gICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICBpZiAoXG4gICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XG4gICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwO1xuICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhEQzAwO1xuICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ICsgMSA9PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcbiAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRUeXBlKHR5cGUsIGV4cGVjdGVkKSB7XG4gICAgaWYgKGV4cGVjdGVkLmluZGV4T2YoJ3wnKSA9PSAtMSkge1xuICAgICAgaWYgKHR5cGUgPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBleHBlY3RlZCA9IGFzc2VydFR5cGUuaGFzT3duUHJvcGVydHkoZXhwZWN0ZWQpXG4gICAgICA/IGFzc2VydFR5cGVbZXhwZWN0ZWRdXG4gICAgICA6IChhc3NlcnRUeXBlW2V4cGVjdGVkXSA9IFJlZ0V4cCgnXig/OicgKyBleHBlY3RlZCArICcpJCcpKTtcblxuICAgIGlmIChleHBlY3RlZC50ZXN0KHR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbm9kZSB0eXBlOiAnICsgdHlwZSk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlKSB7XG4gICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG5cbiAgICBpZiAoZ2VuZXJhdGUuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgdHlwZW9mIGdlbmVyYXRlW3R5cGVdID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVt0eXBlXShub2RlKTtcbiAgICB9XG5cbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlIHR5cGU6ICcgKyB0eXBlKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQWx0ZXJuYXRpdmUobm9kZSkge1xuICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnYWx0ZXJuYXRpdmUnKTtcblxuICAgIHZhciB0ZXJtcyA9IG5vZGUuYm9keSxcbiAgICAgICAgbGVuZ3RoID0gdGVybXMgPyB0ZXJtcy5sZW5ndGggOiAwO1xuXG4gICAgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVUZXJtKHRlcm1zWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gZ2VuZXJhdGVUZXJtKHRlcm1zW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUFuY2hvcihub2RlKSB7XG4gICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbmNob3InKTtcblxuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHJldHVybiAnXic7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICByZXR1cm4gJyQnO1xuICAgICAgY2FzZSAnYm91bmRhcnknOlxuICAgICAgICByZXR1cm4gJ1xcXFxiJztcbiAgICAgIGNhc2UgJ25vdC1ib3VuZGFyeSc6XG4gICAgICAgIHJldHVybiAnXFxcXEInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYXNzZXJ0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVBdG9tKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2FuY2hvcnxjaGFyYWN0ZXJDbGFzc3xjaGFyYWN0ZXJDbGFzc0VzY2FwZXxkb3R8Z3JvdXB8cmVmZXJlbmNlfHZhbHVlJyk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdGUobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2NoYXJhY3RlckNsYXNzJyk7XG5cbiAgICB2YXIgY2xhc3NSYW5nZXMgPSBub2RlLmJvZHksXG4gICAgICAgIGxlbmd0aCA9IGNsYXNzUmFuZ2VzID8gY2xhc3NSYW5nZXMubGVuZ3RoIDogMDtcblxuICAgIHZhciBpID0gLTEsXG4gICAgICAgIHJlc3VsdCA9ICdbJztcblxuICAgIGlmIChub2RlLm5lZ2F0aXZlKSB7XG4gICAgICByZXN1bHQgKz0gJ14nO1xuICAgIH1cblxuICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZUNsYXNzQXRvbShjbGFzc1Jhbmdlc1tpXSk7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9ICddJztcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzRXNjYXBlKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2NoYXJhY3RlckNsYXNzRXNjYXBlJyk7XG5cbiAgICByZXR1cm4gJ1xcXFwnICsgbm9kZS52YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3NSYW5nZShub2RlKSB7XG4gICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdjaGFyYWN0ZXJDbGFzc1JhbmdlJyk7XG5cbiAgICB2YXIgbWluID0gbm9kZS5taW4sXG4gICAgICAgIG1heCA9IG5vZGUubWF4O1xuXG4gICAgaWYgKG1pbi50eXBlID09ICdjaGFyYWN0ZXJDbGFzc1JhbmdlJyB8fCBtYXgudHlwZSA9PSAnY2hhcmFjdGVyQ2xhc3NSYW5nZScpIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBjbGFzcyByYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzQXRvbShtaW4pICsgJy0nICsgZ2VuZXJhdGVDbGFzc0F0b20obWF4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NBdG9tKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2FuY2hvcnxjaGFyYWN0ZXJDbGFzc0VzY2FwZXxjaGFyYWN0ZXJDbGFzc1JhbmdlfGRvdHx2YWx1ZScpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRlKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVEaXNqdW5jdGlvbihub2RlKSB7XG4gICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdkaXNqdW5jdGlvbicpO1xuXG4gICAgdmFyIGJvZHkgPSBub2RlLmJvZHksXG4gICAgICAgIGxlbmd0aCA9IGJvZHkgPyBib2R5Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAobGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdObyBib2R5Jyk7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlKGJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ3wnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZShib2R5W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZURvdChub2RlKSB7XG4gICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdkb3QnKTtcblxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUdyb3VwKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2dyb3VwJyk7XG5cbiAgICB2YXIgcmVzdWx0ID0gJygnO1xuXG4gICAgc3dpdGNoIChub2RlLmJlaGF2aW9yKSB7XG4gICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgIHJlc3VsdCArPSAnPzonO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvb2thaGVhZCc6XG4gICAgICAgIHJlc3VsdCArPSAnPz0nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25lZ2F0aXZlTG9va2FoZWFkJzpcbiAgICAgICAgcmVzdWx0ICs9ICc/ISc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYmVoYXZpb3VyOiAnICsgbm9kZS5iZWhhdmlvdXIpO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gbm9kZS5ib2R5LFxuICAgICAgICBsZW5ndGggPSBib2R5ID8gYm9keS5sZW5ndGggOiAwO1xuXG4gICAgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICByZXN1bHQgKz0gZ2VuZXJhdGUoYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpID0gLTE7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGdlbmVyYXRlKGJvZHlbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCArPSAnKSc7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVRdWFudGlmaWVyKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ3F1YW50aWZpZXInKTtcblxuICAgIHZhciBxdWFudGlmaWVyID0gJycsXG4gICAgICAgIG1pbiA9IG5vZGUubWluLFxuICAgICAgICBtYXggPSBub2RlLm1heDtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgc3dpdGNoIChtaW4pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBxdWFudGlmaWVyID0gJyonXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBxdWFudGlmaWVyID0gJysnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnLH0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobWluID09IG1heCkge1xuICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluID09IDAgJiYgbWF4ID09IDEpIHtcbiAgICAgICAgICBxdWFudGlmaWVyID0gJz8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnLCcgKyBtYXggKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmdyZWVkeSkge1xuICAgICAgcXVhbnRpZmllciArPSAnPyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlbmVyYXRlQXRvbShub2RlLmJvZHlbMF0pICsgcXVhbnRpZmllcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUmVmZXJlbmNlKG5vZGUpIHtcbiAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ3JlZmVyZW5jZScpO1xuXG4gICAgcmV0dXJuICdcXFxcJyArIG5vZGUubWF0Y2hJbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVGVybShub2RlKSB7XG4gICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbmNob3J8Y2hhcmFjdGVyQ2xhc3N8Y2hhcmFjdGVyQ2xhc3NFc2NhcGV8ZW1wdHl8Z3JvdXB8cXVhbnRpZmllcnxyZWZlcmVuY2V8dmFsdWUnKTtcblxuICAgIHJldHVybiBnZW5lcmF0ZShub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVmFsdWUobm9kZSkge1xuICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAndmFsdWUnKTtcblxuICAgIHZhciBraW5kID0gbm9kZS5raW5kLFxuICAgICAgICBjb2RlUG9pbnQgPSBub2RlLmNvZGVQb2ludDtcblxuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSAnY29udHJvbExldHRlcic6XG4gICAgICAgIHJldHVybiAnXFxcXGMnICsgZnJvbUNvZGVQb2ludChjb2RlUG9pbnQgKyA2NCk7XG4gICAgICBjYXNlICdoZXhhZGVjaW1hbEVzY2FwZSc6XG4gICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgICAgIGNhc2UgJ2lkZW50aWZpZXInOlxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBjb2RlUG9pbnQ7XG4gICAgICBjYXNlICdvY3RhbCc6XG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoOCk7XG4gICAgICBjYXNlICdzaW5nbGVFc2NhcGUnOlxuICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuICAgICAgICAgIGNhc2UgMHgwMDA4OlxuICAgICAgICAgICAgcmV0dXJuICdcXFxcYic7XG4gICAgICAgICAgY2FzZSAweDAwOTpcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHQnO1xuICAgICAgICAgIGNhc2UgMHgwMEE6XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgICBjYXNlIDB4MDBCOlxuICAgICAgICAgICAgcmV0dXJuICdcXFxcdic7XG4gICAgICAgICAgY2FzZSAweDAwQzpcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGYnO1xuICAgICAgICAgIGNhc2UgMHgwMEQ6XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29kZXBvaW50OiAnICsgY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgIGNhc2UgJ3VuaWNvZGVFc2NhcGUnOlxuICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgIGNhc2UgJ3VuaWNvZGVDb2RlUG9pbnRFc2NhcGUnOlxuICAgICAgICByZXR1cm4gJ1xcXFx1eycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnfSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgbm9kZSBraW5kOiAnICsga2luZCk7XG4gICAgfVxuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgZ2VuZXJhdGUuYWx0ZXJuYXRpdmUgPSBnZW5lcmF0ZUFsdGVybmF0aXZlO1xuICBnZW5lcmF0ZS5hbmNob3IgPSBnZW5lcmF0ZUFuY2hvcjtcbiAgZ2VuZXJhdGUuY2hhcmFjdGVyQ2xhc3MgPSBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzO1xuICBnZW5lcmF0ZS5jaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3NFc2NhcGU7XG4gIGdlbmVyYXRlLmNoYXJhY3RlckNsYXNzUmFuZ2UgPSBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzUmFuZ2U7XG4gIGdlbmVyYXRlLmRpc2p1bmN0aW9uID0gZ2VuZXJhdGVEaXNqdW5jdGlvbjtcbiAgZ2VuZXJhdGUuZG90ID0gZ2VuZXJhdGVEb3Q7XG4gIGdlbmVyYXRlLmdyb3VwID0gZ2VuZXJhdGVHcm91cDtcbiAgZ2VuZXJhdGUucXVhbnRpZmllciA9IGdlbmVyYXRlUXVhbnRpZmllcjtcbiAgZ2VuZXJhdGUucmVmZXJlbmNlID0gZ2VuZXJhdGVSZWZlcmVuY2U7XG4gIGdlbmVyYXRlLnZhbHVlID0gZ2VuZXJhdGVWYWx1ZTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvcnQgcmVnanNnZW5cbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmUgYWxpYXNlZFxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdnZW5lcmF0ZSc6IGdlbmVyYXRlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5hcndoYWwsIE5vZGUuanMsIFJoaW5vIC1yZXF1aXJlLCBvciBSaW5nb0pTXG4gICAgZnJlZUV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgfVxuICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgZWxzZSB7XG4gICAgcm9vdC5yZWdqc2dlbiA9IHtcbiAgICAgICdnZW5lcmF0ZSc6IGdlbmVyYXRlXG4gICAgfTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8vIHJlZ2pzcGFyc2VyXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gU2VlIEVDTUEtMjYyIFN0YW5kYXJkOiAxNS4xMC4xXG4vL1xuLy8gTk9URTogVGhlIEVDTUEtMjYyIHN0YW5kYXJkIHVzZXMgdGhlIHRlcm0gXCJBc3NlcnRpb25cIiBmb3IgL14vLiBIZXJlIHRoZVxuLy8gICB0ZXJtIFwiQW5jaG9yXCIgaXMgdXNlZC5cbi8vXG4vLyBQYXR0ZXJuIDo6XG4vLyAgICAgIERpc2p1bmN0aW9uXG4vL1xuLy8gRGlzanVuY3Rpb24gOjpcbi8vICAgICAgQWx0ZXJuYXRpdmVcbi8vICAgICAgQWx0ZXJuYXRpdmUgfCBEaXNqdW5jdGlvblxuLy9cbi8vIEFsdGVybmF0aXZlIDo6XG4vLyAgICAgIFtlbXB0eV1cbi8vICAgICAgQWx0ZXJuYXRpdmUgVGVybVxuLy9cbi8vIFRlcm0gOjpcbi8vICAgICAgQW5jaG9yXG4vLyAgICAgIEF0b21cbi8vICAgICAgQXRvbSBRdWFudGlmaWVyXG4vL1xuLy8gQW5jaG9yIDo6XG4vLyAgICAgIF5cbi8vICAgICAgJFxuLy8gICAgICBcXCBiXG4vLyAgICAgIFxcIEJcbi8vICAgICAgKCA/ID0gRGlzanVuY3Rpb24gKVxuLy8gICAgICAoID8gISBEaXNqdW5jdGlvbiApXG4vL1xuLy8gUXVhbnRpZmllciA6OlxuLy8gICAgICBRdWFudGlmaWVyUHJlZml4XG4vLyAgICAgIFF1YW50aWZpZXJQcmVmaXggP1xuLy9cbi8vIFF1YW50aWZpZXJQcmVmaXggOjpcbi8vICAgICAgKlxuLy8gICAgICArXG4vLyAgICAgID9cbi8vICAgICAgeyBEZWNpbWFsRGlnaXRzIH1cbi8vICAgICAgeyBEZWNpbWFsRGlnaXRzICwgfVxuLy8gICAgICB7IERlY2ltYWxEaWdpdHMgLCBEZWNpbWFsRGlnaXRzIH1cbi8vXG4vLyBBdG9tIDo6XG4vLyAgICAgIFBhdHRlcm5DaGFyYWN0ZXJcbi8vICAgICAgLlxuLy8gICAgICBcXCBBdG9tRXNjYXBlXG4vLyAgICAgIENoYXJhY3RlckNsYXNzXG4vLyAgICAgICggRGlzanVuY3Rpb24gKVxuLy8gICAgICAoID8gOiBEaXNqdW5jdGlvbiApXG4vL1xuLy8gUGF0dGVybkNoYXJhY3RlciA6OlxuLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBhbnkgb2Y6IF4gJCBcXCAuICogKyA/ICggKSBbIF0geyB9IHxcbi8vXG4vLyBBdG9tRXNjYXBlIDo6XG4vLyAgICAgIERlY2ltYWxFc2NhcGVcbi8vICAgICAgQ2hhcmFjdGVyRXNjYXBlXG4vLyAgICAgIENoYXJhY3RlckNsYXNzRXNjYXBlXG4vL1xuLy8gQ2hhcmFjdGVyRXNjYXBlW1VdIDo6XG4vLyAgICAgIENvbnRyb2xFc2NhcGVcbi8vICAgICAgYyBDb250cm9sTGV0dGVyXG4vLyAgICAgIEhleEVzY2FwZVNlcXVlbmNlXG4vLyAgICAgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV0gKEVTNilcbi8vICAgICAgSWRlbnRpdHlFc2NhcGVbP1VdXG4vL1xuLy8gQ29udHJvbEVzY2FwZSA6OlxuLy8gICAgICBvbmUgb2YgZiBuIHIgdCB2XG4vLyBDb250cm9sTGV0dGVyIDo6XG4vLyAgICAgIG9uZSBvZlxuLy8gICAgICAgICAgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgbSBuIG8gcCBxIHIgcyB0IHUgdiB3IHggeSB6XG4vLyAgICAgICAgICBBIEIgQyBEIEUgRiBHIEggSSBKIEsgTCBNIE4gTyBQIFEgUiBTIFQgVSBWIFcgWCBZIFpcbi8vXG4vLyBJZGVudGl0eUVzY2FwZSA6OlxuLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBJZGVudGlmaWVyUGFydFxuLy8gICAgICA8WldKPlxuLy8gICAgICA8WldOSj5cbi8vXG4vLyBEZWNpbWFsRXNjYXBlIDo6XG4vLyAgICAgIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCBbbG9va2FoZWFkIOKIiSBEZWNpbWFsRGlnaXRdXG4vL1xuLy8gQ2hhcmFjdGVyQ2xhc3NFc2NhcGUgOjpcbi8vICAgICAgb25lIG9mIGQgRCBzIFMgdyBXXG4vL1xuLy8gQ2hhcmFjdGVyQ2xhc3MgOjpcbi8vICAgICAgWyBbbG9va2FoZWFkIOKIiSB7Xn1dIENsYXNzUmFuZ2VzIF1cbi8vICAgICAgWyBeIENsYXNzUmFuZ2VzIF1cbi8vXG4vLyBDbGFzc1JhbmdlcyA6OlxuLy8gICAgICBbZW1wdHldXG4vLyAgICAgIE5vbmVtcHR5Q2xhc3NSYW5nZXNcbi8vXG4vLyBOb25lbXB0eUNsYXNzUmFuZ2VzIDo6XG4vLyAgICAgIENsYXNzQXRvbVxuLy8gICAgICBDbGFzc0F0b20gTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuLy8gICAgICBDbGFzc0F0b20gLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbi8vXG4vLyBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoIDo6XG4vLyAgICAgIENsYXNzQXRvbVxuLy8gICAgICBDbGFzc0F0b21Ob0Rhc2ggTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuLy8gICAgICBDbGFzc0F0b21Ob0Rhc2ggLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbi8vXG4vLyBDbGFzc0F0b20gOjpcbi8vICAgICAgLVxuLy8gICAgICBDbGFzc0F0b21Ob0Rhc2hcbi8vXG4vLyBDbGFzc0F0b21Ob0Rhc2ggOjpcbi8vICAgICAgU291cmNlQ2hhcmFjdGVyIGJ1dCBub3Qgb25lIG9mIFxcIG9yIF0gb3IgLVxuLy8gICAgICBcXCBDbGFzc0VzY2FwZVxuLy9cbi8vIENsYXNzRXNjYXBlIDo6XG4vLyAgICAgIERlY2ltYWxFc2NhcGVcbi8vICAgICAgYlxuLy8gICAgICBDaGFyYWN0ZXJFc2NhcGVcbi8vICAgICAgQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHN0ciwgZmxhZ3MpIHtcbiAgICB2YXIgaGFzVW5pY29kZUZsYWcgPSAoZmxhZ3MgfHwgXCJcIikuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBjbG9zZWRDYXB0dXJlQ291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBhZGRSYXcobm9kZSkge1xuICAgICAgbm9kZS5yYXcgPSBzdHIuc3Vic3RyaW5nKG5vZGUucmFuZ2VbMF0sIG5vZGUucmFuZ2VbMV0pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUmF3U3RhcnQobm9kZSwgc3RhcnQpIHtcbiAgICAgIG5vZGUucmFuZ2VbMF0gPSBzdGFydDtcbiAgICAgIHJldHVybiBhZGRSYXcobm9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQW5jaG9yKGtpbmQsIHJhd0xlbmd0aCkge1xuICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgIHR5cGU6ICdhbmNob3InLFxuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICByYW5nZTogW1xuICAgICAgICAgIHBvcyAtIHJhd0xlbmd0aCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsdWUoa2luZCwgY29kZVBvaW50LCBmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgIHR5cGU6ICd2YWx1ZScsXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGNvZGVQb2ludDogY29kZVBvaW50LFxuICAgICAgICByYW5nZTogW2Zyb20sIHRvXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXNjYXBlZChraW5kLCBjb2RlUG9pbnQsIHZhbHVlLCBmcm9tT2Zmc2V0KSB7XG4gICAgICBmcm9tT2Zmc2V0ID0gZnJvbU9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZVZhbHVlKGtpbmQsIGNvZGVQb2ludCwgcG9zIC0gKHZhbHVlLmxlbmd0aCArIGZyb21PZmZzZXQpLCBwb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlcihtYXRjaGVzKSB7XG4gICAgICB2YXIgX2NoYXIgPSBtYXRjaGVzWzBdO1xuICAgICAgdmFyIGZpcnN0ID0gX2NoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChoYXNVbmljb2RlRmxhZykge1xuICAgICAgICB2YXIgc2Vjb25kO1xuICAgICAgICBpZiAoX2NoYXIubGVuZ3RoID09PSAxICYmIGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYpIHtcbiAgICAgICAgICBzZWNvbmQgPSBsb29rYWhlYWQoKS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZhbHVlKFxuICAgICAgICAgICAgICAgICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDAsXG4gICAgICAgICAgICAgICAgcG9zIC0gMiwgcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWYWx1ZSgnc3ltYm9sJywgZmlyc3QsIHBvcyAtIDEsIHBvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGlzanVuY3Rpb24oYWx0ZXJuYXRpdmVzLCBmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgIHR5cGU6ICdkaXNqdW5jdGlvbicsXG4gICAgICAgIGJvZHk6IGFsdGVybmF0aXZlcyxcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvXG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURvdCgpIHtcbiAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICB0eXBlOiAnZG90JyxcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBwb3MgLSAxLFxuICAgICAgICAgIHBvc1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc0VzY2FwZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgIHR5cGU6ICdjaGFyYWN0ZXJDbGFzc0VzY2FwZScsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBwb3MgLSAyLFxuICAgICAgICAgIHBvc1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2UobWF0Y2hJbmRleCkge1xuICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgIHR5cGU6ICdyZWZlcmVuY2UnLFxuICAgICAgICBtYXRjaEluZGV4OiBwYXJzZUludChtYXRjaEluZGV4LCAxMCksXG4gICAgICAgIHJhbmdlOiBbXG4gICAgICAgICAgcG9zIC0gMSAtIG1hdGNoSW5kZXgubGVuZ3RoLFxuICAgICAgICAgIHBvc1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cChiZWhhdmlvciwgZGlzanVuY3Rpb24sIGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgICAgICBib2R5OiBkaXNqdW5jdGlvbixcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvXG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVF1YW50aWZpZXIobWluLCBtYXgsIGZyb20sIHRvKSB7XG4gICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICBmcm9tID0gcG9zIC0gMTtcbiAgICAgICAgdG8gPSBwb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICB0eXBlOiAncXVhbnRpZmllcicsXG4gICAgICAgIG1pbjogbWluLFxuICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBib2R5OiBudWxsLCAvLyBzZXQgbGF0ZXIgb24sXG4gICAgICAgIHJhbmdlOiBbXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0b1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBbHRlcm5hdGl2ZSh0ZXJtcywgZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICB0eXBlOiAnYWx0ZXJuYXRpdmUnLFxuICAgICAgICBib2R5OiB0ZXJtcyxcbiAgICAgICAgcmFuZ2U6IFtcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvXG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlckNsYXNzKGNsYXNzUmFuZ2VzLCBuZWdhdGl2ZSwgZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICB0eXBlOiAnY2hhcmFjdGVyQ2xhc3MnLFxuICAgICAgICBib2R5OiBjbGFzc1JhbmdlcyxcbiAgICAgICAgbmVnYXRpdmU6IG5lZ2F0aXZlLFxuICAgICAgICByYW5nZTogW1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG9cbiAgICAgICAgXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NSYW5nZShtaW4sIG1heCwgZnJvbSwgdG8pIHtcbiAgICAgIC8vIFNlZSAxNS4xMC4yLjE1OlxuICAgICAgaWYgKG1pbi5jb2RlUG9pbnQgPiBtYXguY29kZVBvaW50KSB7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCdpbnZhbGlkIHJhbmdlIGluIGNoYXJhY3RlciBjbGFzcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgdHlwZTogJ2NoYXJhY3RlckNsYXNzUmFuZ2UnLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIHJhbmdlOiBbXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0b1xuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuQm9keShib2R5KSB7XG4gICAgICBpZiAoYm9keS50eXBlID09PSAnYWx0ZXJuYXRpdmUnKSB7XG4gICAgICAgIHJldHVybiBib2R5LmJvZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2JvZHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLnR5cGUgPT09ICdlbXB0eSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5jcihhbW91bnQpIHtcbiAgICAgIGFtb3VudCA9IChhbW91bnQgfHwgMSk7XG4gICAgICB2YXIgcmVzID0gc3RyLnN1YnN0cmluZyhwb3MsIHBvcyArIGFtb3VudCk7XG4gICAgICBwb3MgKz0gKGFtb3VudCB8fCAxKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcCh2YWx1ZSkge1xuICAgICAgaWYgKCFtYXRjaCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ2NoYXJhY3RlcjogJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKHZhbHVlLCBwb3MpID09PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGluY3IodmFsdWUubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rYWhlYWQoKSB7XG4gICAgICByZXR1cm4gc3RyW3Bvc107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHZhbHVlLCBwb3MpID09PSBwb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHN0cltwb3MgKyAxXSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hSZWcocmVnRXhwKSB7XG4gICAgICB2YXIgc3ViU3RyID0gc3RyLnN1YnN0cmluZyhwb3MpO1xuICAgICAgdmFyIHJlcyA9IHN1YlN0ci5tYXRjaChyZWdFeHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICByZXMucmFuZ2UgPSBbXTtcbiAgICAgICAgcmVzLnJhbmdlWzBdID0gcG9zO1xuICAgICAgICBpbmNyKHJlc1swXS5sZW5ndGgpO1xuICAgICAgICByZXMucmFuZ2VbMV0gPSBwb3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRGlzanVuY3Rpb24oKSB7XG4gICAgICAvLyBEaXNqdW5jdGlvbiA6OlxuICAgICAgLy8gICAgICBBbHRlcm5hdGl2ZVxuICAgICAgLy8gICAgICBBbHRlcm5hdGl2ZSB8IERpc2p1bmN0aW9uXG4gICAgICB2YXIgcmVzID0gW10sIGZyb20gPSBwb3M7XG4gICAgICByZXMucHVzaChwYXJzZUFsdGVybmF0aXZlKCkpO1xuXG4gICAgICB3aGlsZSAobWF0Y2goJ3wnKSkge1xuICAgICAgICByZXMucHVzaChwYXJzZUFsdGVybmF0aXZlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlRGlzanVuY3Rpb24ocmVzLCBmcm9tLCBwb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQWx0ZXJuYXRpdmUoKSB7XG4gICAgICB2YXIgcmVzID0gW10sIGZyb20gPSBwb3M7XG4gICAgICB2YXIgdGVybTtcblxuICAgICAgLy8gQWx0ZXJuYXRpdmUgOjpcbiAgICAgIC8vICAgICAgW2VtcHR5XVxuICAgICAgLy8gICAgICBBbHRlcm5hdGl2ZSBUZXJtXG4gICAgICB3aGlsZSAodGVybSA9IHBhcnNlVGVybSgpKSB7XG4gICAgICAgIHJlcy5wdXNoKHRlcm0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlQWx0ZXJuYXRpdmUocmVzLCBmcm9tLCBwb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGVybSgpIHtcbiAgICAgIC8vIFRlcm0gOjpcbiAgICAgIC8vICAgICAgQW5jaG9yXG4gICAgICAvLyAgICAgIEF0b21cbiAgICAgIC8vICAgICAgQXRvbSBRdWFudGlmaWVyXG5cbiAgICAgIGlmIChwb3MgPj0gc3RyLmxlbmd0aCB8fCBjdXJyZW50KCd8JykgfHwgY3VycmVudCgnKScpKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvKiBNZWFuczogVGhlIHRlcm0gaXMgZW1wdHkgKi9cbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IHBhcnNlQW5jaG9yKCk7XG5cbiAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0b20gPSBwYXJzZUF0b20oKTtcbiAgICAgIGlmICghYXRvbSkge1xuICAgICAgICB0aHJvdyBTeW50YXhFcnJvcignRXhwZWN0ZWQgYXRvbScpXG4gICAgICB9XG4gICAgICB2YXIgcXVhbnRpZmllciA9IHBhcnNlUXVhbnRpZmllcigpIHx8IGZhbHNlO1xuICAgICAgaWYgKHF1YW50aWZpZXIpIHtcbiAgICAgICAgcXVhbnRpZmllci5ib2R5ID0gZmxhdHRlbkJvZHkoYXRvbSk7XG4gICAgICAgIC8vIFRoZSBxdWFudGlmaWVyIGNvbnRhaW5zIHRoZSBhdG9tLiBUaGVyZWZvcmUsIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICAgICAgIC8vIHF1YW50aWZpZXIgcmFuZ2UgaXMgZ2l2ZW4gYnkgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXRvbS5cbiAgICAgICAgdXBkYXRlUmF3U3RhcnQocXVhbnRpZmllciwgYXRvbS5yYW5nZVswXSk7XG4gICAgICAgIHJldHVybiBxdWFudGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0b207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cChtYXRjaEEsIHR5cGVBLCBtYXRjaEIsIHR5cGVCKSB7XG4gICAgICB2YXIgdHlwZSA9IG51bGwsIGZyb20gPSBwb3M7XG5cbiAgICAgIGlmIChtYXRjaChtYXRjaEEpKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlQTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gobWF0Y2hCKSkge1xuICAgICAgICB0eXBlID0gdHlwZUI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBib2R5ID0gcGFyc2VEaXNqdW5jdGlvbigpO1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCdFeHBlY3RlZCBkaXNqdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgc2tpcCgnKScpO1xuICAgICAgdmFyIGdyb3VwID0gY3JlYXRlR3JvdXAodHlwZSwgZmxhdHRlbkJvZHkoYm9keSksIGZyb20sIHBvcyk7XG5cbiAgICAgIGlmICh0eXBlID09ICdub3JtYWwnKSB7XG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBjbG9zZWQgZ3JvdXBzLiBUaGlzIGlzIHJlcXVpcmVkIGZvclxuICAgICAgICAvLyBwYXJzZURlY2ltYWxFc2NhcGUoKS5cbiAgICAgICAgY2xvc2VkQ2FwdHVyZUNvdW50ZXIrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFuY2hvcigpIHtcbiAgICAgIC8vIEFuY2hvciA6OlxuICAgICAgLy8gICAgICBeXG4gICAgICAvLyAgICAgICRcbiAgICAgIC8vICAgICAgXFwgYlxuICAgICAgLy8gICAgICBcXCBCXG4gICAgICAvLyAgICAgICggPyA9IERpc2p1bmN0aW9uIClcbiAgICAgIC8vICAgICAgKCA/ICEgRGlzanVuY3Rpb24gKVxuICAgICAgdmFyIHJlcywgZnJvbSA9IHBvcztcblxuICAgICAgaWYgKG1hdGNoKCdeJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignc3RhcnQnLCAxIC8qIHJhd0xlbmd0aCAqLyk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCckJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignZW5kJywgMSAvKiByYXdMZW5ndGggKi8pO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnXFxcXGInKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQW5jaG9yKCdib3VuZGFyeScsIDIgLyogcmF3TGVuZ3RoICovKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1xcXFxCJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignbm90LWJvdW5kYXJ5JywgMiAvKiByYXdMZW5ndGggKi8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXAoJyg/PScsICdsb29rYWhlYWQnLCAnKD8hJywgJ25lZ2F0aXZlTG9va2FoZWFkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VRdWFudGlmaWVyKCkge1xuICAgICAgLy8gUXVhbnRpZmllciA6OlxuICAgICAgLy8gICAgICBRdWFudGlmaWVyUHJlZml4XG4gICAgICAvLyAgICAgIFF1YW50aWZpZXJQcmVmaXggP1xuICAgICAgLy9cbiAgICAgIC8vIFF1YW50aWZpZXJQcmVmaXggOjpcbiAgICAgIC8vICAgICAgKlxuICAgICAgLy8gICAgICArXG4gICAgICAvLyAgICAgID9cbiAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzIH1cbiAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzICwgfVxuICAgICAgLy8gICAgICB7IERlY2ltYWxEaWdpdHMgLCBEZWNpbWFsRGlnaXRzIH1cblxuICAgICAgdmFyIHJlcztcbiAgICAgIHZhciBxdWFudGlmaWVyO1xuICAgICAgdmFyIG1pbiwgbWF4O1xuXG4gICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICBxdWFudGlmaWVyID0gY3JlYXRlUXVhbnRpZmllcigwKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1hdGNoKCcrJykpIHtcbiAgICAgICAgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIoMSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKDAsIDEpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL15cXHsoWzAtOV0rKVxcfS8pKSB7XG4gICAgICAgIG1pbiA9IHBhcnNlSW50KHJlc1sxXSwgMTApO1xuICAgICAgICBxdWFudGlmaWVyID0gY3JlYXRlUXVhbnRpZmllcihtaW4sIG1pbiwgcmVzLnJhbmdlWzBdLCByZXMucmFuZ2VbMV0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL15cXHsoWzAtOV0rKSxcXH0vKSkge1xuICAgICAgICBtaW4gPSBwYXJzZUludChyZXNbMV0sIDEwKTtcbiAgICAgICAgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIobWluLCB1bmRlZmluZWQsIHJlcy5yYW5nZVswXSwgcmVzLnJhbmdlWzFdKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFx7KFswLTldKyksKFswLTldKylcXH0vKSkge1xuICAgICAgICBtaW4gPSBwYXJzZUludChyZXNbMV0sIDEwKTtcbiAgICAgICAgbWF4ID0gcGFyc2VJbnQocmVzWzJdLCAxMCk7XG4gICAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcignbnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKG1pbiwgbWF4LCByZXMucmFuZ2VbMF0sIHJlcy5yYW5nZVsxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChxdWFudGlmaWVyKSB7XG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgcXVhbnRpZmllci5ncmVlZHkgPSBmYWxzZTtcbiAgICAgICAgICBxdWFudGlmaWVyLnJhbmdlWzFdICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHF1YW50aWZpZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VBdG9tKCkge1xuICAgICAgLy8gQXRvbSA6OlxuICAgICAgLy8gICAgICBQYXR0ZXJuQ2hhcmFjdGVyXG4gICAgICAvLyAgICAgIC5cbiAgICAgIC8vICAgICAgXFwgQXRvbUVzY2FwZVxuICAgICAgLy8gICAgICBDaGFyYWN0ZXJDbGFzc1xuICAgICAgLy8gICAgICAoIERpc2p1bmN0aW9uIClcbiAgICAgIC8vICAgICAgKCA/IDogRGlzanVuY3Rpb24gKVxuXG4gICAgICB2YXIgcmVzO1xuXG4gICAgICAvLyBqdmllcmVjazogYWxsb3cgJ10nLCAnfScgaGVyZSBhcyB3ZWxsIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBicm93c2VyJ3NcbiAgICAgIC8vICAgaW1wbGVtZW50YXRpb25zOiAnXScubWF0Y2goL10vKTtcbiAgICAgIC8vIGlmIChyZXMgPSBtYXRjaFJlZygvXlteXiRcXFxcLiorPygpW1xcXXt9fF0vKSkge1xuICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eW15eJFxcXFwuKis/KCl7W3xdLykpIHtcbiAgICAgICAgLy8gICAgICBQYXR0ZXJuQ2hhcmFjdGVyXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXIocmVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgLy8gICAgICAuXG4gICAgICAgIHJldHVybiBjcmVhdGVEb3QoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1hdGNoKCdcXFxcJykpIHtcbiAgICAgICAgLy8gICAgICBcXCBBdG9tRXNjYXBlXG4gICAgICAgIHJlcyA9IHBhcnNlQXRvbUVzY2FwZSgpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCdhdG9tRXNjYXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlcyA9IHBhcnNlQ2hhcmFjdGVyQ2xhc3MoKSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vICAgICAgKCBEaXNqdW5jdGlvbiApXG4gICAgICAgIC8vICAgICAgKCA/IDogRGlzanVuY3Rpb24gKVxuICAgICAgICByZXR1cm4gcGFyc2VHcm91cCgnKD86JywgJ2lnbm9yZScsICcoJywgJ25vcm1hbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoZmlyc3RFc2NhcGUpIHtcbiAgICAgIGlmIChoYXNVbmljb2RlRmxhZykge1xuICAgICAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICAgICAgaWYgKGZpcnN0RXNjYXBlLmtpbmQgPT0gJ3VuaWNvZGVFc2NhcGUnICYmXG4gICAgICAgICAgKGZpcnN0ID0gZmlyc3RFc2NhcGUuY29kZVBvaW50KSA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmXG4gICAgICAgICAgY3VycmVudCgnXFxcXCcpICYmIG5leHQoJ3UnKSApIHtcbiAgICAgICAgICB2YXIgcHJldlBvcyA9IHBvcztcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB2YXIgc2Vjb25kRXNjYXBlID0gcGFyc2VDbGFzc0VzY2FwZSgpO1xuICAgICAgICAgIGlmIChzZWNvbmRFc2NhcGUua2luZCA9PSAndW5pY29kZUVzY2FwZScgJiZcbiAgICAgICAgICAgIChzZWNvbmQgPSBzZWNvbmRFc2NhcGUuY29kZVBvaW50KSA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICAgICAgLy8gVW5pY29kZSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgZmlyc3RFc2NhcGUucmFuZ2VbMV0gPSBzZWNvbmRFc2NhcGUucmFuZ2VbMV07XG4gICAgICAgICAgICBmaXJzdEVzY2FwZS5jb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgZmlyc3RFc2NhcGUudHlwZSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICBmaXJzdEVzY2FwZS5raW5kID0gJ3VuaWNvZGVDb2RlUG9pbnRFc2NhcGUnO1xuICAgICAgICAgICAgYWRkUmF3KGZpcnN0RXNjYXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBwcmV2UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0RXNjYXBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NFc2NhcGUoKSB7XG4gICAgICByZXR1cm4gcGFyc2VBdG9tRXNjYXBlKHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXRvbUVzY2FwZShpbnNpZGVDaGFyYWN0ZXJDbGFzcykge1xuICAgICAgLy8gQXRvbUVzY2FwZSA6OlxuICAgICAgLy8gICAgICBEZWNpbWFsRXNjYXBlXG4gICAgICAvLyAgICAgIENoYXJhY3RlckVzY2FwZVxuICAgICAgLy8gICAgICBDaGFyYWN0ZXJDbGFzc0VzY2FwZVxuXG4gICAgICB2YXIgcmVzO1xuXG4gICAgICByZXMgPSBwYXJzZURlY2ltYWxFc2NhcGUoKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIENsYXNzRXNjYXBlXG4gICAgICBpZiAoaW5zaWRlQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICAgICAgaWYgKG1hdGNoKCdiJykpIHtcbiAgICAgICAgICAvLyAxNS4xMC4yLjE5XG4gICAgICAgICAgLy8gVGhlIHByb2R1Y3Rpb24gQ2xhc3NFc2NhcGUgOjogYiBldmFsdWF0ZXMgYnkgcmV0dXJuaW5nIHRoZVxuICAgICAgICAgIC8vIENoYXJTZXQgY29udGFpbmluZyB0aGUgb25lIGNoYXJhY3RlciA8QlM+IChVbmljb2RlIHZhbHVlIDAwMDgpLlxuICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdzaW5nbGVFc2NhcGUnLCAweDAwMDgsICdcXFxcYicpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdCJykpIHtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcignXFxcXEIgbm90IHBvc3NpYmxlIGluc2lkZSBvZiBDaGFyYWN0ZXJDbGFzcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHBhcnNlQ2hhcmFjdGVyRXNjYXBlKCk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZURlY2ltYWxFc2NhcGUoKSB7XG4gICAgICAvLyBEZWNpbWFsRXNjYXBlIDo6XG4gICAgICAvLyAgICAgIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCBbbG9va2FoZWFkIOKIiSBEZWNpbWFsRGlnaXRdXG4gICAgICAvLyAgICAgIENoYXJhY3RlckNsYXNzRXNjYXBlIDo6IG9uZSBvZiBkIEQgcyBTIHcgV1xuXG4gICAgICB2YXIgcmVzLCBtYXRjaDtcblxuICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eKD8hMClcXGQrLykpIHtcbiAgICAgICAgbWF0Y2ggPSByZXNbMF07XG4gICAgICAgIHZhciByZWZJZHggPSBwYXJzZUludChyZXNbMF0sIDEwKTtcbiAgICAgICAgaWYgKHJlZklkeCA8PSBjbG9zZWRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgaXMgc21hbGxlciB0aGFuIHRoZSBub3JtYWwtZ3JvdXBzIGZvdW5kIHNvXG4gICAgICAgICAgLy8gZmFyLCB0aGVuIGl0IGlzIGEgcmVmZXJlbmNlLi4uXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZmVyZW5jZShyZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UgaXQgbmVlZHMgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBvY3RhbCAoaWYgdGhlXG4gICAgICAgICAgLy8gbnVtYmVyIGlzIGluIGFuIG9jdGFsIGZvcm1hdCkuIElmIGl0IGlzIE5PVCBvY3RhbCBmb3JtYXQsXG4gICAgICAgICAgLy8gdGhlbiB0aGUgc2xhc2ggaXMgaWdub3JlZCBhbmQgdGhlIG51bWJlciBpcyBtYXRjaGVkIGxhdGVyXG4gICAgICAgICAgLy8gYXMgbm9ybWFsIGNoYXJhY3RlcnMuXG5cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcG9zaXRpb24gYWdhaW4sIGFzIG1heWJlIG9ubHkgcGFydHMgb2YgdGhlIHByZXZpb3VzXG4gICAgICAgICAgLy8gbWF0Y2hlZCBudW1iZXJzIGFyZSBhY3R1YWwgb2N0YWwgbnVtYmVycy4gRS5nLiBpbiAnMDE5JyBvbmx5XG4gICAgICAgICAgLy8gdGhlICcwMScgc2hvdWxkIGJlIG1hdGNoZWQuXG4gICAgICAgICAgaW5jcigtcmVzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eWzAtN117MSwzfS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnb2N0YWwnLCBwYXJzZUludChyZXNbMF0sIDgpLCByZXNbMF0sIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgd2UgaGF2ZSBhIGNhc2UgbGlrZSAvXFw5MS8uIFRoZW4gdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCBzbGFzaCBpcyB0byBiZSBpZ25vcmVkIGFuZCB0aGUgOSAmIDEgdG8gYmUgdHJlYXRlZFxuICAgICAgICAgICAgLy8gbGlrZSBvcmRpbmFyeSBjaGFyYWN0ZXJzLiBDcmVhdGUgYSBjaGFyYWN0ZXIgZm9yIHRoZVxuICAgICAgICAgICAgLy8gZmlyc3QgbnVtYmVyIG9ubHkgaGVyZSAtIG90aGVyIG51bWJlci1jaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyAoaWYgYXZhaWxhYmxlKSB3aWxsIGJlIG1hdGNoZWQgbGF0ZXIuXG4gICAgICAgICAgICByZXMgPSBjcmVhdGVDaGFyYWN0ZXIobWF0Y2hSZWcoL15bODldLykpO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJhd1N0YXJ0KHJlcywgcmVzLnJhbmdlWzBdIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBPbmx5IGFsbG93IG9jdGFsIG51bWJlcnMgaW4gdGhlIGZvbGxvd2luZy4gQWxsIG1hdGNoZWQgbnVtYmVycyBzdGFydFxuICAgICAgLy8gd2l0aCBhIHplcm8gKGlmIHRoZSBkbyBub3QsIHRoZSBwcmV2aW91cyBpZi1icmFuY2ggaXMgZXhlY3V0ZWQpLlxuICAgICAgLy8gSWYgdGhlIG51bWJlciBpcyBub3Qgb2N0YWwgZm9ybWF0IGFuZCBzdGFydHMgd2l0aCB6ZXJvIChlLmcuIGAwOTFgKVxuICAgICAgLy8gdGhlbiBvbmx5IHRoZSB6ZXJvcyBgMGAgaXMgdHJlYXRlZCBoZXJlIGFuZCB0aGUgYDkxYCBhcmUgb3JkaW5hcnlcbiAgICAgIC8vIGNoYXJhY3RlcnMuXG4gICAgICAvLyBFeGFtcGxlOlxuICAgICAgLy8gICAvXFwwOTEvLmV4ZWMoJ1xcMDkxJylbMF0ubGVuZ3RoID09PSAzXG4gICAgICBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXlswLTddezEsM30vKSkge1xuICAgICAgICBtYXRjaCA9IHJlc1swXTtcbiAgICAgICAgaWYgKC9eMHsxLDN9JC8udGVzdChtYXRjaCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBhbGwgemVyb3MsIHRoZW4gb25seSB0YWtlIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ251bGwnLCAweDAwMDAsICcwJywgbWF0Y2gubGVuZ3RoICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ29jdGFsJywgcGFyc2VJbnQobWF0Y2gsIDgpLCBtYXRjaCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL15bZERzU3dXXS8pKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzc0VzY2FwZShyZXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyRXNjYXBlKCkge1xuICAgICAgLy8gQ2hhcmFjdGVyRXNjYXBlIDo6XG4gICAgICAvLyAgICAgIENvbnRyb2xFc2NhcGVcbiAgICAgIC8vICAgICAgYyBDb250cm9sTGV0dGVyXG4gICAgICAvLyAgICAgIEhleEVzY2FwZVNlcXVlbmNlXG4gICAgICAvLyAgICAgIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxuICAgICAgLy8gICAgICBJZGVudGl0eUVzY2FwZVxuXG4gICAgICB2YXIgcmVzO1xuICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eW2ZucnR2XS8pKSB7XG4gICAgICAgIC8vIENvbnRyb2xFc2NhcGVcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IDA7XG4gICAgICAgIHN3aXRjaCAocmVzWzBdKSB7XG4gICAgICAgICAgY2FzZSAndCc6IGNvZGVQb2ludCA9IDB4MDA5OyBicmVhaztcbiAgICAgICAgICBjYXNlICduJzogY29kZVBvaW50ID0gMHgwMEE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3YnOiBjb2RlUG9pbnQgPSAweDAwQjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZic6IGNvZGVQb2ludCA9IDB4MDBDOyBicmVhaztcbiAgICAgICAgICBjYXNlICdyJzogY29kZVBvaW50ID0gMHgwMEQ7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdzaW5nbGVFc2NhcGUnLCBjb2RlUG9pbnQsICdcXFxcJyArIHJlc1swXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eYyhbYS16QS1aXSkvKSkge1xuICAgICAgICAvLyBjIENvbnRyb2xMZXR0ZXJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2NvbnRyb2xMZXR0ZXInLCByZXNbMV0uY2hhckNvZGVBdCgwKSAlIDMyLCByZXNbMV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXngoWzAtOWEtZkEtRl17Mn0pLykpIHtcbiAgICAgICAgLy8gSGV4RXNjYXBlU2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2hleGFkZWNpbWFsRXNjYXBlJywgcGFyc2VJbnQocmVzWzFdLCAxNiksIHJlc1sxXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9edShbMC05YS1mQS1GXXs0fSkvKSkge1xuICAgICAgICAvLyBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoXG4gICAgICAgICAgY3JlYXRlRXNjYXBlZCgndW5pY29kZUVzY2FwZScsIHBhcnNlSW50KHJlc1sxXSwgMTYpLCByZXNbMV0sIDIpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1VuaWNvZGVGbGFnICYmIChyZXMgPSBtYXRjaFJlZygvXnVcXHsoWzAtOWEtZkEtRl17MSx9KVxcfS8pKSkge1xuICAgICAgICAvLyBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgKEVTNiBVbmljb2RlIGNvZGUgcG9pbnQgZXNjYXBlKVxuICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgndW5pY29kZUNvZGVQb2ludEVzY2FwZScsIHBhcnNlSW50KHJlc1sxXSwgMTYpLCByZXNbMV0sIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWRlbnRpdHlFc2NhcGVcbiAgICAgICAgcmV0dXJuIHBhcnNlSWRlbnRpdHlFc2NhcGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWtlbiBmcm9tIHRoZSBFc3ByaW1hIHBhcnNlci5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAvLyBHZW5lcmF0ZWQgYnkgYHRvb2xzL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuICAgICAgdmFyIE5vbkFzY2lpSWRlbnRpZmllclBhcnQgPSBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyk7XG5cbiAgICAgIHJldHVybiAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgKGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgICAgIC8vIGEuLnpcbiAgICAgICAgKGNoID49IDQ4ICYmIGNoIDw9IDU3KSB8fCAgICAgICAgIC8vIDAuLjlcbiAgICAgICAgKGNoID09PSA5MikgfHwgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICgoY2ggPj0gMHg4MCkgJiYgTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZGVudGl0eUVzY2FwZSgpIHtcbiAgICAgIC8vIElkZW50aXR5RXNjYXBlIDo6XG4gICAgICAvLyAgICAgIFNvdXJjZUNoYXJhY3RlciBidXQgbm90IElkZW50aWZpZXJQYXJ0XG4gICAgICAvLyAgICAgIDxaV0o+XG4gICAgICAvLyAgICAgIDxaV05KPlxuXG4gICAgICB2YXIgWldKID0gJ1xcdTIwMEMnO1xuICAgICAgdmFyIFpXTkogPSAnXFx1MjAwRCc7XG5cbiAgICAgIHZhciByZXM7XG4gICAgICB2YXIgdG1wO1xuXG4gICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQobG9va2FoZWFkKCkpKSB7XG4gICAgICAgIHRtcCA9IGluY3IoKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2lkZW50aWZpZXInLCB0bXAuY2hhckNvZGVBdCgwKSwgdG1wLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKFpXSikpIHtcbiAgICAgICAgLy8gPFpXSj5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2lkZW50aWZpZXInLCAweDIwMEMsIFpXSik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKFpXTkopKSB7XG4gICAgICAgIC8vIDxaV05KPlxuICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnaWRlbnRpZmllcicsIDB4MjAwRCwgWldOSik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyQ2xhc3MoKSB7XG4gICAgICAvLyBDaGFyYWN0ZXJDbGFzcyA6OlxuICAgICAgLy8gICAgICBbIFtsb29rYWhlYWQg4oiJIHtefV0gQ2xhc3NSYW5nZXMgXVxuICAgICAgLy8gICAgICBbIF4gQ2xhc3NSYW5nZXMgXVxuXG4gICAgICB2YXIgcmVzLCBmcm9tID0gcG9zO1xuICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFxbXFxeLykpIHtcbiAgICAgICAgcmVzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICBza2lwKCddJyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzcyhyZXMsIHRydWUsIGZyb20sIHBvcyk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgcmVzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICBza2lwKCddJyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzcyhyZXMsIGZhbHNlLCBmcm9tLCBwb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzUmFuZ2VzKCkge1xuICAgICAgLy8gQ2xhc3NSYW5nZXMgOjpcbiAgICAgIC8vICAgICAgW2VtcHR5XVxuICAgICAgLy8gICAgICBOb25lbXB0eUNsYXNzUmFuZ2VzXG5cbiAgICAgIHZhciByZXM7XG4gICAgICBpZiAoY3VycmVudCgnXScpKSB7XG4gICAgICAgIC8vIEVtcHR5IGFycmF5IG1lYW5zIG5vdGhpbmcgaW5zaW5kZSBvZiB0aGUgQ2xhc3NSYW5nZS5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcGFyc2VOb25lbXB0eUNsYXNzUmFuZ2VzKCk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ25vbkVtcHR5Q2xhc3NSYW5nZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSGVscGVyQ2xhc3NSYW5nZXMoYXRvbSkge1xuICAgICAgdmFyIGZyb20sIHRvLCByZXM7XG4gICAgICBpZiAoY3VycmVudCgnLScpICYmICFuZXh0KCddJykpIHtcbiAgICAgICAgLy8gQ2xhc3NBdG9tIC0gQ2xhc3NBdG9tIENsYXNzUmFuZ2VzXG4gICAgICAgIHNraXAoJy0nKTtcblxuICAgICAgICByZXMgPSBwYXJzZUNsYXNzQXRvbSgpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCdjbGFzc0F0b20nKTtcbiAgICAgICAgfVxuICAgICAgICB0byA9IHBvcztcbiAgICAgICAgdmFyIGNsYXNzUmFuZ2VzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICBpZiAoIWNsYXNzUmFuZ2VzKSB7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ2NsYXNzUmFuZ2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbSA9IGF0b20ucmFuZ2VbMF07XG4gICAgICAgIGlmIChjbGFzc1Jhbmdlcy50eXBlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDbGFzc1JhbmdlKGF0b20sIHJlcywgZnJvbSwgdG8pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NyZWF0ZUNsYXNzUmFuZ2UoYXRvbSwgcmVzLCBmcm9tLCB0byldLmNvbmNhdChjbGFzc1Jhbmdlcyk7XG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHBhcnNlTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaCgpO1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ25vbkVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2gnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFthdG9tXS5jb25jYXQocmVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbmVtcHR5Q2xhc3NSYW5nZXMoKSB7XG4gICAgICAvLyBOb25lbXB0eUNsYXNzUmFuZ2VzIDo6XG4gICAgICAvLyAgICAgIENsYXNzQXRvbVxuICAgICAgLy8gICAgICBDbGFzc0F0b20gTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICAgICAgLy8gICAgICBDbGFzc0F0b20gLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcblxuICAgICAgdmFyIGF0b20gPSBwYXJzZUNsYXNzQXRvbSgpO1xuICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCdjbGFzc0F0b20nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQoJ10nKSkge1xuICAgICAgICAvLyBDbGFzc0F0b21cbiAgICAgICAgcmV0dXJuIFthdG9tXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xhc3NBdG9tIE5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbiAgICAgIC8vIENsYXNzQXRvbSAtIENsYXNzQXRvbSBDbGFzc1Jhbmdlc1xuICAgICAgcmV0dXJuIHBhcnNlSGVscGVyQ2xhc3NSYW5nZXMoYXRvbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoKCkge1xuICAgICAgLy8gTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaCA6OlxuICAgICAgLy8gICAgICBDbGFzc0F0b21cbiAgICAgIC8vICAgICAgQ2xhc3NBdG9tTm9EYXNoIE5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbiAgICAgIC8vICAgICAgQ2xhc3NBdG9tTm9EYXNoIC0gQ2xhc3NBdG9tIENsYXNzUmFuZ2VzXG5cbiAgICAgIHZhciByZXMgPSBwYXJzZUNsYXNzQXRvbSgpO1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ2NsYXNzQXRvbScpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQoJ10nKSkge1xuICAgICAgICAvLyAgICAgIENsYXNzQXRvbVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGFzc0F0b21Ob0Rhc2ggTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICAgICAgLy8gQ2xhc3NBdG9tTm9EYXNoIC0gQ2xhc3NBdG9tIENsYXNzUmFuZ2VzXG4gICAgICByZXR1cm4gcGFyc2VIZWxwZXJDbGFzc1JhbmdlcyhyZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NBdG9tKCkge1xuICAgICAgLy8gQ2xhc3NBdG9tIDo6XG4gICAgICAvLyAgICAgIC1cbiAgICAgIC8vICAgICAgQ2xhc3NBdG9tTm9EYXNoXG4gICAgICBpZiAobWF0Y2goJy0nKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKCctJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0F0b21Ob0Rhc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzQXRvbU5vRGFzaCgpIHtcbiAgICAgIC8vIENsYXNzQXRvbU5vRGFzaCA6OlxuICAgICAgLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBvbmUgb2YgXFwgb3IgXSBvciAtXG4gICAgICAvLyAgICAgIFxcIENsYXNzRXNjYXBlXG5cbiAgICAgIHZhciByZXM7XG4gICAgICBpZiAocmVzID0gbWF0Y2hSZWcoL15bXlxcXFxcXF0tXS8pKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXIocmVzWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1xcXFwnKSkge1xuICAgICAgICByZXMgPSBwYXJzZUNsYXNzRXNjYXBlKCk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ2NsYXNzRXNjYXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VVbmljb2RlU3Vycm9nYXRlUGFpckVzY2FwZShyZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIGlucHV0IHRvIGEgc3RyaW5nIGFuZCB0cmVhdCB0aGUgZW1wdHkgc3RyaW5nIHNwZWNpYWwuXG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgaWYgKHN0ciA9PT0gJycpIHtcbiAgICAgIHN0ciA9ICcoPzopJztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VEaXNqdW5jdGlvbigpO1xuXG4gICAgaWYgKHJlc3VsdC5yYW5nZVsxXSAhPT0gc3RyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgU3ludGF4RXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBlbnRpcmUgaW5wdXQgLSBnb3Qgc3R1Y2s6ICcgKyBzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHJlZ2pzcGFyc2VyID0ge1xuICAgIHBhcnNlOiBwYXJzZVxuICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVnanNwYXJzZXI7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LnJlZ2pzcGFyc2VyID0gcmVnanNwYXJzZXI7XG4gIH1cblxufSgpKTtcbiIsInZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoJ3JlZ2pzZ2VuJykuZ2VuZXJhdGU7XG52YXIgcGFyc2UgPSByZXF1aXJlKCdyZWdqc3BhcnNlcicpLnBhcnNlO1xudmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCdyZWdlbmVyYXRlJyk7XG52YXIgaXVNYXBwaW5ncyA9IHJlcXVpcmUoJy4vZGF0YS9pdS1tYXBwaW5ncy5qc29uJyk7XG52YXIgRVNDQVBFX1NFVFMgPSByZXF1aXJlKCcuL2RhdGEvY2hhcmFjdGVyLWNsYXNzLWVzY2FwZS1zZXRzLmpzJyk7XG5cbmZ1bmN0aW9uIGdldENoYXJhY3RlckNsYXNzRXNjYXBlU2V0KGNoYXJhY3Rlcikge1xuXHRpZiAodW5pY29kZSkge1xuXHRcdGlmIChpZ25vcmVDYXNlKSB7XG5cdFx0XHRyZXR1cm4gRVNDQVBFX1NFVFMuVU5JQ09ERV9JR05PUkVfQ0FTRVtjaGFyYWN0ZXJdO1xuXHRcdH1cblx0XHRyZXR1cm4gRVNDQVBFX1NFVFMuVU5JQ09ERVtjaGFyYWN0ZXJdO1xuXHR9XG5cdHJldHVybiBFU0NBUEVfU0VUUy5SRUdVTEFSW2NoYXJhY3Rlcl07XG59XG5cbnZhciBvYmplY3QgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHByb3BlcnR5KSB7XG5cdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xufVxuXG4vLyBQcmVwYXJlIGEgUmVnZW5lcmF0ZSBzZXQgY29udGFpbmluZyBhbGwgY29kZSBwb2ludHMsIHVzZWQgZm9yIG5lZ2F0aXZlXG4vLyBjaGFyYWN0ZXIgY2xhc3NlcyAoaWYgYW55KS5cbnZhciBVTklDT0RFX1NFVCA9IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4MTBGRkZGKTtcbi8vIFdpdGhvdXQgdGhlIGB1YCBmbGFnLCB0aGUgcmFuZ2Ugc3RvcHMgYXQgMHhGRkZGLlxuLy8gaHR0cHM6Ly9tdGhzLmJlL2VzNiNzZWMtcGF0dGVybi1zZW1hbnRpY3NcbnZhciBCTVBfU0VUID0gcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHhGRkZGKTtcblxuLy8gUHJlcGFyZSBhIFJlZ2VuZXJhdGUgc2V0IGNvbnRhaW5pbmcgYWxsIGNvZGUgcG9pbnRzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGJlXG4vLyBtYXRjaGVkIGJ5IGAvLi91YC4gaHR0cHM6Ly9tdGhzLmJlL2VzNiNzZWMtYXRvbVxudmFyIERPVF9TRVRfVU5JQ09ERSA9IFVOSUNPREVfU0VULmNsb25lKCkgLy8gYWxsIFVuaWNvZGUgY29kZSBwb2ludHNcblx0LnJlbW92ZShcblx0XHQvLyBtaW51cyBgTGluZVRlcm1pbmF0b3JgcyAoaHR0cHM6Ly9tdGhzLmJlL2VzNiNzZWMtbGluZS10ZXJtaW5hdG9ycyk6XG5cdFx0MHgwMDBBLCAvLyBMaW5lIEZlZWQgPExGPlxuXHRcdDB4MDAwRCwgLy8gQ2FycmlhZ2UgUmV0dXJuIDxDUj5cblx0XHQweDIwMjgsIC8vIExpbmUgU2VwYXJhdG9yIDxMUz5cblx0XHQweDIwMjkgIC8vIFBhcmFncmFwaCBTZXBhcmF0b3IgPFBTPlxuXHQpO1xuLy8gUHJlcGFyZSBhIFJlZ2VuZXJhdGUgc2V0IGNvbnRhaW5pbmcgYWxsIGNvZGUgcG9pbnRzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGJlXG4vLyBtYXRjaGVkIGJ5IGAvLi9gIChvbmx5IEJNUCBjb2RlIHBvaW50cykuXG52YXIgRE9UX1NFVCA9IERPVF9TRVRfVU5JQ09ERS5jbG9uZSgpXG5cdC5pbnRlcnNlY3Rpb24oQk1QX1NFVCk7XG5cbi8vIEFkZCBhIHJhbmdlIG9mIGNvZGUgcG9pbnRzICsgYW55IGNhc2UtZm9sZGVkIGNvZGUgcG9pbnRzIGluIHRoYXQgcmFuZ2UgdG8gYVxuLy8gc2V0LlxucmVnZW5lcmF0ZS5wcm90b3R5cGUuaXVBZGRSYW5nZSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cdHZhciAkdGhpcyA9IHRoaXM7XG5cdGRvIHtcblx0XHR2YXIgZm9sZGVkID0gY2FzZUZvbGQobWluKTtcblx0XHRpZiAoZm9sZGVkKSB7XG5cdFx0XHQkdGhpcy5hZGQoZm9sZGVkKTtcblx0XHR9XG5cdH0gd2hpbGUgKCsrbWluIDw9IG1heCk7XG5cdHJldHVybiAkdGhpcztcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuXHRmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdFx0Ly8gTm90ZTogYGhhc093blByb3BlcnR5YCBpcyBub3QgbmVlZGVkIGhlcmUuXG5cdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGUoaXRlbSwgcGF0dGVybikge1xuXHQvLyBUT0RPOiBUZXN0IGlmIG1lbW9pemluZyBgcGF0dGVybmAgaGVyZSBpcyB3b3J0aCB0aGUgZWZmb3J0LlxuXHRpZiAoIXBhdHRlcm4pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIHRyZWUgPSBwYXJzZShwYXR0ZXJuLCAnJyk7XG5cdHN3aXRjaCAodHJlZS50eXBlKSB7XG5cdFx0Y2FzZSAnY2hhcmFjdGVyQ2xhc3MnOlxuXHRcdGNhc2UgJ2dyb3VwJzpcblx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHQvLyBObyB3cmFwcGluZyBuZWVkZWQuXG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0Ly8gV3JhcCB0aGUgcGF0dGVybiBpbiBhIG5vbi1jYXB0dXJpbmcgZ3JvdXAuXG5cdFx0XHR0cmVlID0gd3JhcCh0cmVlLCBwYXR0ZXJuKTtcblx0fVxuXHRhc3NpZ24oaXRlbSwgdHJlZSk7XG59XG5cbmZ1bmN0aW9uIHdyYXAodHJlZSwgcGF0dGVybikge1xuXHQvLyBXcmFwIHRoZSBwYXR0ZXJuIGluIGEgbm9uLWNhcHR1cmluZyBncm91cC5cblx0cmV0dXJuIHtcblx0XHQndHlwZSc6ICdncm91cCcsXG5cdFx0J2JlaGF2aW9yJzogJ2lnbm9yZScsXG5cdFx0J2JvZHknOiBbdHJlZV0sXG5cdFx0J3Jhdyc6ICcoPzonICsgcGF0dGVybiArICcpJ1xuXHR9O1xufVxuXG5mdW5jdGlvbiBjYXNlRm9sZChjb2RlUG9pbnQpIHtcblx0cmV0dXJuIGhhcyhpdU1hcHBpbmdzLCBjb2RlUG9pbnQpID8gaXVNYXBwaW5nc1tjb2RlUG9pbnRdIDogZmFsc2U7XG59XG5cbnZhciBpZ25vcmVDYXNlID0gZmFsc2U7XG52YXIgdW5pY29kZSA9IGZhbHNlO1xuZnVuY3Rpb24gcHJvY2Vzc0NoYXJhY3RlckNsYXNzKGNoYXJhY3RlckNsYXNzSXRlbSkge1xuXHR2YXIgc2V0ID0gcmVnZW5lcmF0ZSgpO1xuXHR2YXIgYm9keSA9IGNoYXJhY3RlckNsYXNzSXRlbS5ib2R5LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdHN3aXRjaCAoaXRlbS50eXBlKSB7XG5cdFx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHRcdHNldC5hZGQoaXRlbS5jb2RlUG9pbnQpO1xuXHRcdFx0XHRpZiAoaWdub3JlQ2FzZSAmJiB1bmljb2RlKSB7XG5cdFx0XHRcdFx0dmFyIGZvbGRlZCA9IGNhc2VGb2xkKGl0ZW0uY29kZVBvaW50KTtcblx0XHRcdFx0XHRpZiAoZm9sZGVkKSB7XG5cdFx0XHRcdFx0XHRzZXQuYWRkKGZvbGRlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2hhcmFjdGVyQ2xhc3NSYW5nZSc6XG5cdFx0XHRcdHZhciBtaW4gPSBpdGVtLm1pbi5jb2RlUG9pbnQ7XG5cdFx0XHRcdHZhciBtYXggPSBpdGVtLm1heC5jb2RlUG9pbnQ7XG5cdFx0XHRcdHNldC5hZGRSYW5nZShtaW4sIG1heCk7XG5cdFx0XHRcdGlmIChpZ25vcmVDYXNlICYmIHVuaWNvZGUpIHtcblx0XHRcdFx0XHRzZXQuaXVBZGRSYW5nZShtaW4sIG1heCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjaGFyYWN0ZXJDbGFzc0VzY2FwZSc6XG5cdFx0XHRcdHNldC5hZGQoZ2V0Q2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXQoaXRlbS52YWx1ZSkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdC8vIFRoZSBgZGVmYXVsdGAgY2xhdXNlIGlzIG9ubHkgaGVyZSBhcyBhIHNhZmVndWFyZDsgaXQgc2hvdWxkIG5ldmVyIGJlXG5cdFx0XHQvLyByZWFjaGVkLiBDb2RlIGNvdmVyYWdlIHRvb2xzIHNob3VsZCBpZ25vcmUgaXQuXG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ1Vua25vd24gdGVybSB0eXBlOiAnICsgaXRlbS50eXBlKTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoY2hhcmFjdGVyQ2xhc3NJdGVtLm5lZ2F0aXZlKSB7XG5cdFx0c2V0ID0gKHVuaWNvZGUgPyBVTklDT0RFX1NFVCA6IEJNUF9TRVQpLmNsb25lKCkucmVtb3ZlKHNldCk7XG5cdH1cblx0dXBkYXRlKGNoYXJhY3RlckNsYXNzSXRlbSwgc2V0LnRvU3RyaW5nKCkpO1xuXHRyZXR1cm4gY2hhcmFjdGVyQ2xhc3NJdGVtO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVGVybShpdGVtKSB7XG5cdHN3aXRjaCAoaXRlbS50eXBlKSB7XG5cdFx0Y2FzZSAnZG90Jzpcblx0XHRcdHVwZGF0ZShcblx0XHRcdFx0aXRlbSxcblx0XHRcdFx0KHVuaWNvZGUgPyBET1RfU0VUX1VOSUNPREUgOiBET1RfU0VUKS50b1N0cmluZygpXG5cdFx0XHQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY2hhcmFjdGVyQ2xhc3MnOlxuXHRcdFx0aXRlbSA9IHByb2Nlc3NDaGFyYWN0ZXJDbGFzcyhpdGVtKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2NoYXJhY3RlckNsYXNzRXNjYXBlJzpcblx0XHRcdHVwZGF0ZShcblx0XHRcdFx0aXRlbSxcblx0XHRcdFx0Z2V0Q2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXQoaXRlbS52YWx1ZSkudG9TdHJpbmcoKVxuXHRcdFx0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2FsdGVybmF0aXZlJzpcblx0XHRjYXNlICdkaXNqdW5jdGlvbic6XG5cdFx0Y2FzZSAnZ3JvdXAnOlxuXHRcdGNhc2UgJ3F1YW50aWZpZXInOlxuXHRcdFx0aXRlbS5ib2R5ID0gaXRlbS5ib2R5Lm1hcChwcm9jZXNzVGVybSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd2YWx1ZSc6XG5cdFx0XHR2YXIgY29kZVBvaW50ID0gaXRlbS5jb2RlUG9pbnQ7XG5cdFx0XHR2YXIgc2V0ID0gcmVnZW5lcmF0ZShjb2RlUG9pbnQpO1xuXHRcdFx0aWYgKGlnbm9yZUNhc2UgJiYgdW5pY29kZSkge1xuXHRcdFx0XHR2YXIgZm9sZGVkID0gY2FzZUZvbGQoY29kZVBvaW50KTtcblx0XHRcdFx0aWYgKGZvbGRlZCkge1xuXHRcdFx0XHRcdHNldC5hZGQoZm9sZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dXBkYXRlKGl0ZW0sIHNldC50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2FuY2hvcic6XG5cdFx0Y2FzZSAnZW1wdHknOlxuXHRcdGNhc2UgJ2dyb3VwJzpcblx0XHRjYXNlICdyZWZlcmVuY2UnOlxuXHRcdFx0Ly8gTm90aGluZyB0byBkbyBoZXJlLlxuXHRcdFx0YnJlYWs7XG5cdFx0Ly8gVGhlIGBkZWZhdWx0YCBjbGF1c2UgaXMgb25seSBoZXJlIGFzIGEgc2FmZWd1YXJkOyBpdCBzaG91bGQgbmV2ZXIgYmVcblx0XHQvLyByZWFjaGVkLiBDb2RlIGNvdmVyYWdlIHRvb2xzIHNob3VsZCBpZ25vcmUgaXQuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgRXJyb3IoJ1Vua25vd24gdGVybSB0eXBlOiAnICsgaXRlbS50eXBlKTtcblx0fVxuXHRyZXR1cm4gaXRlbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0dGVybiwgZmxhZ3MpIHtcblx0dmFyIHRyZWUgPSBwYXJzZShwYXR0ZXJuLCBmbGFncyk7XG5cdGlnbm9yZUNhc2UgPSBmbGFncyA/IGZsYWdzLmluZGV4T2YoJ2knKSA+IC0xIDogZmFsc2U7XG5cdHVuaWNvZGUgPSBmbGFncyA/IGZsYWdzLmluZGV4T2YoJ3UnKSA+IC0xIDogZmFsc2U7XG5cdGFzc2lnbih0cmVlLCBwcm9jZXNzVGVybSh0cmVlKSk7XG5cdHJldHVybiBnZW5lcmF0ZSh0cmVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudCcpO1xuXHR9XG5cblx0aWYgKG4gPCAwIHx8ICFpc0Zpbml0ZShuKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZmluaXRlIHBvc2l0aXZlIG51bWJlcicpO1xuXHR9XG5cblx0dmFyIHJldCA9ICcnO1xuXG5cdGRvIHtcblx0XHRpZiAobiAmIDEpIHtcblx0XHRcdHJldCArPSBzdHI7XG5cdFx0fVxuXG5cdFx0c3RyICs9IHN0cjtcblx0fSB3aGlsZSAobiA9IG4gPj4gMSk7XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IC9eIyEuKi87XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0dmFyIGlzRXh0ZW5kZWRMZW5ndGhQYXRoID0gL15cXFxcXFxcXFxcP1xcXFwvLnRlc3Qoc3RyKTtcblx0dmFyIGhhc05vbkFzY2lpID0gL1teXFx4MDAtXFx4ODBdKy8udGVzdChzdHIpO1xuXG5cdGlmIChpc0V4dGVuZGVkTGVuZ3RoUGF0aCB8fCBoYXNOb25Bc2NpaSkge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0dmFyIGJhc2U2NCA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodmFsKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRyZXR1cm4gJy8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJhc2U2NDtcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gICAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICAgKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gICAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gICAqL1xuICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5oYXMoYVN0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICBpZiAodGhpcy5oYXMoYVN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFPdXRQYXJhbSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcbiAgICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChpID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG4gICAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQXQoaSsrKSk7XG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgICBhT3V0UGFyYW0ucmVzdCA9IGFTdHIuc2xpY2UoaSk7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgY2hhclRvSW50TWFwID0ge307XG4gIHZhciBpbnRUb0NoYXJNYXAgPSB7fTtcblxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgICAuc3BsaXQoJycpXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGNoLCBpbmRleCkge1xuICAgICAgY2hhclRvSW50TWFwW2NoXSA9IGluZGV4O1xuICAgICAgaW50VG9DaGFyTWFwW2luZGV4XSA9IGNoO1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGFOdW1iZXIpIHtcbiAgICBpZiAoYU51bWJlciBpbiBpbnRUb0NoYXJNYXApIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbYU51bWJlcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgYU51bWJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IHRvIGFuIGludGVnZXIuXG4gICAqL1xuICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoYUNoYXIpIHtcbiAgICBpZiAoYUNoYXIgaW4gY2hhclRvSW50TWFwKSB7XG4gICAgICByZXR1cm4gY2hhclRvSW50TWFwW2FDaGFyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFwiICsgYUNoYXIpO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAgIC8vICAgICAgdGhlIG5leHQgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgbGVzcyB0aGFuIHRoYXQgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gICAgLy8gICAgICBlbGVtZW50IHdoaWNoIGlzIGxlc3MgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZVxuICAgIC8vICAgICAgcmV0dXJuIC0xLlxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgZ3JlYXRlciB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gV2UgZGlkIG5vdCBmaW5kIGFuIGV4YWN0IG1hdGNoLCByZXR1cm4gdGhlIG5leHQgY2xvc2VzdCBvbmVcbiAgICAgIC8vICh0ZXJtaW5hdGlvbiBjYXNlIDIpLlxuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhSGF5c3RhY2tbbWlkXSBpcyBsZXNzIHRoYW4gb3VyIG5lZWRsZS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMikgb3IgKDMpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAgICogdGhlIGluZGV4IG9mIG5leHQgbG93ZXN0IHZhbHVlIGNoZWNrZWQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzXG4gICAqIGJlY2F1c2UgbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGVcbiAgICogcG9pbnRzLCBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3NcbiAgICoganVzdCBtZWFucyB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKVxuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICAgKiBwb3NpdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gICAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICAgKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAgICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAgICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAgICpcbiAgICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICAgIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICB9O1xuXG4gIGV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuXG4gIC8qKlxuICAgKiBBIFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAgICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gICAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAgICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICAgKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICAgKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbiA6IDMsXG4gICAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gICAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICAgKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICAgKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAgICogICAgIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICBzb3VyY2VzID0gc291cmNlcy5tYXAodXRpbC5ub3JtYWxpemUpO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgU291cmNlTWFwQ29uc3VtZXJcbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgICBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgICAgc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpXG4gICAgICAgIC5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gc21jO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIpIHtcbiAgICAgIHZhciBjID0gYVN0ci5jaGFyQXQoMCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgc3RyID0gYVN0cjtcbiAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHIuY2hhckF0KDApID09PSAnLCcpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWFwcGluZyA9IHt9O1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcblxuICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHByZXZpb3VzU291cmNlICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHRoaXMuX25hbWVzLmF0KHByZXZpb3VzTmFtZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICAgKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yKSB7XG4gICAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgdGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGlibGUuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAqIGFuZCBsaW5lIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIEluZmluaXR5LCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3RcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBJbmZpbml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbmVlZGxlLm9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbLS1pbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBpbmdzLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZVxuICAgICAgICB9O1xuICAgICAgfSkuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbiAgdmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuICAvLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbiAgdmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4gIC8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2ZcbiAgLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3NcbiAgLy8gdmVyc2lvbnMhXG4gIHZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4gIC8qKlxuICAgKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gICAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICAgKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAgICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gICAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAgICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gICAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICAgKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gICAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICAgIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gICAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAgICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAgICovXG4gIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gXCJcIjtcbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoYUNodW5rKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgdmFyIG5ld0NoaWxkcmVuO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICB9XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICAgKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfTtcblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAgICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICAgKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gICAqIG1hcC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgIGNvZGU6IFwiXCIsXG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICAgIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG4gIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gICAqIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICAgKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gICAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG4gIHZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xuICB2YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbiAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgICBwYXRoOiBtYXRjaFs1XVxuICAgIH07XG4gIH1cbiAgZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG4gIGZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgICB2YXIgdXJsID0gJyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gICAgfVxuICAgIHVybCArPSAnLy8nO1xuICAgIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuICAvKipcbiAgICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gICAqXG4gICAqIC0gUmVwbGFjZXMgY29uc2VxdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAgICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gICAqXG4gICAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICAgIHZhciBwYXRoID0gYVBhdGg7XG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSB1cmwucGF0aDtcbiAgICB9XG4gICAgdmFyIGlzQWJzb2x1dGUgPSAocGF0aC5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gICAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgICB1cCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgIHVwLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgdXJsLnBhdGggPSBwYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICAgKlxuICAgKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICAgKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAgICogICBmaXJzdC5cbiAgICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gICAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICAgKiAgIGlzIHJldHVybmVkLlxuICAgKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gICAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAgICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG4gICAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgICBhUGF0aCA9IFwiLlwiO1xuICAgIH1cbiAgICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgICB9XG5cbiAgICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICAgIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgICB9XG5cbiAgICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICA/IGFQYXRoXG4gICAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgfVxuICAgIHJldHVybiBqb2luZWQ7XG4gIH1cbiAgZXhwb3J0cy5qb2luID0gam9pbjtcblxuICAvKipcbiAgICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgYVJvb3QgPSBcIi5cIjtcbiAgICB9XG5cbiAgICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgICAvLyBYWFg6IEl0IGlzIHBvc3NpYmxlIHRvIHJlbW92ZSB0aGlzIGJsb2NrLCBhbmQgdGhlIHRlc3RzIHN0aWxsIHBhc3MhXG4gICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVBhdGguY2hhckF0KDApID09IFwiL1wiICYmIHVybCAmJiB1cmwucGF0aCA9PSBcIi9cIikge1xuICAgICAgcmV0dXJuIGFQYXRoLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMFxuICAgICAgPyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSlcbiAgICAgIDogYVBhdGg7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgIHZhciBzMiA9IGFTdHIyIHx8IFwiXCI7XG4gICAgcmV0dXJuIChzMSA+IHMyKSAtIChzMSA8IHMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcDtcblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmVcbiAgICogY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM7XG5cbn0pO1xuIiwiLyoqIHZpbTogZXQ6dHM9NDpzdz00OnN0cz00XG4gKiBAbGljZW5zZSBhbWRlZmluZSAwLjEuMCBDb3B5cmlnaHQgKGMpIDIwMTEsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGRlcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW1kUmVxdWlyZS50b1VybCA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgaWYgKGZpbGVQYXRoLmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoZmlsZVBhdGgsIHBhdGguZGlybmFtZShtb2R1bGUuZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhbWRSZXF1aXJlO1xuICAgIH07XG5cbiAgICAvL0Zhdm9yIGV4cGxpY2l0IHZhbHVlLCBwYXNzZWQgaW4gaWYgdGhlIG1vZHVsZSB3YW50cyB0byBzdXBwb3J0IE5vZGUgMC40LlxuICAgIHJlcXVpcmVGbiA9IHJlcXVpcmVGbiB8fCBmdW5jdGlvbiByZXEoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUucmVxdWlyZS5hcHBseShtb2R1bGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHIsIGUsIG0sIHJlc3VsdDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGUgPSBsb2FkZXJDYWNoZVtpZF0gPSB7fTtcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHVyaTogX19maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9Pbmx5IHN1cHBvcnQgb25lIGRlZmluZSBjYWxsIHBlciBmaWxlXG4gICAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgd2l0aCBubyBtb2R1bGUgSUQgY2Fubm90IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBwZXIgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL1VzZSB0aGUgcmVhbCB2YXJpYWJsZXMgZnJvbSBub2RlXG4gICAgICAgICAgICAvL1VzZSBtb2R1bGUuZXhwb3J0cyBmb3IgZXhwb3J0cywgc2luY2VcbiAgICAgICAgICAgIC8vdGhlIGV4cG9ydHMgaW4gaGVyZSBpcyBhbWRlZmluZSBleHBvcnRzLlxuICAgICAgICAgICAgZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgICAgICAgICAgbSA9IG1vZHVsZTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIG1vZHVsZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0lmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMsIHRoZXkgYXJlIHN0cmluZ3MsIHNvIG5lZWRcbiAgICAgICAgLy90byBjb252ZXJ0IHRoZW0gdG8gZGVwZW5kZW5jeSB2YWx1ZXMuXG4gICAgICAgIGlmIChkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcihkZXBOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DYWxsIHRoZSBmYWN0b3J5IHdpdGggdGhlIHJpZ2h0IGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5LmFwcGx5KG0uZXhwb3J0cywgZGVwcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSBtLmV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJpbmdSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgaWQsIHJlbElkKSB7XG4gICAgICAgIC8vU3BsaXQgdGhlIElEIGJ5IGEgISBzbyB0aGF0XG4gICAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoJyEnKSxcbiAgICAgICAgICAgIG9yaWdpbmFsSWQgPSBpZCxcbiAgICAgICAgICAgIHByZWZpeCwgcGx1Z2luO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG5cbiAgICAgICAgICAgIC8vU3RyYWlnaHQgbW9kdWxlIGxvb2t1cC4gSWYgaXQgaXMgb25lIG9mIHRoZSBzcGVjaWFsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIC8vZGVhbCB3aXRoIGl0LCBvdGhlcndpc2UsIGRlbGVnYXRlIHRvIG5vZGUuXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdyZXF1aXJlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdleHBvcnRzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2FkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoc3lzdGVtUmVxdWlyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtUmVxdWlyZShvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vZHVsZSB3aXRoIElEOiAnICsgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVGhlcmUgaXMgYSBwbHVnaW4gaW4gcGxheS5cbiAgICAgICAgICAgIHByZWZpeCA9IGlkLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZyhpbmRleCArIDEsIGlkLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHBsdWdpbiA9IHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBwcmVmaXgsIHJlbElkKTtcblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBsdWdpbi5ub3JtYWxpemUoaWQsIG1ha2VOb3JtYWxpemUocmVsSWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9Ob3JtYWxpemUgdGhlIElEIG5vcm1hbGx5LlxuICAgICAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ubG9hZChpZCwgbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCksIG1ha2VMb2FkKGlkKSwge30pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL0NyZWF0ZSBhIGRlZmluZSBmdW5jdGlvbiBzcGVjaWZpYyB0byB0aGUgbW9kdWxlIGFza2luZyBmb3IgYW1kZWZpbmUuXG4gICAgZnVuY3Rpb24gZGVmaW5lKGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gaWQ7XG4gICAgICAgICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwcyAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ107XG4gICAgICAgIH1cblxuICAgICAgICAvL1NldCB1cCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZHVsZS4gSWYgYW4gSUQsIHRoZW4gdXNlXG4gICAgICAgIC8vaW50ZXJuYWwgY2FjaGUuIElmIG5vIElELCB0aGVuIHVzZSB0aGUgZXh0ZXJuYWwgdmFyaWFibGVzXG4gICAgICAgIC8vZm9yIHRoaXMgbm9kZSBtb2R1bGUuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgLy9QdXQgdGhlIG1vZHVsZSBpbiBkZWVwIGZyZWV6ZSB1bnRpbCB0aGVyZSBpcyBhXG4gICAgICAgICAgICAvL3JlcXVpcmUgY2FsbCBmb3IgaXQuXG4gICAgICAgICAgICBkZWZpbmVDYWNoZVtpZF0gPSBbaWQsIGRlcHMsIGZhY3RvcnldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlZmluZS5yZXF1aXJlLCB3aGljaCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgdmFsdWVzIGluIHRoZVxuICAgIC8vY2FjaGUuIFVzZWZ1bCBmb3IgQU1EIG1vZHVsZXMgdGhhdCBhbGwgaGF2ZSBJRHMgaW4gdGhlIGZpbGUsXG4gICAgLy9idXQgbmVlZCB0byBmaW5hbGx5IGV4cG9ydCBhIHZhbHVlIHRvIG5vZGUgYmFzZWQgb24gb25lIG9mIHRob3NlXG4gICAgLy9JRHMuXG4gICAgZGVmaW5lLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lLmFtZCA9IHt9O1xuXG4gICAgcmV0dXJuIGRlZmluZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbWRlZmluZTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiYmFiZWxcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlR1cm4gRVM2IGNvZGUgaW50byByZWFkYWJsZSB2YW5pbGxhIEVTNSB3aXRoIHNvdXJjZSBtYXBzXCIsXG4gIFwidmVyc2lvblwiOiBcIjQuMy4wXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTZWJhc3RpYW4gTWNLZW56aWVcIixcbiAgICBcImVtYWlsXCI6IFwic2VibWNrQGdtYWlsLmNvbVwiXG4gIH0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2JhYmVsanMuaW8vXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWxcIlxuICB9LFxuICBcInByZWZlckdsb2JhbFwiOiB0cnVlLFxuICBcIm1haW5cIjogXCJsaWIvYmFiZWwvYXBpL25vZGUuanNcIixcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcIi4vbGliL2JhYmVsL2FwaS9yZWdpc3Rlci9ub2RlLmpzXCI6IFwiLi9saWIvYmFiZWwvYXBpL3JlZ2lzdGVyL2Jyb3dzZXIuanNcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCI2dG81XCI6IFwiLi9iaW4vZGVwcmVjYXRlZC82dG81XCIsXG4gICAgXCI2dG81LW1pbmlmeVwiOiBcIi4vYmluL2RlcHJlY2F0ZWQvNnRvNS1taW5pZnlcIixcbiAgICBcIjZ0bzUtbm9kZVwiOiBcIi4vYmluL2RlcHJlY2F0ZWQvNnRvNS1ub2RlXCIsXG4gICAgXCI2dG81LXJ1bnRpbWVcIjogXCIuL2Jpbi9kZXByZWNhdGVkLzZ0bzUtcnVudGltZVwiLFxuICAgIFwiYmFiZWxcIjogXCIuL2Jpbi9iYWJlbC9pbmRleC5qc1wiLFxuICAgIFwiYmFiZWwtbWluaWZ5XCI6IFwiLi9iaW4vYmFiZWwtbWluaWZ5XCIsXG4gICAgXCJiYWJlbC1ub2RlXCI6IFwiLi9iaW4vYmFiZWwtbm9kZVwiLFxuICAgIFwiYmFiZWwtZXh0ZXJuYWwtaGVscGVyc1wiOiBcIi4vYmluL2JhYmVsLWV4dGVybmFsLWhlbHBlcnNcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImhhcm1vbnlcIixcbiAgICBcImNsYXNzZXNcIixcbiAgICBcIm1vZHVsZXNcIixcbiAgICBcImxldFwiLFxuICAgIFwiY29uc3RcIixcbiAgICBcInZhclwiLFxuICAgIFwiZXM2XCIsXG4gICAgXCJ0cmFuc3BpbGVcIixcbiAgICBcInRyYW5zcGlsZXJcIixcbiAgICBcIjZ0bzVcIixcbiAgICBcImJhYmVsXCJcbiAgXSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJlbmNoXCI6IFwibWFrZSBiZW5jaFwiLFxuICAgIFwidGVzdFwiOiBcIm1ha2UgdGVzdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImFjb3JuLWJhYmVsXCI6IFwiMC4xMS4xLTMzXCIsXG4gICAgXCJhc3QtdHlwZXNcIjogXCJ+MC42LjFcIixcbiAgICBcImNoYWxrXCI6IFwiXjAuNS4xXCIsXG4gICAgXCJjaG9raWRhclwiOiBcIl4wLjEyLjZcIixcbiAgICBcImNvbW1hbmRlclwiOiBcIl4yLjYuMFwiLFxuICAgIFwiY29yZS1qc1wiOiBcIl4wLjUuNFwiLFxuICAgIFwiZGVidWdcIjogXCJeMi4xLjFcIixcbiAgICBcImRldGVjdC1pbmRlbnRcIjogXCJeMy4wLjBcIixcbiAgICBcImVzdHJhdmVyc2VcIjogXCJeMS45LjFcIixcbiAgICBcImVzdXRpbHNcIjogXCJeMS4xLjZcIixcbiAgICBcImZzLXJlYWRkaXItcmVjdXJzaXZlXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJnbG9iYWxzXCI6IFwiXjYuMi4wXCIsXG4gICAgXCJpcy1pbnRlZ2VyXCI6IFwiXjEuMC40XCIsXG4gICAgXCJqcy10b2tlbml6ZXJcIjogXCJeMS4zLjNcIixcbiAgICBcImxldmVuXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJsb2Rhc2hcIjogXCJeMy4yLjBcIixcbiAgICBcIm91dHB1dC1maWxlLXN5bmNcIjogXCJeMS4xLjBcIixcbiAgICBcInBhdGgtaXMtYWJzb2x1dGVcIjogXCJeMS4wLjBcIixcbiAgICBcInByaXZhdGVcIjogXCJeMC4xLjZcIixcbiAgICBcInJlZ2VuZXJhdG9yLWJhYmVsXCI6IFwiMC44LjEwLTJcIixcbiAgICBcInJlZ2V4cHVcIjogXCJeMS4xLjFcIixcbiAgICBcInJlcGVhdGluZ1wiOiBcIl4xLjEuMlwiLFxuICAgIFwic2hlYmFuZy1yZWdleFwiOiBcIl4xLjAuMFwiLFxuICAgIFwic2xhc2hcIjogXCJeMS4wLjBcIixcbiAgICBcInNvdXJjZS1tYXBcIjogXCJeMC4xLjQzXCIsXG4gICAgXCJzb3VyY2UtbWFwLXN1cHBvcnRcIjogXCJeMC4yLjlcIixcbiAgICBcInNvdXJjZS1tYXAtdG8tY29tbWVudFwiOiBcIl4xLjAuMFwiLFxuICAgIFwidHJpbS1yaWdodFwiOiBcIl4xLjAuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeOC4xLjNcIixcbiAgICBcImNoYWlcIjogXCJeMi4wLjBcIixcbiAgICBcImVzdmFsaWRcIjogXCJeMS4xLjBcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuMy41XCIsXG4gICAgXCJqc2NzXCI6IFwiXjEuMTEuM1wiLFxuICAgIFwianNoaW50XCI6IFwiXjIuNi4wXCIsXG4gICAgXCJqc2hpbnQtc3R5bGlzaFwiOiBcIl4xLjAuMFwiLFxuICAgIFwibWF0Y2hhXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjEuMFwiLFxuICAgIFwicmltcmFmXCI6IFwiXjIuMi44XCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJeMi40LjE2XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiYmIxOTY0OWFmODYxMmE2NjJhMTFhYWViMzYxYTJiYzFjN2EyODRmYVwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlc1wiXG4gIH0sXG4gIFwiX2lkXCI6IFwiYmFiZWxANC4zLjBcIixcbiAgXCJfc2hhc3VtXCI6IFwiNmVlY2FjMmIyNGNmMmEwMzA4ZGY3NGZjZmZiZmYwMDkzOTUzMGMwNlwiLFxuICBcIl9mcm9tXCI6IFwiYmFiZWxAPj00LjMuMCA8NS4wLjBcIixcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjIuMS4xOFwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjEuMC4yXCIsXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcInNlYm1ja1wiLFxuICAgIFwiZW1haWxcIjogXCJzZWJtY2tAZ21haWwuY29tXCJcbiAgfSxcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwic2VibWNrXCIsXG4gICAgICBcImVtYWlsXCI6IFwic2VibWNrQGdtYWlsLmNvbVwiXG4gICAgfVxuICBdLFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiNmVlY2FjMmIyNGNmMmEwMzA4ZGY3NGZjZmZiZmYwMDkzOTUzMGMwNlwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvYmFiZWwvLS9iYWJlbC00LjMuMC50Z3pcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHt9LFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2JhYmVsLy0vYmFiZWwtNC4zLjAudGd6XCIsXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJhYnN0cmFjdC1leHByZXNzaW9uLWNhbGxcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiUFJPUEVSVFlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlN5bWJvbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlZmVyZW5jZUdldFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9CSkVDVFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFic3RyYWN0LWV4cHJlc3Npb24tZGVsZXRlXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJQUk9QRVJUWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU3ltYm9sXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVmZXJlbmNlRGVsZXRlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFic3RyYWN0LWV4cHJlc3Npb24tZ2V0XCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJQUk9QRVJUWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU3ltYm9sXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVmZXJlbmNlR2V0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFic3RyYWN0LWV4cHJlc3Npb24tc2V0XCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJQUk9QRVJUWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU3ltYm9sXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVmZXJlbmNlU2V0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJWQUxVRVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcHBseS1jb25zdHJ1Y3RvclwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJDb25zdHJ1Y3RvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJnc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaW5zdGFuY2VcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY3JlYXRlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJDb25zdHJ1Y3RvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInByb3RvdHlwZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQ29uc3RydWN0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcHBseVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImluc3RhbmNlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzdWx0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiIT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOm51bGwsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiJiZcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIlVuYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwidHlwZW9mXCIsXCJwcmVmaXhcIjp0cnVlLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlc3VsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcIm9iamVjdFwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcInx8XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIlVuYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwidHlwZW9mXCIsXCJwcmVmaXhcIjp0cnVlLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlc3VsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcImZ1bmN0aW9uXCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaW5zdGFuY2VcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJyYXktY29tcHJlaGVuc2lvbi1jb250YWluZXJcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W10sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIktFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkFycmF5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJlbGVtZW50c1wiOltdLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJyYXktZnJvbVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmcm9tXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFMVUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJyYXktcHVzaFwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicHVzaFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlNUQVRFTUVOVFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhc3luYy10by1nZW5lcmF0b3JcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZm5cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbXSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZ2VuXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImZuXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXBwbHlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiVGhpc0V4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJndW1lbnRzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIk5ld0V4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJQcm9taXNlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzb2x2ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsTmV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdGVwXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYmluZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6bnVsbCxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSx7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6XCJuZXh0XCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY2FsbFRocm93XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0ZXBcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJiaW5kXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpudWxsLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LHtcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcInRocm93XCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0ZXBcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmdcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJUcnlTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYmxvY2tcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaW5mb1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZW5cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInZhbHVlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImluZm9cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJoYW5kbGVyXCI6e1widHlwZVwiOlwiQ2F0Y2hDbGF1c2VcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwicGFyYW1cIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImVycm9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJndWFyZFwiOm51bGwsXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZXJyb3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJndWFyZGVkSGFuZGxlcnNcIjpbXSxcImZpbmFsaXplclwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpbmZvXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZG9uZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzb2x2ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJQcm9taXNlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzb2x2ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInZhbHVlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInRoZW5cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsTmV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY2FsbFRocm93XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsTmV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImJpbmRcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiRnVuY3Rpb25cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYmluZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjYWxsXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPQkpFQ1RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQ09OVEVYVFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjbGFzcy1jYWxsLWNoZWNrXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImluc3RhbmNlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJDb25zdHJ1Y3RvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIiFcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaW5zdGFuY2VcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCJpbnN0YW5jZW9mXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQ29uc3RydWN0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlRocm93U3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiTmV3RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlR5cGVFcnJvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjbGFzcy1zdXBlci1jb25zdHJ1Y3Rvci1jYWxsLWxvb3NlXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlNVUEVSX05BTUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCIhPVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6bnVsbCxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJTVVBFUl9OQU1FXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXBwbHlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiVGhpc0V4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJndW1lbnRzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY2xhc3Mtc3VwZXItY29uc3RydWN0b3ItY2FsbFwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJTVVBFUl9OQU1FXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiIT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOm51bGwsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU1VQRVJfTkFNRVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFwcGx5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIlRoaXNFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ3VtZW50c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvcmVqcy1pcy1pdGVyYXRvclwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJDT1JFX0lEXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiJGZvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpc0l0ZXJhYmxlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFMVUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29yZWpzLWl0ZXJhdG9yXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkNPUkVfSURcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCIkZm9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImdldEl0ZXJhdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFMVUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiZGVmYXVsdC1wYXJhbWV0ZXJcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJWQVJJQUJMRV9OQU1FXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQVJHVU1FTlRTXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQVJHVU1FTlRfS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidW5kZWZpbmVkXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJERUZBVUxUX1ZBTFVFXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQVJHVU1FTlRTXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQVJHVU1FTlRfS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwibGV0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiZGVmYXVsdHNcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZhdWx0c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVmYXVsdHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRm9yU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImluaXRcIjp7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6MCxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCI8XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwibGVuZ3RoXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidXBkYXRlXCI6e1widHlwZVwiOlwiVXBkYXRlRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiKytcIixcInByZWZpeFwiOmZhbHNlLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImtleXNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZhdWx0c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCImJlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjb25maWd1cmFibGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiJiZcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImtleVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj09PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInVuZGVmaW5lZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlZmluZVByb3BlcnR5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInZhbHVlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImRlZmluZS1wcm9wZXJ0eVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmpcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImtleVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVmaW5lUHJvcGVydHlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmpcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImtleVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIk9iamVjdEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwicHJvcGVydGllc1wiOlt7XCJ0eXBlXCI6XCJQcm9wZXJ0eVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJtZXRob2RcIjpmYWxzZSxcInNob3J0aGFuZFwiOmZhbHNlLFwiY29tcHV0ZWRcIjpmYWxzZSxcImtleVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInZhbHVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJlbnVtZXJhYmxlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjb25maWd1cmFibGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInZhbHVlXCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOnRydWUsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJraW5kXCI6XCJpbml0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUHJvcGVydHlcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibWV0aG9kXCI6ZmFsc2UsXCJzaG9ydGhhbmRcIjpmYWxzZSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJrZXlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIndyaXRhYmxlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImV4cG9ydHMtYXNzaWduXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImV4cG9ydHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJLRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFMVUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJleHBvcnRzLWRlZmF1bHQtYXNzaWduXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm1vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImV4cG9ydHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFMVUVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJleHBvcnRzLW1vZHVsZS1kZWNsYXJhdGlvbi1sb29zZVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJleHBvcnRzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX19lc01vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOnRydWUsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiZXhwb3J0cy1tb2R1bGUtZGVjbGFyYXRpb25cIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlZmluZVByb3BlcnR5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZXhwb3J0c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcIl9fZXNNb2R1bGVcIixcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSx7XCJ0eXBlXCI6XCJPYmplY3RFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInByb3BlcnRpZXNcIjpbe1widHlwZVwiOlwiUHJvcGVydHlcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibWV0aG9kXCI6ZmFsc2UsXCJzaG9ydGhhbmRcIjpmYWxzZSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJrZXlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInZhbHVlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiZXh0ZW5kc1wiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFzc2lnblwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCJ8fFwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ0YXJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJGb3JTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaW5pdFwiOntcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjoxLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidGVzdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIjxcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ3VtZW50c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImxlbmd0aFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInVwZGF0ZVwiOntcInR5cGVcIjpcIlVwZGF0ZUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIisrXCIsXCJwcmVmaXhcIjpmYWxzZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInNvdXJjZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmd1bWVudHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRm9ySW5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzb3VyY2VcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInByb3RvdHlwZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJoYXNPd25Qcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic291cmNlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ0YXJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInNvdXJjZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImtleVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInRhcmdldFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJmb3Itb2YtbG9vc2VcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRm9yU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImluaXRcIjp7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxPT1BfT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPQkpFQ1RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklTX0FSUkFZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkFycmF5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaXNBcnJheVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxPT1BfT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiSU5ERVhcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6MCxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxPT1BfT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklTX0FSUkFZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJMT09QX09CSkVDVFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxPT1BfT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJTeW1ib2xcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpdGVyYXRvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOltdLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidGVzdFwiOm51bGwsXCJ1cGRhdGVcIjpudWxsLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJJRFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiSVNfQVJSQVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklOREVYXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPj1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxPT1BfT0JKRUNUXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwibGVuZ3RoXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJyZWFrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxhYmVsXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklEXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJMT09QX09CSkVDVFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJVcGRhdGVFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCIrK1wiLFwicHJlZml4XCI6ZmFsc2UsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiSU5ERVhcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJJTkRFWFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiTE9PUF9PQkpFQ1RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJuZXh0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJJTkRFWFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRvbmVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQnJlYWtTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGFiZWxcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiSURcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklOREVYXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJmb3Itb2ZcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRm9yU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImluaXRcIjp7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIklURVJBVE9SX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPQkpFQ1RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlN5bWJvbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIml0ZXJhdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjp0cnVlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJTVEVQX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ0ZXN0XCI6e1widHlwZVwiOlwiVW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCIhXCIsXCJwcmVmaXhcIjp0cnVlLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJTVEVQX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiSVRFUkFUT1JfS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwibmV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOltdLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRvbmVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ1cGRhdGVcIjpudWxsLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbXSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJnZXRcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVjZWl2ZXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlc2NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidW5kZWZpbmVkXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInBhcmVudFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRQcm90b3R5cGVPZlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwYXJlbnRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCI9PT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOm51bGwsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInVuZGVmaW5lZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInBhcmVudFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicHJvcGVydHlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlY2VpdmVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcInZhbHVlXCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiaW5cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiJiZcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlc2NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ3cml0YWJsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImdldHRlclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZ2V0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImdldHRlclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj09PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInVuZGVmaW5lZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ1bmRlZmluZWRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXR0ZXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjYWxsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVjZWl2ZXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJoYXMtb3duXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInByb3RvdHlwZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJoYXNPd25Qcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbmhlcml0c1wiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdWJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3VwZXJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiVW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCJ0eXBlb2ZcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3VwZXJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiE9PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6XCJmdW5jdGlvblwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiYmXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3VwZXJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiE9PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6bnVsbCxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlRocm93U3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiTmV3RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlR5cGVFcnJvclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiK1wiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcInR5cGVvZlwiLFwicHJlZml4XCI6dHJ1ZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdXBlckNsYXNzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3ViQ2xhc3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjcmVhdGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3VwZXJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiYmXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdXBlckNsYXNzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicHJvdG90eXBlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIk9iamVjdEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwicHJvcGVydGllc1wiOlt7XCJ0eXBlXCI6XCJQcm9wZXJ0eVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJtZXRob2RcIjpmYWxzZSxcInNob3J0aGFuZFwiOmZhbHNlLFwiY29tcHV0ZWRcIjpmYWxzZSxcImtleVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY29uc3RydWN0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInZhbHVlXCI6e1widHlwZVwiOlwiT2JqZWN0RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJwcm9wZXJ0aWVzXCI6W3tcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidmFsdWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN1YkNsYXNzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJraW5kXCI6XCJpbml0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUHJvcGVydHlcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibWV0aG9kXCI6ZmFsc2UsXCJzaG9ydGhhbmRcIjpmYWxzZSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJrZXlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImVudW1lcmFibGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInZhbHVlXCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOmZhbHNlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ3cml0YWJsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidmFsdWVcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6dHJ1ZSxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcImtpbmRcIjpcImluaXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJQcm9wZXJ0eVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJtZXRob2RcIjpmYWxzZSxcInNob3J0aGFuZFwiOmZhbHNlLFwiY29tcHV0ZWRcIjpmYWxzZSxcImtleVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY29uZmlndXJhYmxlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImtpbmRcIjpcImluaXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN1cGVyQ2xhc3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdWJDbGFzc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9fcHJvdG9fX1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdXBlckNsYXNzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbnRlcm9wLXJlcXVpcmUtd2lsZGNhcmRcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmpcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCImJlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX19lc01vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiT2JqZWN0RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJwcm9wZXJ0aWVzXCI6W3tcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZhdWx0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJraW5kXCI6XCJpbml0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbnRlcm9wLXJlcXVpcmVcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmpcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCImJlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX19lc01vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVmYXVsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImxldC1zY29waW5nLXJldHVyblwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiVW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCJ0eXBlb2ZcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiUkVUVVJOXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcIm9iamVjdFwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJSRVRVUk5cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJuYW1lZC1mdW5jXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOltdLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiR0VUX09VVEVSX0lEXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOltdLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJJRFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib2JqZWN0LWRlc3RydWN0dXJpbmctZW1wdHlcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOm51bGwsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiVGhyb3dTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJOZXdFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVHlwZUVycm9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOlwiQ2Fubm90IGRlc3RydWN0dXJlIHVuZGVmaW5lZFwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9iamVjdC13aXRob3V0LXByb3BlcnRpZXNcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJrZXlzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ0YXJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJPYmplY3RFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInByb3BlcnRpZXNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJGb3JJblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmpcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwia2V5c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImluZGV4T2ZcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj49XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjowLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkNvbnRpbnVlU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxhYmVsXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIlVuYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiIVwiLFwicHJlZml4XCI6dHJ1ZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaGFzT3duUHJvcGVydHlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY2FsbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJDb250aW51ZVN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsYWJlbFwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInRhcmdldFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ0YXJnZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHktbWV0aG9kLWFzc2lnbm1lbnQtd3JhcHBlci1nZW5lcmF0b3JcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiRlVOQ1RJT05fS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWNsYXJhdGlvbnNcIjpbe1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJXUkFQUEVSX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiRlVOQ1RJT05fSURcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImdlbmVyYXRvclwiOnRydWUsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbXSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIllpZWxkRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJkZWxlZ2F0ZVwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJGVU5DVElPTl9LRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcHBseVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJUaGlzRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmd1bWVudHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIldSQVBQRVJfS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidG9TdHJpbmdcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOltdLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInRvU3RyaW5nXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiV1JBUFBFUl9LRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJGVU5DVElPTlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eS1tZXRob2QtYXNzaWdubWVudC13cmFwcGVyXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiV1JBUFBFUl9LRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OX0lEXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOltdLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFwcGx5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIlRoaXNFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ3VtZW50c1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiV1JBUFBFUl9LRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ0b1N0cmluZ1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W10sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiRlVOQ1RJT05fS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidG9TdHJpbmdcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJXUkFQUEVSX0tFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3RvdHlwZS1pZGVudGlmaWVyXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJDTEFTU19OQU1FXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicHJvdG90eXBlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3RvdHlwZS1wcm9wZXJ0aWVzXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImNoaWxkXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdGF0aWNQcm9wc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaW5zdGFuY2VQcm9wc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0YXRpY1Byb3BzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlZmluZVByb3BlcnRpZXNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjaGlsZFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic3RhdGljUHJvcHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImluc3RhbmNlUHJvcHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVmaW5lUHJvcGVydGllc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY2hpbGRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpbnN0YW5jZVByb3BzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmVxdWlyZS1hc3NpZ24ta2V5XCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVkFSSUFCTEVfTkFNRVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXF1aXJlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJNT0RVTEVfTkFNRVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJLRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmVxdWlyZVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlcXVpcmVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk1PRFVMRV9OQU1FXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJlc3RcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRm9yU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImluaXRcIjp7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkxFTlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBUkdVTUVOVFNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJsZW5ndGhcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBUlJBWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkFSUkFZX0xFTlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIktFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU1RBUlRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIktFWVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIjxcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJMRU5cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInVwZGF0ZVwiOntcInR5cGVcIjpcIlVwZGF0ZUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIisrXCIsXCJwcmVmaXhcIjpmYWxzZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJLRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkFSUkFZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQVJSQVlfS0VZXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBUkdVTUVOVFNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJLRVlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6dHJ1ZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwic2VsZi1jb250YWluZWQtaGVscGVycy1oZWFkXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaGVscGVyc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImV4cG9ydHNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZhdWx0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJPYmplY3RFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInByb3BlcnRpZXNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJleHBvcnRzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX19lc01vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOnRydWUsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwic2VsZi1nbG9iYWxcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcInR5cGVvZlwiLFwicHJlZml4XCI6dHJ1ZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnbG9iYWxcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCI9PT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOlwidW5kZWZpbmVkXCIsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzZWxmXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImdsb2JhbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInNldFwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInNldFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJvYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInByb3BlcnR5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVjZWl2ZXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlc2NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidW5kZWZpbmVkXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInBhcmVudFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJnZXRQcm90b3R5cGVPZlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwYXJlbnRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCIhPT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOm51bGwsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInNldFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicGFyZW50XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm9wZXJ0eVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlY2VpdmVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6XCJ2YWx1ZVwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwib3BlcmF0b3JcIjpcImluXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVzY1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiYmXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwid3JpdGFibGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZXNjXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic2V0dGVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlc2NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzZXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwia2luZFwiOlwidmFyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic2V0dGVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiIT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidW5kZWZpbmVkXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic2V0dGVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY2FsbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlY2VpdmVyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwic2xpY2VcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwic2xpY2VcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwic2xpY2VkLXRvLWFycmF5XCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpc0FycmF5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjp7XCJ0eXBlXCI6XCJJZlN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlN5bWJvbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIml0ZXJhdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcImluXCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9hcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImluaXRcIjp7XCJ0eXBlXCI6XCJBcnJheUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZWxlbWVudHNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJGb3JTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaW5pdFwiOntcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX2l0ZXJhdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU3ltYm9sXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaXRlcmF0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9zdGVwXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3RcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIiFcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9zdGVwXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJfaXRlcmF0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJuZXh0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W10sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZG9uZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInVwZGF0ZVwiOm51bGwsXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX2FyclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInB1c2hcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9zdGVwXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsdWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiJiZcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIl9hcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJsZW5ndGhcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJyZWFrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxhYmVsXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX2FyclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiVGhyb3dTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJOZXdFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiVHlwZUVycm9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOlwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInN5c3RlbVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU3lzdGVtXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVnaXN0ZXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJNT0RVTEVfTkFNRVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiTU9EVUxFX0RFUEVOREVOQ0lFU1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkVYUE9SVF9JREVOVElGSUVSXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiT2JqZWN0RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJwcm9wZXJ0aWVzXCI6W3tcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzZXR0ZXJzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiU0VUVEVSU1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJleGVjdXRlXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ2YWx1ZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiRVhFQ1VURVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRhZ2dlZC10ZW1wbGF0ZS1saXRlcmFsLWxvb3NlXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0cmluZ3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJhd1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0cmluZ3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyYXdcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmF3XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdHJpbmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRhZ2dlZC10ZW1wbGF0ZS1saXRlcmFsXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInN0cmluZ3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJhd1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJPYmplY3RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmcmVlemVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIk9iamVjdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImRlZmluZVByb3BlcnRpZXNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJzdHJpbmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiT2JqZWN0RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJwcm9wZXJ0aWVzXCI6W3tcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyYXdcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInZhbHVlXCI6e1widHlwZVwiOlwiT2JqZWN0RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJwcm9wZXJ0aWVzXCI6W3tcInR5cGVcIjpcIlByb3BlcnR5XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm1ldGhvZFwiOmZhbHNlLFwic2hvcnRoYW5kXCI6ZmFsc2UsXCJjb21wdXRlZFwiOmZhbHNlLFwia2V5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWx1ZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidmFsdWVcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiT2JqZWN0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZnJlZXplXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmF3XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwia2luZFwiOlwiaW5pdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImtpbmRcIjpcImluaXRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidGFpbC1jYWxsLWJvZHlcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJMYWJlbGVkU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjp7XCJ0eXBlXCI6XCJXaGlsZVN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOnRydWUsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJib2R5XCI6e1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJCTE9DS1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwibGFiZWxcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkZVTkNUSU9OX0lEXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRhaWwtY2FsbFwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbXSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlRhaWxcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZnVuY1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJnc1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY29udGV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJUaGlzRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZnVuY1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29tcHV0ZWRcIjpmYWxzZSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInJpZ2h0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmdW5jXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIlRoaXNFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiVGhpc0V4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImNvbnRleHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiY29udGV4dFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlRhaWxcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJwcm90b3R5cGVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX2lzVGFpbERlc2NyaXB0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaXNSdW5uaW5nXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJpbml0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOmZhbHNlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImZ1bmNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFyZ3NcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImNvbnRleHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImRlY2xhcmF0aW9uc1wiOlt7XCJ0eXBlXCI6XCJWYXJpYWJsZURlY2xhcmF0b3JcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlc3VsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIk5ld0V4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJUYWlsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmdW5jXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjb250ZXh0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImtpbmRcIjpcInZhclwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIklmU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInRlc3RcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIiFcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaXNSdW5uaW5nXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwiPVwiLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaXNSdW5uaW5nXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjp0cnVlLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIkRvV2hpbGVTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlc3VsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmdW5jXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFwcGx5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJjb250ZXh0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcmdzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ0ZXN0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzdWx0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiaW5zdGFuY2VvZlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlRhaWxcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCJ8fFwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMb2dpY2FsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJyZXN1bHRcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCImJlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwicmVzdWx0XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiX2lzVGFpbERlc2NyaXB0b3JcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcIj1cIixcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlzUnVubmluZ1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6ZmFsc2UsXCJyYXdcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInJlc3VsdFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbXSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ0ZW1wb3JhbC1hc3NlcnQtZGVmaW5lZFwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJ2YWxcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm5hbWVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcInVuZGVmXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidmFsXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiPT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwidW5kZWZcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlRocm93U3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiTmV3RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlJlZmVyZW5jZUVycm9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJuYW1lXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiK1wiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6XCIgaXMgbm90IGRlZmluZWQgLSB0ZW1wb3JhbCBkZWFkIHpvbmVcIixcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6dHJ1ZSxcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidGVtcG9yYWwtdW5kZWZpbmVkXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIk9iamVjdEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwicHJvcGVydGllc1wiOltdLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3QtZXhwb3J0c1wiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcInR5cGVvZlwiLFwicHJlZml4XCI6dHJ1ZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJleHBvcnRzXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiIT09XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcInVuZGVmaW5lZFwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3QtbW9kdWxlXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkJpbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIlVuYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvcGVyYXRvclwiOlwidHlwZW9mXCIsXCJwcmVmaXhcIjp0cnVlLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm1vZHVsZVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIiE9PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJMaXRlcmFsXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcInZhbHVlXCI6XCJ1bmRlZmluZWRcIixcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ0by1hcnJheVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJib2R5XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBcnJheVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlzQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFsdGVybmF0ZVwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBcnJheVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImZyb21cIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRvLWNvbnN1bWFibGUtYXJyYXlcIjp7XCJ0eXBlXCI6XCJQcm9ncmFtXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImlkXCI6bnVsbCxcImdlbmVyYXRvclwiOmZhbHNlLFwiZXhwcmVzc2lvblwiOmZhbHNlLFwicGFyYW1zXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJBcnJheVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlzQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhcmd1bWVudHNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb25zZXF1ZW50XCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJGb3JTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaW5pdFwiOntcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZGVjbGFyYXRpb25zXCI6W3tcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjowLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LHtcInR5cGVcIjpcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJyMlwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiaW5pdFwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwibGVuZ3RoXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJraW5kXCI6XCJ2YXJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInRlc3RcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCI8XCIsXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJsZW5ndGhcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbXB1dGVkXCI6ZmFsc2UsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJ1cGRhdGVcIjp7XCJ0eXBlXCI6XCJVcGRhdGVFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCIrK1wiLFwicHJlZml4XCI6ZmFsc2UsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiaVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYm9keVwiOntcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCI9XCIsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImFycjJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJyaWdodFwiOntcInR5cGVcIjpcIk1lbWJlckV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib2JqZWN0XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnJcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJpXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOnRydWUsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0se1widHlwZVwiOlwiUmV0dXJuU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJhcnIyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiQmxvY2tTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJSZXR1cm5TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYXJndW1lbnRcIjp7XCJ0eXBlXCI6XCJDYWxsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJjYWxsZWVcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQXJyYXlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInByb3BlcnR5XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmcm9tXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYXJyXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwidHlwZW9mXCI6e1widHlwZVwiOlwiUHJvZ3JhbVwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJpZFwiOm51bGwsXCJnZW5lcmF0b3JcIjpmYWxzZSxcImV4cHJlc3Npb25cIjpmYWxzZSxcInBhcmFtc1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcImJvZHlcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIlJldHVyblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ0ZXN0XCI6e1widHlwZVwiOlwiTG9naWNhbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibGVmdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJvcGVyYXRvclwiOlwiJiZcIixcInJpZ2h0XCI6e1widHlwZVwiOlwiQmluYXJ5RXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJsZWZ0XCI6e1widHlwZVwiOlwiTWVtYmVyRXhwcmVzc2lvblwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJvYmplY3RcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIm9ialwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImNvbnN0cnVjdG9yXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwib3BlcmF0b3JcIjpcIj09PVwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIlN5bWJvbFwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkxpdGVyYWxcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidmFsdWVcIjpcInN5bWJvbFwiLFwicmF3XCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiVW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9wZXJhdG9yXCI6XCJ0eXBlb2ZcIixcInByZWZpeFwiOnRydWUsXCJhcmd1bWVudFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwib2JqXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcInVtZC1ydW5uZXItYm9keVwiOntcInR5cGVcIjpcIlByb2dyYW1cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiYm9keVwiOlt7XCJ0eXBlXCI6XCJFeHByZXNzaW9uU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImV4cHJlc3Npb25cIjp7XCJ0eXBlXCI6XCJGdW5jdGlvbkV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiaWRcIjpudWxsLFwiZ2VuZXJhdG9yXCI6ZmFsc2UsXCJleHByZXNzaW9uXCI6ZmFsc2UsXCJwYXJhbXNcIjpbe1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJmYWN0b3J5XCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiYm9keVwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImxlZnRcIjp7XCJ0eXBlXCI6XCJVbmFyeUV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwib3BlcmF0b3JcIjpcInR5cGVvZlwiLFwicHJlZml4XCI6dHJ1ZSxcImFyZ3VtZW50XCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZpbmVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCI9PT1cIixcInJpZ2h0XCI6e1widHlwZVwiOlwiTGl0ZXJhbFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJ2YWx1ZVwiOlwiZnVuY3Rpb25cIixcInJhd1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIm9wZXJhdG9yXCI6XCImJlwiLFwicmlnaHRcIjp7XCJ0eXBlXCI6XCJNZW1iZXJFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm9iamVjdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZGVmaW5lXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJwcm9wZXJ0eVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiYW1kXCIsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJjb21wdXRlZFwiOmZhbHNlLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiY29uc2VxdWVudFwiOntcInR5cGVcIjpcIkJsb2NrU3RhdGVtZW50XCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImJvZHlcIjpbe1widHlwZVwiOlwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJleHByZXNzaW9uXCI6e1widHlwZVwiOlwiQ2FsbEV4cHJlc3Npb25cIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiY2FsbGVlXCI6e1widHlwZVwiOlwiSWRlbnRpZmllclwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJuYW1lXCI6XCJkZWZpbmVcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImFyZ3VtZW50c1wiOlt7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcIkFNRF9BUkdVTUVOVFNcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSx7XCJ0eXBlXCI6XCJJZGVudGlmaWVyXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcIm5hbWVcIjpcImZhY3RvcnlcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH1dLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYWx0ZXJuYXRlXCI6e1widHlwZVwiOlwiSWZTdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwidGVzdFwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQ09NTU9OX1RFU1RcIixcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcImNvbnNlcXVlbnRcIjp7XCJ0eXBlXCI6XCJCbG9ja1N0YXRlbWVudFwiLFwic3RhcnRcIjpudWxsLFwiZW5kXCI6bnVsbCxcImxvY1wiOm51bGwsXCJyYW5nZVwiOm51bGwsXCJib2R5XCI6W3tcInR5cGVcIjpcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwiZXhwcmVzc2lvblwiOntcInR5cGVcIjpcIkNhbGxFeHByZXNzaW9uXCIsXCJzdGFydFwiOm51bGwsXCJlbmRcIjpudWxsLFwibG9jXCI6bnVsbCxcInJhbmdlXCI6bnVsbCxcImNhbGxlZVwiOntcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiZmFjdG9yeVwiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiYXJndW1lbnRzXCI6W3tcInR5cGVcIjpcIklkZW50aWZpZXJcIixcInN0YXJ0XCI6bnVsbCxcImVuZFwiOm51bGwsXCJsb2NcIjpudWxsLFwicmFuZ2VcIjpudWxsLFwibmFtZVwiOlwiQ09NTU9OX0FSR1VNRU5UU1wiLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfc2NvcGVJbmZvXCI6bnVsbCxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH0sXCJhbHRlcm5hdGVcIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9LFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcIl9zY29wZUluZm9cIjpudWxsLFwidG9rZW5zXCI6bnVsbCxcInJhd1wiOm51bGx9XSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9zY29wZUluZm9cIjpudWxsLFwiX2RlY2xhcmF0aW9uc1wiOm51bGwsXCJleHRlbmRlZFJhbmdlXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfSxcIl9kZWNsYXJhdGlvbnNcIjpudWxsLFwiZXh0ZW5kZWRSYW5nZVwiOm51bGwsXCJfc2NvcGVJbmZvXCI6bnVsbCxcInRva2Vuc1wiOm51bGwsXCJyYXdcIjpudWxsfV0sXCJfZGVjbGFyYXRpb25zXCI6bnVsbCxcImV4dGVuZGVkUmFuZ2VcIjpudWxsLFwiX3Njb3BlSW5mb1wiOm51bGwsXCJ0b2tlbnNcIjpudWxsLFwicmF3XCI6bnVsbH19IixudWxsLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gK3N1YmplY3RcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGwpIHsgLy8gYXNzdW1lIG9iamVjdCBpcyBhcnJheS1saWtlXG4gICAgaWYgKHN1YmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShzdWJqZWN0LmRhdGEpKVxuICAgICAgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPiBrTWF4TGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG5cbiAgaWYgKGxlbmd0aCA8IDApXG4gICAgbGVuZ3RoID0gMFxuICBlbHNlXG4gICAgbGVuZ3RoID4+Pj0gMCAvLyBDb2VyY2UgdG8gdWludDMyLlxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXRoaXMgKi9cbiAgICBzZWxmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgLyplc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgc2VsZi5sZW5ndGggPSBsZW5ndGhcbiAgICBzZWxmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgc2VsZi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgc2VsZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgc2VsZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc2VsZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplKVxuICAgIHNlbGYucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiBzZWxmXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSknKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggPj4+IDFcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcblxuICBpZiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgaWYgKG5ld0J1Zi5sZW5ndGgpXG4gICAgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bClcbiAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bClcbiAgICB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSlcbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSA+Pj4gMCAmIDB4RkZcblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJbnQodGhpcyxcbiAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpIC0gMSxcbiAgICAgICAgICAgICAtTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSlcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0ludCh0aGlzLFxuICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgICAgICAgIC1NYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpcyAvLyBzb3VyY2VcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldF9zdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludExFID0gQlAucmVhZFVJbnRMRVxuICBhcnIucmVhZFVJbnRCRSA9IEJQLnJlYWRVSW50QkVcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50TEUgPSBCUC5yZWFkSW50TEVcbiAgYXJyLnJlYWRJbnRCRSA9IEJQLnJlYWRJbnRCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnRMRSA9IEJQLndyaXRlVUludExFXG4gIGFyci53cml0ZVVJbnRCRSA9IEJQLndyaXRlVUludEJFXG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnRMRSA9IEJQLndyaXRlSW50TEVcbiAgYXJyLndyaXRlSW50QkUgPSBCUC53cml0ZUludEJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtelxcLV0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gbGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCB8IDB4MTAwMDBcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgyMDAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gZmFsc2U7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIEluIHN0cmVhbXMgdGhhdCBuZXZlciBoYXZlIGFueSBkYXRhLCBhbmQgZG8gcHVzaChudWxsKSByaWdodCBhd2F5LFxuICAvLyB0aGUgY29uc3VtZXIgY2FuIG1pc3MgdGhlICdlbmQnIGV2ZW50IGlmIHRoZXkgZG8gc29tZSBJL08gYmVmb3JlXG4gIC8vIGNvbnN1bWluZyB0aGUgc3RyZWFtLiAgU28sIHdlIGRvbid0IGVtaXQoJ2VuZCcpIHVudGlsIHNvbWUgcmVhZGluZ1xuICAvLyBoYXBwZW5zLlxuICB0aGlzLmNhbGxlZFJlYWQgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKG4gPT09IG51bGwgfHwgaXNOYU4obikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgdmFyIHJldDtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgcmV0ID0gbnVsbDtcblxuICAgIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBkZWNvZGVyIGRpZCBub3QgcmVjZWl2ZSBlbm91Z2ggZGF0YVxuICAgIC8vIHRvIHByb2R1Y2UgYSBmdWxsIGNodW5rLCB0aGVuIGltbWVkaWF0ZWx5IHJlY2VpdmVkIGFuXG4gICAgLy8gRU9GLCBzdGF0ZS5idWZmZXIgd2lsbCBjb250YWluIFs8QnVmZmVyID4sIDxCdWZmZXIgMDAgLi4uPl0uXG4gICAgLy8gaG93TXVjaFRvUmVhZCB3aWxsIHNlZSB0aGlzIGFuZCBjb2VyY2UgdGhlIGFtb3VudCB0b1xuICAgIC8vIHJlYWQgdG8gemVybyAoYmVjYXVzZSBpdCdzIGxvb2tpbmcgYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAvLyBmaXJzdCA8QnVmZmVyID4gaW4gc3RhdGUuYnVmZmVyKSwgYW5kIHdlJ2xsIGVuZCB1cCBoZXJlLlxuICAgIC8vXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gdmlhIHN0YXRlLmRlY29kZXIgLS0gbm8gb3RoZXIgdmVudWVcbiAgICAvLyBleGlzdHMgZm9yIHB1c2hpbmcgYSB6ZXJvLWxlbmd0aCBjaHVuayBpbnRvIHN0YXRlLmJ1ZmZlclxuICAgIC8vIGFuZCB0cmlnZ2VyaW5nIHRoaXMgYmVoYXZpb3IuIEluIHRoaXMgY2FzZSwgd2UgcmV0dXJuIG91clxuICAgIC8vIHJlbWFpbmluZyBkYXRhIGFuZCBlbmQgdGhlIHN0cmVhbSwgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA+IDAgJiYgc3RhdGUuZGVjb2Rlcikge1xuICAgICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICAgICAgc3RhdGUubGVuZ3RoIC09IHJldC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoIC0gbiA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIGRvUmVhZCA9IHRydWU7XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZylcbiAgICBkb1JlYWQgPSBmYWxzZTtcblxuICBpZiAoZG9SZWFkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBjYWxsZWQgaXRzIGNhbGxiYWNrIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgXG4gIC8vIHdpbGwgYmUgZmFsc2UsIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2VcbiAgLy8gY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSBoYXBwZW5lZCB0byByZWFkKCkgZXhhY3RseSB0aGUgcmVtYWluaW5nIGFtb3VudCBpbiB0aGVcbiAgLy8gYnVmZmVyLCBhbmQgdGhlIEVPRiBoYXMgYmVlbiBzZWVuIGF0IHRoaXMgcG9pbnQsIHRoZW4gbWFrZSBzdXJlXG4gIC8vIHRoYXQgd2UgZW1pdCAnZW5kJyBvbiB0aGUgdmVyeSBuZXh0IHRpY2suXG4gIGlmIChzdGF0ZS5lbmRlZCAmJiAhc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQgYW5kIHdlIGhhdmUgc29tZSBkYXRhIGxlZnQsIHRoZW4gZW1pdFxuICAvLyAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICBlbHNlXG4gICAgZW5kUmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgICByZXR1cm47XG5cbiAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLnN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGlmIChyZWFkYWJsZSAhPT0gc3JjKSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlc3QgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDApXG4gICAgICBmbG93KHNyYyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb3coc3JjKSB7XG4gIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIGNodW5rO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcblxuICBmdW5jdGlvbiB3cml0ZShkZXN0LCBpLCBsaXN0KSB7XG4gICAgdmFyIHdyaXR0ZW4gPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHdyaXR0ZW4pIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucGlwZXNDb3VudCAmJiBudWxsICE9PSAoY2h1bmsgPSBzcmMucmVhZCgpKSkge1xuXG4gICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgICB3cml0ZShzdGF0ZS5waXBlcywgMCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgZm9yRWFjaChzdGF0ZS5waXBlcywgd3JpdGUpO1xuXG4gICAgc3JjLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG5cbiAgICAvLyBpZiBhbnlvbmUgbmVlZHMgYSBkcmFpbiwgdGhlbiB3ZSBoYXZlIHRvIHdhaXQgZm9yIHRoYXQuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPiAwKVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgZXZlcnkgZGVzdGluYXRpb24gd2FzIHVucGlwZWQsIGVpdGhlciBiZWZvcmUgZW50ZXJpbmcgdGhpc1xuICAvLyBmdW5jdGlvbiwgb3IgaW4gdGhlIHdoaWxlIGxvb3AsIHRoZW4gc3RvcCBmbG93aW5nLlxuICAvL1xuICAvLyBOQjogVGhpcyBpcyBhIHByZXR0eSByYXJlIGVkZ2UgY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICAvLyBpZiB0aGVyZSB3ZXJlIGRhdGEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkLCB0aGVuIHN3aXRjaCB0byBvbGQgbW9kZS5cbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykgPiAwKVxuICAgICAgZW1pdERhdGFFdmVudHMoc3JjKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBubyBvbmUgbmVlZGVkIGEgZHJhaW4sIHNvIHdlIGp1c3QgcmFuIG91dCBvZiBkYXRhXG4gIC8vIG9uIHRoZSBuZXh0IHJlYWRhYmxlIGV2ZW50LCBzdGFydCBpdCBvdmVyIGFnYWluLlxuICBzdGF0ZS5yYW5PdXQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwaXBlT25SZWFkYWJsZSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0KSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQgPSBmYWxzZTtcbiAgICBmbG93KHRoaXMpO1xuICB9XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHRoaXMucmVhZCgwKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcyk7XG4gIHRoaXMucmVhZCgwKTtcbiAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzLCB0cnVlKTtcbiAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuZnVuY3Rpb24gZW1pdERhdGFFdmVudHMoc3RyZWFtLCBzdGFydFBhdXNlZCkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMTZcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2l0Y2ggdG8gb2xkIG1vZGUgbm93LicpO1xuICB9XG5cbiAgdmFyIHBhdXNlZCA9IHN0YXJ0UGF1c2VkIHx8IGZhbHNlO1xuICB2YXIgcmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBjb252ZXJ0IHRvIGFuIG9sZC1zdHlsZSBzdHJlYW0uXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG4gIHN0cmVhbS5waXBlID0gU3RyZWFtLnByb3RvdHlwZS5waXBlO1xuICBzdHJlYW0ub24gPSBzdHJlYW0uYWRkTGlzdGVuZXIgPSBTdHJlYW0ucHJvdG90eXBlLm9uO1xuXG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICByZWFkYWJsZSA9IHRydWU7XG5cbiAgICB2YXIgYztcbiAgICB3aGlsZSAoIXBhdXNlZCAmJiAobnVsbCAhPT0gKGMgPSBzdHJlYW0ucmVhZCgpKSkpXG4gICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGMpO1xuXG4gICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9O1xuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAocmVhZGFibGUpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICB9O1xuXG4gIC8vIG5vdyBtYWtlIGl0IHN0YXJ0LCBqdXN0IGluIGNhc2UgaXQgaGFkbid0IGFscmVhZHkuXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIC8vaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihhcmcpO1xufVxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJleHBvcnRzLmlzYXR0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG5mdW5jdGlvbiBSZWFkU3RyZWFtKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3R0eS5SZWFkU3RyZWFtIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuZXhwb3J0cy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbTtcblxuZnVuY3Rpb24gV3JpdGVTdHJlYW0oKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG59XG5leHBvcnRzLldyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXG4gKiBBZGFwdGVkIHRvIEJhYmVsIGJ5IERhcsOtbyBKYXZpZXIgQ3JhdmVybyA8ZGFyaW9AdXh0ZW1wbGUuY29tPlxuICpcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXZhbCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKCdiYWJlbCcpLnRyYW5zZm9ybTtcblxudmFyIGhlYWRFbDtcbnZhciBkdW1teUFuY2hvcjtcbnZhciBpbmxpbmVTY3JpcHRDb3VudCA9IDA7XG5cbi8vIFRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgcmVsaWVzIG9uIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgYnV0IElFOCBkb2Vzbid0XG4vLyBzdXBwb3J0IGl0IGZ1bGx5IGV2ZW4gd2l0aCBlczUtc2hhbS4gSW5kZWVkLCBlczUtc2hhbSdzIGRlZmluZVByb3BlcnR5XG4vLyB0aHJvd3Mgd2hlbiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18gaXMgbWlzc2luZywgc28gd2Ugc2tpcCBidWlsZGluZ1xuLy8gdGhlIHNvdXJjZSBtYXAgaW4gdGhhdCBjYXNlLlxudmFyIHN1cHBvcnRzQWNjZXNzb3JzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX19kZWZpbmVHZXR0ZXJfXycpO1xuXG4vKipcbiAqIFJ1biBwcm92aWRlZCBjb2RlIHRocm91Z2gganN0cmFuc2Zvcm0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBPcmlnaW5hbCBzb3VyY2UgY29kZVxuICogQHBhcmFtIHtvYmplY3Q/fSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyB0byBqc3RyYW5zZm9ybVxuICogQHJldHVybiB7b2JqZWN0fSBvYmplY3QgYXMgcmV0dXJuZWQgZnJvbSBqc3RyYW5zZm9ybVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1CYWJlbChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge3NvdXJjZU1hcDogdHJ1ZSwgZXhwZXJpbWVudGFsOiB0cnVlfTtcblxuICByZXR1cm4gdHJhbnNmb3JtKHNvdXJjZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogRXZhbCBwcm92aWRlZCBzb3VyY2UgYWZ0ZXIgdHJhbnNmb3JtaW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgT3JpZ2luYWwgc291cmNlIGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0P30gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8ganN0cmFuc2Zvcm1cbiAqL1xuZnVuY3Rpb24gZXhlYyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGV2YWwodHJhbnNmb3JtQmFiZWwoc291cmNlLCBvcHRpb25zKS5jb2RlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmljZWx5IGZvcm1hdGVkIGxpbmUgb2YgY29kZSBwb2ludGluZyB0byB0aGUgZXhhY3RcbiAqIGxvY2F0aW9uIG9mIHRoZSBlcnJvciBgZWAuIFRoZSBsaW5lIGlzIGxpbWl0ZWQgaW4gc2l6ZSBzbyBiaWcgbGluZXMgb2YgY29kZVxuICogYXJlIGFsc28gc2hvd24gaW4gYSByZWFkYWJsZSB3YXkuXG4gKlxuICogRXhhbXBsZTpcbiAqIC4uLiB4Jywgb3ZlcmZsb3c6J3Njcm9sbCd9fSBpZD17fSBvblNjcm9sbD17dGhpcy5zY3JvbGx9IGNsYXNzPVwiIC4uLlxuICogXlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBmdWxsIHN0cmluZyBvZiBjb2RlXG4gKiBAcGFyYW0ge0Vycm9yfSBlIFRoZSBlcnJvciBiZWluZyB0aHJvd25cbiAqIEByZXR1cm4ge3N0cmluZ30gZm9ybWF0dGVkIG1lc3NhZ2VcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVTb3VyY2VDb2RlRXJyb3JNZXNzYWdlKGNvZGUsIGUpIHtcbiAgdmFyIHNvdXJjZUxpbmVzID0gY29kZS5zcGxpdCgnXFxuJyk7XG4gIC8vIGUubGluZU51bWJlciBpcyBub24tc3RhbmRhcmQgc28gd2UgY2FuJ3QgZGVwZW5kIG9uIGl0cyBhdmFpbGFiaWxpdHkuIElmXG4gIC8vIHdlJ3JlIGluIGEgYnJvd3NlciB3aGVyZSBpdCBpc24ndCBzdXBwb3J0ZWQsIGRvbid0IGV2ZW4gYm90aGVyIHRyeWluZyB0b1xuICAvLyBmb3JtYXQgYW55dGhpbmcuIFdlIG1heSBhbHNvIGhpdCBhIGNhc2Ugd2hlcmUgdGhlIGxpbmUgbnVtYmVyIGlzIHJlcG9ydGVkXG4gIC8vIGluY29ycmVjdGx5IGFuZCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGFjdHVhbCBjb2RlLiBIYW5kbGUgdGhhdCB0b28uXG4gIGlmICghZS5saW5lTnVtYmVyIHx8IGUubGluZU51bWJlciA+IHNvdXJjZUxpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgZXJyb25lb3VzTGluZSA9IHNvdXJjZUxpbmVzW2UubGluZU51bWJlciAtIDFdO1xuXG4gIC8vIFJlbW92ZXMgYW55IGxlYWRpbmcgaW5kZW50aW5nIHNwYWNlcyBhbmQgZ2V0cyB0aGUgbnVtYmVyIG9mXG4gIC8vIGNoYXJzIGluZGVudGluZyB0aGUgYGVycm9uZW91c0xpbmVgXG4gIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gIGVycm9uZW91c0xpbmUgPSBlcnJvbmVvdXNMaW5lLnJlcGxhY2UoL15cXHMrLywgZnVuY3Rpb24obGVhZGluZ1NwYWNlcykge1xuICAgIGluZGVudGF0aW9uID0gbGVhZGluZ1NwYWNlcy5sZW5ndGg7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcblxuICAvLyBEZWZpbmVzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBnb2luZyB0byBzaG93XG4gIC8vIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGVycm9uZW91cyBjb2RlXG4gIHZhciBMSU1JVCA9IDMwO1xuICB2YXIgZXJyb3JDb2x1bW4gPSBlLmNvbHVtbiAtIGluZGVudGF0aW9uO1xuXG4gIGlmIChlcnJvckNvbHVtbiA+IExJTUlUKSB7XG4gICAgZXJyb25lb3VzTGluZSA9ICcuLi4gJyArIGVycm9uZW91c0xpbmUuc2xpY2UoZXJyb3JDb2x1bW4gLSBMSU1JVCk7XG4gICAgZXJyb3JDb2x1bW4gPSA0ICsgTElNSVQ7XG4gIH1cbiAgaWYgKGVycm9uZW91c0xpbmUubGVuZ3RoIC0gZXJyb3JDb2x1bW4gPiBMSU1JVCkge1xuICAgIGVycm9uZW91c0xpbmUgPSBlcnJvbmVvdXNMaW5lLnNsaWNlKDAsIGVycm9yQ29sdW1uICsgTElNSVQpICsgJyAuLi4nO1xuICB9XG4gIHZhciBtZXNzYWdlID0gJ1xcblxcbicgKyBlcnJvbmVvdXNMaW5lICsgJ1xcbic7XG4gIG1lc3NhZ2UgKz0gbmV3IEFycmF5KGVycm9yQ29sdW1uIC0gMSkuam9pbignICcpICsgJ14nO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuLyoqXG4gKiBBY3R1YWxseSB0cmFuc2Zvcm0gdGhlIGNvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gdXJsXG4gKiBAcGFyYW0ge29iamVjdD99IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRyYW5zZm9ybWVkIGNvZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQ29kZShjb2RlLCB1cmwsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1CYWJlbChjb2RlLCBvcHRpb25zKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG4gICAgYXQgJztcbiAgICBpZiAodXJsKSB7XG4gICAgICBpZiAoJ2ZpbGVOYW1lJyBpbiBlKSB7XG4gICAgICAgIC8vIFdlIHNldCBgZmlsZU5hbWVgIGlmIGl0J3Mgc3VwcG9ydGVkIGJ5IHRoaXMgZXJyb3Igb2JqZWN0IGFuZFxuICAgICAgICAvLyBhIGB1cmxgIHdhcyBwcm92aWRlZC5cbiAgICAgICAgLy8gVGhlIGVycm9yIHdpbGwgY29ycmVjdGx5IHBvaW50IHRvIGB1cmxgIGluIEZpcmVmb3guXG4gICAgICAgIGUuZmlsZU5hbWUgPSB1cmw7XG4gICAgICB9XG4gICAgICBlLm1lc3NhZ2UgKz0gdXJsICsgJzonICsgZS5saW5lTnVtYmVyICsgJzonICsgZS5jb2x1bW5OdW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUubWVzc2FnZSArPSBsb2NhdGlvbi5ocmVmO1xuICAgIH1cbiAgICBlLm1lc3NhZ2UgKz0gY3JlYXRlU291cmNlQ29kZUVycm9yTWVzc2FnZShjb2RlLCBlKTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgaWYgKCF0cmFuc2Zvcm1lZC5zb3VyY2VNYXApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQuY29kZTtcbiAgfVxuXG4gIHZhciBtYXAgPSB0cmFuc2Zvcm1lZC5zb3VyY2VNYXAudG9KU09OKCk7XG4gIHZhciBzb3VyY2U7XG4gIGlmICh1cmwgPT0gbnVsbCkge1xuICAgIHNvdXJjZSA9IFwiSW5saW5lIEpTWCBzY3JpcHRcIjtcbiAgICBpbmxpbmVTY3JpcHRDb3VudCsrO1xuICAgIGlmIChpbmxpbmVTY3JpcHRDb3VudCA+IDEpIHtcbiAgICAgIHNvdXJjZSArPSAnICgnICsgaW5saW5lU2NyaXB0Q291bnQgKyAnKSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGR1bW15QW5jaG9yKSB7XG4gICAgLy8gRmlyZWZveCBoYXMgcHJvYmxlbXMgd2hlbiB0aGUgc291cmNlbWFwIHNvdXJjZSBpcyBhIHByb3BlciBVUkwgd2l0aCBhXG4gICAgLy8gcHJvdG9jb2wgYW5kIGhvc3RuYW1lLCBzbyB1c2UgdGhlIHBhdGhuYW1lLiBXZSBjb3VsZCB1c2UganVzdCB0aGVcbiAgICAvLyBmaWxlbmFtZSwgYnV0IGhvcGVmdWxseSB1c2luZyB0aGUgZnVsbCBwYXRoIHdpbGwgcHJldmVudCBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZXMgd2hlcmUgdGhlIHNhbWUgZmlsZW5hbWUgZXhpc3RzIGluIG11bHRpcGxlIGRpcmVjdG9yaWVzLlxuICAgIGR1bW15QW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgc291cmNlID0gZHVtbXlBbmNob3IucGF0aG5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIG1hcC5zb3VyY2VzID0gW3NvdXJjZV07XG4gIG1hcC5zb3VyY2VzQ29udGVudCA9IFtjb2RlXTtcblxuICByZXR1cm4gKFxuICAgIHRyYW5zZm9ybWVkLmNvZGUgK1xuICAgICdcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgK1xuICAgIGJ1ZmZlci5CdWZmZXIoSlNPTi5zdHJpbmdpZnkobWFwKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICk7XG59XG5cblxuLyoqXG4gKiBBcHBlbmRzIGEgc2NyaXB0IGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgPGhlYWQ+IHdpdGggdGhlIGNvbnRlbnQgb2YgY29kZSxcbiAqIGFmdGVyIHRyYW5zZm9ybWluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgb3JpZ2luYWwgc291cmNlIGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gdXJsIFdoZXJlIHRoZSBjb2RlIGNhbWUgZnJvbS4gbnVsbCBpZiBpbmxpbmVcbiAqIEBwYXJhbSB7b2JqZWN0P30gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8ganN0cmFuc2Zvcm1cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBydW4oY29kZSwgdXJsLCBvcHRpb25zKSB7XG4gIHZhciBzY3JpcHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHRFbC50ZXh0ID0gdHJhbnNmb3JtQ29kZShjb2RlLCB1cmwsIG9wdGlvbnMpO1xuICBoZWFkRWwuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xufVxuXG4vKipcbiAqIExvYWQgc2NyaXB0IGZyb20gdGhlIHByb3ZpZGVkIHVybCBhbmQgcGFzcyB0aGUgY29udGVudCB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgbG9jYXRpb24gb2YgdGhlIHNjcmlwdCBzcmNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGNhbGwgd2l0aCB0aGUgY29udGVudCBvZiB1cmxcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBsb2FkKHVybCwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciB4aHI7XG4gIHhociA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0ID8gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgLy8gYXN5bmMsIGhvd2V2ZXIgc2NyaXB0cyB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBpbiB0aGVcbiAgLy8gRE9NIHRvIG1pcnJvciBub3JtYWwgc2NyaXB0IGxvYWRpbmcuXG4gIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICBpZiAoJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocikge1xuICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluJyk7XG4gIH1cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGxvYWQgXCIgKyB1cmwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHhoci5zZW5kKG51bGwpO1xufVxuXG4vKipcbiAqIExvb3Agb3ZlciBwcm92aWRlZCBzY3JpcHQgdGFncyBhbmQgZ2V0IHRoZSBjb250ZW50LCB2aWEgaW5uZXJIVE1MIGlmIGFuXG4gKiBpbmxpbmUgc2NyaXB0LCBvciBieSB1c2luZyBYSFIuIFRyYW5zZm9ybXMgYXJlIGFwcGxpZWQgaWYgbmVlZGVkLiBUaGUgc2NyaXB0c1xuICogYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZCBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzY3JpcHRzIFRoZSA8c2NyaXB0PiBlbGVtZW50cyB0byBsb2FkIGFuZCBydW4uXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbG9hZFNjcmlwdHMoc2NyaXB0cykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IHNjcmlwdHMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIHZhciBzY3JpcHQsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgc2NyaXB0ID0gcmVzdWx0W2ldO1xuXG4gICAgICBpZiAoc2NyaXB0LmxvYWRlZCAmJiAhc2NyaXB0LmV4ZWN1dGVkKSB7XG4gICAgICAgIHNjcmlwdC5leGVjdXRlZCA9IHRydWU7XG4gICAgICAgIHJ1bihzY3JpcHQuY29udGVudCwgc2NyaXB0LnVybCwgc2NyaXB0Lm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICghc2NyaXB0LmxvYWRlZCAmJiAhc2NyaXB0LmVycm9yICYmICFzY3JpcHQuYXN5bmMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2NyaXB0cy5mb3JFYWNoKGZ1bmN0aW9uKHNjcmlwdCwgaSkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc291cmNlTWFwOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoLztoYXJtb255PXRydWUoO3wkKS8udGVzdChzY3JpcHQudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMuaGFybW9ueSA9IHRydWU7XG4gICAgfVxuICAgIGlmICgvO3N0cmlwVHlwZXM9dHJ1ZSg7fCQpLy50ZXN0KHNjcmlwdC50eXBlKSkge1xuICAgICAgb3B0aW9ucy5zdHJpcFR5cGVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBzY3JpcHQuYXN5bmMgaXMgYWx3YXlzIHRydWUgZm9yIG5vbi1qYXZhc2NyaXB0IHNjcmlwdCB0YWdzXG4gICAgdmFyIGFzeW5jID0gc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnYXN5bmMnKTtcblxuICAgIGlmIChzY3JpcHQuc3JjKSB7XG4gICAgICByZXN1bHRbaV0gPSB7XG4gICAgICAgIGFzeW5jOiBhc3luYyxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBleGVjdXRlZDogZmFsc2UsXG4gICAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgIHVybDogc2NyaXB0LnNyYyxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgbG9hZChzY3JpcHQuc3JjLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHJlc3VsdFtpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICByZXN1bHRbaV0uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGNoZWNrKCk7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0W2ldLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2hlY2soKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbaV0gPSB7XG4gICAgICAgIGFzeW5jOiBhc3luYyxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBleGVjdXRlZDogZmFsc2UsXG4gICAgICAgIGNvbnRlbnQ6IHNjcmlwdC5pbm5lckhUTUwsXG4gICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgY2hlY2soKTtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCBydW4gYWxsIHNjcmlwdCB0YWdzIHdpdGggdHlwZT1cInRleHQvanN4XCIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHJ1blNjcmlwdHMoKSB7XG4gIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG4gIC8vIEFycmF5LnByb3RvdHlwZS5zbGljZSBjYW5ub3QgYmUgdXNlZCBvbiBOb2RlTGlzdCBvbiBJRThcbiAgdmFyIHNjcmlwdHNUb0xvYWQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKC9edGV4dFxcLyhiYWJlbHxlczZ8ZXM3fGpzeCkoO3wkKS8udGVzdChzY3JpcHRzLml0ZW0oaSkudHlwZSkpIHtcbiAgICAgIHNjcmlwdHNUb0xvYWQucHVzaChzY3JpcHRzLml0ZW0oaSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzY3JpcHRzVG9Mb2FkLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zb2xlLndhcm4oXG4gICAgJ1lvdSBhcmUgdXNpbmcgYmFiZWxcXCdzIGluLWJyb3dzZXIgRVM2LzcgJiBKU1ggdHJhbnNmb3JtZXIuIEJlIHN1cmUgdG8gcHJlY29tcGlsZSAnICtcbiAgICAneW91ciBFUzYvNyAmIEpTWCBmb3IgcHJvZHVjdGlvbiAtICcgK1xuICAgICdiYWJlbGpzLmlvL2RvY3MvdXNpbmctYmFiZWwvJyArXG4gICAgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b29saW5nLWludGVncmF0aW9uLmh0bWwjanN4J1xuICApO1xuXG4gIGxvYWRTY3JpcHRzKHNjcmlwdHNUb0xvYWQpO1xufVxuXG4vLyBMaXN0ZW4gZm9yIGxvYWQgZXZlbnQgaWYgd2UncmUgaW4gYSBicm93c2VyIGFuZCB0aGVuIGtpY2sgb2ZmIGZpbmRpbmcgYW5kXG4vLyBydW5uaW5nIG9mIHNjcmlwdHMuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgaGVhZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgZHVtbXlBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBydW5TY3JpcHRzLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCBydW5TY3JpcHRzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1CYWJlbCxcbiAgZXhlYzogZXhlY1xufTtcbiJdfQ==
